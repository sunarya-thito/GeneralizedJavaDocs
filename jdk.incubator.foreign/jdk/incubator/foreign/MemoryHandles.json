{
  "packageName": "jdk.incubator.foreign",
  "simpleName": "MemoryHandles",
  "moduleName": "jdk.incubator.foreign",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "carrier"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "byteOrder"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "varHandle",
      "comment": "Creates a memory access var handle with the given carrier type and byte order. The returned var handle\u0027s type is carrier and the list of coordinate types is (MemorySegment, long), where the long coordinate type corresponds to byte offset into a given memory segment. The returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from a value of the type carrier according to the given endianness; the alignment constraint (in bytes) for the resulting memory access var handle is the same as the size (in bytes) of the carrier type carrier.",
      "tagMap": {
        "apiNote": [
          "the resulting var handle features certain \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemoryHandles.html#memaccess-mode\"\u003eaccess mode restrictions\u003c/a\u003e, which are common to all memory access var handles."
        ],
        "param": [
          "\u003ccode\u003ecarrier\u003c/code\u003e - the carrier type. Valid carriers are \n\u003ccode\u003ebyte\u003c/code\u003e, \n\u003ccode\u003eshort\u003c/code\u003e, \n\u003ccode\u003echar\u003c/code\u003e, \n\u003ccode\u003eint\u003c/code\u003e, \n\u003ccode\u003efloat\u003c/code\u003e, \n\u003ccode\u003elong\u003c/code\u003e, and \n\u003ccode\u003edouble\u003c/code\u003e.",
          "\u003ccode\u003ebyteOrder\u003c/code\u003e - the required byte order."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - when an illegal carrier type is used"
        ],
        "return": [
          "the new memory access var handle."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "carrier"
          }
        },
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "alignmentBytes"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "byteOrder"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "varHandle",
      "comment": "Creates a memory access var handle with the given carrier type, alignment constraint, and byte order. The returned var handle\u0027s type is carrier and the list of coordinate types is (MemorySegment, long), where the long coordinate type corresponds to byte offset into a given memory segment. The returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from a value of the type carrier according to the given endianness; the alignment constraint (in bytes) for the resulting memory access var handle is given by alignmentBytes.",
      "tagMap": {
        "apiNote": [
          "the resulting var handle features certain \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemoryHandles.html#memaccess-mode\"\u003eaccess mode restrictions\u003c/a\u003e, which are common to all memory access var handles."
        ],
        "param": [
          "\u003ccode\u003ecarrier\u003c/code\u003e - the carrier type. Valid carriers are \n\u003ccode\u003ebyte\u003c/code\u003e, \n\u003ccode\u003eshort\u003c/code\u003e, \n\u003ccode\u003echar\u003c/code\u003e, \n\u003ccode\u003eint\u003c/code\u003e, \n\u003ccode\u003efloat\u003c/code\u003e, \n\u003ccode\u003elong\u003c/code\u003e, and \n\u003ccode\u003edouble\u003c/code\u003e.",
          "\u003ccode\u003ealignmentBytes\u003c/code\u003e - the alignment constraint (in bytes). Must be a power of two.",
          "\u003ccode\u003ebyteOrder\u003c/code\u003e - the required byte order."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if an illegal carrier type is used, or if \n\u003ccode\u003ealignmentBytes\u003c/code\u003e is not a power of two."
        ],
        "return": [
          "the new memory access var handle."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "asAddressVarHandle",
      "comment": "Adapt an existing var handle into a new var handle whose carrier type is MemorySegment. That is, when calling VarHandle.get(Object...) on the returned var handle, the read numeric value will be turned into a memory address (as if by calling MemoryAddress.ofLong(long)); similarly, when calling VarHandle.set(Object...), the memory address to be set will be converted into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to) memory depends on the carrier of the original memory access var handle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the memory access var handle to be adapted"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the carrier type of \n\u003ccode\u003evarHandle\u003c/code\u003e is either \n\u003ccode\u003eboolean\u003c/code\u003e, \n\u003ccode\u003efloat\u003c/code\u003e, or \n\u003ccode\u003edouble\u003c/code\u003e, or is not a primitive type."
        ],
        "return": [
          "the adapted var handle."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "adaptedType"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "asUnsigned",
      "comment": "Adapts a target var handle by narrowing incoming values and widening outgoing values, to and from the given type, respectively. The returned var handle can be used to conveniently treat unsigned primitive data types as if they were a wider signed primitive type. For example, it is often convenient to model an unsigned short as a Java int to avoid dealing with negative values, which would be the case if modeled as a Java short. This is illustrated in the following example: \n    MemorySegment segment \u003d MemorySegment.allocateNative(2);\n    VarHandle SHORT_VH \u003d MemoryLayouts.JAVA_SHORT.varHandle(short.class);\n    VarHandle INT_VH \u003d MemoryHandles.asUnsigned(SHORT_VH, int.class);\n    SHORT_VH.set(segment, (short)-1);\n    INT_VH.get(segment); // returns 65535\n When calling e.g. VarHandle.set(Object...) on the resulting var handle, the incoming value (of type adaptedType) is converted by a narrowing primitive conversion and then passed to the target var handle. A narrowing primitive conversion may lose information about the overall magnitude of a numeric value. Conversely, when calling e.g. VarHandle.get(Object...) on the resulting var handle, the returned value obtained from the target var handle is converted by a unsigned widening conversion before being returned to the caller. In an unsigned widening conversion the high-order bits greater than that of the target carrier type are zero, and the low-order bits (equal to the width of the target carrier type) are equal to the bits of the value obtained from the target var handle. The returned var handle will feature the variable type adaptedType, and the same access coordinates, the same access modes (see VarHandle.AccessMode, and the same atomic access guarantees, as those featured by the target var handle.",
      "tagMap": {
        "See Java Language Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-5.html#jls-5.1.3\"\u003e5.1.3 Narrowing Primitive Conversion\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the memory access var handle to be adapted",
          "\u003ccode\u003eadaptedType\u003c/code\u003e - the adapted type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the carrier type of \n\u003ccode\u003etarget\u003c/code\u003e is not one of \n\u003ccode\u003ebyte\u003c/code\u003e, \n\u003ccode\u003eshort\u003c/code\u003e, or \n\u003ccode\u003eint\u003c/code\u003e; if \n\u003ccode\u003e adaptedType\u003c/code\u003e is not one of \n\u003ccode\u003eint\u003c/code\u003e, or \n\u003ccode\u003elong\u003c/code\u003e; if the bitwidth of the \n\u003ccode\u003eadaptedType\u003c/code\u003e is not greater than that of the \n\u003ccode\u003etarget\u003c/code\u003e carrier type."
        ],
        "return": [
          "the adapted var handle."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "filterToTarget"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "filterFromTarget"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "filterValue",
      "comment": "Adapts a target var handle by pre-processing incoming and outgoing values using a pair of filter functions. When calling e.g. VarHandle.set(Object...) on the resulting var handle, the incoming value (of type T, where T is the last parameter type of the first filter function) is processed using the first filter and then passed to the target var handle. Conversely, when calling e.g. VarHandle.get(Object...) on the resulting var handle, the return value obtained from the target var handle (of type T, where T is the last parameter type of the second filter function) is processed using the second filter and returned to the caller. More advanced access mode types, such as VarHandle.AccessMode.COMPARE_AND_EXCHANGE might apply both filters at the same time. For the boxing and unboxing filters to be well formed, their types must be of the form (A... , S) -\u003e T and (A... , T) -\u003e S, respectively, where T is the type of the target var handle. If this is the case, the resulting var handle will have type S and will feature the additional coordinates A... (which will be appended to the coordinates of the target var handle). The resulting var handle will feature the same access modes (see VarHandle.AccessMode and atomic access guarantees as those featured by the target var handle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the target var handle",
          "\u003ccode\u003efilterToTarget\u003c/code\u003e - a filter to convert some type \n\u003ccode\u003eS\u003c/code\u003e into the type of \n\u003ccode\u003etarget\u003c/code\u003e",
          "\u003ccode\u003efilterFromTarget\u003c/code\u003e - a filter to convert the type of \n\u003ccode\u003etarget\u003c/code\u003e to some type \n\u003ccode\u003eS\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efilterFromTarget\u003c/code\u003e and \n\u003ccode\u003efilterToTarget\u003c/code\u003e are not well-formed, that is, they have types other than \n\u003ccode\u003e(A... , S) -\u0026gt; T\u003c/code\u003e and \n\u003ccode\u003e(A... , T) -\u0026gt; S\u003c/code\u003e, respectively, where \n\u003ccode\u003eT\u003c/code\u003e is the type of the target var handle, or if either \n\u003ccode\u003efilterFromTarget\u003c/code\u003e or \n\u003ccode\u003efilterToTarget\u003c/code\u003e throws any checked exceptions."
        ],
        "return": [
          "an adapter var handle which accepts a new type, performing the provided boxing/unboxing conversions."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "filters"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "filterCoordinates",
      "comment": "Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions. When calling e.g. VarHandle.get(Object...) on the resulting var handle, the incoming coordinate values starting at position pos (of type C1, C2 ... Cn, where C1, C2 ... Cn are the return type of the unary filter functions) are transformed into new values (of type S1, S2 ... Sn, where S1, S2 ... Sn are the parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered by the adaptation) to the target var handle. For the coordinate filters to be well formed, their types must be of the form S1 -\u003e T1, S2 -\u003e T1 ... Sn -\u003e Tn, where T1, T2 ... Tn are the coordinate types starting at position pos of the target var handle. The resulting var handle will feature the same access modes (see VarHandle.AccessMode) and atomic access guarantees as those featured by the target var handle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the target var handle",
          "\u003ccode\u003epos\u003c/code\u003e - the position of the first coordinate to be transformed",
          "\u003ccode\u003efilters\u003c/code\u003e - the unary functions which are used to transform coordinates starting at position \n\u003ccode\u003epos\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the handles in \n\u003ccode\u003efilters\u003c/code\u003e are not well-formed, that is, they have types other than \n\u003ccode\u003eS1 -\u0026gt; T1, S2 -\u0026gt; T2, ... Sn -\u0026gt; Tn\u003c/code\u003e where \n\u003ccode\u003eT1, T2 ... Tn\u003c/code\u003e are the coordinate types starting at position \n\u003ccode\u003epos\u003c/code\u003e of the target var handle, if \n\u003ccode\u003epos\u003c/code\u003e is not between 0 and the target var handle coordinate arity, inclusive, or if more filters are provided than the actual number of coordinate types available starting at \n\u003ccode\u003epos\u003c/code\u003e, or if any of the filters throws any checked exceptions."
        ],
        "return": [
          "an adapter var handle which accepts new coordinate types, applying the provided transformation to the new coordinate values."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "values"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "insertCoordinates",
      "comment": "Provides a target var handle with one or more bound coordinates in advance of the var handle\u0027s invocation. As a consequence, the resulting var handle will feature less coordinate types than the target var handle. When calling e.g. VarHandle.get(Object...) on the resulting var handle, incoming coordinate values are joined with bound coordinate values, and then passed to the target var handle. For the bound coordinates to be well formed, their types must be T1, T2 ... Tn , where T1, T2 ... Tn are the coordinate types starting at position pos of the target var handle. The resulting var handle will feature the same access modes (see VarHandle.AccessMode) and atomic access guarantees as those featured by the target var handle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the var handle to invoke after the bound coordinates are inserted",
          "\u003ccode\u003epos\u003c/code\u003e - the position of the first coordinate to be inserted",
          "\u003ccode\u003evalues\u003c/code\u003e - the series of bound coordinates to insert"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epos\u003c/code\u003e is not between 0 and the target var handle coordinate arity, inclusive, or if more values are provided than the actual number of coordinate types available starting at \n\u003ccode\u003epos\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the bound coordinates in \n\u003ccode\u003evalues\u003c/code\u003e are not well-formed, that is, they have types other than \n\u003ccode\u003eT1, T2 ... Tn \u003c/code\u003e, where \n\u003ccode\u003eT1, T2 ... Tn\u003c/code\u003e are the coordinate types starting at position \n\u003ccode\u003epos\u003c/code\u003e of the target var handle."
        ],
        "return": [
          "an adapter var handle which inserts an additional coordinates, before calling the target var handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.Class",
                "parameters": [
                  {
                    "type": "Wildcard"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "newCoordinates"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "reorder"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "permuteCoordinates",
      "comment": "Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them so that the new coordinates match the provided ones. The given array controls the reordering. Call #I the number of incoming coordinates (the value newCoordinates.size(), and call #O the number of outgoing coordinates (the number of coordinates associated with the target var handle). Then the length of the reordering array must be #O, and each element must be a non-negative number less than #I. For every N less than #O, the N-th outgoing coordinate will be taken from the I-th incoming coordinate, where I is reorder[N]. No coordinate value conversions are applied. The type of each incoming coordinate, as determined by newCoordinates, must be identical to the type of the corresponding outgoing coordinate in the target var handle. The reordering array need not specify an actual permutation. An incoming coordinate will be duplicated if its index appears more than once in the array, and an incoming coordinate will be dropped if its index does not appear in the array. The resulting var handle will feature the same access modes (see VarHandle.AccessMode) and atomic access guarantees as those featured by the target var handle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the var handle to invoke after the coordinates have been reordered",
          "\u003ccode\u003enewCoordinates\u003c/code\u003e - the new coordinate types",
          "\u003ccode\u003ereorder\u003c/code\u003e - an index array which controls the reordering"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the index array length is not equal to the number of coordinates of the target var handle, or if any index array element is not a valid index for a coordinate of \n\u003ccode\u003enewCoordinates\u003c/code\u003e, or if two corresponding coordinate types in the target var handle and in \n\u003ccode\u003enewCoordinates\u003c/code\u003e are not identical."
        ],
        "return": [
          "an adapter var handle which re-arranges the incoming coordinate values, before calling the target var handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "filter"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "collectCoordinates",
      "comment": "Adapts a target var handle handle by pre-processing a sub-sequence of its coordinate values with a filter (a method handle). The pre-processed coordinates are replaced by the result (if any) of the filter function and the target var handle is then called on the modified (usually shortened) coordinate list. If R is the return type of the filter (which cannot be void), the target var handle must accept a value of type R as its coordinate in position pos, preceded and/or followed by any coordinate not passed to the filter. No coordinates are reordered, and the result returned from the filter replaces (in order) the whole subsequence of coordinates originally passed to the adapter. The argument types (if any) of the filter replace zero or one coordinate types of the target var handle, at position pos, in the resulting adapted var handle. The return type of the filter must be identical to the coordinate type of the target var handle at position pos, and that target var handle coordinate is supplied by the return value of the filter. The resulting var handle will feature the same access modes (see VarHandle.AccessMode) and atomic access guarantees as those featured by the target var handle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the var handle to invoke after the coordinates have been filtered",
          "\u003ccode\u003epos\u003c/code\u003e - the position of the coordinate to be filtered",
          "\u003ccode\u003efilter\u003c/code\u003e - the filter method handle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the return type of \n\u003ccode\u003efilter\u003c/code\u003e is void, or it is not the same as the \n\u003ccode\u003epos\u003c/code\u003e coordinate of the target var handle, if \n\u003ccode\u003epos\u003c/code\u003e is not between 0 and the target var handle coordinate arity, inclusive, if the resulting var handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MethodHandle.html#maxarity\"\u003etoo many coordinates\u003c/a\u003e, or if \n\u003ccode\u003efilter\u003c/code\u003e throws any checked exceptions."
        ],
        "return": [
          "an adapter var handle which filters the incoming coordinate values, before calling the target var handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "valueTypes"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "dropCoordinates",
      "comment": "Returns a var handle which will discard some dummy coordinates before delegating to the target var handle. As a consequence, the resulting var handle will feature more coordinate types than the target var handle. The pos argument may range between zero and N, where N is the arity of the target var handle\u0027s coordinate types. If pos is zero, the dummy coordinates will precede the target\u0027s real arguments; if pos is N they will come after. The resulting var handle will feature the same access modes (see VarHandle.AccessMode) and atomic access guarantees as those featured by the target var handle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the var handle to invoke after the dummy coordinates are dropped",
          "\u003ccode\u003epos\u003c/code\u003e - position of first coordinate to drop (zero for the leftmost)",
          "\u003ccode\u003evalueTypes\u003c/code\u003e - the type(s) of the coordinate(s) to drop"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epos\u003c/code\u003e is not between 0 and the target var handle coordinate arity, inclusive."
        ],
        "return": [
          "an adapter var handle which drops some dummy coordinates, before calling the target var handle"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "jdk.incubator.foreign.MemoryHandles",
  "comment": "This class defines several factory methods for constructing and combining memory access var handles. To obtain a memory access var handle, clients must start from one of the \n\u003cem\u003eleaf\u003c/em\u003e methods (see \n\u003ca href\u003d\"#varHandle(java.lang.Class,java.nio.ByteOrder)\"\u003e\u003ccode\u003evarHandle(Class, ByteOrder)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"#varHandle(java.lang.Class,long,java.nio.ByteOrder)\"\u003e\u003ccode\u003evarHandle(Class, long, ByteOrder)\u003c/code\u003e\u003c/a\u003e). This determines the variable type (all primitive types but \n\u003ccode\u003evoid\u003c/code\u003e and \n\u003ccode\u003eboolean\u003c/code\u003e are supported), as well as the alignment constraint and the byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways to emulate different addressing modes. The var handles created by this class feature a \n\u003cem\u003emandatory\u003c/em\u003e coordinate type (of type \n\u003ca href\u003d\"MemorySegment.html\" title\u003d\"interface in jdk.incubator.foreign\"\u003e\u003ccode\u003eMemorySegment\u003c/code\u003e\u003c/a\u003e), and one \n\u003ccode\u003elong\u003c/code\u003e coordinate type, which represents the offset, in bytes, relative to the segment, at which dereference should occur. \n\u003cp\u003e As an example, consider the memory layout expressed by a \u003ca href\u003d\"GroupLayout.html\" title\u003d\"class in jdk.incubator.foreign\"\u003e\u003ccode\u003eGroupLayout\u003c/code\u003e\u003c/a\u003e instance constructed as follows: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nGroupLayout seq \u003d MemoryLayout.ofStruct(\n        MemoryLayout.ofPaddingBits(32),\n        MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(\"value\")\n);\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e To access the member layout named \n\u003ccode\u003evalue\u003c/code\u003e, we can construct a memory access var handle as follows: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nVarHandle handle \u003d MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -\u0026gt; int\nhandle \u003d MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -\u0026gt; int\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Unless otherwise specified, passing a \u003ccode\u003enull\u003c/code\u003e argument, or an array argument containing one or more \u003ccode\u003enull\u003c/code\u003e elements to a method in this class causes a \u003ca href\u003d\"../../../../java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eNullPointerException\u003c/code\u003e\u003c/a\u003e to be thrown. \u003c/p\u003e \n\u003ch2\u003e\u003ca id\u003d\"memaccess-mode\"\u003e\u003c/a\u003eAlignment and access modes\u003c/h2\u003e A memory access var handle is associated with an access size \n\u003ccode\u003eS\u003c/code\u003e and an alignment constraint \n\u003ccode\u003eB\u003c/code\u003e (both expressed in bytes). We say that a memory access operation is \n\u003cem\u003efully aligned\u003c/em\u003e if it occurs at a memory address \n\u003ccode\u003eA\u003c/code\u003e which is compatible with both alignment constraints \n\u003ccode\u003eS\u003c/code\u003e and \n\u003ccode\u003eB\u003c/code\u003e. If access is fully aligned then following access modes are supported and are guaranteed to support atomic access: \n\u003cul\u003e \n \u003cli\u003eread write access modes for all \u003ccode\u003eT\u003c/code\u003e, with the exception of access modes \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e for \u003ccode\u003elong\u003c/code\u003e and \u003ccode\u003edouble\u003c/code\u003e on 32-bit platforms. \u003c/li\u003e\n \u003cli\u003eatomic update access modes for \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e or \u003ccode\u003edouble\u003c/code\u003e. (Future major platform releases of the JDK may support additional types for certain currently unsupported access modes.) \u003c/li\u003e\n \u003cli\u003enumeric atomic update access modes for \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003elong\u003c/code\u003e. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) \u003c/li\u003e\n \u003cli\u003ebitwise atomic update access modes for \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003elong\u003c/code\u003e. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) \u003c/li\u003e\n\u003c/ul\u003e If \n\u003ccode\u003eT\u003c/code\u003e is \n\u003ccode\u003efloat\u003c/code\u003e or \n\u003ccode\u003edouble\u003c/code\u003e then atomic update access modes compare values using their bitwise representation (see \n\u003ca href\u003d\"../../../../java.base/java/lang/Float.html#floatToRawIntBits(float)\"\u003e\u003ccode\u003eFloat.floatToRawIntBits(float)\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"../../../../java.base/java/lang/Double.html#doubleToRawLongBits(double)\"\u003e\u003ccode\u003eDouble.doubleToRawLongBits(double)\u003c/code\u003e\u003c/a\u003e, respectively). \n\u003cp\u003e Alternatively, a memory access operation is \u003cem\u003epartially aligned\u003c/em\u003e if it occurs at a memory address \u003ccode\u003eA\u003c/code\u003e which is only compatible with the alignment constraint \u003ccode\u003eB\u003c/code\u003e; in such cases, access for anything other than the \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e access modes will result in an \u003ccode\u003eIllegalStateException\u003c/code\u003e. If access is partially aligned, atomic access is only guaranteed with respect to the largest power of two that divides the GCD of \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eS\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e Finally, in all other cases, we say that a memory access operation is \u003cem\u003emisaligned\u003c/em\u003e; in such cases an \u003ccode\u003eIllegalStateException\u003c/code\u003e is thrown, irrespective of the access mode being used.\u003c/p\u003e",
  "tagMap": {}
}