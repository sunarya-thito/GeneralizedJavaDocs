{
  "packageName": "jdk.incubator.foreign",
  "simpleName": "LibraryLookup",
  "moduleName": "jdk.incubator.foreign",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "name": "jdk.incubator.foreign.LibraryLookup$Symbol",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "lookup",
      "comment": "Looks up a symbol with given name in this library. The returned symbol maintains a strong reference to this lookup object.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - the symbol name."
        ],
        "return": [
          "the library symbol (if any)."
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.foreign.LibraryLookup",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "ofDefault",
      "comment": "Obtain a default library lookup object.",
      "tagMap": {
        "return": [
          "the default library lookup object."
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.foreign.LibraryLookup",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.nio.file.Path",
            "type": "Class"
          },
          "field": {
            "name": "path"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "ofPath",
      "comment": "Obtain a library lookup object corresponding to a library identified by given path.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epath\u003c/code\u003e - the library absolute path."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the specified path does not correspond to an absolute path, e.g. if \n\u003ccode\u003e!path.isAbsolute()\u003c/code\u003e."
        ],
        "return": [
          "a library lookup object for given path."
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.foreign.LibraryLookup",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "libName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "ofLibrary",
      "comment": "Obtain a library lookup object corresponding to a library identified by given library name. The library name is decorated according to the platform conventions (e.g. on Linux, the lib prefix is added, as well as the .so extension); the resulting name is then looked up in the standard native library path (which can be overriden, by setting the java.library.path property).",
      "tagMap": {
        "param": [
          "\u003ccode\u003elibName\u003c/code\u003e - the library name."
        ],
        "return": [
          "a library lookup object for given library name."
        ]
      }
    }
  ],
  "innerClasses": [
    "jdk.incubator.foreign.LibraryLookup$Symbol"
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "jdk.incubator.foreign.LibraryLookup",
  "comment": "A native library lookup. Exposes a lookup operation for searching symbols, see \n\u003ca href\u003d\"#lookup(java.lang.String)\"\u003e\u003ccode\u003elookup(String)\u003c/code\u003e\u003c/a\u003e. A given native library remains loaded as long as there is at least one \n\u003cem\u003elive\u003c/em\u003e library lookup instance referring to it. All symbol instances (see \n\u003ca href\u003d\"LibraryLookup.Symbol.html\" title\u003d\"interface in jdk.incubator.foreign\"\u003e\u003ccode\u003eLibraryLookup.Symbol\u003c/code\u003e\u003c/a\u003e) generated by a given library lookup object contain a strong reference to said lookup object, therefore preventing library unloading; in turn method handle instances obtained from \n\u003ca href\u003d\"CLinker.html#downcallHandle(jdk.incubator.foreign.Addressable,java.lang.invoke.MethodType,jdk.incubator.foreign.FunctionDescriptor)\"\u003e\u003ccode\u003eCLinker.downcallHandle(Addressable, MethodType, FunctionDescriptor)\u003c/code\u003e\u003c/a\u003e) also maintain a strong reference to the addressable parameter used for their construction. This means that there is always a strong reachability chain from a native method handle to a lookup object (the one that was used to lookup the native library symbol the method handle refers to); this is useful to prevent situations where a native library is unloaded in the middle of a native call. \n\u003cp\u003e\u003ca id\u003d\"var-symbols\"\u003e\u003c/a\u003e\u003c/p\u003e In cases where a client wants to create a memory segment out of a lookup symbol, the client might want to attach the lookup symbol to the newly created segment, so that the symbol will be kept reachable as long as the memory segment is reachable; this can be achieved by creating the segment using the \n\u003ca href\u003d\"MemoryAddress.html#asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\"\u003e\u003ccode\u003eMemoryAddress.asSegmentRestricted(long, Runnable, Object)\u003c/code\u003e\u003c/a\u003e restricted segment factory, as follows: \n\u003cpre\u003e\u003ccode\u003e\nLibraryLookup defaultLookup \u003d LibraryLookup.defaultLookup();\nLibraryLookup.Symbol errno \u003d defaultLookup.lookup(\"errno\");\nMemorySegment errnoSegment \u003d errno.address().asRestrictedSegment(4, errno);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e To allow for a library to be unloaded, a client will have to discard any strong references it maintains, directly, or indirectly to a lookup object associated with given library. \u003c/p\u003e\n\u003cp\u003e Unless otherwise specified, passing a \u003ccode\u003enull\u003c/code\u003e argument, or an array argument containing one or more \u003ccode\u003enull\u003c/code\u003e elements to a method in this class causes a \u003ca href\u003d\"../../../../java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eNullPointerException\u003c/code\u003e\u003c/a\u003e to be thrown. \u003c/p\u003e",
  "tagMap": {}
}