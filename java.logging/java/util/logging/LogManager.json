{
  "packageName": "java.util.logging",
  "simpleName": "LogManager",
  "moduleName": "java.logging",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "LOGGING_MXBEAN_NAME",
      "comment": "String representation of the ObjectName for the management interface for the logging facility.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.management/java/lang/management/PlatformLoggingMXBean.html\" title\u003d\"interface in java.lang.management\"\u003e\u003ccode\u003ePlatformLoggingMXBean\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.logging.LogManager.LOGGING_MXBEAN_NAME\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.logging.LogManager",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getLogManager",
      "comment": "Returns the global LogManager object.",
      "tagMap": {
        "return": [
          "the global LogManager object"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.logging.Logger",
            "type": "Class"
          },
          "field": {
            "name": "logger"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "addLogger",
      "comment": "Add a named logger. This does nothing and returns false if a logger with the same name is already registered. The Logger factory methods call this method to register each newly created Logger. The application should retain its own reference to the Logger object to avoid it being garbage collected. The LogManager may only retain a weak reference.",
      "tagMap": {
        "param": [
          "\u003ccode\u003elogger\u003c/code\u003e - the new logger."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the logger name is null."
        ],
        "return": [
          "true if the argument logger was registered successfully, false if a logger of that name already exists."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.logging.Logger",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLogger",
      "comment": "Method to find a named logger. Note that since untrusted code may create loggers with arbitrary names this method should not be relied on to find Loggers for security sensitive logging. It is also important to note that the Logger associated with the String name may be garbage collected at any time if there is no strong reference to the Logger. The caller of this method must check the return value for null in order to properly handle the case where the Logger has been garbage collected.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - name of the logger"
        ],
        "return": [
          "matching logger or null if none is found"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Enumeration",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLoggerNames",
      "comment": "Get an enumeration of known logger names. Note: Loggers may be added dynamically as new classes are loaded. This method only reports on the loggers that are currently registered. It is also important to note that this method only returns the name of a Logger, not a strong reference to the Logger itself. The returned String does nothing to prevent the Logger from being garbage collected. In particular, if the returned name is passed to LogManager.getLogger(), then the caller must check the return value from LogManager.getLogger() for null to properly handle the case where the Logger has been garbage collected in the time since its name was returned by this method.",
      "tagMap": {
        "return": [
          "enumeration of logger name strings"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "java.lang.SecurityException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "readConfiguration",
      "comment": "Reads and initializes the logging configuration. If the \"java.util.logging.config.class\" system property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object\u0027s constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use readConfiguration(InputStream) to define properties in the LogManager. If \"java.util.logging.config.class\" system property is not set, then this method will read the initial configuration from a properties file and calls the readConfiguration(InputStream) method to initialize the configuration. The \"java.util.logging.config.file\" system property can be used to specify the properties file that will be read as the initial configuration; if not set, then the LogManager default configuration is used. The default configuration is typically loaded from the properties file \"conf/logging.properties\" in the Java installation directory. Any registered configuration listener will be invoked after the properties are read.",
      "tagMap": {
        "apiNote": [
          "This \n\u003ccode\u003ereadConfiguration\u003c/code\u003e method should only be used for initializing the configuration during LogManager initialization or used with the \"java.util.logging.config.class\" property. When this method is called after loggers have been created, and the \"java.util.logging.config.class\" system property is not set, all existing loggers will be \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#reset()\"\u003ereset\u003c/a\u003e. Then any existing loggers that have a level property specified in the new configuration stream will be \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Logger.html#setLevel(java.util.logging.Level)\"\u003eset\u003c/a\u003e to the specified log level. \n\u003cp\u003e To properly update the logging configuration, use the \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#updateConfiguration(java.util.function.Function)\"\u003e\u003ccode\u003eupdateConfiguration(java.util.function.Function)\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#updateConfiguration(java.io.InputStream,java.util.function.Function)\"\u003e\u003ccode\u003eupdateConfiguration(java.io.InputStream, java.util.function.Function)\u003c/code\u003e\u003c/a\u003e methods instead.\u003c/p\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\").",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if there are IO problems reading the configuration."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.SecurityException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "reset",
      "comment": "Reset the logging configuration. For all named loggers, the reset operation removes and closes all Handlers and (except for the root logger) sets the level to null. The root logger\u0027s level is set to Level.INFO.",
      "tagMap": {
        "apiNote": [
          "Calling this method also clears the LogManager \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#getProperty(java.lang.String)\"\u003eproperties\u003c/a\u003e. The \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#updateConfiguration(java.util.function.Function)\"\u003e\u003ccode\u003eupdateConfiguration(Function)\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#updateConfiguration(java.io.InputStream,java.util.function.Function)\"\u003e\u003ccode\u003eupdateConfiguration(InputStream, Function)\u003c/code\u003e\u003c/a\u003e method can be used to properly update to a new configuration."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\")."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "java.lang.SecurityException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.io.InputStream",
            "type": "Class"
          },
          "field": {
            "name": "ins"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "readConfiguration",
      "comment": "Reads and initializes the logging configuration from the given input stream. Any registered configuration listener will be invoked after the properties are read.",
      "tagMap": {
        "apiNote": [
          "This \n\u003ccode\u003ereadConfiguration\u003c/code\u003e method should only be used for initializing the configuration during LogManager initialization or used with the \"java.util.logging.config.class\" property. When this method is called after loggers have been created, all existing loggers will be \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#reset()\"\u003ereset\u003c/a\u003e. Then any existing loggers that have a level property specified in the given input stream will be \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Logger.html#setLevel(java.util.logging.Level)\"\u003eset\u003c/a\u003e to the specified log level. \n\u003cp\u003e To properly update the logging configuration, use the \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#updateConfiguration(java.util.function.Function)\"\u003e\u003ccode\u003eupdateConfiguration(java.util.function.Function)\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#updateConfiguration(java.io.InputStream,java.util.function.Function)\"\u003e\u003ccode\u003eupdateConfiguration(java.io.InputStream, java.util.function.Function)\u003c/code\u003e\u003c/a\u003e method instead.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eins\u003c/code\u003e - stream to read properties from"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\").",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if there are problems reading from the stream, or the given stream is not in the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Properties.html\" title\u003d\"class in java.util\"\u003eproperties file\u003c/a\u003e format."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              },
              {
                "name": "java.util.function.BiFunction",
                "parameters": [
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  },
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  },
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "updateConfiguration",
      "comment": "Updates the logging configuration. If the \"java.util.logging.config.file\" system property is set, then the property value specifies the properties file to be read as the new configuration. Otherwise, the LogManager default configuration is used. The default configuration is typically loaded from the properties file \"conf/logging.properties\" in the Java installation directory. This method reads the new configuration and calls the updateConfiguration(ins, mapper) method to update the configuration.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#updateConfiguration(java.io.InputStream,java.util.function.Function)\"\u003e\u003ccode\u003eupdateConfiguration(java.io.InputStream, java.util.function.Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method updates the logging configuration from reading a properties file and ignores the \"java.util.logging.config.class\" system property. The \"java.util.logging.config.class\" property is only used by the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LogManager.html#readConfiguration()\"\u003e\u003ccode\u003ereadConfiguration()\u003c/code\u003e\u003c/a\u003e method to load a custom configuration class as an initial configuration."
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a functional interface that takes a configuration key \n\u003ci\u003ek\u003c/i\u003e and returns a function \n\u003ci\u003ef(o,n)\u003c/i\u003e whose returned value will be applied to the resulting configuration. The function \n\u003ci\u003ef\u003c/i\u003e may return \n\u003ccode\u003enull\u003c/code\u003e to indicate that the property \n\u003ci\u003ek\u003c/i\u003e will not be added to the resulting configuration. \n\u003cbr\u003e If \n\u003ccode\u003emapper\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e then \n\u003ccode\u003e(k) -\u0026gt; ((o, n) -\u0026gt; n)\u003c/code\u003e is assumed. \n\u003cbr\u003e For each \n\u003ci\u003ek\u003c/i\u003e, the mapped function \n\u003ci\u003ef\u003c/i\u003e will be invoked with the value associated with \n\u003ci\u003ek\u003c/i\u003e in the old configuration (i.e \n\u003ci\u003eo\u003c/i\u003e) and the value associated with \n\u003ci\u003ek\u003c/i\u003e in the new configuration (i.e. \n\u003ci\u003en\u003c/i\u003e). \n\u003cbr\u003eA \n\u003ccode\u003enull\u003c/code\u003e value for \n\u003ci\u003eo\u003c/i\u003e or \n\u003ci\u003en\u003c/i\u003e indicates that no value was present for \n\u003ci\u003ek\u003c/i\u003e in the corresponding configuration."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\"), or does not have the permissions required to set up the configuration (e.g. open file specified for FileHandlers etc...)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emapper\u003c/code\u003e returns a \n\u003ccode\u003enull\u003c/code\u003e function when invoked.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if there are problems reading from the logging configuration file."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.io.InputStream",
            "type": "Class"
          },
          "field": {
            "name": "ins"
          }
        },
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              },
              {
                "name": "java.util.function.BiFunction",
                "parameters": [
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  },
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  },
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "updateConfiguration",
      "comment": "Updates the logging configuration. For each configuration key in the existing configuration and the given input stream configuration, the given mapper function is invoked to map from the configuration key to a function, f(o,n), that takes the old value and new value and returns the resulting value to be applied in the resulting configuration, as specified in the table below. Let k be a configuration key in the old or new configuration, o be the old value (i.e. the value associated with k in the old configuration), n be the new value (i.e. the value associated with k in the new configuration), and f be the function returned by mapper.apply(k): then v \u003d f(o,n) is the resulting value. If v is not null, then a property k with value v will be added to the resulting configuration. Otherwise, it will be omitted. A null value may be passed to function f to indicate that the corresponding configuration has no configuration key k. The function f may return null to indicate that there will be no value associated with k in the resulting configuration. If mapper is null, then v will be set to n. LogManager properties are updated with the resulting value in the resulting configuration. The registered configuration listeners will be invoked after the configuration is successfully updated. Updating configuration properties Property Resulting Behavior \u003clogger\u003e.level If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary. If the old configuration defined a level for a logger, and the resulting configuration doesn\u0027t, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call reset to empty the current configuration, before calling updateConfiguration. \u003clogger\u003e.useParentHandlers If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true. \u003clogger\u003e.handlers If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary. If the old configuration defined some handlers for a logger, and the resulting configuration doesn\u0027t, if that logger exists, its handlers will be removed and closed. Changing the list of handlers on an existing logger will cause all its previous handlers to be removed and closed, regardless of whether they had been created from the configuration or programmatically. The old handlers will be replaced by new handlers, if any. \u003chandler-name\u003e.* Properties configured/changed on handler classes will only affect newly created handlers. If a node is configured with the same list of handlers in the old and the resulting configuration, then these handlers will remain unchanged. config and any other property The resulting value for these property will be stored in the LogManager properties, but updateConfiguration will not parse or process their values. Example mapper functions: Replace all logging properties with the new configuration: (k) -\u003e ((o, n) -\u003e n): this is equivalent to passing a null mapper parameter. Merge the new configuration and old configuration and use the new value if k exists in the new configuration: (k) -\u003e ((o, n) -\u003e n \u003d\u003d null ? o : n): as if merging two collections as follows: result.putAll(oldc); result.putAll(newc). Merge the new configuration and old configuration and use the old value if k exists in the old configuration: (k) -\u003e ((o, n) -\u003e o \u003d\u003d null ? n : o): as if merging two collections as follows: result.putAll(newc); result.putAll(oldc). Replace all properties with the new configuration except the handler property to configure Logger\u0027s handler that is not root logger: (k) -\u003e k.endsWith(\".handlers\")\n          ? ((o, n) -\u003e (o \u003d\u003d null ? n : o))\n          : ((o, n) -\u003e n) To completely reinitialize a configuration, an application can first call reset to fully remove the old configuration, followed by updateConfiguration to initialize the new configuration.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eins\u003c/code\u003e - a stream to read properties from",
          "\u003ccode\u003emapper\u003c/code\u003e - a functional interface that takes a configuration key \n\u003ci\u003ek\u003c/i\u003e and returns a function \n\u003ci\u003ef(o,n)\u003c/i\u003e whose returned value will be applied to the resulting configuration. The function \n\u003ci\u003ef\u003c/i\u003e may return \n\u003ccode\u003enull\u003c/code\u003e to indicate that the property \n\u003ci\u003ek\u003c/i\u003e will not be added to the resulting configuration. \n\u003cbr\u003e If \n\u003ccode\u003emapper\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e then \n\u003ccode\u003e(k) -\u0026gt; ((o, n) -\u0026gt; n)\u003c/code\u003e is assumed. \n\u003cbr\u003e For each \n\u003ci\u003ek\u003c/i\u003e, the mapped function \n\u003ci\u003ef\u003c/i\u003e will be invoked with the value associated with \n\u003ci\u003ek\u003c/i\u003e in the old configuration (i.e \n\u003ci\u003eo\u003c/i\u003e) and the value associated with \n\u003ci\u003ek\u003c/i\u003e in the new configuration (i.e. \n\u003ci\u003en\u003c/i\u003e). \n\u003cbr\u003eA \n\u003ccode\u003enull\u003c/code\u003e value for \n\u003ci\u003eo\u003c/i\u003e or \n\u003ci\u003en\u003c/i\u003e indicates that no value was present for \n\u003ci\u003ek\u003c/i\u003e in the corresponding configuration."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\"), or does not have the permissions required to set up the configuration (e.g. open files specified for FileHandlers)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eins\u003c/code\u003e is null or if \n\u003ccode\u003emapper\u003c/code\u003e returns a null function when invoked.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if there are problems reading from the stream, or the given stream is not in the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Properties.html\" title\u003d\"class in java.util\"\u003eproperties file\u003c/a\u003e format."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getProperty",
      "comment": "Get the value of a logging property. The method returns null if the property is not found.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - property name"
        ],
        "return": [
          "property value"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.SecurityException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "checkAccess",
      "comment": "Check that the current context is trusted to modify the logging configuration. This requires LoggingPermission(\"control\"). If the check fails we throw a SecurityException, otherwise we return normally.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\")."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.logging.LoggingMXBean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getLoggingMXBean",
      "comment": "Returns LoggingMXBean for managing loggers.",
      "annotations": [
        {
          "type": "Deprecated",
          "values": [
            {
              "name": "since",
              "value": "9"
            }
          ]
        }
      ],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.management/java/lang/management/PlatformLoggingMXBean.html\" title\u003d\"interface in java.lang.management\"\u003e\u003ccode\u003ePlatformLoggingMXBean\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/LoggingMXBean.html\" title\u003d\"interface in java.util.logging\"\u003e\u003ccode\u003eLoggingMXBean\u003c/code\u003e\u003c/a\u003e object."
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.logging.LogManager",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Runnable",
            "type": "Class"
          },
          "field": {
            "name": "listener"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "addConfigurationListener",
      "comment": "Adds a configuration listener to be invoked each time the logging configuration is read. If the listener is already registered the method does nothing. The listener is invoked with privileges that are restricted by the calling context of this method. The order in which the listeners are invoked is unspecified. It is recommended that listeners do not throw errors or exceptions. If a listener terminates with an uncaught error or exception then the first exception will be propagated to the caller of readConfiguration() (or readConfiguration(java.io.InputStream)) after all listeners have been invoked.",
      "tagMap": {
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - A configuration listener that will be invoked after the configuration changed."
        ],
        "implNote": [
          "If more than one listener terminates with an uncaught error or exception, an implementation may record the additional errors or exceptions as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)\"\u003esuppressed exceptions\u003c/a\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\").",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the listener is null."
        ],
        "return": [
          "This LogManager."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Runnable",
            "type": "Class"
          },
          "field": {
            "name": "listener"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "removeConfigurationListener",
      "comment": "Removes a previously registered configuration listener. Returns silently if the listener is not found.",
      "tagMap": {
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - the configuration listener to remove."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the listener is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have LoggingPermission(\"control\")."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Protected constructor. This is protected so that container applications (such as J2EE containers) can subclass the object. It is non-public as it is intended that there only be one LogManager object, whose value is retrieved by calling LogManager.getLogManager.",
      "tagMap": {}
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.util.logging.LogManager",
  "comment": "There is a single global LogManager object that is used to maintain a set of shared state about Loggers and log services. \n\u003cp\u003e This LogManager object: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e Manages a hierarchical namespace of Logger objects. All named Loggers are stored in this namespace. \u003c/li\u003e\n \u003cli\u003e Manages a set of logging control properties. These are simple key-value pairs that can be used by Handlers and other logging objects to configure themselves. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The global LogManager object can be retrieved using LogManager.getLogManager(). The LogManager object is created during class initialization and cannot subsequently be changed. \u003c/p\u003e\n\u003cp\u003e At startup the LogManager class is located using the java.util.logging.manager system property. \u003c/p\u003e\n\u003ch2\u003eLogManager Configuration\u003c/h2\u003e A LogManager initializes the logging configuration via the \n\u003ca href\u003d\"#readConfiguration()\"\u003e\u003ccode\u003ereadConfiguration()\u003c/code\u003e\u003c/a\u003e method during LogManager initialization. By default, LogManager default configuration is used. The logging configuration read by LogManager must be in the \n\u003ca href\u003d\"../../../../java.base/java/util/Properties.html\" title\u003d\"class in java.util\"\u003eproperties file\u003c/a\u003e format. \n\u003cp\u003e The LogManager defines two optional system properties that allow control over the initial configuration, as specified in the \u003ca href\u003d\"#readConfiguration()\"\u003e\u003ccode\u003ereadConfiguration()\u003c/code\u003e\u003c/a\u003e method: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ccode\u003e\u003cspan id\u003d\"java.util.logging.config.class\" class\u003d\"search-tag-result\"\u003ejava.util.logging.config.class\u003c/span\u003e\u003c/code\u003e \u003c/li\u003e\n \u003cli\u003e\u003ccode\u003e\u003cspan id\u003d\"java.util.logging.config.file\" class\u003d\"search-tag-result\"\u003ejava.util.logging.config.file\u003c/span\u003e\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e These two system properties may be specified on the command line to the \"java\" command, or as system property definitions passed to JNI_CreateJavaVM. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"../../../../java.base/java/util/Properties.html\" title\u003d\"class in java.util\"\u003eproperties\u003c/a\u003e for loggers and Handlers will have names starting with the dot-separated name for the handler or logger.\u003cbr\u003e The global logging properties may include: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eA property \"handlers\". This defines a whitespace or comma separated list of class names for handler classes to load and register as handlers on the root Logger (the Logger named \"\"). Each class name must be for a Handler class which has a default constructor. Note that these Handlers may be created lazily, when they are first used. \u003c/li\u003e\n \u003cli\u003eA property \"\u0026lt;logger\u0026gt;.handlers\". This defines a whitespace or comma separated list of class names for handlers classes to load and register as handlers to the specified logger. Each class name must be for a Handler class which has a default constructor. Note that these Handlers may be created lazily, when they are first used. \u003c/li\u003e\n \u003cli\u003eA property \"\u0026lt;logger\u0026gt;.handlers.ensureCloseOnReset\". This defines a a boolean value. If \"\u0026lt;logger\u0026gt;.handlers\" is not defined or is empty, this property is ignored. Otherwise it defaults to \u003ccode\u003etrue\u003c/code\u003e. When the value is \u003ccode\u003etrue\u003c/code\u003e, the handlers associated with the logger are guaranteed to be closed on \u003ca href\u003d\"#reset()\"\u003ereset()\u003c/a\u003e and shutdown. This can be turned off by explicitly setting \"\u0026lt;logger\u0026gt;.handlers.ensureCloseOnReset\u003dfalse\" in the configuration. Note that turning this property off causes the risk of introducing a resource leak, as the logger may get garbage collected before \u003ccode\u003ereset()\u003c/code\u003e is called, thus preventing its handlers from being closed on \u003ccode\u003ereset()\u003c/code\u003e. In that case it is the responsibility of the application to ensure that the handlers are closed before the logger is garbage collected. \u003c/li\u003e\n \u003cli\u003eA property \"\u0026lt;logger\u0026gt;.useParentHandlers\". This defines a boolean value. By default every logger calls its parent in addition to handling the logging message itself, this often result in messages being handled by the root logger as well. When setting this property to false a Handler needs to be configured for this logger otherwise no logging messages are delivered. \u003c/li\u003e\n \u003cli\u003eA property \"config\". This property is intended to allow arbitrary configuration code to be run. The property defines a whitespace or comma separated list of class names. A new instance will be created for each named class. The default constructor of each class may execute arbitrary code to update the logging configuration, such as setting logger levels, adding handlers, adding filters, etc. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Note that all classes loaded during LogManager configuration are first searched on the system class path before any user class path. That includes the LogManager class, any config classes, and any handler classes. \u003c/p\u003e\n\u003cp\u003e Loggers are organized into a naming hierarchy based on their dot separated names. Thus \"a.b.c\" is a child of \"a.b\", but \"a.b1\" and a.b2\" are peers. \u003c/p\u003e\n\u003cp\u003e All properties whose names end with \".level\" are assumed to define log levels for Loggers. Thus \"foo.level\" defines a log level for the logger called \"foo\" and (recursively) for any of its children in the naming hierarchy. Log Levels are applied in the order they are defined in the properties file. Thus level settings for child nodes in the tree should come after settings for their parents. The property name \".level\" can be used to set the level for the root of the tree. \u003c/p\u003e\n\u003cp\u003e All methods on the LogManager object are multi-thread safe.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.4"
    ]
  }
}