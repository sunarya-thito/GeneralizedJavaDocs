{
  "packageName": "java.util.logging",
  "simpleName": "MemoryHandler",
  "moduleName": "java.logging",
  "type": "CLASS",
  "superClass": {
    "name": "java.util.logging.Handler",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.logging.LogRecord",
            "type": "Class"
          },
          "field": {
            "name": "record"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "publish",
      "comment": "Store a LogRecord in an internal buffer. If there is a Filter, its isLoggable method is called to check if the given log record is loggable. If not we return. Otherwise the given record is copied into an internal circular buffer. Then the record\u0027s level property is compared with the pushLevel. If the given level is greater than or equal to the pushLevel then push is called to write all buffered records to the target output Handler.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html#publish(java.util.logging.LogRecord)\"\u003epublish\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html\" title\u003d\"class in java.util.logging\"\u003eHandler\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003erecord\u003c/code\u003e - description of the log event. A null record is silently ignored and is not published"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "push",
      "comment": "Push any buffered output to the target Handler. The buffer is then cleared.",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "flush",
      "comment": "Causes a flush on the target Handler. Note that the current contents of the MemoryHandler buffer are not written out. That requires a \"push\".",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html#flush()\"\u003eflush\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html\" title\u003d\"class in java.util.logging\"\u003eHandler\u003c/a\u003e\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.SecurityException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "close",
      "comment": "Close the Handler and free all associated resources. This will also close the target Handler.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html#close()\"\u003eclose\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html\" title\u003d\"class in java.util.logging\"\u003eHandler\u003c/a\u003e\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have \n\u003ccode\u003eLoggingPermission(\"control\")\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.SecurityException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.util.logging.Level",
            "type": "Class"
          },
          "field": {
            "name": "newLevel"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setPushLevel",
      "comment": "Set the pushLevel. After a LogRecord is copied into our internal buffer, if its level is greater than or equal to the pushLevel, then push will be called.",
      "tagMap": {
        "param": [
          "\u003ccode\u003enewLevel\u003c/code\u003e - the new value of the \n\u003ccode\u003epushLevel\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and if the caller does not have \n\u003ccode\u003eLoggingPermission(\"control\")\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.logging.Level",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPushLevel",
      "comment": "Get the pushLevel.",
      "tagMap": {
        "return": [
          "the value of the \n\u003ccode\u003epushLevel\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.logging.LogRecord",
            "type": "Class"
          },
          "field": {
            "name": "record"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isLoggable",
      "comment": "Check if this Handler would actually log a given LogRecord into its internal buffer. This method checks if the LogRecord has an appropriate level and whether it satisfies any Filter. However it does not check whether the LogRecord would result in a \"push\" of the buffer contents. It will return false if the LogRecord is null.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html#isLoggable(java.util.logging.LogRecord)\"\u003eisLoggable\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.logging/java/util/logging/Handler.html\" title\u003d\"class in java.util.logging\"\u003eHandler\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003erecord\u003c/code\u003e - a \n\u003ccode\u003eLogRecord\u003c/code\u003e (may be null)."
        ],
        "return": [
          "true if the \n\u003ccode\u003eLogRecord\u003c/code\u003e would be logged."
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Create a MemoryHandler and configure it based on LogManager configuration properties.",
      "tagMap": {}
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.util.logging.Handler",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "size"
          }
        },
        {
          "type": {
            "name": "java.util.logging.Level",
            "type": "Class"
          },
          "field": {
            "name": "pushLevel"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Create a MemoryHandler. The MemoryHandler is configured based on LogManager properties (or their default values) except that the given pushLevel argument and buffer size argument are used.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the Handler to which to publish output.",
          "\u003ccode\u003esize\u003c/code\u003e - the number of log records to buffer (must be greater than zero)",
          "\u003ccode\u003epushLevel\u003c/code\u003e - message level to push on"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003esize is \u0026lt;\u003d 0\u003c/code\u003e"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.util.logging.MemoryHandler",
  "comment": "\u003ccode\u003eHandler\u003c/code\u003e that buffers requests in a circular buffer in memory. \n\u003cp\u003e Normally this \u003ccode\u003eHandler\u003c/code\u003e simply stores incoming \u003ccode\u003eLogRecords\u003c/code\u003e into its memory buffer and discards earlier records. This buffering is very cheap and avoids formatting costs. On certain trigger conditions, the \u003ccode\u003eMemoryHandler\u003c/code\u003e will push out its current buffer contents to a target \u003ccode\u003eHandler\u003c/code\u003e, which will typically publish them to the outside world. \u003c/p\u003e\n\u003cp\u003e There are three main models for triggering a push of the buffer: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e An incoming \u003ccode\u003eLogRecord\u003c/code\u003e has a type that is greater than a pre-defined level, the \u003ccode\u003epushLevel\u003c/code\u003e. \u003c/li\u003e \n \u003cli\u003e An external class calls the \u003ccode\u003epush\u003c/code\u003e method explicitly. \u003c/li\u003e \n \u003cli\u003e A subclass overrides the \u003ccode\u003elog\u003c/code\u003e method and scans each incoming \u003ccode\u003eLogRecord\u003c/code\u003e and calls \u003ccode\u003epush\u003c/code\u003e if a record matches some desired criteria. \u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003cb\u003eConfiguration:\u003c/b\u003e By default each \u003ccode\u003eMemoryHandler\u003c/code\u003e is initialized using the following \u003ccode\u003eLogManager\u003c/code\u003e configuration properties where \u003ccode\u003e\u0026lt;handler-name\u0026gt;\u003c/code\u003e refers to the fully-qualified class name of the handler. If properties are not defined (or have invalid values) then the specified default values are used. If no default value is defined then a RuntimeException is thrown. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u0026lt;handler-name\u0026gt;.level specifies the level for the \u003ccode\u003eHandler\u003c/code\u003e (defaults to \u003ccode\u003eLevel.ALL\u003c/code\u003e). \u003c/li\u003e \n \u003cli\u003e \u0026lt;handler-name\u0026gt;.filter specifies the name of a \u003ccode\u003eFilter\u003c/code\u003e class to use (defaults to no \u003ccode\u003eFilter\u003c/code\u003e). \u003c/li\u003e \n \u003cli\u003e \u0026lt;handler-name\u0026gt;.size defines the buffer size (defaults to 1000). \u003c/li\u003e \n \u003cli\u003e \u0026lt;handler-name\u0026gt;.push defines the \u003ccode\u003epushLevel\u003c/code\u003e (defaults to \u003ccode\u003elevel.SEVERE\u003c/code\u003e). \u003c/li\u003e \n \u003cli\u003e \u0026lt;handler-name\u0026gt;.target specifies the name of the target \u003ccode\u003eHandler \u003c/code\u003e class. (no default). \u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e For example, the properties for \u003ccode\u003eMemoryHandler\u003c/code\u003e would be: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e java.util.logging.MemoryHandler.level\u003dINFO \u003c/li\u003e \n \u003cli\u003e java.util.logging.MemoryHandler.formatter\u003djava.util.logging.SimpleFormatter \u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e For a custom handler, e.g. com.foo.MyHandler, the properties would be: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e com.foo.MyHandler.level\u003dINFO \u003c/li\u003e \n \u003cli\u003e com.foo.MyHandler.formatter\u003djava.util.logging.SimpleFormatter \u003c/li\u003e \n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.4"
    ]
  }
}