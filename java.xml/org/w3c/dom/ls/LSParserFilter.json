{
  "packageName": "org.w3c.dom.ls",
  "simpleName": "LSParserFilter",
  "moduleName": "java.xml",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "short",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "FILTER_ACCEPT",
      "comment": "Accept the node.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#org.w3c.dom.ls.LSParserFilter.FILTER_ACCEPT\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "short",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "FILTER_REJECT",
      "comment": "Reject the node and its children.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#org.w3c.dom.ls.LSParserFilter.FILTER_REJECT\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "short",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "FILTER_SKIP",
      "comment": "Skip this single node. The children of this node will still be considered.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#org.w3c.dom.ls.LSParserFilter.FILTER_SKIP\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "short",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "FILTER_INTERRUPT",
      "comment": "Interrupt the normal processing of the document.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#org.w3c.dom.ls.LSParserFilter.FILTER_INTERRUPT\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "short",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "org.w3c.dom.Element",
            "type": "Class"
          },
          "name": "elementArg",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "startElement",
      "comment": "The parser will call this method after each Element start tag has been scanned, but before the remainder of the Element is processed. The intent is to allow the element, including any children, to be efficiently skipped. Note that only element nodes are passed to the startElement function. The element node passed to startElement for filtering will include all of the Element\u0027s attributes, but none of the children nodes. The Element may not yet be in place in the document being constructed (it may not have a parent node.) A startElement filter function may access or change the attributes for the Element. Changing Namespace declarations will have no effect on namespace resolution by the parser. For efficiency, the Element node passed to the filter may not be the same one as is actually placed in the tree if the node is accepted. And the actual node (node object identity) may be reused during the process of reading in and filtering a document.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eelementArg\u003c/code\u003e - The newly encountered element. At the time this method is called, the element is incomplete - it will have its attributes, but no children."
        ],
        "return": [
          "\u003cul\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_ACCEPT\u003c/code\u003e if the \u003ccode\u003eElement\u003c/code\u003e should be included in the DOM document being built. \u003c/li\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_REJECT\u003c/code\u003e if the \u003ccode\u003eElement\u003c/code\u003e and all of its children should be rejected. \u003c/li\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_SKIP\u003c/code\u003e if the \u003ccode\u003eElement\u003c/code\u003e should be skipped. All of its children are inserted in place of the skipped \u003ccode\u003eElement\u003c/code\u003e node. \u003c/li\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_INTERRUPT\u003c/code\u003e if the filter wants to stop the processing of the document. Interrupting the processing of the document does no longer guarantee that the resulting DOM tree is XML well-formed. The \u003ccode\u003eElement\u003c/code\u003e is rejected. \u003c/li\u003e \n\u003c/ul\u003e Returning any other values will result in unspecified behavior."
        ]
      }
    },
    {
      "returnType": {
        "name": "short",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "org.w3c.dom.Node",
            "type": "Class"
          },
          "name": "nodeArg",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "acceptNode",
      "comment": "This method will be called by the parser at the completion of the parsing of each node. The node and all of its descendants will exist and be complete. The parent node will also exist, although it may be incomplete, i.e. it may have additional children that have not yet been parsed. Attribute nodes are never passed to this function. From within this method, the new node may be freely modified - children may be added or removed, text nodes modified, etc. The state of the rest of the document outside this node is not defined, and the affect of any attempt to navigate to, or to modify any other part of the document is undefined. For validating parsers, the checks are made on the original document, before any modification by the filter. No validity checks are made on any document modifications made by the filter. If this new node is rejected, the parser might reuse the new node and any of its descendants.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enodeArg\u003c/code\u003e - The newly constructed element. At the time this method is called, the element is complete - it has all of its children (and their children, recursively) and attributes, and is attached as a child to its parent."
        ],
        "return": [
          "\u003cul\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_ACCEPT\u003c/code\u003e if this \u003ccode\u003eNode\u003c/code\u003e should be included in the DOM document being built. \u003c/li\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_REJECT\u003c/code\u003e if the \u003ccode\u003eNode\u003c/code\u003e and all of its children should be rejected. \u003c/li\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_SKIP\u003c/code\u003e if the \u003ccode\u003eNode\u003c/code\u003e should be skipped and the \u003ccode\u003eNode\u003c/code\u003e should be replaced by all the children of the \u003ccode\u003eNode\u003c/code\u003e. \u003c/li\u003e \n \u003cli\u003e \u003ccode\u003eFILTER_INTERRUPT\u003c/code\u003e if the filter wants to stop the processing of the document. Interrupting the processing of the document does no longer guarantee that the resulting DOM tree is XML well-formed. The \u003ccode\u003eNode\u003c/code\u003e is accepted and will be the last completely parsed node. \u003c/li\u003e \n\u003c/ul\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getWhatToShow",
      "comment": "Tells the LSParser what types of nodes to show to the method LSParserFilter.acceptNode. If a node is not shown to the filter using this attribute, it is automatically included in the DOM document being built. See NodeFilter for definition of the constants. The constants SHOW_ATTRIBUTE , SHOW_DOCUMENT, SHOW_DOCUMENT_TYPE, SHOW_NOTATION, SHOW_ENTITY, and SHOW_DOCUMENT_FRAGMENT are meaningless here. Those nodes will never be passed to LSParserFilter.acceptNode. The constants used here are defined in [DOM Level 2 Traversal and Range].",
      "annotations": [],
      "tagMap": {}
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "org.w3c.dom.ls.LSParserFilter",
  "annotations": [],
  "tagMap": {
    "since": [
      "1.5"
    ]
  }
}