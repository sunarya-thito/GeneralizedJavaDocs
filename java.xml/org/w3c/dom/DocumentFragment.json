{
  "packageName": "org.w3c.dom",
  "simpleName": "DocumentFragment",
  "moduleName": "java.xml",
  "type": "INTERFACE",
  "superClass": {
    "name": "org.w3c.dom.Node",
    "type": "Class"
  },
  "members": [],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "org.w3c.dom.DocumentFragment",
  "comment": "\u003ccode\u003eDocumentFragment\u003c/code\u003e is a \"lightweight\" or \"minimal\" \n\u003ccode\u003eDocument\u003c/code\u003e object. It is very common to want to be able to extract a portion of a document\u0027s tree or to create a new fragment of a document. Imagine implementing a user command like cut or rearranging a document by moving fragments around. It is desirable to have an object which can hold such fragments and it is quite natural to use a Node for this purpose. While it is true that a \n\u003ccode\u003eDocument\u003c/code\u003e object could fulfill this role, a \n\u003ccode\u003eDocument\u003c/code\u003e object can potentially be a heavyweight object, depending on the underlying implementation. What is really needed for this is a very lightweight object. \n\u003ccode\u003eDocumentFragment\u003c/code\u003e is such an object. \n\u003cp\u003eFurthermore, various operations -- such as inserting nodes as children of another \u003ccode\u003eNode\u003c/code\u003e -- may take \u003ccode\u003eDocumentFragment\u003c/code\u003e objects as arguments; this results in all the child nodes of the \u003ccode\u003eDocumentFragment\u003c/code\u003e being moved to the child list of this node. \u003c/p\u003e\n\u003cp\u003eThe children of a \u003ccode\u003eDocumentFragment\u003c/code\u003e node are zero or more nodes representing the tops of any sub-trees defining the structure of the document. \u003ccode\u003eDocumentFragment\u003c/code\u003e nodes do not need to be well-formed XML documents (although they do need to follow the rules imposed upon well-formed XML parsed entities, which can have multiple top nodes). For example, a \u003ccode\u003eDocumentFragment\u003c/code\u003e might have only one child and that child node could be a \u003ccode\u003eText\u003c/code\u003e node. Such a structure model represents neither an HTML document nor a well-formed XML document. \u003c/p\u003e\n\u003cp\u003eWhen a \u003ccode\u003eDocumentFragment\u003c/code\u003e is inserted into a \u003ccode\u003eDocument\u003c/code\u003e (or indeed any other \u003ccode\u003eNode\u003c/code\u003e that may take children) the children of the \u003ccode\u003eDocumentFragment\u003c/code\u003e and not the \u003ccode\u003eDocumentFragment\u003c/code\u003e itself are inserted into the \u003ccode\u003eNode\u003c/code\u003e. This makes the \u003ccode\u003eDocumentFragment\u003c/code\u003e very useful when the user wishes to create nodes that are siblings; the \u003ccode\u003eDocumentFragment\u003c/code\u003e acts as the parent of these nodes so that the user can use the standard methods from the \u003ccode\u003eNode\u003c/code\u003e interface, such as \u003ccode\u003eNode.insertBefore\u003c/code\u003e and \u003ccode\u003eNode.appendChild\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003eSee also the \u003ca href\u003d\"http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407\"\u003eDocument Object Model (DOM) Level 3 Core Specification\u003c/a\u003e.\u003c/p\u003e",
  "tagMap": {}
}