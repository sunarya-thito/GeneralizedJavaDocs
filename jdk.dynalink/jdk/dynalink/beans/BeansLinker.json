{
  "packageName": "jdk.dynalink.beans",
  "simpleName": "BeansLinker",
  "moduleName": "jdk.dynalink",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "jdk.dynalink.linker.TypeBasedGuardingDynamicLinker",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLinkerForClass",
      "comment": "Returns a bean linker for a particular single class. Useful when you need to override or extend the behavior of linking for some classes in your language runtime\u0027s linker, but still want to delegate to the default behavior in some cases.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class"
        ],
        "return": [
          "a bean linker for that class"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "obj"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "isDynamicMethod",
      "comment": "Returns true if the object is a Java dynamic method (e.g., one obtained through a GET:METHOD operation on a Java object or StaticClass or through getConstructorMethod(Class, String).",
      "tagMap": {
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the object we want to test for being a Java dynamic method."
        ],
        "return": [
          "true if it is a dynamic method, false otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "obj"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "isDynamicConstructor",
      "comment": "Returns true if the object is a Java constructor (obtained through getConstructorMethod(Class, String)}.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the object we want to test for being a Java constructor."
        ],
        "return": [
          "true if it is a constructor, false otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "signature"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getConstructorMethod",
      "comment": "Return the dynamic method of constructor of the given class and the given signature. This method is useful for exposing a functionality for selecting an overloaded constructor based on an explicit signature, as this functionality is not otherwise exposed by Dynalink as StaticClass objects act as overloaded constructors without explicit signature selection. Example usage would be: getConstructorMethod(java.awt.Color.class, \"int, int, int\").",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class",
          "\u003ccode\u003esignature\u003c/code\u003e - full signature of the constructor. Note how you can use names of primitive types, array names with normal Java notation (e.g. \n\u003ccode\u003e\"int[]\"\u003c/code\u003e), and normally you can even use unqualified class names (e.g. \n\u003ccode\u003e\"String, List\"\u003c/code\u003e instead of \n\u003ccode\u003e\"java.lang.String, java.util.List\"\u003c/code\u003e as long as they don\u0027t cause ambiguity in the specific parameter position."
        ],
        "return": [
          "dynamic method for the constructor or null if no constructor with the specified signature exists."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getReadableInstancePropertyNames",
      "comment": "Returns a set of names of all readable instance properties of a class.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class"
        ],
        "return": [
          "a set of names of all readable instance properties of a class."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getWritableInstancePropertyNames",
      "comment": "Returns a set of names of all writable instance properties of a class.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class"
        ],
        "return": [
          "a set of names of all writable instance properties of a class."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getInstanceMethodNames",
      "comment": "Returns a set of names of all instance methods of a class.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class"
        ],
        "return": [
          "a set of names of all instance methods of a class."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getReadableStaticPropertyNames",
      "comment": "Returns a set of names of all readable static properties of a class.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class"
        ],
        "return": [
          "a set of names of all readable static properties of a class."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getWritableStaticPropertyNames",
      "comment": "Returns a set of names of all writable static properties of a class.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class"
        ],
        "return": [
          "a set of names of all writable static properties of a class."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clazz"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getStaticMethodNames",
      "comment": "Returns a set of names of all static methods of a class.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eclazz\u003c/code\u003e - the class"
        ],
        "return": [
          "a set of names of all static methods of a class."
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.dynalink.linker.GuardedInvocation",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.Exception",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "jdk.dynalink.linker.LinkRequest",
            "type": "Class"
          },
          "field": {
            "name": "request"
          }
        },
        {
          "type": {
            "name": "jdk.dynalink.linker.LinkerServices",
            "type": "Class"
          },
          "field": {
            "name": "linkerServices"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getGuardedInvocation",
      "comment": "Description copied from interface: GuardingDynamicLinker",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.dynalink/jdk/dynalink/linker/GuardingDynamicLinker.html#getGuardedInvocation(jdk.dynalink.linker.LinkRequest,jdk.dynalink.linker.LinkerServices)\"\u003egetGuardedInvocation\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.dynalink/jdk/dynalink/linker/GuardingDynamicLinker.html\" title\u003d\"interface in jdk.dynalink.linker\"\u003eGuardingDynamicLinker\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003erequest\u003c/code\u003e - the object describing the request for linking a particular invocation",
          "\u003ccode\u003elinkerServices\u003c/code\u003e - linker services"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Exception.html\" title\u003d\"class in java.lang\"\u003eException\u003c/a\u003e\u003c/code\u003e - if the operation fails for whatever reason"
        ],
        "return": [
          "a guarded invocation with a method handle suitable for the arguments, as well as a guard condition that if fails should trigger relinking. Must return null if it can\u0027t resolve the invocation. If the returned invocation is unconditional (which is actually quite rare), the guard in the return value can be null. The invocation can also have any number of switch points for asynchronous invalidation of the linkage, as well as a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Throwable.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eThrowable\u003c/code\u003e\u003c/a\u003e subclass that describes an expected exception condition that also triggers relinking (often it is faster to rely on an infrequent but expected \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eClassCastException\u003c/code\u003e\u003c/a\u003e than on an always evaluated \n\u003ccode\u003einstanceof\u003c/code\u003e guard). While the linker must produce an invocation with parameter types matching those in the call site descriptor of the link request, it should not try to match the return type expected at the call site except when it can do it with only the conversions that lose neither precision nor magnitude, see \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.dynalink/jdk/dynalink/linker/LinkerServices.html#asTypeLosslessReturn(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eLinkerServices.asTypeLosslessReturn(MethodHandle, MethodType)\u003c/code\u003e\u003c/a\u003e for further explanation."
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new beans linker. Equivalent to BeansLinker(MissingMemberHandlerFactory) with null passed as the missing member handler factory, resulting in the default behavior for linking and evaluating missing members.",
      "tagMap": {}
    },
    {
      "parameters": [
        {
          "type": {
            "name": "jdk.dynalink.beans.MissingMemberHandlerFactory",
            "type": "Class"
          },
          "field": {
            "name": "missingMemberHandlerFactory"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new beans linker with the specified factory for creating missing member handlers. The passed factory can be null if the default behavior is adequate. See MissingMemberHandlerFactory for details.",
      "tagMap": {
        "param": [
          "\u003ccode\u003emissingMemberHandlerFactory\u003c/code\u003e - a factory for creating handlers for operations on missing members."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "jdk.dynalink.beans.BeansLinker",
  "comment": "A linker for ordinary Java objects. Normally used as the ultimate fallback linker by the \n\u003ca href\u003d\"../DynamicLinkerFactory.html\" title\u003d\"class in jdk.dynalink\"\u003e\u003ccode\u003eDynamicLinkerFactory\u003c/code\u003e\u003c/a\u003e so it is given the chance to link calls to all objects that no other linker recognized. Specifically, this linker will: \n\u003cul\u003e \n \u003cli\u003eexpose all public methods of form \u003ccode\u003esetXxx()\u003c/code\u003e, \u003ccode\u003egetXxx()\u003c/code\u003e, and \u003ccode\u003eisXxx()\u003c/code\u003e as property setters and getters for \u003ca href\u003d\"../StandardOperation.html#SET\"\u003e\u003ccode\u003eStandardOperation.SET\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"../StandardOperation.html#GET\"\u003e\u003ccode\u003eStandardOperation.GET\u003c/code\u003e\u003c/a\u003e operations in the \u003ca href\u003d\"../StandardNamespace.html#PROPERTY\"\u003e\u003ccode\u003eStandardNamespace.PROPERTY\u003c/code\u003e\u003c/a\u003e namespace;\u003c/li\u003e \n \u003cli\u003eexpose all public methods for retrieval for \u003ca href\u003d\"../StandardOperation.html#GET\"\u003e\u003ccode\u003eStandardOperation.GET\u003c/code\u003e\u003c/a\u003e operation in the \u003ca href\u003d\"../StandardNamespace.html#METHOD\"\u003e\u003ccode\u003eStandardNamespace.METHOD\u003c/code\u003e\u003c/a\u003e namespace; the methods thus retrieved can then be invoked using \u003ca href\u003d\"../StandardOperation.html#CALL\"\u003e\u003ccode\u003eStandardOperation.CALL\u003c/code\u003e\u003c/a\u003e.\u003c/li\u003e \n \u003cli\u003eexpose all public fields as properties, unless there are getters or setters for the properties of the same name;\u003c/li\u003e \n \u003cli\u003e expose elements of native Java arrays, \u003ca href\u003d\"../../../../java.base/java/util/List.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eList\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"../../../../java.base/java/util/Map.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eMap\u003c/code\u003e\u003c/a\u003e objects as \u003ca href\u003d\"../StandardOperation.html#GET\"\u003e\u003ccode\u003eStandardOperation.GET\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"../StandardOperation.html#SET\"\u003e\u003ccode\u003eStandardOperation.SET\u003c/code\u003e\u003c/a\u003e operations in the \u003ca href\u003d\"../StandardNamespace.html#ELEMENT\"\u003e\u003ccode\u003eStandardNamespace.ELEMENT\u003c/code\u003e\u003c/a\u003e namespace;\u003c/li\u003e \n \u003cli\u003e expose removal of elements of \u003ca href\u003d\"../../../../java.base/java/util/List.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eList\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"../../../../java.base/java/util/Map.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eMap\u003c/code\u003e\u003c/a\u003e objects as \u003ca href\u003d\"../StandardOperation.html#REMOVE\"\u003e\u003ccode\u003eStandardOperation.REMOVE\u003c/code\u003e\u003c/a\u003e operation in the \u003ca href\u003d\"../StandardNamespace.html#ELEMENT\"\u003e\u003ccode\u003eStandardNamespace.ELEMENT\u003c/code\u003e\u003c/a\u003e namespace;\u003c/li\u003e \n \u003cli\u003eexpose a virtual property named \u003ccode\u003elength\u003c/code\u003e on Java arrays, \u003ca href\u003d\"../../../../java.base/java/util/Collection.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eCollection\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"../../../../java.base/java/util/Map.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eMap\u003c/code\u003e\u003c/a\u003e objects;\u003c/li\u003e \n \u003cli\u003eexpose \u003ca href\u003d\"../StandardOperation.html#NEW\"\u003e\u003ccode\u003eStandardOperation.NEW\u003c/code\u003e\u003c/a\u003e on instances of \u003ca href\u003d\"StaticClass.html\" title\u003d\"class in jdk.dynalink.beans\"\u003e\u003ccode\u003eStaticClass\u003c/code\u003e\u003c/a\u003e as calls to constructors, including those static class objects that represent Java arrays (their constructors take a single \u003ccode\u003eint\u003c/code\u003e parameter representing the length of the array to create);\u003c/li\u003e \n \u003cli\u003eexpose static methods, fields, and properties of classes in a similar manner to how instance method, fields, and properties are exposed, on \u003ca href\u003d\"StaticClass.html\" title\u003d\"class in jdk.dynalink.beans\"\u003e\u003ccode\u003eStaticClass\u003c/code\u003e\u003c/a\u003e objects.\u003c/li\u003e \n \u003cli\u003eexpose a virtual property named \u003ccode\u003estatic\u003c/code\u003e on instances of \u003ca href\u003d\"../../../../java.base/java/lang/Class.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eClass\u003c/code\u003e\u003c/a\u003e to access their \u003ca href\u003d\"StaticClass.html\" title\u003d\"class in jdk.dynalink.beans\"\u003e\u003ccode\u003eStaticClass\u003c/code\u003e\u003c/a\u003e.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003cstrong\u003eOverloaded method resolution\u003c/strong\u003e is performed automatically for property setters, methods, and constructors. Additionally, manual overloaded method selection is supported by having a call site specify a name for a method that contains an explicit signature, e.g. \u003ccode\u003eStandardOperation.GET.withNamespace(METHOD).named(\"parseInt(String,int)\")\u003c/code\u003e You can use non-qualified class names in such signatures regardless of those classes\u0027 packages, they will match any class with the same non-qualified name. You only have to use a fully qualified class name in case non-qualified class names would cause selection ambiguity (that is extremely rare). Overloaded resolution for constructors is not automatic as there is no logical place to attach that functionality to but if a language wishes to provide this functionality, it can use \u003ca href\u003d\"#getConstructorMethod(java.lang.Class,java.lang.String)\"\u003e\u003ccode\u003egetConstructorMethod(Class, String)\u003c/code\u003e\u003c/a\u003e as a useful building block for it.\u003c/p\u003e \n\u003cp\u003e\u003cstrong\u003eVariable argument invocation\u003c/strong\u003e is handled for both methods and constructors.\u003c/p\u003e \n\u003cp\u003e\u003cstrong\u003eCaller sensitive methods\u003c/strong\u003e can be linked as long as they are otherwise public and link requests have call site descriptors carrying full-strength \u003ca href\u003d\"../../../../java.base/java/lang/invoke/MethodHandles.Lookup.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandles.Lookup\u003c/code\u003e\u003c/a\u003e objects and not weakened lookups or the public lookup.\u003c/p\u003e \n\u003cp\u003e\u003cstrong\u003eThe behavior for handling missing members\u003c/strong\u003e can be customized by passing a \u003ca href\u003d\"MissingMemberHandlerFactory.html\" title\u003d\"interface in jdk.dynalink.beans\"\u003e\u003ccode\u003eMissingMemberHandlerFactory\u003c/code\u003e\u003c/a\u003e to the \u003ca href\u003d\"#%3Cinit%3E(jdk.dynalink.beans.MissingMemberHandlerFactory)\"\u003e\u003ccode\u003econstructor\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e \n\u003cp\u003eThe class also exposes various methods for discovery of available property and method names on classes and class instances, as well as access to per-class linkers using the \u003ca href\u003d\"#getLinkerForClass(java.lang.Class)\"\u003e\u003ccode\u003egetLinkerForClass(Class)\u003c/code\u003e\u003c/a\u003e method.\u003c/p\u003e",
  "tagMap": {}
}