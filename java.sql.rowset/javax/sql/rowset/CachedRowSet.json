{
  "packageName": "javax.sql.rowset",
  "simpleName": "CachedRowSet",
  "moduleName": "java.sql.rowset",
  "type": "INTERFACE",
  "interfaces": [
    {
      "name": "javax.sql.RowSet",
      "type": "Class"
    },
    {
      "name": "javax.sql.rowset.Joinable",
      "type": "Class"
    }
  ],
  "members": [
    {
      "type": {
        "name": "boolean",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "COMMIT_ON_ACCEPT_CHANGES",
      "comment": "Causes the CachedRowSet object\u0027s SyncProvider to commit the changes when acceptChanges() is called. If set to false, the changes will not be committed until one of the CachedRowSet interface transaction methods is called.",
      "annotations": [
        {
          "type": {
            "name": "Deprecated",
            "type": "Class"
          }
        }
      ],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#commit()\"\u003e\u003ccode\u003ecommit()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#rollback()\"\u003e\u003ccode\u003erollback()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.sql.rowset.CachedRowSet.COMMIT_ON_ACCEPT_CHANGES\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "populate",
      "comment": "Populates this CachedRowSet object with data from the given ResultSet object. This method can be used as an alternative to the execute method when an application has a connection to an open ResultSet object. Using the method populate can be more efficient than using the version of the execute method that takes no parameters because it does not open a new connection and re-execute this CachedRowSet object\u0027s command. Using the populate method is more a matter of convenience when compared to using the version of execute that takes a ResultSet object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)\"\u003e\u003ccode\u003eexecute(java.sql.Connection)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSet.html\" title\u003d\"interface in java.sql\"\u003e\u003ccode\u003eResultSet\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSetMetaData.html\" title\u003d\"interface in java.sql\"\u003e\u003ccode\u003eResultSetMetaData\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003edata\u003c/code\u003e - the \n\u003ccode\u003eResultSet\u003c/code\u003e object containing the data to be read into this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if a null \n\u003ccode\u003eResultSet\u003c/code\u003e object is supplied or this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object cannot retrieve the associated \n\u003ccode\u003eResultSetMetaData\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "execute",
      "comment": "Populates this CachedRowSet object with data, using the given connection to produce the result set from which the data will be read. This method should close any database connections that it creates to ensure that this CachedRowSet object is disconnected except when it is reading data from its data source or writing data to its data source. The reader for this CachedRowSet object will use conn to establish a connection to the data source so that it can execute the rowset\u0027s command and read data from the the resulting ResultSet object into this CachedRowSet object. This method also closes conn after it has populated this CachedRowSet object. If this method is called when an implementation has already been populated, the contents and the metadata are (re)set. Also, if this method is called before the method acceptChanges has been called to commit outstanding updates, those updates are lost.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)\"\u003e\u003ccode\u003epopulate(java.sql.ResultSet)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/Connection.html\" title\u003d\"interface in java.sql\"\u003e\u003ccode\u003eConnection\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003econn\u003c/code\u003e - a standard JDBC \n\u003ccode\u003eConnection\u003c/code\u003e object with valid properties"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an invalid \n\u003ccode\u003eConnection\u003c/code\u003e object is supplied or an error occurs in establishing the connection to the data source"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "acceptChanges",
      "comment": "Propagates row update, insert and delete changes made to this CachedRowSet object to the underlying data source. This method calls on this CachedRowSet object\u0027s writer to do the work behind the scenes. Standard CachedRowSet implementations should use the SyncFactory singleton to obtain a SyncProvider instance providing a RowSetWriter object (writer). The writer will attempt to propagate changes made in this CachedRowSet object back to the data source. When the method acceptChanges executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. Depending on the synchronization level of the SyncProvider implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the RIOptimisticProvider implementation, for example, throws a SyncProviderException and does not write anything to the data source. An application may choose to catch the SyncProviderException object and retrieve the SyncResolver object it contains. The SyncResolver object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the acceptChanges method again to write resolved values to the data source. If all of the values in the data source are already the values to be persisted, the method acceptChanges does nothing. Some provider implementations may use locks to ensure that there are no conflicts. In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method acceptChanges is called. This method may be called immediately after the methods updateRow, insertRow, or deleteRow have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. Note: The acceptChanges() method will determine if the COMMIT_ON_ACCEPT_CHANGES is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application must explicitly call the commit() or rollback() methods as appropriate.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#acceptChanges(java.sql.Connection)\"\u003e\u003ccode\u003eacceptChanges(java.sql.Connection)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetWriter.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSetWriter\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncFactory.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncFactory\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProvider.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncProvider\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProviderException.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncProviderException\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncResolver.html\" title\u003d\"interface in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncResolver\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProviderException.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003eSyncProviderException\u003c/a\u003e\u003c/code\u003e - if the underlying synchronization provider\u0027s writer fails to write the updates back to the data source"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "acceptChanges",
      "comment": "Propagates all row update, insert and delete changes to the data source backing this CachedRowSet object using the specified Connection object to establish a connection to the data source. The other version of the acceptChanges method is not passed a connection because it uses the Connection object already defined within the RowSet object, which is the connection used for populating it initially. This form of the method acceptChanges is similar to the form that takes no arguments; however, unlike the other form, this form can be used only when the underlying data source is a JDBC data source. The updated Connection properties must be used by the SyncProvider to reset the RowSetWriter configuration to ensure that the contents of the CachedRowSet object are synchronized correctly. When the method acceptChanges executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. Depending on the synchronization level of the SyncProvider implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the RIOptimisticProvider implementation, for example, throws a SyncProviderException and does not write anything to the data source. An application may choose to catch the SyncProviderException object and retrieve the SyncResolver object it contains. The SyncResolver object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the acceptChanges method again to write resolved values to the data source. If all of the values in the data source are already the values to be persisted, the method acceptChanges does nothing. Some provider implementations may use locks to ensure that there are no conflicts. In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method acceptChanges is called. This method may be called immediately after the methods updateRow, insertRow, or deleteRow have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. Note: The acceptChanges() method will determine if the COMMIT_ON_ACCEPT_CHANGES is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application must explicitly call the commit or rollback methods as appropriate.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#acceptChanges()\"\u003e\u003ccode\u003eacceptChanges()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetWriter.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSetWriter\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncFactory.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncFactory\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProvider.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncProvider\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProviderException.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncProviderException\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncResolver.html\" title\u003d\"interface in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncResolver\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003econ\u003c/code\u003e - a standard JDBC \n\u003ccode\u003eConnection\u003c/code\u003e object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProviderException.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003eSyncProviderException\u003c/a\u003e\u003c/code\u003e - if the underlying synchronization provider\u0027s writer fails to write the updates back to the data source"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "restoreOriginal",
      "comment": "Restores this CachedRowSet object to its original value, that is, its value before the last set of changes. If there have been no changes to the rowset or only one set of changes, the original value is the value with which this CachedRowSet object was populated; otherwise, the original value is the value it had immediately before its current value. When this method is called, a CachedRowSet implementation must ensure that all updates, inserts, and deletes to the current rowset instance are replaced by the previous values. In addition, the cursor should be reset to the first row and a rowSetChanged event should be fired to notify all registered listeners.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetListener.html#rowSetChanged(javax.sql.RowSetEvent)\"\u003e\u003ccode\u003eRowSetListener.rowSetChanged(javax.sql.RowSetEvent)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs rolling back the current value of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object to its previous value"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "release",
      "comment": "Releases the current contents of this CachedRowSet object and sends a rowSetChanged event to all registered listeners. Any outstanding updates are discarded and the rowset contains no rows after this method is called. There are no interactions with the underlying data source, and any rowset content, metadata, and content updates should be non-recoverable. This CachedRowSet object should lock until its contents and associated updates are fully cleared, thus preventing \u0027dirty\u0027 reads by other components that hold a reference to this RowSet object. In addition, the contents cannot be released until all components reading this CachedRowSet object have completed their reads. This CachedRowSet object should be returned to normal behavior after firing the rowSetChanged event. The metadata, including JDBC properties and Synchronization SPI properties, are maintained for future use. It is important that properties such as the command property be relevant to the originating data source from which this CachedRowSet object was originally established. This method empties a rowset, as opposed to the close method, which marks the entire rowset as recoverable to allow the garbage collector the rowset\u0027s Java VM resources.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetListener.html#rowSetChanged(javax.sql.RowSetEvent)\"\u003e\u003ccode\u003eRowSetListener.rowSetChanged(javax.sql.RowSetEvent)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSet.html#close()\"\u003e\u003ccode\u003eResultSet.close()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs flushing the contents of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "undoDelete",
      "comment": "Cancels the deletion of the current row and notifies listeners that a row has changed. After this method is called, the current row is no longer marked for deletion. This method can be called at any time during the lifetime of the rowset. In addition, multiple cancellations of row deletions can be made by adjusting the position of the cursor using any of the cursor position control methods such as: CachedRowSet.absolute CachedRowSet.first CachedRowSet.last",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#undoInsert()\"\u003e\u003ccode\u003eundoInsert()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSet.html#cancelRowUpdates()\"\u003e\u003ccode\u003eResultSet.cancelRowUpdates()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if (1) the current row has not been deleted or (2) the cursor is on the insert row, before the first row, or after the last row"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "undoInsert",
      "comment": "Immediately removes the current row from this CachedRowSet object if the row has been inserted, and also notifies listeners that a row has changed. This method can be called at any time during the lifetime of a rowset and assuming the current row is within the exception limitations (see below), it cancels the row insertion of the current row. In addition, multiple cancellations of row insertions can be made by adjusting the position of the cursor using any of the cursor position control methods such as: CachedRowSet.absolute CachedRowSet.first CachedRowSet.last",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#undoDelete()\"\u003e\u003ccode\u003eundoDelete()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSet.html#cancelRowUpdates()\"\u003e\u003ccode\u003eResultSet.cancelRowUpdates()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if (1) the current row has not been inserted or (2) the cursor is before the first row, after the last row, or on the insert row"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "undoUpdate",
      "comment": "Immediately reverses the last update operation if the row has been modified. This method can be called to reverse updates on all columns until all updates in a row have been rolled back to their state just prior to the last synchronization (acceptChanges) or population. This method may also be called while performing updates to the insert row. undoUpdate may be called at any time during the lifetime of a rowset; however, after a synchronization has occurred, this method has no effect until further modification to the rowset data has occurred.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#undoDelete()\"\u003e\u003ccode\u003eundoDelete()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#undoInsert()\"\u003e\u003ccode\u003eundoInsert()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSet.html#cancelRowUpdates()\"\u003e\u003ccode\u003eResultSet.cancelRowUpdates()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if the cursor is before the first row or after the last row in this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "columnUpdated",
      "comment": "Indicates whether the designated column in the current row of this CachedRowSet object has been updated.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/DatabaseMetaData.html#updatesAreDetected(int)\"\u003e\u003ccode\u003eDatabaseMetaData.updatesAreDetected(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eidx\u003c/code\u003e - an \n\u003ccode\u003eint\u003c/code\u003e identifying the column to be checked for updates"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if the cursor is on the insert row, before the first row, or after the last row"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the designated column has been visibly updated; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "columnUpdated",
      "comment": "Indicates whether the designated column in the current row of this CachedRowSet object has been updated.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/DatabaseMetaData.html#updatesAreDetected(int)\"\u003e\u003ccode\u003eDatabaseMetaData.updatesAreDetected(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ecolumnName\u003c/code\u003e - a \n\u003ccode\u003eString\u003c/code\u003e object giving the name of the column to be checked for updates"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if the cursor is on the insert row, before the first row, or after the last row"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the column has been visibly updated; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Collection",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toCollection",
      "comment": "Converts this CachedRowSet object to a Collection object that contains all of this CachedRowSet object\u0027s data. Implementations have some latitude in how they can represent this Collection object because of the abstract nature of the Collection framework. Each row must be fully represented in either a general purpose Collection implementation or a specialized Collection implementation, such as a TreeMap object or a Vector object. An SQL NULL column value must be represented as a null in the Java programming language. The standard reference implementation for the CachedRowSet interface uses a TreeMap object for the rowset, with the values in each row being contained in Vector objects. It is expected that most implementations will do the same. The TreeMap type of collection guarantees that the map will be in ascending key order, sorted according to the natural order for the key\u0027s class. Each key references a Vector object that corresponds to one row of a RowSet object. Therefore, the size of each Vector object must be exactly equal to the number of columns in the RowSet object. The key used by the TreeMap collection is determined by the implementation, which may choose to leverage a set key that is available within the internal RowSet tabular structure by virtue of a key already set either on the RowSet object itself or on the underlying SQL data.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#toCollection(int)\"\u003e\u003ccode\u003etoCollection(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)\"\u003e\u003ccode\u003etoCollection(String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs generating the collection"
        ],
        "return": [
          "a \n\u003ccode\u003eCollection\u003c/code\u003e object that contains the values in each row in this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Collection",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toCollection",
      "comment": "Converts the designated column in this CachedRowSet object to a Collection object. Implementations have some latitude in how they can represent this Collection object because of the abstract nature of the Collection framework. Each column value should be fully represented in either a general purpose Collection implementation or a specialized Collection implementation, such as a Vector object. An SQL NULL column value must be represented as a null in the Java programming language. The standard reference implementation uses a Vector object to contain the column values, and it is expected that most implementations will do the same. If a Vector object is used, it size must be exactly equal to the number of rows in this CachedRowSet object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#toCollection()\"\u003e\u003ccode\u003etoCollection()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)\"\u003e\u003ccode\u003etoCollection(String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ecolumn\u003c/code\u003e - an \n\u003ccode\u003eint\u003c/code\u003e indicating the column whose values are to be represented in a \n\u003ccode\u003eCollection\u003c/code\u003e object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs generating the collection or an invalid column id is provided"
        ],
        "return": [
          "a \n\u003ccode\u003eCollection\u003c/code\u003e object that contains the values stored in the specified column of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Collection",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toCollection",
      "comment": "Converts the designated column in this CachedRowSet object to a Collection object. Implementations have some latitude in how they can represent this Collection object because of the abstract nature of the Collection framework. Each column value should be fully represented in either a general purpose Collection implementation or a specialized Collection implementation, such as a Vector object. An SQL NULL column value must be represented as a null in the Java programming language. The standard reference implementation uses a Vector object to contain the column values, and it is expected that most implementations will do the same. If a Vector object is used, it size must be exactly equal to the number of rows in this CachedRowSet object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#toCollection()\"\u003e\u003ccode\u003etoCollection()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#toCollection(int)\"\u003e\u003ccode\u003etoCollection(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ecolumn\u003c/code\u003e - a \n\u003ccode\u003eString\u003c/code\u003e object giving the name of the column whose values are to be represented in a collection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs generating the collection or an invalid column id is provided"
        ],
        "return": [
          "a \n\u003ccode\u003eCollection\u003c/code\u003e object that contains the values stored in the specified column of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sql.rowset.spi.SyncProvider",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getSyncProvider",
      "comment": "Retrieves the SyncProvider implementation for this CachedRowSet object. Internally, this method is used by a rowset to trigger read or write actions between the rowset and the data source. For example, a rowset may need to get a handle on the rowset reader (RowSetReader object) from the SyncProvider to allow the rowset to be populated.      RowSetReader rowsetReader \u003d null;\n     SyncProvider provider \u003d\n         SyncFactory.getInstance(\"javax.sql.rowset.provider.RIOptimisticProvider\");\n         if (provider instanceof RIOptimisticProvider) {\n             rowsetReader \u003d provider.getRowSetReader();\n         }\n Assuming rowsetReader is a private, accessible field within the rowset implementation, when an application calls the execute method, it in turn calls on the reader\u0027s readData method to populate the RowSet object.      rowsetReader.readData((RowSetInternal)this);\n In addition, an application can use the SyncProvider object returned by this method to call methods that return information about the SyncProvider object, including information about the vendor, version, provider identification, synchronization grade, and locks it currently has set.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#setSyncProvider(java.lang.String)\"\u003e\u003ccode\u003esetSyncProvider(java.lang.String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs while returning the \n\u003ccode\u003eSyncProvider\u003c/code\u003e object"
        ],
        "return": [
          "the \n\u003ccode\u003eSyncProvider\u003c/code\u003e object that was set when the rowset was instantiated, or if none was set, the default provider"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setSyncProvider",
      "comment": "Sets the SyncProvider object for this CachedRowSet object to the one specified. This method allows the SyncProvider object to be reset. A CachedRowSet implementation should always be instantiated with an available SyncProvider mechanism, but there are cases where resetting the SyncProvider object is desirable or necessary. For example, an application might want to use the default SyncProvider object for a time and then choose to use a provider that has more recently become available and better fits its needs. Resetting the SyncProvider object causes the RowSet object to request a new SyncProvider implementation from the SyncFactory. This has the effect of resetting all previous connections and relationships with the originating data source and can potentially drastically change the synchronization behavior of a disconnected rowset.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#getSyncProvider()\"\u003e\u003ccode\u003egetSyncProvider()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eprovider\u003c/code\u003e - a \n\u003ccode\u003eString\u003c/code\u003e object giving the fully qualified class name of a \n\u003ccode\u003eSyncProvider\u003c/code\u003e implementation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs while attempting to reset the \n\u003ccode\u003eSyncProvider\u003c/code\u003e implementation"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "size",
      "comment": "Returns the number of rows in this CachedRowSet object.",
      "annotations": [],
      "tagMap": {
        "return": [
          "number of rows in the rowset"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setMetaData",
      "comment": "Sets the metadata for this CachedRowSet object with the given RowSetMetaData object. When a RowSetReader object is reading the contents of a rowset, it creates a RowSetMetaData object and initializes it using the methods in the RowSetMetaData implementation. The reference implementation uses the RowSetMetaDataImpl class. When the reader has completed reading the rowset contents, this method is called internally to pass the RowSetMetaData object to the rowset.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003emd\u003c/code\u003e - a \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e object containing metadata about the columns in this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if invalid metadata is supplied to the rowset"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.sql.ResultSet",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getOriginal",
      "comment": "Returns a ResultSet object containing the original value of this CachedRowSet object. The cursor for the ResultSet object should be positioned before the first row. In addition, the returned ResultSet object should have the following properties: ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.CONCUR_UPDATABLE The original value for a RowSet object is the value it had before the last synchronization with the underlying data source. If there have been no synchronizations, the original value will be the value with which the RowSet object was populated. This method is called internally when an application calls the method acceptChanges and the SyncProvider object has been implemented to check for conflicts. If this is the case, the writer compares the original value with the value currently in the data source to check for conflicts.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs producing the \n\u003ccode\u003eResultSet\u003c/code\u003e object"
        ],
        "return": [
          "a \n\u003ccode\u003eResultSet\u003c/code\u003e object that contains the original value for this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.sql.ResultSet",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getOriginalRow",
      "comment": "Returns a ResultSet object containing the original value for the current row only of this CachedRowSet object. The cursor for the ResultSet object should be positioned before the first row. In addition, the returned ResultSet object should have the following properties: ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.CONCUR_UPDATABLE",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#setOriginalRow()\"\u003e\u003ccode\u003esetOriginalRow()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if there is no current row"
        ],
        "return": [
          "the original result set of the row"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setOriginalRow",
      "comment": "Sets the current row in this CachedRowSet object as the original row. This method is called internally after the any modified values in the current row have been synchronized with the data source. The current row must be tagged as no longer inserted, deleted or updated. A call to setOriginalRow is irreversible.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#getOriginalRow()\"\u003e\u003ccode\u003egetOriginalRow()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if there is no current row or an error is encountered resetting the contents of the original row"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getTableName",
      "comment": "Returns an identifier for the object (table) that was used to create this CachedRowSet object. This name may be set on multiple occasions, and the specification imposes no limits on how many times this may occur or whether standard implementations should keep track of previous table names.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSetMetaData.html#getTableName(int)\"\u003e\u003ccode\u003eResultSetMetaData.getTableName(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error is encountered returning the table name"
        ],
        "return": [
          "a \n\u003ccode\u003eString\u003c/code\u003e object giving the name of the table that is the source of data for this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object or \n\u003ccode\u003enull\u003c/code\u003e if no name has been set for the table"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setTableName",
      "comment": "Sets the identifier for the table from which this CachedRowSet object was derived to the given table name. The writer uses this name to determine which table to use when comparing the values in the data source with the CachedRowSet object\u0027s values during a synchronization attempt. The table identifier also indicates where modified values from this CachedRowSet object should be written. The implementation of this CachedRowSet object may obtain the the name internally from the RowSetMetaDataImpl object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetMetaData.html#setTableName(int,java.lang.String)\"\u003e\u003ccode\u003eRowSetMetaData.setTableName(int, java.lang.String)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetWriter.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSetWriter\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProvider.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncProvider\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etabName\u003c/code\u003e - a \n\u003ccode\u003eString\u003c/code\u003e object identifying the table from which this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object was derived; cannot be \n\u003ccode\u003enull\u003c/code\u003e but may be an empty string"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error is encountered naming the table or \n\u003ci\u003etabName\u003c/i\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getKeyColumns",
      "comment": "Returns an array containing one or more column numbers indicating the columns that form a key that uniquely identifies a row in this CachedRowSet object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#setKeyColumns(int%5B%5D)\"\u003e\u003ccode\u003esetKeyColumns(int[])\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/Joinable.html#getMatchColumnIndexes()\"\u003e\u003ccode\u003eJoinable.getMatchColumnIndexes()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/Joinable.html#getMatchColumnNames()\"\u003e\u003ccode\u003eJoinable.getMatchColumnNames()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object is empty"
        ],
        "return": [
          "an array containing the column number or numbers that indicate which columns constitute a primary key for a row in this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object. This array should be empty if no columns are representative of a primary key."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setKeyColumns",
      "comment": "Sets this CachedRowSet object\u0027s keyCols field with the given array of column numbers, which forms a key for uniquely identifying a row in this CachedRowSet object. If a CachedRowSet object becomes part of a JoinRowSet object, the keys defined by this method and the resulting constraints are maintained if the columns designated as key columns also become match columns.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#getKeyColumns()\"\u003e\u003ccode\u003egetKeyColumns()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/Joinable.html#setMatchColumn(java.lang.String)\"\u003e\u003ccode\u003eJoinable.setMatchColumn(String)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/Joinable.html#setMatchColumn(int)\"\u003e\u003ccode\u003eJoinable.setMatchColumn(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeys\u003c/code\u003e - an array of \n\u003ccode\u003eint\u003c/code\u003e indicating the columns that form a primary key for this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object; every element in the array must be greater than \n\u003ccode\u003e0\u003c/code\u003e and less than or equal to the number of columns in this rowset"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if any of the numbers in the given array are not valid for this rowset"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sql.RowSet",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createShared",
      "comment": "Returns a new RowSet object backed by the same data as that of this CachedRowSet object. In effect, both CachedRowSet objects have a cursor over the same data. As a result, any changes made by a duplicate are visible to the original and to any other duplicates, just as a change made by the original is visible to all of its duplicates. If a duplicate calls a method that changes the underlying data, the method it calls notifies all registered listeners just as it would when it is called by the original CachedRowSet object. In addition, any RowSet object created by this method will have the same properties as this CachedRowSet object. For example, if this CachedRowSet object is read-only, all of its duplicates will also be read-only. If it is changed to be updatable, the duplicates also become updatable. NOTE: If multiple threads access RowSet objects created from the createShared() method, the following behavior is specified to preserve shared data integrity: reads and writes of all shared RowSet objects should be made serially between each object and the single underlying tabular structure.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetEvent.html\" title\u003d\"class in javax.sql\"\u003e\u003ccode\u003eRowSetEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetListener.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSetListener\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs or cloning is not supported in the underlying platform"
        ],
        "return": [
          "a new shared \n\u003ccode\u003eRowSet\u003c/code\u003e object that has the same properties as this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object and that has a cursor over the same data"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sql.rowset.CachedRowSet",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createCopy",
      "comment": "Creates a RowSet object that is a deep copy of the data in this CachedRowSet object. In contrast to the RowSet object generated from a createShared call, updates made to the copy of the original RowSet object must not be visible to the original RowSet object. Also, any event listeners that are registered with the original RowSet must not have scope over the new RowSet copies. In addition, any constraint restrictions established must be maintained.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createShared()\"\u003e\u003ccode\u003ecreateShared()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createCopySchema()\"\u003e\u003ccode\u003ecreateCopySchema()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()\"\u003e\u003ccode\u003ecreateCopyNoConstraints()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetEvent.html\" title\u003d\"class in javax.sql\"\u003e\u003ccode\u003eRowSetEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetListener.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSetListener\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs in generating the copy of the of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ],
        "return": [
          "a new \n\u003ccode\u003eRowSet\u003c/code\u003e object that is a deep copy of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object and is completely independent of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sql.rowset.CachedRowSet",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createCopySchema",
      "comment": "Creates a CachedRowSet object that is an empty copy of this CachedRowSet object. The copy must not contain any contents but only represent the table structure of the original CachedRowSet object. In addition, primary or foreign key constraints set in the originating CachedRowSet object must be equally enforced in the new empty CachedRowSet object. In contrast to the RowSet object generated from a createShared method call, updates made to a copy of this CachedRowSet object with the createCopySchema method must not be visible to it. Applications can form a WebRowSet object from the CachedRowSet object returned by this method in order to export the RowSet schema definition to XML for future use.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createShared()\"\u003e\u003ccode\u003ecreateShared()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createCopySchema()\"\u003e\u003ccode\u003ecreateCopySchema()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()\"\u003e\u003ccode\u003ecreateCopyNoConstraints()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetEvent.html\" title\u003d\"class in javax.sql\"\u003e\u003ccode\u003eRowSetEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetListener.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSetListener\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs in cloning the structure of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ],
        "return": [
          "An empty copy of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sql.rowset.CachedRowSet",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createCopyNoConstraints",
      "comment": "Creates a CachedRowSet object that is a deep copy of this CachedRowSet object\u0027s data but is independent of it. In contrast to the RowSet object generated from a createShared method call, updates made to a copy of this CachedRowSet object must not be visible to it. Also, any event listeners that are registered with this CachedRowSet object must not have scope over the new RowSet object. In addition, any constraint restrictions established for this CachedRowSet object must not be maintained in the copy.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createCopy()\"\u003e\u003ccode\u003ecreateCopy()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createShared()\"\u003e\u003ccode\u003ecreateShared()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#createCopySchema()\"\u003e\u003ccode\u003ecreateCopySchema()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetEvent.html\" title\u003d\"class in javax.sql\"\u003e\u003ccode\u003eRowSetEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSetListener.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSetListener\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs in generating the copy of the of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ],
        "return": [
          "a new \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object that is a deep copy of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object and is completely independent of this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sql.rowset.RowSetWarning",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getRowSetWarnings",
      "comment": "Retrieves the first warning reported by calls on this RowSet object. Subsequent warnings on this RowSet object will be chained to the RowSetWarning object that this method returns. The warning chain is automatically cleared each time a new row is read. This method may not be called on a RowSet object that has been closed; doing so will cause a SQLException to be thrown.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/RowSetWarning.html\" title\u003d\"class in javax.sql.rowset\"\u003e\u003ccode\u003eRowSetWarning\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if this method is called on a closed RowSet"
        ],
        "return": [
          "RowSetWarning the first \n\u003ccode\u003eRowSetWarning\u003c/code\u003e object reported or null if there are none"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getShowDeleted",
      "comment": "Retrieves a boolean indicating whether rows marked for deletion appear in the set of current rows. If true is returned, deleted rows are visible with the current rows. If false is returned, rows are not visible with the set of current rows. The default value is false. Standard rowset implementations may choose to restrict this behavior due to security considerations or to better fit certain deployment scenarios. This is left as implementation defined and does not represent standard behavior. Note: Allowing deleted rows to remain visible complicates the behavior of some standard JDBC RowSet Implementations methods. However, most rowset users can simply ignore this extra detail because only very specialized applications will likely want to take advantage of this feature.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#setShowDeleted(boolean)\"\u003e\u003ccode\u003esetShowDeleted(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if a rowset implementation is unable to to determine whether rows marked for deletion are visible"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if deleted rows are visible; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setShowDeleted",
      "comment": "Sets the property showDeleted to the given boolean value, which determines whether rows marked for deletion appear in the set of current rows. If the value is set to true, deleted rows are immediately visible with the set of current rows. If the value is set to false, the deleted rows are set as invisible with the current set of rows. Standard rowset implementations may choose to restrict this behavior due to security considerations or to better fit certain deployment scenarios. This is left as implementations defined and does not represent standard behavior.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#getShowDeleted()\"\u003e\u003ccode\u003egetShowDeleted()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eb\u003c/code\u003e - \n\u003ccode\u003etrue\u003c/code\u003e if deleted rows should be shown; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if a rowset implementation is unable to to reset whether deleted rows should be visible"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "commit",
      "comment": "Each CachedRowSet object\u0027s SyncProvider contains a Connection object from the ResultSet or JDBC properties passed to it\u0027s constructors. This method wraps the Connection commit method to allow flexible auto commit or non auto commit transactional control support. Makes all changes that are performed by the acceptChanges() method since the previous commit/rollback permanent. This method should be used only when auto-commit mode has been disabled.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/Connection.html#setAutoCommit(boolean)\"\u003e\u003ccode\u003eConnection.setAutoCommit(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if a database access error occurs or this Connection object within this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e is in auto-commit mode"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "rollback",
      "comment": "Each CachedRowSet object\u0027s SyncProvider contains a Connection object from the original ResultSet or JDBC properties passed to it. Undoes all changes made in the current transaction. This method should be used only when auto-commit mode has been disabled.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if a database access error occurs or this Connection object within this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e is in auto-commit mode."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "rollback",
      "comment": "Each CachedRowSet object\u0027s SyncProvider contains a Connection object from the original ResultSet or JDBC properties passed to it. Undoes all changes made in the current transaction back to the last Savepoint transaction marker. This method should be used only when auto-commit mode has been disabled.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - A \n\u003ccode\u003eSavepoint\u003c/code\u003e transaction marker"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if a database access error occurs or this Connection object within this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e is in auto-commit mode."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "rowSetPopulated",
      "comment": "Notifies registered listeners that a RowSet object in the given RowSetEvent object has populated a number of additional rows. The numRows parameter ensures that this event will only be fired every numRow. The source of the event can be retrieved with the method event.getSource.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eevent\u003c/code\u003e - a \n\u003ccode\u003eRowSetEvent\u003c/code\u003e object that contains the \n\u003ccode\u003eRowSet\u003c/code\u003e object that is the source of the events",
          "\u003ccode\u003enumRows\u003c/code\u003e - when populating, the number of rows interval on which the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e populated should fire; the default value is zero; cannot be less than \n\u003ccode\u003efetchSize\u003c/code\u003e or zero"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - \n\u003ccode\u003enumRows \u0026lt; 0 or numRows \u0026lt; getFetchSize() \u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "populate",
      "comment": "Populates this CachedRowSet object with data from the given ResultSet object. While related to the populate(ResultSet) method, an additional parameter is provided to allow starting position within the ResultSet from where to populate the CachedRowSet instance. This method can be used as an alternative to the execute method when an application has a connection to an open ResultSet object. Using the method populate can be more efficient than using the version of the execute method that takes no parameters because it does not open a new connection and re-execute this CachedRowSet object\u0027s command. Using the populate method is more a matter of convenience when compared to using the version of execute that takes a ResultSet object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)\"\u003e\u003ccode\u003eexecute(java.sql.Connection)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)\"\u003e\u003ccode\u003epopulate(ResultSet)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSet.html\" title\u003d\"interface in java.sql\"\u003e\u003ccode\u003eResultSet\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/ResultSetMetaData.html\" title\u003d\"interface in java.sql\"\u003e\u003ccode\u003eResultSetMetaData\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003estartRow\u003c/code\u003e - the position in the \n\u003ccode\u003eResultSet\u003c/code\u003e from where to start populating the records in this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e",
          "\u003ccode\u003ers\u003c/code\u003e - the \n\u003ccode\u003eResultSet\u003c/code\u003e object containing the data to be read into this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if a null \n\u003ccode\u003eResultSet\u003c/code\u003e object is supplied or this \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object cannot retrieve the associated \n\u003ccode\u003eResultSetMetaData\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setPageSize",
      "comment": "Sets the CachedRowSet object\u0027s page-size. A CachedRowSet may be configured to populate itself in page-size sized batches of rows. When either populate() or execute() are called, the CachedRowSet fetches an additional page according to the original SQL query used to populate the RowSet.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esize\u003c/code\u003e - the page-size of the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs setting the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e page size or if the page size is less than 0."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getPageSize",
      "comment": "Returns the page-size for the CachedRowSet object",
      "annotations": [],
      "tagMap": {
        "return": [
          "an \n\u003ccode\u003eint\u003c/code\u003e page size"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "nextPage",
      "comment": "Increments the current page of the CachedRowSet. This causes the CachedRowSet implementation to fetch the next page-size rows and populate the RowSet, if remaining rows remain within scope of the original SQL query used to populated the RowSet.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs fetching the next page, or if this method is called prematurely before populate or execute."
        ],
        "return": [
          "true if more pages exist; false if this is the last page"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "previousPage",
      "comment": "Decrements the current page of the CachedRowSet. This causes the CachedRowSet implementation to fetch the previous page-size rows and populate the RowSet. The amount of rows returned in the previous page must always remain within scope of the original SQL query used to populate the RowSet.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs fetching the previous page, or if this method is called prematurely before populate or execute."
        ],
        "return": [
          "true if the previous page is successfully retrieved; false if this is the first page."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "javax.sql.rowset.CachedRowSet",
  "comment": "The interface that all standard implementations of \n\u003ccode\u003eCachedRowSet\u003c/code\u003e must implement. \n\u003cp\u003e The reference implementation of the \u003ccode\u003eCachedRowSet\u003c/code\u003e interface provided by Oracle Corporation is a standard implementation. Developers may use this implementation just as it is, they may extend it, or they may choose to write their own implementations of this interface. \u003c/p\u003e\n\u003cp\u003e A \u003ccode\u003eCachedRowSet\u003c/code\u003e object is a container for rows of data that caches its rows in memory, which makes it possible to operate without always being connected to its data source. Further, it is a JavaBeans component and is scrollable, updatable, and serializable. A \u003ccode\u003eCachedRowSet\u003c/code\u003e object typically contains rows from a result set, but it can also contain rows from any file with a tabular format, such as a spread sheet. The reference implementation supports getting data only from a \u003ccode\u003eResultSet\u003c/code\u003e object, but developers can extend the \u003ccode\u003eSyncProvider\u003c/code\u003e implementations to provide access to other tabular data sources. \u003c/p\u003e\n\u003cp\u003e An application can modify the data in a \u003ccode\u003eCachedRowSet\u003c/code\u003e object, and those modifications can then be propagated back to the source of the data. \u003c/p\u003e\n\u003cp\u003e A \u003ccode\u003eCachedRowSet\u003c/code\u003e object is a \u003ci\u003edisconnected\u003c/i\u003e rowset, which means that it makes use of a connection to its data source only briefly. It connects to its data source while it is reading data to populate itself with rows and again while it is propagating changes back to its underlying data source. The rest of the time, a \u003ccode\u003eCachedRowSet\u003c/code\u003e object is disconnected, including while its data is being modified. Being disconnected makes a \u003ccode\u003eRowSet\u003c/code\u003e object much leaner and therefore much easier to pass to another component. For example, a disconnected \u003ccode\u003eRowSet\u003c/code\u003e object can be serialized and passed over the wire to a thin client such as a personal digital assistant (PDA). \u003c/p\u003e\n\u003ch2\u003e1.0 Creating a \u003ccode\u003eCachedRowSet\u003c/code\u003e Object\u003c/h2\u003e The following line of code uses the default constructor for \n\u003ccode\u003eCachedRowSet\u003c/code\u003e supplied in the reference implementation (RI) to create a default \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object. \n\u003cpre\u003e     CachedRowSetImpl crs \u003d new CachedRowSetImpl();\n \u003c/pre\u003e This new \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object will have its properties set to the default properties of a \n\u003ccode\u003eBaseRowSet\u003c/code\u003e object, and, in addition, it will have an \n\u003ccode\u003eRIOptimisticProvider\u003c/code\u003e object as its synchronization provider. \n\u003ccode\u003eRIOptimisticProvider\u003c/code\u003e, one of two \n\u003ccode\u003eSyncProvider\u003c/code\u003e implementations included in the RI, is the default provider that the \n\u003ccode\u003eSyncFactory\u003c/code\u003e singleton will supply when no synchronization provider is specified. \n\u003cp\u003e A \u003ccode\u003eSyncProvider\u003c/code\u003e object provides a \u003ccode\u003eCachedRowSet\u003c/code\u003e object with a reader (a \u003ccode\u003eRowSetReader\u003c/code\u003e object) for reading data from a data source to populate itself with data. A reader can be implemented to read data from a \u003ccode\u003eResultSet\u003c/code\u003e object or from a file with a tabular format. A \u003ccode\u003eSyncProvider\u003c/code\u003e object also provides a writer (a \u003ccode\u003eRowSetWriter\u003c/code\u003e object) for synchronizing any modifications to the \u003ccode\u003eCachedRowSet\u003c/code\u003e object\u0027s data made while it was disconnected with the data in the underlying data source. \u003c/p\u003e\n\u003cp\u003e A writer can be implemented to exercise various degrees of care in checking for conflicts and in avoiding them. (A conflict occurs when a value in the data source has been changed after the rowset populated itself with that value.) The \u003ccode\u003eRIOptimisticProvider\u003c/code\u003e implementation assumes there will be few or no conflicts and therefore sets no locks. It updates the data source with values from the \u003ccode\u003eCachedRowSet\u003c/code\u003e object only if there are no conflicts. Other writers can be implemented so that they always write modified data to the data source, which can be accomplished either by not checking for conflicts or, on the other end of the spectrum, by setting locks sufficient to prevent data in the data source from being changed. Still other writer implementations can be somewhere in between. \u003c/p\u003e\n\u003cp\u003e A \u003ccode\u003eCachedRowSet\u003c/code\u003e object may use any \u003ccode\u003eSyncProvider\u003c/code\u003e implementation that has been registered with the \u003ccode\u003eSyncFactory\u003c/code\u003e singleton. An application can find out which \u003ccode\u003eSyncProvider\u003c/code\u003e implementations have been registered by calling the following line of code. \u003c/p\u003e\n\u003cpre\u003e      java.util.Enumeration providers \u003d SyncFactory.getRegisteredProviders();\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e There are two ways for a \u003ccode\u003eCachedRowSet\u003c/code\u003e object to specify which \u003ccode\u003eSyncProvider\u003c/code\u003e object it will use. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eSupplying the name of the implementation to the constructor\u003cbr\u003e The following line of code creates the \u003ccode\u003eCachedRowSet\u003c/code\u003e object \u003ci\u003ecrs2\u003c/i\u003e that is initialized with default values except that its \u003ccode\u003eSyncProvider\u003c/code\u003e object is the one specified. \u003cpre\u003e          CachedRowSetImpl crs2 \u003d new CachedRowSetImpl(\n                                 \"com.fred.providers.HighAvailabilityProvider\");\n     \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003eSetting the \u003ccode\u003eSyncProvider\u003c/code\u003e using the \u003ccode\u003eCachedRowSet\u003c/code\u003e method \u003ccode\u003esetSyncProvider\u003c/code\u003e\u003cbr\u003e The following line of code resets the \u003ccode\u003eSyncProvider\u003c/code\u003e object for \u003ci\u003ecrs\u003c/i\u003e, the \u003ccode\u003eCachedRowSet\u003c/code\u003e object created with the default constructor. \u003cpre\u003e           crs.setSyncProvider(\"com.fred.providers.HighAvailabilityProvider\");\n      \u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e See the comments for \n\u003ccode\u003eSyncFactory\u003c/code\u003e and \n\u003ccode\u003eSyncProvider\u003c/code\u003e for more details. \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e2.0 Retrieving Data from a \u003ccode\u003eCachedRowSet\u003c/code\u003e Object\u003c/h2\u003e Data is retrieved from a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object by using the getter methods inherited from the \n\u003ccode\u003eResultSet\u003c/code\u003e interface. The following examples, in which \n\u003ccode\u003ecrs\u003c/code\u003e is a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object, demonstrate how to iterate through the rows, retrieving the column values in each row. The first example uses the version of the getter methods that take a column number; the second example uses the version that takes a column name. Column numbers are generally used when the \n\u003ccode\u003eRowSet\u003c/code\u003e object\u0027s command is of the form \n\u003ccode\u003eSELECT * FROM TABLENAME\u003c/code\u003e; column names are most commonly used when the command specifies columns by name. \n\u003cpre\u003e    while (crs.next()) {\n        String name \u003d crs.getString(1);\n        int id \u003d crs.getInt(2);\n        Clob comment \u003d crs.getClob(3);\n        short dept \u003d crs.getShort(4);\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n \u003c/pre\u003e \n\u003cpre\u003e    while (crs.next()) {\n        String name \u003d crs.getString(\"NAME\");\n        int id \u003d crs.getInt(\"ID\");\n        Clob comment \u003d crs.getClob(\"COM\");\n        short dept \u003d crs.getShort(\"DEPT\");\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n \u003c/pre\u003e \n\u003ch3\u003e2.1 Retrieving \u003ccode\u003eRowSetMetaData\u003c/code\u003e\u003c/h3\u003e An application can get information about the columns in a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object by calling \n\u003ccode\u003eResultSetMetaData\u003c/code\u003e and \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e methods on a \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e object. The following code fragment, in which \n\u003ci\u003ecrs\u003c/i\u003e is a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object, illustrates the process. The first line creates a \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e object with information about the columns in \n\u003ci\u003ecrs\u003c/i\u003e. The method \n\u003ccode\u003egetMetaData\u003c/code\u003e, inherited from the \n\u003ccode\u003eResultSet\u003c/code\u003e interface, returns a \n\u003ccode\u003eResultSetMetaData\u003c/code\u003e object, which is cast to a \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e object before being assigned to the variable \n\u003ci\u003ersmd\u003c/i\u003e. The second line finds out how many columns \n\u003ci\u003ejrs\u003c/i\u003e has, and the third line gets the JDBC type of values stored in the second column of \n\u003ccode\u003ejrs\u003c/code\u003e. \n\u003cpre\u003e     RowSetMetaData rsmd \u003d (RowSetMetaData)crs.getMetaData();\n     int count \u003d rsmd.getColumnCount();\n     int type \u003d rsmd.getColumnType(2);\n \u003c/pre\u003e The \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e interface differs from the \n\u003ccode\u003eResultSetMetaData\u003c/code\u003e interface in two ways. \n\u003cul\u003e \n \u003cli\u003e\u003ci\u003eIt includes \u003ccode\u003esetter\u003c/code\u003e methods:\u003c/i\u003e A \u003ccode\u003eRowSet\u003c/code\u003e object uses these methods internally when it is populated with data from a different \u003ccode\u003eResultSet\u003c/code\u003e object. \u003c/li\u003e\n \u003cli\u003e\u003ci\u003eIt contains fewer \u003ccode\u003egetter\u003c/code\u003e methods:\u003c/i\u003e Some \u003ccode\u003eResultSetMetaData\u003c/code\u003e methods to not apply to a \u003ccode\u003eRowSet\u003c/code\u003e object. For example, methods retrieving whether a column value is writable or read only do not apply because all of a \u003ccode\u003eRowSet\u003c/code\u003e object\u0027s columns will be writable or read only, depending on whether the rowset is updatable or not. \u003c/li\u003e\n\u003c/ul\u003e NOTE: In order to return a \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e object, implementations must override the \n\u003ccode\u003egetMetaData()\u003c/code\u003e method defined in \n\u003ccode\u003ejava.sql.ResultSet\u003c/code\u003e and return a \n\u003ccode\u003eRowSetMetaData\u003c/code\u003e object. \n\u003ch2\u003e3.0 Updating a \u003ccode\u003eCachedRowSet\u003c/code\u003e Object\u003c/h2\u003e Updating a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object is similar to updating a \n\u003ccode\u003eResultSet\u003c/code\u003e object, but because the rowset is not connected to its data source while it is being updated, it must take an additional step to effect changes in its underlying data source. After calling the method \n\u003ccode\u003eupdateRow\u003c/code\u003e or \n\u003ccode\u003einsertRow\u003c/code\u003e, a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object must also call the method \n\u003ccode\u003eacceptChanges\u003c/code\u003e to have updates written to the data source. The following example, in which the cursor is on a row in the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object \n\u003ci\u003ecrs\u003c/i\u003e, shows the code required to update two column values in the current row and also update the \n\u003ccode\u003eRowSet\u003c/code\u003e object\u0027s underlying data source. \n\u003cpre\u003e     crs.updateShort(3, 58);\n     crs.updateInt(4, 150000);\n     crs.updateRow();\n     crs.acceptChanges();\n \u003c/pre\u003e \n\u003cp\u003e The next example demonstrates moving to the insert row, building a new row on the insert row, inserting it into the rowset, and then calling the method \u003ccode\u003eacceptChanges\u003c/code\u003e to add the new row to the underlying data source. Note that as with the getter methods, the updater methods may take either a column index or a column name to designate the column being acted upon. \u003c/p\u003e\n\u003cpre\u003e     crs.moveToInsertRow();\n     crs.updateString(\"Name\", \"Shakespeare\");\n     crs.updateInt(\"ID\", 10098347);\n     crs.updateShort(\"Age\", 58);\n     crs.updateInt(\"Sal\", 150000);\n     crs.insertRow();\n     crs.moveToCurrentRow();\n     crs.acceptChanges();\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e NOTE: Where the \u003ccode\u003einsertRow()\u003c/code\u003e method inserts the contents of a \u003ccode\u003eCachedRowSet\u003c/code\u003e object\u0027s insert row is implementation-defined. The reference implementation for the \u003ccode\u003eCachedRowSet\u003c/code\u003e interface inserts a new row immediately following the current row, but it could be implemented to insert new rows in any number of other places. \u003c/p\u003e\n\u003cp\u003e Another thing to note about these examples is how they use the method \u003ccode\u003eacceptChanges\u003c/code\u003e. It is this method that propagates changes in a \u003ccode\u003eCachedRowSet\u003c/code\u003e object back to the underlying data source, calling on the \u003ccode\u003eRowSet\u003c/code\u003e object\u0027s writer internally to write changes to the data source. To do this, the writer has to incur the expense of establishing a connection with that data source. The preceding two code fragments call the method \u003ccode\u003eacceptChanges\u003c/code\u003e immediately after calling \u003ccode\u003eupdateRow\u003c/code\u003e or \u003ccode\u003einsertRow\u003c/code\u003e. However, when there are multiple rows being changed, it is more efficient to call \u003ccode\u003eacceptChanges\u003c/code\u003e after all calls to \u003ccode\u003eupdateRow\u003c/code\u003e and \u003ccode\u003einsertRow\u003c/code\u003e have been made. If \u003ccode\u003eacceptChanges\u003c/code\u003e is called only once, only one connection needs to be established. \u003c/p\u003e\n\u003ch2\u003e4.0 Updating the Underlying Data Source\u003c/h2\u003e When the method \n\u003ccode\u003eacceptChanges\u003c/code\u003e is executed, the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object\u0027s writer, a \n\u003ccode\u003eRowSetWriterImpl\u003c/code\u003e object, is called behind the scenes to write the changes made to the rowset to the underlying data source. The writer is implemented to make a connection to the data source and write updates to it. \n\u003cp\u003e A writer is made available through an implementation of the \u003ccode\u003eSyncProvider\u003c/code\u003e interface, as discussed in section 1, \"Creating a \u003ccode\u003eCachedRowSet\u003c/code\u003e Object.\" The default reference implementation provider, \u003ccode\u003eRIOptimisticProvider\u003c/code\u003e, has its writer implemented to use an optimistic concurrency control mechanism. That is, it maintains no locks in the underlying database while the rowset is disconnected from the database and simply checks to see if there are any conflicts before writing data to the data source. If there are any conflicts, it does not write anything to the data source. \u003c/p\u003e\n\u003cp\u003e The reader/writer facility provided by the \u003ccode\u003eSyncProvider\u003c/code\u003e class is pluggable, allowing for the customization of data retrieval and updating. If a different concurrency control mechanism is desired, a different implementation of \u003ccode\u003eSyncProvider\u003c/code\u003e can be plugged in using the method \u003ccode\u003esetSyncProvider\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e In order to use the optimistic concurrency control routine, the \u003ccode\u003eRIOptimisticProvider\u003c/code\u003e maintains both its current value and its original value (the value it had immediately preceding the current value). Note that if no changes have been made to the data in a \u003ccode\u003eRowSet\u003c/code\u003e object, its current values and its original values are the same, both being the values with which the \u003ccode\u003eRowSet\u003c/code\u003e object was initially populated. However, once any values in the \u003ccode\u003eRowSet\u003c/code\u003e object have been changed, the current values and the original values will be different, though at this stage, the original values are still the initial values. With any subsequent changes to data in a \u003ccode\u003eRowSet\u003c/code\u003e object, its original values and current values will still differ, but its original values will be the values that were previously the current values. \u003c/p\u003e\n\u003cp\u003e Keeping track of original values allows the writer to compare the \u003ccode\u003eRowSet\u003c/code\u003e object\u0027s original value with the value in the database. If the values in the database differ from the \u003ccode\u003eRowSet\u003c/code\u003e object\u0027s original values, which means that the values in the database have been changed, there is a conflict. Whether a writer checks for conflicts, what degree of checking it does, and how it handles conflicts all depend on how it is implemented. \u003c/p\u003e\n\u003ch2\u003e5.0 Registering and Notifying Listeners\u003c/h2\u003e Being JavaBeans components, all rowsets participate in the JavaBeans event model, inheriting methods for registering listeners and notifying them of changes from the \n\u003ccode\u003eBaseRowSet\u003c/code\u003e class. A listener for a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object is a component that wants to be notified whenever there is a change in the rowset. For example, if a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object contains the results of a query and those results are being displayed in, say, a table and a bar graph, the table and bar graph could be registered as listeners with the rowset so that they can update themselves to reflect changes. To become listeners, the table and bar graph classes must implement the \n\u003ccode\u003eRowSetListener\u003c/code\u003e interface. Then they can be added to the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object\u0027s list of listeners, as is illustrated in the following lines of code. \n\u003cpre\u003e    crs.addRowSetListener(table);\n    crs.addRowSetListener(barGraph);\n \u003c/pre\u003e Each \n\u003ccode\u003eCachedRowSet\u003c/code\u003e method that moves the cursor or changes data also notifies registered listeners of the changes, so \n\u003ccode\u003etable\u003c/code\u003e and \n\u003ccode\u003ebarGraph\u003c/code\u003e will be notified when there is a change in \n\u003ccode\u003ecrs\u003c/code\u003e. \n\u003ch2\u003e6.0 Passing Data to Thin Clients\u003c/h2\u003e One of the main reasons to use a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object is to pass data between different components of an application. Because it is serializable, a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object can be used, for example, to send the result of a query executed by an enterprise JavaBeans component running in a server environment over a network to a client running in a web browser. \n\u003cp\u003e While a \u003ccode\u003eCachedRowSet\u003c/code\u003e object is disconnected, it can be much leaner than a \u003ccode\u003eResultSet\u003c/code\u003e object with the same data. As a result, it can be especially suitable for sending data to a thin client such as a PDA, where it would be inappropriate to use a JDBC driver due to resource limitations or security considerations. Thus, a \u003ccode\u003eCachedRowSet\u003c/code\u003e object provides a means to \"get rows in\" without the need to implement the full JDBC API. \u003c/p\u003e\n\u003ch2\u003e7.0 Scrolling and Updating\u003c/h2\u003e A second major use for \n\u003ccode\u003eCachedRowSet\u003c/code\u003e objects is to provide scrolling and updating for \n\u003ccode\u003eResultSet\u003c/code\u003e objects that do not provide these capabilities themselves. In other words, a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object can be used to augment the capabilities of a JDBC technology-enabled driver (hereafter called a \"JDBC driver\") when the DBMS does not provide full support for scrolling and updating. To achieve the effect of making a non-scrollable and read-only \n\u003ccode\u003eResultSet\u003c/code\u003e object scrollable and updatable, a programmer simply needs to create a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object populated with that \n\u003ccode\u003eResultSet\u003c/code\u003e object\u0027s data. This is demonstrated in the following code fragment, where \n\u003ccode\u003estmt\u003c/code\u003e is a \n\u003ccode\u003eStatement\u003c/code\u003e object. \n\u003cpre\u003e    ResultSet rs \u003d stmt.executeQuery(\"SELECT * FROM EMPLOYEES\");\n    CachedRowSetImpl crs \u003d new CachedRowSetImpl();\n    crs.populate(rs);\n \u003c/pre\u003e \n\u003cp\u003e The object \u003ccode\u003ecrs\u003c/code\u003e now contains the data from the table \u003ccode\u003eEMPLOYEES\u003c/code\u003e, just as the object \u003ccode\u003ers\u003c/code\u003e does. The difference is that the cursor for \u003ccode\u003ecrs\u003c/code\u003e can be moved forward, backward, or to a particular row even if the cursor for \u003ccode\u003ers\u003c/code\u003e can move only forward. In addition, \u003ccode\u003ecrs\u003c/code\u003e is updatable even if \u003ccode\u003ers\u003c/code\u003e is not because by default, a \u003ccode\u003eCachedRowSet\u003c/code\u003e object is both scrollable and updatable. \u003c/p\u003e\n\u003cp\u003e In summary, a \u003ccode\u003eCachedRowSet\u003c/code\u003e object can be thought of as simply a disconnected set of rows that are being cached outside of a data source. Being thin and serializable, it can easily be sent across a wire, and it is well suited to sending data to a thin client. However, a \u003ccode\u003eCachedRowSet\u003c/code\u003e object does have a limitation: It is limited in size by the amount of data it can store in memory at one time. \u003c/p\u003e\n\u003ch2\u003e8.0 Getting Universal Data Access\u003c/h2\u003e Another advantage of the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e class is that it makes it possible to retrieve and store data from sources other than a relational database. The reader for a rowset can be implemented to read and populate its rowset with data from any tabular data source, including a spreadsheet or flat file. Because both a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object and its metadata can be created from scratch, a component that acts as a factory for rowsets can use this capability to create a rowset containing data from non-SQL data sources. Nevertheless, it is expected that most of the time, \n\u003ccode\u003eCachedRowSet\u003c/code\u003e objects will contain data that was fetched from an SQL database using the JDBC API. \n\u003ch2\u003e9.0 Setting Properties\u003c/h2\u003e All rowsets maintain a set of properties, which will usually be set using a tool. The number and kinds of properties a rowset has will vary, depending on what the rowset does and how it gets its data. For example, rowsets that get their data from a \n\u003ccode\u003eResultSet\u003c/code\u003e object need to set the properties that are required for making a database connection. If a rowset uses the \n\u003ccode\u003eDriverManager\u003c/code\u003e facility to make a connection, it needs to set a property for the JDBC URL that identifies the appropriate driver, and it needs to set the properties that give the user name and password. If, on the other hand, the rowset uses a \n\u003ccode\u003eDataSource\u003c/code\u003e object to make the connection, which is the preferred method, it does not need to set the property for the JDBC URL. Instead, it needs to set properties for the logical name of the data source, for the user name, and for the password. \n\u003cp\u003e NOTE: In order to use a \u003ccode\u003eDataSource\u003c/code\u003e object for making a connection, the \u003ccode\u003eDataSource\u003c/code\u003e object must have been registered with a naming service that uses the Java Naming and Directory Interface (JNDI) API. This registration is usually done by a person acting in the capacity of a system administrator. \u003c/p\u003e\n\u003cp\u003e In order to be able to populate itself with data from a database, a rowset needs to set a command property. This property is a query that is a \u003ccode\u003ePreparedStatement\u003c/code\u003e object, which allows the query to have parameter placeholders that are set at run time, as opposed to design time. To set these placeholder parameters with values, a rowset provides setter methods for setting values of each data type, similar to the setter methods provided by the \u003ccode\u003ePreparedStatement\u003c/code\u003e interface. \u003c/p\u003e\n\u003cp\u003e The following code fragment illustrates how the \u003ccode\u003eCachedRowSet\u003c/code\u003e object \u003ccode\u003ecrs\u003c/code\u003e might have its command property set. Note that if a tool is used to set properties, this is the code that the tool would use. \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n    crs.setCommand(\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS \" +\n                   \"WHERE CREDIT_LIMIT \u0026gt; ? AND REGION \u003d ?\");\n \u003c/code\u003e \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The values that will be used to set the command\u0027s placeholder parameters are contained in the \u003ccode\u003eRowSet\u003c/code\u003e object\u0027s \u003ccode\u003eparams\u003c/code\u003e field, which is a \u003ccode\u003eVector\u003c/code\u003e object. The \u003ccode\u003eCachedRowSet\u003c/code\u003e class provides a set of setter methods for setting the elements in its \u003ccode\u003eparams\u003c/code\u003e field. The following code fragment demonstrates setting the two parameters in the query from the previous example. \u003c/p\u003e\n\u003cpre\u003e    crs.setInt(1, 5000);\n    crs.setString(2, \"West\");\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The \u003ccode\u003eparams\u003c/code\u003e field now contains two elements, each of which is an array two elements long. The first element is the parameter number; the second is the value to be set. In this case, the first element of \u003ccode\u003eparams\u003c/code\u003e is \u003ccode\u003e1\u003c/code\u003e, \u003ccode\u003e5000\u003c/code\u003e, and the second element is \u003ccode\u003e2\u003c/code\u003e, \u003ccode\u003e\"West\"\u003c/code\u003e. When an application calls the method \u003ccode\u003eexecute\u003c/code\u003e, it will in turn call on this \u003ccode\u003eRowSet\u003c/code\u003e object\u0027s reader, which will in turn invoke its \u003ccode\u003ereadData\u003c/code\u003e method. As part of its implementation, \u003ccode\u003ereadData\u003c/code\u003e will get the values in \u003ccode\u003eparams\u003c/code\u003e and use them to set the command\u0027s placeholder parameters. The following code fragment gives an idea of how the reader does this, after obtaining the \u003ccode\u003eConnection\u003c/code\u003e object \u003ccode\u003econ\u003c/code\u003e. \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n    PreparedStatement pstmt \u003d con.prepareStatement(crs.getCommand());\n    reader.decodeParams();\n    // decodeParams figures out which setter methods to use and does something\n    // like the following:\n    //    for (i \u003d 0; i \u0026lt; params.length; i++) {\n    //        pstmt.setObject(i + 1, params[i]);\n    //    }\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e At this point, the command for \u003ccode\u003ecrs\u003c/code\u003e is the query \u003ccode\u003e\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT \u0026gt; 5000 AND REGION \u003d \"West\"\u003c/code\u003e. After the \u003ccode\u003ereadData\u003c/code\u003e method executes this command with the following line of code, it will have the data from \u003ccode\u003ers\u003c/code\u003e with which to populate \u003ccode\u003ecrs\u003c/code\u003e. \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     ResultSet rs \u003d pstmt.executeQuery();\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The preceding code fragments give an idea of what goes on behind the scenes; they would not appear in an application, which would not invoke methods like \u003ccode\u003ereadData\u003c/code\u003e and \u003ccode\u003edecodeParams\u003c/code\u003e. In contrast, the following code fragment shows what an application might do. It sets the rowset\u0027s command, sets the command\u0027s parameters, and executes the command. Simply by calling the \u003ccode\u003eexecute\u003c/code\u003e method, \u003ccode\u003ecrs\u003c/code\u003e populates itself with the requested data from the table \u003ccode\u003eCUSTOMERS\u003c/code\u003e. \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n    crs.setCommand(\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS\" +\n                   \"WHERE CREDIT_LIMIT \u0026gt; ? AND REGION \u003d ?\");\n    crs.setInt(1, 5000);\n    crs.setString(2, \"West\");\n    crs.execute();\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e10.0 Paging Data\u003c/h2\u003e Because a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object stores data in memory, the amount of data that it can contain at any one time is determined by the amount of memory available. To get around this limitation, a \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object can retrieve data from a \n\u003ccode\u003eResultSet\u003c/code\u003e object in chunks of data, called \n\u003ci\u003epages\u003c/i\u003e. To take advantage of this mechanism, an application sets the number of rows to be included in a page using the method \n\u003ccode\u003esetPageSize\u003c/code\u003e. In other words, if the page size is set to five, a chunk of five rows of data will be fetched from the data source at one time. An application can also optionally set the maximum number of rows that may be fetched at one time. If the maximum number of rows is set to zero, or no maximum number of rows is set, there is no limit to the number of rows that may be fetched at a time. \n\u003cp\u003e After properties have been set, the \u003ccode\u003eCachedRowSet\u003c/code\u003e object must be populated with data using either the method \u003ccode\u003epopulate\u003c/code\u003e or the method \u003ccode\u003eexecute\u003c/code\u003e. The following lines of code demonstrate using the method \u003ccode\u003epopulate\u003c/code\u003e. Note that this version of the method takes two parameters, a \u003ccode\u003eResultSet\u003c/code\u003e handle and the row in the \u003ccode\u003eResultSet\u003c/code\u003e object from which to start retrieving rows. \u003c/p\u003e\n\u003cpre\u003e     CachedRowSet crs \u003d new CachedRowSetImpl();\n     crs.setMaxRows(20);\n     crs.setPageSize(4);\n     crs.populate(rsHandle, 10);\n \u003c/pre\u003e When this code runs, \n\u003ci\u003ecrs\u003c/i\u003e will be populated with four rows from \n\u003ci\u003ersHandle\u003c/i\u003e starting with the tenth row. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The next code fragment shows populating a \u003ccode\u003eCachedRowSet\u003c/code\u003e object using the method \u003ccode\u003eexecute\u003c/code\u003e, which may or may not take a \u003ccode\u003eConnection\u003c/code\u003e object as a parameter. This code passes \u003ccode\u003eexecute\u003c/code\u003e the \u003ccode\u003eConnection\u003c/code\u003e object \u003ci\u003econHandle\u003c/i\u003e. \u003c/p\u003e\n\u003cp\u003e Note that there are two differences between the following code fragment and the previous one. First, the method \u003ccode\u003esetMaxRows\u003c/code\u003e is not called, so there is no limit set for the number of rows that \u003ci\u003ecrs\u003c/i\u003e may contain. (Remember that \u003ci\u003ecrs\u003c/i\u003e always has the overriding limit of how much data it can store in memory.) The second difference is that the you cannot pass the method \u003ccode\u003eexecute\u003c/code\u003e the number of the row in the \u003ccode\u003eResultSet\u003c/code\u003e object from which to start retrieving rows. This method always starts with the first row. \u003c/p\u003e\n\u003cpre\u003e     CachedRowSet crs \u003d new CachedRowSetImpl();\n     crs.setPageSize(5);\n     crs.execute(conHandle);\n \u003c/pre\u003e After this code has run, \n\u003ci\u003ecrs\u003c/i\u003e will contain five rows of data from the \n\u003ccode\u003eResultSet\u003c/code\u003e object produced by the command for \n\u003ci\u003ecrs\u003c/i\u003e. The writer for \n\u003ci\u003ecrs\u003c/i\u003e will use \n\u003ci\u003econHandle\u003c/i\u003e to connect to the data source and execute the command for \n\u003ci\u003ecrs\u003c/i\u003e. An application is then able to operate on the data in \n\u003ci\u003ecrs\u003c/i\u003e in the same way that it would operate on data in any other \n\u003ccode\u003eCachedRowSet\u003c/code\u003e object. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e To access the next page (chunk of data), an application calls the method \u003ccode\u003enextPage\u003c/code\u003e. This method creates a new \u003ccode\u003eCachedRowSet\u003c/code\u003e object and fills it with the next page of data. For example, assume that the \u003ccode\u003eCachedRowSet\u003c/code\u003e object\u0027s command returns a \u003ccode\u003eResultSet\u003c/code\u003e object \u003ci\u003ers\u003c/i\u003e with 1000 rows of data. If the page size has been set to 100, the first call to the method \u003ccode\u003enextPage\u003c/code\u003e will create a \u003ccode\u003eCachedRowSet\u003c/code\u003e object containing the first 100 rows of \u003ci\u003ers\u003c/i\u003e. After doing what it needs to do with the data in these first 100 rows, the application can again call the method \u003ccode\u003enextPage\u003c/code\u003e to create another \u003ccode\u003eCachedRowSet\u003c/code\u003e object with the second 100 rows from \u003ci\u003ers\u003c/i\u003e. The data from the first \u003ccode\u003eCachedRowSet\u003c/code\u003e object will no longer be in memory because it is replaced with the data from the second \u003ccode\u003eCachedRowSet\u003c/code\u003e object. After the tenth call to the method \u003ccode\u003enextPage\u003c/code\u003e, the tenth \u003ccode\u003eCachedRowSet\u003c/code\u003e object will contain the last 100 rows of data from \u003ci\u003ers\u003c/i\u003e, which are stored in memory. At any given time, the data from only one \u003ccode\u003eCachedRowSet\u003c/code\u003e object is stored in memory. \u003c/p\u003e\n\u003cp\u003e The method \u003ccode\u003enextPage\u003c/code\u003e returns \u003ccode\u003etrue\u003c/code\u003e as long as the current page is not the last page of rows and \u003ccode\u003efalse\u003c/code\u003e when there are no more pages. It can therefore be used in a \u003ccode\u003ewhile\u003c/code\u003e loop to retrieve all of the pages, as is demonstrated in the following lines of code. \u003c/p\u003e\n\u003cpre\u003e     CachedRowSet crs \u003d CachedRowSetImpl();\n     crs.setPageSize(100);\n     crs.execute(conHandle);\n\n     while(crs.nextPage()) {\n         while(crs.next()) {\n             . . . // operate on chunks (of 100 rows each) in crs,\n                   // row by row\n         }\n     }\n \u003c/pre\u003e After this code fragment has been run, the application will have traversed all 1000 rows, but it will have had no more than 100 rows in memory at a time. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The \u003ccode\u003eCachedRowSet\u003c/code\u003e interface also defines the method \u003ccode\u003epreviousPage\u003c/code\u003e. Just as the method \u003ccode\u003enextPage\u003c/code\u003e is analogous to the \u003ccode\u003eResultSet\u003c/code\u003e method \u003ccode\u003enext\u003c/code\u003e, the method \u003ccode\u003epreviousPage\u003c/code\u003e is analogous to the \u003ccode\u003eResultSet\u003c/code\u003e method \u003ccode\u003eprevious\u003c/code\u003e. Similar to the method \u003ccode\u003enextPage\u003c/code\u003e, \u003ccode\u003epreviousPage\u003c/code\u003e creates a \u003ccode\u003eCachedRowSet\u003c/code\u003e object containing the number of rows set as the page size. So, for instance, the method \u003ccode\u003epreviousPage\u003c/code\u003e could be used in a \u003ccode\u003ewhile\u003c/code\u003e loop at the end of the preceding code fragment to navigate back through the pages from the last page to the first page. The method \u003ccode\u003epreviousPage\u003c/code\u003e is also similar to \u003ccode\u003enextPage\u003c/code\u003e in that it can be used in a \u003ccode\u003ewhile\u003c/code\u003e loop, except that it returns \u003ccode\u003etrue\u003c/code\u003e as long as there is another page preceding it and \u003ccode\u003efalse\u003c/code\u003e when there are no more pages ahead of it. \u003c/p\u003e\n\u003cp\u003e By positioning the cursor after the last row for each page, as is done in the following code fragment, the method \u003ccode\u003eprevious\u003c/code\u003e navigates from the last row to the first row in each page. The code could also have left the cursor before the first row on each page and then used the method \u003ccode\u003enext\u003c/code\u003e in a \u003ccode\u003ewhile\u003c/code\u003e loop to navigate each page from the first row to the last row. \u003c/p\u003e\n\u003cp\u003e The following code fragment assumes a continuation from the previous code fragment, meaning that the cursor for the tenth \u003ccode\u003eCachedRowSet\u003c/code\u003e object is on the last row. The code moves the cursor to after the last row so that the first call to the method \u003ccode\u003eprevious\u003c/code\u003e will put the cursor back on the last row. After going through all of the rows in the last page (the \u003ccode\u003eCachedRowSet\u003c/code\u003e object \u003ci\u003ecrs\u003c/i\u003e), the code then enters the \u003ccode\u003ewhile\u003c/code\u003e loop to get to the ninth page, go through the rows backwards, go to the eighth page, go through the rows backwards, and so on to the first row of the first page. \u003c/p\u003e\n\u003cpre\u003e     crs.afterLast();\n     while(crs.previous())  {\n         . . . // navigate through the rows, last to first\n     {\n     while(crs.previousPage())  {\n         crs.afterLast();\n         while(crs.previous())  {\n             . . . // go from the last row to the first row of each page\n         }\n     }\n \u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.5"
    ]
  }
}