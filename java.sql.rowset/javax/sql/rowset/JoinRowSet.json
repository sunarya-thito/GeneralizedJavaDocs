{
  "packageName": "javax.sql.rowset",
  "simpleName": "JoinRowSet",
  "moduleName": "java.sql.rowset",
  "type": "INTERFACE",
  "superClass": {
    "name": "javax.sql.rowset.WebRowSet",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "CROSS_JOIN",
      "comment": "An ANSI-style JOIN providing a cross product of two tables",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.sql.rowset.JoinRowSet.CROSS_JOIN\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "INNER_JOIN",
      "comment": "An ANSI-style JOIN providing a inner join between two tables. Any unmatched rows in either table of the join should be discarded.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.sql.rowset.JoinRowSet.INNER_JOIN\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "LEFT_OUTER_JOIN",
      "comment": "An ANSI-style JOIN providing a left outer join between two tables. In SQL, this is described where all records should be returned from the left side of the JOIN statement.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.sql.rowset.JoinRowSet.LEFT_OUTER_JOIN\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "RIGHT_OUTER_JOIN",
      "comment": "An ANSI-style JOIN providing a right outer join between two tables. In SQL, this is described where all records from the table on the right side of the JOIN statement even if the table on the left has no matching record.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.sql.rowset.JoinRowSet.RIGHT_OUTER_JOIN\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "FULL_JOIN",
      "comment": "An ANSI-style JOIN providing a full JOIN. Specifies that all rows from either table be returned regardless of matching records on the other table.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.sql.rowset.JoinRowSet.FULL_JOIN\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.sql.rowset.Joinable",
            "type": "Class"
          },
          "name": "rowset",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addRowSet",
      "comment": "Adds the given RowSet object to this JoinRowSet object. If the RowSet object is the first to be added to this JoinRowSet object, it forms the basis of the JOIN relationship to be established. This method should be used only when the given RowSet object already has a match column that was set with the Joinable method setMatchColumn. Note: A Joinable object is any RowSet object that has implemented the Joinable interface.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/Joinable.html#setMatchColumn(int)\"\u003e\u003ccode\u003eJoinable.setMatchColumn(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003erowset\u003c/code\u003e - the \n\u003ccode\u003eRowSet\u003c/code\u003e object that is to be added to this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object; it must implement the \n\u003ccode\u003eJoinable\u003c/code\u003e interface and have a match column set"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if (1) an empty rowset is added to the to this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object, (2) a match column has not been set for \n\u003ci\u003erowset\u003c/i\u003e, or (3) \n\u003ci\u003erowset\u003c/i\u003e violates the active \n\u003ccode\u003eJOIN\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.sql.RowSet",
            "type": "Class"
          },
          "name": "rowset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "columnIdx",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addRowSet",
      "comment": "Adds the given RowSet object to this JoinRowSet object and sets the designated column as the match column for the RowSet object. If the RowSet object is the first to be added to this JoinRowSet object, it forms the basis of the JOIN relationship to be established. This method should be used when RowSet does not already have a match column set.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/Joinable.html#unsetMatchColumn(int)\"\u003e\u003ccode\u003eJoinable.unsetMatchColumn(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003erowset\u003c/code\u003e - the \n\u003ccode\u003eRowSet\u003c/code\u003e object that is to be added to this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object; it may implement the \n\u003ccode\u003eJoinable\u003c/code\u003e interface",
          "\u003ccode\u003ecolumnIdx\u003c/code\u003e - an \n\u003ccode\u003eint\u003c/code\u003e that identifies the column to become the match column"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if (1) \n\u003ci\u003erowset\u003c/i\u003e is an empty rowset or (2) \n\u003ci\u003erowset\u003c/i\u003e violates the active \n\u003ccode\u003eJOIN\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.sql.RowSet",
            "type": "Class"
          },
          "name": "rowset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "name": "columnName",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addRowSet",
      "comment": "Adds rowset to this JoinRowSet object and sets the designated column as the match column. If rowset is the first to be added to this JoinRowSet object, it forms the basis for the JOIN relationship to be established. This method should be used when the given RowSet object does not already have a match column.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003erowset\u003c/code\u003e - the \n\u003ccode\u003eRowSet\u003c/code\u003e object that is to be added to this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object; it may implement the \n\u003ccode\u003eJoinable\u003c/code\u003e interface",
          "\u003ccode\u003ecolumnName\u003c/code\u003e - the \n\u003ccode\u003eString\u003c/code\u003e object giving the name of the column to be set as the match column"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if (1) \n\u003ci\u003erowset\u003c/i\u003e is an empty rowset or (2) the match column for \n\u003ci\u003erowset\u003c/i\u003e does not satisfy the conditions of the \n\u003ccode\u003eJOIN\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.sql.RowSet",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "rowset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "columnIdx",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addRowSet",
      "comment": "Adds one or more RowSet objects contained in the given array of RowSet objects to this JoinRowSet object and sets the match column for each of the RowSet objects to the match columns in the given array of column indexes. The first element in columnIdx is set as the match column for the first RowSet object in rowset, the second element of columnIdx is set as the match column for the second element in rowset, and so on. The first RowSet object added to this JoinRowSet object forms the basis for the JOIN relationship. This method should be used when the given RowSet object does not already have a match column.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003erowset\u003c/code\u003e - an array of one or more \n\u003ccode\u003eRowSet\u003c/code\u003e objects to be added to the \n\u003ccode\u003eJOIN\u003c/code\u003e; it may implement the \n\u003ccode\u003eJoinable\u003c/code\u003e interface",
          "\u003ccode\u003ecolumnIdx\u003c/code\u003e - an array of \n\u003ccode\u003eint\u003c/code\u003e values indicating the index(es) of the columns to be set as the match columns for the \n\u003ccode\u003eRowSet\u003c/code\u003e objects in \n\u003ci\u003erowset\u003c/i\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if (1) an empty rowset is added to this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object, (2) a match column is not set for a \n\u003ccode\u003eRowSet\u003c/code\u003e object in \n\u003ci\u003erowset\u003c/i\u003e, or (3) a \n\u003ccode\u003eRowSet\u003c/code\u003e object being added violates the active \n\u003ccode\u003eJOIN\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.sql.RowSet",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "rowset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "columnName",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addRowSet",
      "comment": "Adds one or more RowSet objects contained in the given array of RowSet objects to this JoinRowSet object and sets the match column for each of the RowSet objects to the match columns in the given array of column names. The first element in columnName is set as the match column for the first RowSet object in rowset, the second element of columnName is set as the match column for the second element in rowset, and so on. The first RowSet object added to this JoinRowSet object forms the basis for the JOIN relationship. This method should be used when the given RowSet object(s) does not already have a match column.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003erowset\u003c/code\u003e - an array of one or more \n\u003ccode\u003eRowSet\u003c/code\u003e objects to be added to the \n\u003ccode\u003eJOIN\u003c/code\u003e; it may implement the \n\u003ccode\u003eJoinable\u003c/code\u003e interface",
          "\u003ccode\u003ecolumnName\u003c/code\u003e - an array of \n\u003ccode\u003eString\u003c/code\u003e values indicating the names of the columns to be set as the match columns for the \n\u003ccode\u003eRowSet\u003c/code\u003e objects in \n\u003ci\u003erowset\u003c/i\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if (1) an empty rowset is added to this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object, (2) a match column is not set for a \n\u003ccode\u003eRowSet\u003c/code\u003e object in \n\u003ci\u003erowset\u003c/i\u003e, or (3) a \n\u003ccode\u003eRowSet\u003c/code\u003e object being added violates the active \n\u003ccode\u003eJOIN\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Collection",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getRowSets",
      "comment": "Returns a Collection object containing the RowSet objects that have been added to this JoinRowSet object. This should return the \u0027n\u0027 number of RowSet contained within the JOIN and maintain any updates that have occurred while in this union.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs generating the \n\u003ccode\u003eCollection\u003c/code\u003e object to be returned"
        ],
        "return": [
          "a \n\u003ccode\u003eCollection\u003c/code\u003e object consisting of the \n\u003ccode\u003eRowSet\u003c/code\u003e objects added to this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": 1
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getRowSetNames",
      "comment": "Returns a String array containing the names of the RowSet objects added to this JoinRowSet object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html#setTableName(java.lang.String)\"\u003e\u003ccode\u003eCachedRowSet.setTableName(java.lang.String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs retrieving the names of the \n\u003ccode\u003eRowSet\u003c/code\u003e objects"
        ],
        "return": [
          "a \n\u003ccode\u003eString\u003c/code\u003e array of the names of the \n\u003ccode\u003eRowSet\u003c/code\u003e objects in this \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sql.rowset.CachedRowSet",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toCachedRowSet",
      "comment": "Creates a new CachedRowSet object containing the data in this JoinRowSet object, which can be saved to a data source using the SyncProvider object for the CachedRowSet object. If any updates or modifications have been applied to the JoinRowSet the CachedRowSet returned by the method will not be able to persist it\u0027s changes back to the originating rows and tables in the in the datasource. The CachedRowSet instance returned should not contain modification data and it should clear all properties of it\u0027s originating SQL statement. An application should reset the SQL statement using the RowSet.setCommand method. In order to allow changes to be persisted back to the datasource to the originating tables, the acceptChanges method should be used and called on a JoinRowSet object instance. Implementations can leverage the internal data and update tracking in their implementations to interact with the SyncProvider to persist any changes.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/javax/sql/RowSet.html\" title\u003d\"interface in javax.sql\"\u003e\u003ccode\u003eRowSet\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html\" title\u003d\"interface in javax.sql.rowset\"\u003e\u003ccode\u003eCachedRowSet\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/spi/SyncProvider.html\" title\u003d\"class in javax.sql.rowset.spi\"\u003e\u003ccode\u003eSyncProvider\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs assembling the CachedRowSet object"
        ],
        "return": [
          "a CachedRowSet containing the contents of the JoinRowSet"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "supportsCrossJoin",
      "comment": "Indicates if CROSS_JOIN is supported by a JoinRowSet implementation",
      "annotations": [],
      "tagMap": {
        "return": [
          "true if the CROSS_JOIN is supported; false otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "supportsInnerJoin",
      "comment": "Indicates if INNER_JOIN is supported by a JoinRowSet implementation",
      "annotations": [],
      "tagMap": {
        "return": [
          "true is the INNER_JOIN is supported; false otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "supportsLeftOuterJoin",
      "comment": "Indicates if LEFT_OUTER_JOIN is supported by a JoinRowSet implementation",
      "annotations": [],
      "tagMap": {
        "return": [
          "true is the LEFT_OUTER_JOIN is supported; false otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "supportsRightOuterJoin",
      "comment": "Indicates if RIGHT_OUTER_JOIN is supported by a JoinRowSet implementation",
      "annotations": [],
      "tagMap": {
        "return": [
          "true is the RIGHT_OUTER_JOIN is supported; false otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "supportsFullJoin",
      "comment": "Indicates if FULL_JOIN is supported by a JoinRowSet implementation",
      "annotations": [],
      "tagMap": {
        "return": [
          "true is the FULL_JOIN is supported; false otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "joinType",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setJoinType",
      "comment": "Allow the application to adjust the type of JOIN imposed on tables contained within the JoinRowSet object instance. Implementations should throw a SQLException if they do not support a given JOIN type.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/JoinRowSet.html#getJoinType()\"\u003e\u003ccode\u003egetJoinType()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ejoinType\u003c/code\u003e - the standard JoinRowSet.XXX static field definition of a SQL \n\u003ccode\u003eJOIN\u003c/code\u003e to re-configure a JoinRowSet instance on the fly."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an unsupported \n\u003ccode\u003eJOIN\u003c/code\u003e type is set"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getWhereClause",
      "comment": "Return a SQL-like description of the WHERE clause being used in a JoinRowSet object. An implementation can describe the WHERE clause of the SQL JOIN by supplying a SQL strings description of JOIN or provide a textual description to assist applications using a JoinRowSet",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs in generating a representation of the WHERE clause."
        ],
        "return": [
          "whereClause a textual or SQL description of the logical WHERE clause used in the JoinRowSet instance"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getJoinType",
      "comment": "Returns a int describing the set SQL JOIN type governing this JoinRowSet instance. The returned type will be one of standard JoinRowSet types: CROSS_JOIN, INNER_JOIN, LEFT_OUTER_JOIN, RIGHT_OUTER_JOIN or FULL_JOIN.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql.rowset/javax/sql/rowset/JoinRowSet.html#setJoinType(int)\"\u003e\u003ccode\u003esetJoinType(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if an error occurs determining the SQL \n\u003ccode\u003eJOIN\u003c/code\u003e type supported by the JoinRowSet instance."
        ],
        "return": [
          "joinType one of the standard JoinRowSet static field definitions of a SQL \n\u003ccode\u003eJOIN\u003c/code\u003e. \n\u003ccode\u003eJoinRowSet.INNER_JOIN\u003c/code\u003e is returned as the default \n\u003ccode\u003eJOIN\u003c/code\u003e type is no type has been explicitly set."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "javax.sql.rowset.JoinRowSet",
  "comment": "The \n\u003ccode\u003eJoinRowSet\u003c/code\u003e interface provides a mechanism for combining related data from different \n\u003ccode\u003eRowSet\u003c/code\u003e objects into one \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object, which represents an SQL \n\u003ccode\u003eJOIN\u003c/code\u003e. In other words, a \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object acts as a container for the data from \n\u003ccode\u003eRowSet\u003c/code\u003e objects that form an SQL \n\u003ccode\u003eJOIN\u003c/code\u003e relationship. \n\u003cp\u003e The \u003ccode\u003eJoinable\u003c/code\u003e interface provides the methods for setting, retrieving, and unsetting a match column, the basis for establishing an SQL \u003ccode\u003eJOIN\u003c/code\u003e relationship. The match column may alternatively be set by supplying it to the appropriate version of the \u003ccode\u003eJointRowSet\u003c/code\u003e method \u003ccode\u003eaddRowSet\u003c/code\u003e. \u003c/p\u003e\n\u003ch2\u003e1.0 Overview\u003c/h2\u003e Disconnected \n\u003ccode\u003eRowSet\u003c/code\u003e objects (\n\u003ccode\u003eCachedRowSet\u003c/code\u003e objects and implementations extending the \n\u003ccode\u003eCachedRowSet\u003c/code\u003e interface) do not have a standard way to establish an SQL \n\u003ccode\u003eJOIN\u003c/code\u003e between \n\u003ccode\u003eRowSet\u003c/code\u003e objects without the expensive operation of reconnecting to the data source. The \n\u003ccode\u003eJoinRowSet\u003c/code\u003e interface is specifically designed to address this need. \n\u003cp\u003e Any \u003ccode\u003eRowSet\u003c/code\u003e object can be added to a \u003ccode\u003eJoinRowSet\u003c/code\u003e object to become part of an SQL \u003ccode\u003eJOIN\u003c/code\u003e relationship. This means that both connected and disconnected \u003ccode\u003eRowSet\u003c/code\u003e objects can be part of a \u003ccode\u003eJOIN\u003c/code\u003e. \u003ccode\u003eRowSet\u003c/code\u003e objects operating in a connected environment (\u003ccode\u003eJdbcRowSet\u003c/code\u003e objects) are encouraged to use the database to which they are already connected to establish SQL \u003ccode\u003eJOIN\u003c/code\u003e relationships between tables directly. However, it is possible for a \u003ccode\u003eJdbcRowSet\u003c/code\u003e object to be added to a \u003ccode\u003eJoinRowSet\u003c/code\u003e object if necessary. \u003c/p\u003e\n\u003cp\u003e Any number of \u003ccode\u003eRowSet\u003c/code\u003e objects can be added to an instance of \u003ccode\u003eJoinRowSet\u003c/code\u003e provided that they can be related in an SQL \u003ccode\u003eJOIN\u003c/code\u003e. By definition, the SQL \u003ccode\u003eJOIN\u003c/code\u003e statement is used to combine the data contained in two or more relational database tables based upon a common attribute. The \u003ccode\u003eJoinable\u003c/code\u003e interface provides the methods for establishing a common attribute, which is done by setting a \u003ci\u003ematch column\u003c/i\u003e. The match column commonly coincides with the primary key, but there is no requirement that the match column be the same as the primary key. By establishing and then enforcing column matches, a \u003ccode\u003eJoinRowSet\u003c/code\u003e object establishes \u003ccode\u003eJOIN\u003c/code\u003e relationships between \u003ccode\u003eRowSet\u003c/code\u003e objects without the assistance of an available relational database. \u003c/p\u003e\n\u003cp\u003e The type of \u003ccode\u003eJOIN\u003c/code\u003e to be established is determined by setting one of the \u003ccode\u003eJoinRowSet\u003c/code\u003e constants using the method \u003ccode\u003esetJoinType\u003c/code\u003e. The following SQL \u003ccode\u003eJOIN\u003c/code\u003e types can be set: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ccode\u003eCROSS_JOIN\u003c/code\u003e \u003c/li\u003e\n \u003cli\u003e\u003ccode\u003eFULL_JOIN\u003c/code\u003e \u003c/li\u003e\n \u003cli\u003e\u003ccode\u003eINNER_JOIN\u003c/code\u003e - the default if no \u003ccode\u003eJOIN\u003c/code\u003e type has been set \u003c/li\u003e\n \u003cli\u003e\u003ccode\u003eLEFT_OUTER_JOIN\u003c/code\u003e \u003c/li\u003e\n \u003cli\u003e\u003ccode\u003eRIGHT_OUTER_JOIN\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e Note that if no type is set, the \n\u003ccode\u003eJOIN\u003c/code\u003e will automatically be an inner join. The comments for the fields in the \n\u003ccode\u003eJoinRowSet\u003c/code\u003e interface explain these \n\u003ccode\u003eJOIN\u003c/code\u003e types, which are standard SQL \n\u003ccode\u003eJOIN\u003c/code\u003e types. \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e2.0 Using a \u003ccode\u003eJoinRowSet\u003c/code\u003e Object for Creating a \u003ccode\u003eJOIN\u003c/code\u003e\u003c/h2\u003e When a \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object is created, it is empty. The first \n\u003ccode\u003eRowSet\u003c/code\u003e object to be added becomes the basis for the \n\u003ccode\u003eJOIN\u003c/code\u003e relationship. Applications must determine which column in each of the \n\u003ccode\u003eRowSet\u003c/code\u003e objects to be added to the \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object should be the match column. All of the \n\u003ccode\u003eRowSet\u003c/code\u003e objects must contain a match column, and the values in each match column must be ones that can be compared to values in the other match columns. The columns do not have to have the same name, though they often do, and they do not have to store the exact same data type as long as the data types can be compared. \n\u003cp\u003e A match column can be set in two ways: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eBy calling the \u003ccode\u003eJoinable\u003c/code\u003e method \u003ccode\u003esetMatchColumn\u003c/code\u003e\u003cbr\u003e This is the only method that can set the match column before a \u003ccode\u003eRowSet\u003c/code\u003e object is added to a \u003ccode\u003eJoinRowSet\u003c/code\u003e object. The \u003ccode\u003eRowSet\u003c/code\u003e object must have implemented the \u003ccode\u003eJoinable\u003c/code\u003e interface in order to use the method \u003ccode\u003esetMatchColumn\u003c/code\u003e. Once the match column value has been set, this method can be used to reset the match column at any time. \u003c/li\u003e\n \u003cli\u003eBy calling one of the versions of the \u003ccode\u003eJoinRowSet\u003c/code\u003e method \u003ccode\u003eaddRowSet\u003c/code\u003e that takes a column name or number (or an array of column names or numbers)\u003cbr\u003e Four of the five \u003ccode\u003eaddRowSet\u003c/code\u003e methods take a match column as a parameter. These four methods set or reset the match column at the time a \u003ccode\u003eRowSet\u003c/code\u003e object is being added to a \u003ccode\u003eJoinRowSet\u003c/code\u003e object. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e3.0 Sample Usage\u003c/h2\u003e \n\u003cp\u003e The following code fragment adds two \u003ccode\u003eCachedRowSet\u003c/code\u003e objects to a \u003ccode\u003eJoinRowSet\u003c/code\u003e object. Note that in this example, no SQL \u003ccode\u003eJOIN\u003c/code\u003e type is set, so the default \u003ccode\u003eJOIN\u003c/code\u003e type, which is \u003ci\u003eINNER_JOIN\u003c/i\u003e, is established. \u003c/p\u003e\n\u003cp\u003e In the following code fragment, the table \u003ccode\u003eEMPLOYEES\u003c/code\u003e, whose match column is set to the first column (\u003ccode\u003eEMP_ID\u003c/code\u003e), is added to the \u003ccode\u003eJoinRowSet\u003c/code\u003e object \u003ci\u003ejrs\u003c/i\u003e. Then the table \u003ccode\u003eESSP_BONUS_PLAN\u003c/code\u003e, whose match column is likewise the \u003ccode\u003eEMP_ID\u003c/code\u003e column, is added. When this second table is added to \u003ci\u003ejrs\u003c/i\u003e, only the rows in \u003ccode\u003eESSP_BONUS_PLAN\u003c/code\u003e whose \u003ccode\u003eEMP_ID\u003c/code\u003e value matches an \u003ccode\u003eEMP_ID\u003c/code\u003e value in the \u003ccode\u003eEMPLOYEES\u003c/code\u003e table are added. In this case, everyone in the bonus plan is an employee, so all of the rows in the table \u003ccode\u003eESSP_BONUS_PLAN\u003c/code\u003e are added to the \u003ccode\u003eJoinRowSet\u003c/code\u003e object. In this example, both \u003ccode\u003eCachedRowSet\u003c/code\u003e objects being added have implemented the \u003ccode\u003eJoinable\u003c/code\u003e interface and can therefore call the \u003ccode\u003eJoinable\u003c/code\u003e method \u003ccode\u003esetMatchColumn\u003c/code\u003e. \u003c/p\u003e\n\u003cpre\u003e     JoinRowSet jrs \u003d new JoinRowSetImpl();\n\n     ResultSet rs1 \u003d stmt.executeQuery(\"SELECT * FROM EMPLOYEES\");\n     CachedRowSet empl \u003d new CachedRowSetImpl();\n     empl.populate(rs1);\n     empl.setMatchColumn(1);\n     jrs.addRowSet(empl);\n\n     ResultSet rs2 \u003d stmt.executeQuery(\"SELECT * FROM ESSP_BONUS_PLAN\");\n     CachedRowSet bonus \u003d new CachedRowSetImpl();\n     bonus.populate(rs2);\n     bonus.setMatchColumn(1); // EMP_ID is the first column\n     jrs.addRowSet(bonus);\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e At this point, \u003ci\u003ejrs\u003c/i\u003e is an inside JOIN of the two \u003ccode\u003eRowSet\u003c/code\u003e objects based on their \u003ccode\u003eEMP_ID\u003c/code\u003e columns. The application can now browse the combined data as if it were browsing one single \u003ccode\u003eRowSet\u003c/code\u003e object. Because \u003ci\u003ejrs\u003c/i\u003e is itself a \u003ccode\u003eRowSet\u003c/code\u003e object, an application can navigate or modify it using \u003ccode\u003eRowSet\u003c/code\u003e methods. \u003c/p\u003e\n\u003cpre\u003e     jrs.first();\n     int employeeID \u003d jrs.getInt(1);\n     String employeeName \u003d jrs.getString(2);\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Note that because the SQL \u003ccode\u003eJOIN\u003c/code\u003e must be enforced when an application adds a second or subsequent \u003ccode\u003eRowSet\u003c/code\u003e object, there may be an initial degradation in performance while the \u003ccode\u003eJOIN\u003c/code\u003e is being performed. \u003c/p\u003e\n\u003cp\u003e The following code fragment adds an additional \u003ccode\u003eCachedRowSet\u003c/code\u003e object. In this case, the match column (\u003ccode\u003eEMP_ID\u003c/code\u003e) is set when the \u003ccode\u003eCachedRowSet\u003c/code\u003e object is added to the \u003ccode\u003eJoinRowSet\u003c/code\u003e object. \u003c/p\u003e\n\u003cpre\u003e     ResultSet rs3 \u003d stmt.executeQuery(\"SELECT * FROM 401K_CONTRIB\");\n     CachedRowSet fourO1k \u003d new CachedRowSetImpl();\n     four01k.populate(rs3);\n     jrs.addRowSet(four01k, 1);\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The \u003ccode\u003eJoinRowSet\u003c/code\u003e object \u003ci\u003ejrs\u003c/i\u003e now contains values from all three tables. The data in each row in \u003ci\u003efour01k\u003c/i\u003e in which the value for the \u003ccode\u003eEMP_ID\u003c/code\u003e column matches a value for the \u003ccode\u003eEMP_ID\u003c/code\u003e column in \u003ci\u003ejrs\u003c/i\u003e has been added to \u003ci\u003ejrs\u003c/i\u003e. \u003c/p\u003e\n\u003ch2\u003e4.0 \u003ccode\u003eJoinRowSet\u003c/code\u003e Methods\u003c/h2\u003e The \n\u003ccode\u003eJoinRowSet\u003c/code\u003e interface supplies several methods for adding \n\u003ccode\u003eRowSet\u003c/code\u003e objects and for getting information about the \n\u003ccode\u003eJoinRowSet\u003c/code\u003e object. \n\u003cul\u003e \n \u003cli\u003eMethods for adding one or more \u003ccode\u003eRowSet\u003c/code\u003e objects\u003cbr\u003e These methods allow an application to add one \u003ccode\u003eRowSet\u003c/code\u003e object at a time or to add multiple \u003ccode\u003eRowSet\u003c/code\u003e objects at one time. In either case, the methods may specify the match column for each \u003ccode\u003eRowSet\u003c/code\u003e object being added. \u003c/li\u003e\n \u003cli\u003eMethods for getting information\u003cbr\u003e One method retrieves the \u003ccode\u003eRowSet\u003c/code\u003e objects in the \u003ccode\u003eJoinRowSet\u003c/code\u003e object, and another method retrieves the \u003ccode\u003eRowSet\u003c/code\u003e names. A third method retrieves either the SQL \u003ccode\u003eWHERE\u003c/code\u003e clause used behind the scenes to form the \u003ccode\u003eJOIN\u003c/code\u003e or a text description of what the \u003ccode\u003eWHERE\u003c/code\u003e clause does. \u003c/li\u003e\n \u003cli\u003eMethods related to the type of \u003ccode\u003eJOIN\u003c/code\u003e\u003cbr\u003e One method sets the \u003ccode\u003eJOIN\u003c/code\u003e type, and five methods find out whether the \u003ccode\u003eJoinRowSet\u003c/code\u003e object supports a given type. \u003c/li\u003e\n \u003cli\u003eA method to make a separate copy of the \u003ccode\u003eJoinRowSet\u003c/code\u003e object\u003cbr\u003e This method creates a copy that can be persisted to the data source. \u003c/li\u003e\n\u003c/ul\u003e",
  "tagMap": {
    "since": [
      "1.5"
    ]
  }
}