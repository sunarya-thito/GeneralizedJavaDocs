{
  "packageName": "javax.sql.rowset",
  "simpleName": "Predicate",
  "moduleName": "java.sql.rowset",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "javax.sql.RowSet",
            "type": "Class"
          },
          "field": {
            "name": "rs"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "evaluate",
      "comment": "This method is typically called a FilteredRowSet object internal methods (not public) that control the RowSet object\u0027s cursor moving from row to the next. In addition, if this internal method moves the cursor onto a row that has been deleted, the internal method will continue to ove the cursor until a valid row is found.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ers\u003c/code\u003e - The \n\u003ccode\u003eRowSet\u003c/code\u003e to be evaluated"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if there are more rows in the filter; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "column"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "evaluate",
      "comment": "This method is called by a FilteredRowSet object to check whether the value lies between the filtering criterion (or criteria if multiple constraints exist) set using the setFilter() method. The FilteredRowSet object will use this method internally while inserting new rows to a FilteredRowSet instance.",
      "tagMap": {
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - An \n\u003ccode\u003eObject\u003c/code\u003e value which needs to be checked, whether it can be part of this \n\u003ccode\u003eFilterRowSet\u003c/code\u003e object.",
          "\u003ccode\u003ecolumn\u003c/code\u003e - a \n\u003ccode\u003eint\u003c/code\u003e object that must match the SQL index of a column in this \n\u003ccode\u003eRowSet\u003c/code\u003e object. This must have been passed to \n\u003ccode\u003ePredicate\u003c/code\u003e as one of the columns for filtering while initializing a \n\u003ccode\u003ePredicate\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if the column is not part of filtering criteria"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if row value lies within the filter; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.sql.SQLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "columnName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "evaluate",
      "comment": "This method is called by the FilteredRowSet object to check whether the value lies between the filtering criteria set using the setFilter method. The FilteredRowSet object will use this method internally while inserting new rows to a FilteredRowSet instance.",
      "tagMap": {
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - An \n\u003ccode\u003eObject\u003c/code\u003e value which needs to be checked, whether it can be part of this \n\u003ccode\u003eFilterRowSet\u003c/code\u003e.",
          "\u003ccode\u003ecolumnName\u003c/code\u003e - a \n\u003ccode\u003eString\u003c/code\u003e object that must match the SQL name of a column in this \n\u003ccode\u003eRowSet\u003c/code\u003e, ignoring case. This must have been passed to \n\u003ccode\u003ePredicate\u003c/code\u003e as one of the columns for filtering while initializing a \n\u003ccode\u003ePredicate\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.sql/java/sql/SQLException.html\" title\u003d\"class in java.sql\"\u003eSQLException\u003c/a\u003e\u003c/code\u003e - if the column is not part of filtering criteria"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if value lies within the filter; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "javax.sql.rowset.Predicate",
  "comment": "The standard interface that provides the framework for all \n\u003ccode\u003eFilteredRowSet\u003c/code\u003e objects to describe their filters. \n\u003ch2\u003e1.0 Background\u003c/h2\u003e The \n\u003ccode\u003ePredicate\u003c/code\u003e interface is a standard interface that applications can implement to define the filter they wish to apply to a a \n\u003ccode\u003eFilteredRowSet\u003c/code\u003e object. A \n\u003ccode\u003eFilteredRowSet\u003c/code\u003e object consumes implementations of this interface and enforces the constraints defined in the implementation of the method \n\u003ccode\u003eevaluate\u003c/code\u003e. A \n\u003ccode\u003eFilteredRowSet\u003c/code\u003e object enforces the filter constraints in a bi-directional manner: It outputs only rows that are within the constraints of the filter; and conversely, it inserts, modifies, or updates only rows that are within the constraints of the filter. \n\u003ch2\u003e2.0 Implementation Guidelines\u003c/h2\u003e In order to supply a predicate for the \n\u003ccode\u003eFilteredRowSet\u003c/code\u003e. this interface must be implemented. At this time, the JDBC RowSet Implementations (JSR-114) does not specify any standard filters definitions. By specifying a standard means and mechanism for a range of filters to be defined and deployed with both the reference and vendor implementations of the \n\u003ccode\u003eFilteredRowSet\u003c/code\u003e interface, this allows for a flexible and application motivated implementations of \n\u003ccode\u003ePredicate\u003c/code\u003e to emerge. \n\u003cp\u003e A sample implementation would look something like this: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n    public class Range implements Predicate {\n\n       private int[] lo;\n       private int[] hi;\n       private int[] idx;\n\n       public Range(int[] lo, int[] hi, int[] idx) {\n          this.lo \u003d lo;\n          this.hi \u003d hi;\n          this.idx \u003d idx;\n       }\n\n      public boolean evaluate(RowSet rs) {\n\n          // Check the present row determine if it lies\n          // within the filtering criteria.\n\n          for (int i \u003d 0; i \u0026lt; idx.length; i++) {\n             int value;\n             try {\n                 value \u003d (Integer) rs.getObject(idx[i]);\n             } catch (SQLException ex) {\n                 Logger.getLogger(Range.class.getName()).log(Level.SEVERE, null, ex);\n                 return false;\n             }\n\n             if (value \u0026lt; lo[i] \u0026amp;\u0026amp; value \u0026gt; hi[i]) {\n                 // outside of filter constraints\n                 return false;\n             }\n         }\n         // Within filter constraints\n        return true;\n      }\n   }\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The example above implements a simple range predicate. Note, that implementations should but are not required to provide \u003ccode\u003eString\u003c/code\u003e and integer index based constructors to provide for JDBC RowSet Implementation applications that use both column identification conventions.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.5"
    ]
  }
}