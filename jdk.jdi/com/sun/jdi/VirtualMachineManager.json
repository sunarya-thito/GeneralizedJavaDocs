{
  "packageName": "com.sun.jdi",
  "simpleName": "VirtualMachineManager",
  "moduleName": "jdk.jdi",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "com.sun.jdi.connect.LaunchingConnector",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "defaultConnector",
      "comment": "Identifies the default connector. This connector should be used as the launching connector when selection of a connector with specific characteristics is unnecessary.",
      "tagMap": {
        "return": [
          "the default \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/connect/LaunchingConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eLaunchingConnector\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "com.sun.jdi.connect.LaunchingConnector",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "launchingConnectors",
      "comment": "Returns the list of known LaunchingConnector objects. Any of the returned objects can be used to launch a new target VM and immediately create a VirtualMachine mirror for it. Note that a target VM launched by a launching connector is not guaranteed to be stable until after the VMStartEvent has been received.",
      "tagMap": {
        "return": [
          "a list of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/connect/LaunchingConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eLaunchingConnector\u003c/code\u003e\u003c/a\u003e objects."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "com.sun.jdi.connect.AttachingConnector",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "attachingConnectors",
      "comment": "Returns the list of known AttachingConnector objects. Any of the returned objects can be used to attach to an existing target VM and create a VirtualMachine mirror for it.",
      "tagMap": {
        "return": [
          "a list of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/connect/AttachingConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eAttachingConnector\u003c/code\u003e\u003c/a\u003e objects."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "com.sun.jdi.connect.ListeningConnector",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "listeningConnectors",
      "comment": "Returns the list of known ListeningConnector objects. Any of the returned objects can be used to listen for a connection initiated by a target VM and create a VirtualMachine mirror for it.",
      "tagMap": {
        "return": [
          "a list of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/connect/ListeningConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eListeningConnector\u003c/code\u003e\u003c/a\u003e objects."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "com.sun.jdi.connect.Connector",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "allConnectors",
      "comment": "Returns the list of all known Connector objects.",
      "tagMap": {
        "return": [
          "a list of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/connect/Connector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eConnector\u003c/code\u003e\u003c/a\u003e objects."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "com.sun.jdi.VirtualMachine",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "connectedVirtualMachines",
      "comment": "Lists all target VMs which are connected to the debugger. The list includes VirtualMachine instances for any target VMs which initiated a connection and any target VMs to which this manager has initiated a connection. A target VM will remain in this list until the VM is disconnected. VMDisconnectEvent is placed in the event queue after the VM is removed from the list.",
      "tagMap": {
        "return": [
          "a list of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/VirtualMachine.html\" title\u003d\"interface in com.sun.jdi\"\u003e\u003ccode\u003eVirtualMachine\u003c/code\u003e\u003c/a\u003e objects, each mirroring a target VM."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "majorInterfaceVersion",
      "comment": "Returns the major version number of the JDI interface. See VirtualMachine.version() target VM version and information and VirtualMachine.description() more version information.",
      "tagMap": {
        "return": [
          "the integer major version number."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "minorInterfaceVersion",
      "comment": "Returns the minor version number of the JDI interface. See VirtualMachine.version() target VM version and information and VirtualMachine.description() more version information.",
      "tagMap": {
        "return": [
          "the integer minor version number"
        ]
      }
    },
    {
      "returnType": {
        "name": "com.sun.jdi.VirtualMachine",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "com.sun.jdi.connect.spi.Connection",
            "type": "Class"
          },
          "field": {
            "name": "connection"
          }
        },
        {
          "type": {
            "name": "java.lang.Process",
            "type": "Class"
          },
          "field": {
            "name": "process"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createVirtualMachine",
      "comment": "Create a virtual machine mirror for a target VM. Creates a virtual machine mirror for a target VM for which a Connection already exists. A Connection is created when a Connector establishes a connection and successfully handshakes with a target VM. A Connector can then use this method to create a virtual machine mirror to represent the composite state of the target VM. The process argument specifies the Process object for the taget VM. It may be specified as null. If the target VM is launched by a LaunchingConnector the process argument should be specified, otherwise calling VirtualMachine.process() on the created virtual machine will return null. This method exists so that Connectors may create a virtual machine mirror when a connection is established to a target VM. Only developers creating new Connector implementations should need to make direct use of this method.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/connect/spi/Connection.html#isOpen()\"\u003e\u003ccode\u003eConnection.isOpen()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.jdi/com/sun/jdi/VirtualMachine.html#process()\"\u003e\u003ccode\u003eVirtualMachine.process()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003econnection\u003c/code\u003e - The open connection to the target VM.",
          "\u003ccode\u003eprocess\u003c/code\u003e - If launched, the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Process.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eProcess\u003c/code\u003e\u003c/a\u003e object for the target VM. \n\u003ccode\u003enull\u003c/code\u003e if not launched."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the connection is not open"
        ],
        "return": [
          "new virtual machine representing the target VM."
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "com.sun.jdi.VirtualMachine",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "com.sun.jdi.connect.spi.Connection",
            "type": "Class"
          },
          "field": {
            "name": "connection"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createVirtualMachine",
      "comment": "Creates a new virtual machine. This convenience method works as if by invoking createVirtualMachine(Connection, Process) method and specifying null as the process argument. This method exists so that Connectors may create a virtual machine mirror when a connection is established to a target VM. Only developers creating new Connector implementations should need to make direct use of this method.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the connection is not open"
        ],
        "return": [
          "the new virtual machine"
        ],
        "since": [
          "1.5"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "com.sun.jdi.VirtualMachineManager",
  "comment": "A manager of connections to target virtual machines. The VirtualMachineManager allows one application to debug multiple target VMs. (Note that the converse is not supported; a target VM can be debugged by only one debugger application.) This interface contains methods to manage connections to remote target VMs and to obtain the \n\u003ca href\u003d\"VirtualMachine.html\" title\u003d\"interface in com.sun.jdi\"\u003e\u003ccode\u003eVirtualMachine\u003c/code\u003e\u003c/a\u003e mirror for available target VMs. \n\u003cp\u003e Connections can be made using one of several different \u003ca href\u003d\"connect/Connector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eConnector\u003c/code\u003e\u003c/a\u003e objects. Each connector encapsulates a different way of connecting the debugger with a target VM. \u003c/p\u003e\n\u003cp\u003e The VirtualMachineManager supports many different scenarios for connecting a debugger to a virtual machine. Four examples are presented in the table below. The examples use the command line syntax in Sun\u0027s implementation. Some \u003ca href\u003d\"connect/Connector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eConnector\u003c/code\u003e\u003c/a\u003e implementations may require slightly different handling than presented below. \u003c/p\u003e\n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n  Four scenarios for connecting a debugger to a virtual machine\"\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003eScenario\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \n  \u003c/tr\u003e\n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eDebugger launches target VM (simplest, most-common scenario)\u003c/th\u003e \n   \u003ctd\u003eDebugger calls the \u003ca href\u003d\"connect/LaunchingConnector.html#launch(java.util.Map)\"\u003e\u003ccode\u003eLaunchingConnector.launch(java.util.Map)\u003c/code\u003e\u003c/a\u003e method of the default connector, obtained with \u003ca href\u003d\"#defaultConnector()\"\u003e\u003ccode\u003edefaultConnector()\u003c/code\u003e\u003c/a\u003e. The target VM is launched, and a connection between that VM and the debugger is established. A \u003ca href\u003d\"VirtualMachine.html\" title\u003d\"interface in com.sun.jdi\"\u003e\u003ccode\u003eVirtualMachine\u003c/code\u003e\u003c/a\u003e mirror is returned. \u003cp\u003eOr, for more control \u003c/p\u003e\n    \u003cul\u003e \n     \u003cli\u003e Debugger selects a connector from the list returned by \u003ca href\u003d\"#launchingConnectors()\"\u003e\u003ccode\u003elaunchingConnectors()\u003c/code\u003e\u003c/a\u003e with desired characteristics (for example, transport type, etc.). \u003c/li\u003e\n     \u003cli\u003e Debugger calls the \u003ca href\u003d\"connect/LaunchingConnector.html#launch(java.util.Map)\"\u003e\u003ccode\u003eLaunchingConnector.launch(java.util.Map)\u003c/code\u003e\u003c/a\u003e method of the selected connector. The target VM is launched, and a connection between that VM and the debugger is established. A \u003ca href\u003d\"VirtualMachine.html\" title\u003d\"interface in com.sun.jdi\"\u003e\u003ccode\u003eVirtualMachine\u003c/code\u003e\u003c/a\u003e mirror is returned. \u003c/li\u003e\n    \u003c/ul\u003e \u003cp\u003e\u003c/p\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eDebugger attaches to previously-running VM\u003c/th\u003e \n   \u003ctd\u003e \n    \u003cul\u003e \n     \u003cli\u003e Target VM is launched using the options \u003ccode\u003e-agentlib:jdwp\u003dtransport\u003dxxx,server\u003dy\u003c/code\u003e \u003c/li\u003e \n     \u003cli\u003e Target VM generates and outputs the tranport-specific address at which it will listen for a connection.\u003c/li\u003e \n     \u003cli\u003e Debugger is launched. Debugger selects a connector in the list returned by \u003ca href\u003d\"#attachingConnectors()\"\u003e\u003ccode\u003eattachingConnectors()\u003c/code\u003e\u003c/a\u003e matching the transport with the name \"xxx\". \u003c/li\u003e\n     \u003cli\u003e Debugger presents the default connector parameters (obtained through \u003ca href\u003d\"connect/Connector.html#defaultArguments()\"\u003e\u003ccode\u003eConnector.defaultArguments()\u003c/code\u003e\u003c/a\u003e) to the end user, allowing the user to fill in the transport-specific address generated by the target VM. \u003c/li\u003e\n     \u003cli\u003e Debugger calls the \u003ca href\u003d\"connect/AttachingConnector.html#attach(java.util.Map)\"\u003e\u003ccode\u003eAttachingConnector.attach(java.util.Map)\u003c/code\u003e\u003c/a\u003e method of the selected to attach to the target VM. A \u003ca href\u003d\"VirtualMachine.html\" title\u003d\"interface in com.sun.jdi\"\u003e\u003ccode\u003eVirtualMachine\u003c/code\u003e\u003c/a\u003e mirror is returned. \u003c/li\u003e\n    \u003c/ul\u003e \u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eTarget VM attaches to previously-running debugger\u003c/th\u003e \n   \u003ctd\u003e \n    \u003cul\u003e \n     \u003cli\u003e At startup, debugger selects one or more connectors from the list returned by \u003ca href\u003d\"#listeningConnectors()\"\u003e\u003ccode\u003elisteningConnectors()\u003c/code\u003e\u003c/a\u003e for one or more transports.\u003c/li\u003e \n     \u003cli\u003e Debugger calls the \u003ca href\u003d\"connect/ListeningConnector.html#startListening(java.util.Map)\"\u003e\u003ccode\u003eListeningConnector.startListening(java.util.Map)\u003c/code\u003e\u003c/a\u003e method for each selected connector. For each call, a transport-specific address string is generated and returned. The debugger makes the transport names and corresponding address strings available to the end user. \u003c/li\u003e\n     \u003cli\u003e Debugger calls \u003ca href\u003d\"connect/ListeningConnector.html#accept(java.util.Map)\"\u003e\u003ccode\u003eListeningConnector.accept(java.util.Map)\u003c/code\u003e\u003c/a\u003e for each selected connector to wait for a target VM to connect.\u003c/li\u003e \n     \u003cli\u003e Later, target VM is launched by end user with the options \u003ccode\u003e-agentlib:jdwp\u003dtransport\u003dxxx,address\u003dyyy\u003c/code\u003e where \"xxx\" the transport for one of the connectors selected by the the debugger and \"yyy\" is the address generated by \u003ca href\u003d\"connect/ListeningConnector.html#accept(java.util.Map)\"\u003e\u003ccode\u003eListeningConnector.accept(java.util.Map)\u003c/code\u003e\u003c/a\u003e for that transport.\u003c/li\u003e \n     \u003cli\u003e Debugger\u0027s call to \u003ca href\u003d\"connect/ListeningConnector.html#accept(java.util.Map)\"\u003e\u003ccode\u003eListeningConnector.accept(java.util.Map)\u003c/code\u003e\u003c/a\u003e returns a \u003ca href\u003d\"VirtualMachine.html\" title\u003d\"interface in com.sun.jdi\"\u003e\u003ccode\u003eVirtualMachine\u003c/code\u003e\u003c/a\u003e mirror.\u003c/li\u003e \n    \u003c/ul\u003e \u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eTarget VM launches debugger (sometimes called \"Just-In-Time\" debugging)\u003c/th\u003e \n   \u003ctd\u003e \n    \u003cul\u003e \n     \u003cli\u003e Target VM is launched with the options \u003ccode\u003e-agentlib:jdwp\u003dlaunch\u003dcmdline,onuncaught\u003dy,transport\u003dxxx,server\u003dy\u003c/code\u003e \u003c/li\u003e \n     \u003cli\u003e Later, an uncaught exception is thrown in the target VM. The target VM generates the tranport-specific address at which it will listen for a connection. \u003c/li\u003e\n     \u003cli\u003eTarget VM launches the debugger with the following items concatenated together (separated by spaces) to form the command line: \n      \u003cul\u003e \n       \u003cli\u003e The launch\u003d value \u003c/li\u003e\n       \u003cli\u003e The transport\u003d value \u003c/li\u003e\n       \u003cli\u003e The generated transport-specific address at which VM is listening for debugger connection. \u003c/li\u003e\n      \u003c/ul\u003e \u003c/li\u003e\n     \u003cli\u003e Upon launch, debugger selects a connector in the list returned by \u003ca href\u003d\"#attachingConnectors()\"\u003e\u003ccode\u003eattachingConnectors()\u003c/code\u003e\u003c/a\u003e matching the transport with the name \"xxx\". \u003c/li\u003e\n     \u003cli\u003e Debugger changes the default connector parameters (obtained through \u003ca href\u003d\"connect/Connector.html#defaultArguments()\"\u003e\u003ccode\u003eConnector.defaultArguments()\u003c/code\u003e\u003c/a\u003e) to specify the transport specific address at which the VM is listenig. Optionally, other connector arguments can be presented to the user. \u003c/li\u003e\n     \u003cli\u003e Debugger calls the \u003ca href\u003d\"connect/AttachingConnector.html#attach(java.util.Map)\"\u003e\u003ccode\u003eAttachingConnector.attach(java.util.Map)\u003c/code\u003e\u003c/a\u003e method of the selected to attach to the target VM. A \u003ca href\u003d\"VirtualMachine.html\" title\u003d\"interface in com.sun.jdi\"\u003e\u003ccode\u003eVirtualMachine\u003c/code\u003e\u003c/a\u003e mirror is returned. \u003c/li\u003e\n    \u003c/ul\u003e \u003c/td\u003e \n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Connectors are created at start-up time. That is, they are created the first time that \u003ca href\u003d\"Bootstrap.html#virtualMachineManager()\"\u003e\u003ccode\u003eBootstrap.virtualMachineManager()\u003c/code\u003e\u003c/a\u003e is invoked. The list of all Connectors created at start-up time can be obtained from the VirtualMachineManager by invoking the \u003ca href\u003d\"#allConnectors()\"\u003e\u003ccode\u003eallConnectors\u003c/code\u003e\u003c/a\u003e method. \u003c/p\u003e\n\u003cp\u003e Connectors are created at start-up time if they are installed on the platform. In addition, Connectors are created automatically by the VirtualMachineManager to encapsulate any \u003ca href\u003d\"connect/spi/TransportService.html\" title\u003d\"class in com.sun.jdi.connect.spi\"\u003e\u003ccode\u003eTransportService\u003c/code\u003e\u003c/a\u003e implementations that are installed on the platform. These two mechanisms for creating Connectors are described here. \u003c/p\u003e\n\u003cp\u003e A Connector is installed on the platform if it is installed in a jar file that is visible to the defining class loader of the \u003ca href\u003d\"connect/Connector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eConnector\u003c/code\u003e\u003c/a\u003e type, and that jar file contains a provider configuration file named \u003ccode\u003eConnector\u003c/code\u003e in the resource directory \u003ccode\u003eMETA-INF/services\u003c/code\u003e, and the provider configuration file lists the full-qualified class name of the Connector implementation. A Connector is a class that implements the \u003ca href\u003d\"connect/Connector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eConnector\u003c/code\u003e\u003c/a\u003e interface. More appropriately the class implements one of the specific Connector types, namely \u003ca href\u003d\"connect/AttachingConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eAttachingConnector\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"connect/ListeningConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eListeningConnector\u003c/code\u003e\u003c/a\u003e, or \u003ca href\u003d\"connect/LaunchingConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eLaunchingConnector\u003c/code\u003e\u003c/a\u003e. The format of the provider configuration file is one fully-qualified class name per line. Space and tab characters surrounding each class, as well as blank lines are ignored. The comment character is \u003ccode\u003e\u0027#\u0027\u003c/code\u003e (\u003ccode\u003e0x23\u003c/code\u003e), and on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8. \u003c/p\u003e\n\u003cp\u003e At start-up time the VirtualMachineManager attempts to load and instantiate (using the no-arg constructor) each class listed in the provider configuration file. Exceptions thrown when loading or creating the Connector are caught and ignored. In other words, the start-up process continues despite of errors. \u003c/p\u003e\n\u003cp\u003e In addition to Connectors installed on the platform the VirtualMachineManager will also create Connectors to encapsulate any \u003ca href\u003d\"connect/spi/TransportService.html\" title\u003d\"class in com.sun.jdi.connect.spi\"\u003e\u003ccode\u003eTransportService\u003c/code\u003e\u003c/a\u003e implementations that are installed on the platform. A TransportService is installed on the platform if it installed in a jar file that is visible to the defining class loader for the \u003ca href\u003d\"connect/spi/TransportService.html\" title\u003d\"class in com.sun.jdi.connect.spi\"\u003e\u003ccode\u003eTransportService\u003c/code\u003e\u003c/a\u003e type, and that jar file contains a provider configuration file named \u003ccode\u003eTransportService\u003c/code\u003e in the resource directory \u003ccode\u003eMETA-INF/services\u003c/code\u003e, and the provider configuration file lists the full-qualified class name of the TransportService implementation. A TransportService is a concrete sub-class of \u003ca href\u003d\"connect/spi/TransportService.html\" title\u003d\"class in com.sun.jdi.connect.spi\"\u003e\u003ccode\u003eTransportService\u003c/code\u003e\u003c/a\u003e. The format of the provider configuration file is the same as the provider configuration file for Connectors except that each class listed must be the fully-qualified class name of a class that implements the TransportService interface. \u003c/p\u003e\n\u003cp\u003e For each TransportService installed on the platform, the VirtualMachineManager creates a corresponding \u003ca href\u003d\"connect/AttachingConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eAttachingConnector\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"connect/ListeningConnector.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eListeningConnector\u003c/code\u003e\u003c/a\u003e. These Connectors are created to encapsulate a \u003ca href\u003d\"connect/Transport.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eTransport\u003c/code\u003e\u003c/a\u003e that in turn encapsulates the TransportService. The AttachingConnector will be named based on the name of the transport service concatenated with the string \u003ccode\u003eAttach\u003c/code\u003e. For example, if the transport service \u003ca href\u003d\"connect/spi/TransportService.html#name()\"\u003e\u003ccode\u003ename()\u003c/code\u003e\u003c/a\u003e method returns \u003ccode\u003etelepathic\u003c/code\u003e then the AttachingConnector will be named \u003ccode\u003etelepathicAttach\u003c/code\u003e. Similiarly the ListeningConnector will be named with the string \u003ccode\u003eListen\u003c/code\u003e tagged onto the name of the transport service. The \u003ca href\u003d\"connect/Connector.html#description()\"\u003e\u003ccode\u003edescription()\u003c/code\u003e\u003c/a\u003e method of both the AttachingConnector, and the ListeningConnector, will delegate to the \u003ca href\u003d\"connect/spi/TransportService.html#description()\"\u003e\u003ccode\u003edescription()\u003c/code\u003e\u003c/a\u003e method of the underlying transport service. Both the AttachingConnector and the ListeningConnector will have two Connector \u003ca href\u003d\"connect/Connector.Argument.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eArguments\u003c/code\u003e\u003c/a\u003e. A \u003ca href\u003d\"connect/Connector.StringArgument.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eStringArgument\u003c/code\u003e\u003c/a\u003e named \u003ccode\u003eaddress\u003c/code\u003e is the connector argument to specify the address to attach too, or to listen on. A \u003ca href\u003d\"connect/Connector.IntegerArgument.html\" title\u003d\"interface in com.sun.jdi.connect\"\u003e\u003ccode\u003eIntegerArgument\u003c/code\u003e\u003c/a\u003e named \u003ccode\u003etimeout\u003c/code\u003e is the connector argument to specify the timeout when attaching, or accepting. The timeout connector may be ignored depending on if the transport service supports an attach timeout or accept timeout. \u003c/p\u003e\n\u003cp\u003e Initialization of the virtual machine manager will fail, that is \u003ca href\u003d\"Bootstrap.html#virtualMachineManager()\"\u003e\u003ccode\u003eBootstrap.virtualMachineManager()\u003c/code\u003e\u003c/a\u003e will throw an error if the virtual machine manager is unable to create any connectors.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.3"
    ]
  }
}