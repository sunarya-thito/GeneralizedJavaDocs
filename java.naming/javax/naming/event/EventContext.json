{
  "packageName": "javax.naming.event",
  "simpleName": "EventContext",
  "moduleName": "java.naming",
  "type": "INTERFACE",
  "superClass": {
    "name": "javax.naming.Context",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "OBJECT_SCOPE",
      "comment": "Constant for expressing interest in events concerning the object named by the target. The value of this constant is 0.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.naming.event.EventContext.OBJECT_SCOPE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "ONELEVEL_SCOPE",
      "comment": "Constant for expressing interest in events concerning objects in the context named by the target, excluding the context named by the target. The value of this constant is 1.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.naming.event.EventContext.ONELEVEL_SCOPE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "SUBTREE_SCOPE",
      "comment": "Constant for expressing interest in events concerning objects in the subtree of the object named by the target, including the object named by the target. The value of this constant is 2.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.naming.event.EventContext.SUBTREE_SCOPE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addNamingListener",
      "comment": "Adds a listener for receiving naming events fired when the object(s) identified by a target and scope changes. The event source of those events is this context. See the class description for a discussion on event source and target. See the descriptions of the constants OBJECT_SCOPE, ONELEVEL_SCOPE, and SUBTREE_SCOPE to see how scope affects the registration. target needs to name a context only when scope is ONELEVEL_SCOPE. target may name a non-context if scope is either OBJECT_SCOPE or SUBTREE_SCOPE. Using SUBTREE_SCOPE for a non-context might be useful, for example, if the caller does not know in advance whether target is a context and just wants to register interest in the (possibly degenerate subtree) rooted at target. When the listener is notified of an event, the listener may in invoked in a thread other than the one in which addNamingListener() is executed. Care must be taken when multiple threads are accessing the same EventContext concurrently. See the package description for more information on threading issues.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.naming/javax/naming/event/EventContext.html#removeNamingListener(javax.naming.event.NamingListener)\"\u003e\u003ccode\u003eremoveNamingListener(javax.naming.event.NamingListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - A nonnull name to be resolved relative to this context.",
          "\u003ccode\u003escope\u003c/code\u003e - One of \n\u003ccode\u003eOBJECT_SCOPE\u003c/code\u003e, \n\u003ccode\u003eONELEVEL_SCOPE\u003c/code\u003e, or \n\u003ccode\u003eSUBTREE_SCOPE\u003c/code\u003e.",
          "\u003ccode\u003el\u003c/code\u003e - The nonnull listener."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.naming/javax/naming/NamingException.html\" title\u003d\"class in javax.naming\"\u003eNamingException\u003c/a\u003e\u003c/code\u003e - If a problem was encountered while adding the listener."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addNamingListener",
      "comment": "Adds a listener for receiving naming events fired when the object named by the string target name and scope changes. See the overload that accepts a Name for details.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.naming/javax/naming/event/EventContext.html#removeNamingListener(javax.naming.event.NamingListener)\"\u003e\u003ccode\u003eremoveNamingListener(javax.naming.event.NamingListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - The nonnull string name of the object resolved relative to this context.",
          "\u003ccode\u003escope\u003c/code\u003e - One of \n\u003ccode\u003eOBJECT_SCOPE\u003c/code\u003e, \n\u003ccode\u003eONELEVEL_SCOPE\u003c/code\u003e, or \n\u003ccode\u003eSUBTREE_SCOPE\u003c/code\u003e.",
          "\u003ccode\u003el\u003c/code\u003e - The nonnull listener."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.naming/javax/naming/NamingException.html\" title\u003d\"class in javax.naming\"\u003eNamingException\u003c/a\u003e\u003c/code\u003e - If a problem was encountered while adding the listener."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "removeNamingListener",
      "comment": "Removes a listener from receiving naming events fired by this EventContext. The listener may have registered more than once with this EventContext, perhaps with different target/scope arguments. After this method is invoked, the listener will no longer receive events with this EventContext instance as the event source (except for those events already in the process of being dispatched). If the listener was not, or is no longer, registered with this EventContext instance, this method does not do anything.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.naming/javax/naming/event/EventContext.html#addNamingListener(javax.naming.Name,int,javax.naming.event.NamingListener)\"\u003e\u003ccode\u003eaddNamingListener(javax.naming.Name, int, javax.naming.event.NamingListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003el\u003c/code\u003e - The nonnull listener."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.naming/javax/naming/NamingException.html\" title\u003d\"class in javax.naming\"\u003eNamingException\u003c/a\u003e\u003c/code\u003e - If a problem was encountered while removing the listener."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "targetMustExist",
      "comment": "Determines whether a listener can register interest in a target that does not exist.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.naming/javax/naming/NamingException.html\" title\u003d\"class in javax.naming\"\u003eNamingException\u003c/a\u003e\u003c/code\u003e - If the context\u0027s behavior in this regard cannot be determined."
        ],
        "return": [
          "true if the target must exist; false if the target need not exist."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "javax.naming.event.EventContext",
  "comment": "Contains methods for registering/deregistering listeners to be notified of events fired when objects named in a context changes. \n\u003ch2\u003eTarget\u003c/h2\u003e The name parameter in the \n\u003ccode\u003eaddNamingListener()\u003c/code\u003e methods is referred to as the \n\u003cem\u003etarget\u003c/em\u003e. The target, along with the scope, identify the object(s) that the listener is interested in. It is possible to register interest in a target that does not exist, but there might be limitations in the extent to which this can be supported by the service provider and underlying protocol/service. \n\u003cp\u003e If a service only supports registration for existing targets, an attempt to register for a nonexistent target results in a \u003ccode\u003eNameNotFoundException\u003c/code\u003e being thrown as early as possible, preferably at the time \u003ccode\u003eaddNamingListener()\u003c/code\u003e is called, or if that is not possible, the listener will receive the exception through the \u003ccode\u003eNamingExceptionEvent\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e Also, for service providers that only support registration for existing targets, when the target that a listener has registered for is subsequently removed from the namespace, the listener is notified via a \u003ccode\u003eNamingExceptionEvent\u003c/code\u003e (containing a \u003ccode\u003eNameNotFoundException\u003c/code\u003e). \u003c/p\u003e\n\u003cp\u003e An application can use the method \u003ccode\u003etargetMustExist()\u003c/code\u003e to check whether an \u003ccode\u003eEventContext\u003c/code\u003e supports registration of nonexistent targets. \u003c/p\u003e\n\u003ch2\u003eEvent Source\u003c/h2\u003e The \n\u003ccode\u003eEventContext\u003c/code\u003e instance on which you invoke the registration methods is the \n\u003cem\u003eevent source\u003c/em\u003e of the events that are (potentially) generated. The source is \n\u003cem\u003enot necessarily\u003c/em\u003e the object named by the target. Only when the target is the empty name is the object named by the target the source. In other words, the target, along with the scope parameter, are used to identify the object(s) that the listener is interested in, but the event source is the \n\u003ccode\u003eEventContext\u003c/code\u003e instance with which the listener has registered. \n\u003cp\u003e For example, suppose a listener makes the following registration: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e      NamespaceChangeListener listener \u003d ...;\n      src.addNamingListener(\"x\", SUBTREE_SCOPE, listener);\n\u003c/pre\u003e\n\u003c/blockquote\u003e When an object named \"x/y\" is subsequently deleted, the corresponding \n\u003ccode\u003eNamingEvent\u003c/code\u003e (\n\u003ccode\u003eevt\u003c/code\u003e) must contain: \n\u003cblockquote\u003e\n \u003cpre\u003e      evt.getEventContext() \u003d\u003d src\n      evt.getOldBinding().getName().equals(\"x/y\")\n\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Furthermore, listener registration/deregistration is with the \u003ccode\u003eEventContext\u003c/code\u003e \u003cem\u003einstance\u003c/em\u003e, and not with the corresponding object in the namespace. If the program intends at some point to remove a listener, then it needs to keep a reference to the \u003ccode\u003eEventContext\u003c/code\u003e instance on which it invoked \u003ccode\u003eaddNamingListener()\u003c/code\u003e (just as it needs to keep a reference to the listener in order to remove it later). It cannot expect to do a \u003ccode\u003elookup()\u003c/code\u003e and get another instance of an \u003ccode\u003eEventContext\u003c/code\u003e on which to perform the deregistration. \u003c/p\u003e\n\u003ch2\u003eLifetime of Registration\u003c/h2\u003e A registered listener becomes deregistered when: \n\u003cul\u003e \n \u003cli\u003eIt is removed using \u003ccode\u003eremoveNamingListener()\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eAn exception is thrown while collecting information about the events. That is, when the listener receives a \u003ccode\u003eNamingExceptionEvent\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003e\u003ccode\u003eContext.close()\u003c/code\u003e is invoked on the \u003ccode\u003eEventContext\u003c/code\u003e instance with which it has registered. \u003c/li\u003e\n\u003c/ul\u003e Until that point, an \n\u003ccode\u003eEventContext\u003c/code\u003e instance that has outstanding listeners will continue to exist and be maintained by the service provider. \n\u003ch2\u003eListener Implementations\u003c/h2\u003e The registration/deregistration methods accept an instance of \n\u003ccode\u003eNamingListener\u003c/code\u003e. There are subinterfaces of \n\u003ccode\u003eNamingListener\u003c/code\u003e for different of event types of \n\u003ccode\u003eNamingEvent\u003c/code\u003e. For example, the \n\u003ccode\u003eObjectChangeListener\u003c/code\u003e interface is for the \n\u003ccode\u003eNamingEvent.OBJECT_CHANGED\u003c/code\u003e event type. To register interest in multiple event types, the listener implementation should implement multiple \n\u003ccode\u003eNamingListener\u003c/code\u003e subinterfaces and use a single invocation of \n\u003ccode\u003eaddNamingListener()\u003c/code\u003e. In addition to reducing the number of method calls and possibly the code size of the listeners, this allows some service providers to optimize the registration. \n\u003ch2\u003eThreading Issues\u003c/h2\u003e Like \n\u003ccode\u003eContext\u003c/code\u003e instances in general, instances of \n\u003ccode\u003eEventContext\u003c/code\u003e are not guaranteed to be thread-safe. Care must be taken when multiple threads are accessing the same \n\u003ccode\u003eEventContext\u003c/code\u003e concurrently. See the \n\u003ca href\u003d\"package-summary.html#THREADING\"\u003epackage description\u003c/a\u003e for more information on threading issues.",
  "tagMap": {
    "since": [
      "1.3"
    ]
  }
}