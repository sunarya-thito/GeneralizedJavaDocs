{
  "packageName": "jdk.incubator.vector",
  "simpleName": "Vector",
  "moduleName": "jdk.incubator.vector",
  "type": "CLASS",
  "superClass": {
    "name": "jdk.internal.vm.vector.VectorSupport.Vector",
    "parameters": [
      {
        "name": "E",
        "type": "Class"
      }
    ],
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorSpecies",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "species",
      "comment": "Returns the species of this vector.",
      "tagMap": {
        "return": [
          "the species of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "elementType",
      "comment": "Returns the primitive element type (ETYPE) of this vector.",
      "tagMap": {
        "implSpec": [
          "This is the same value as \n\u003ccode\u003ethis.species().elementType()\u003c/code\u003e."
        ],
        "return": [
          "the primitive element type of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "elementSize",
      "comment": "Returns the size of each lane, in bits, of this vector.",
      "tagMap": {
        "implSpec": [
          "This is the same value as \n\u003ccode\u003ethis.species().elementSize()\u003c/code\u003e."
        ],
        "return": [
          "the lane size, in bits, of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorShape",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "shape",
      "comment": "Returns the shape of this vector.",
      "tagMap": {
        "implSpec": [
          "This is the same value as \n\u003ccode\u003ethis.species().vectorShape()\u003c/code\u003e."
        ],
        "return": [
          "the shape of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "length",
      "comment": "Returns the lane count, or vector length (VLENGTH).",
      "tagMap": {
        "return": [
          "the lane count"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "bitSize",
      "comment": "Returns the total size, in bits, of this vector.",
      "tagMap": {
        "implSpec": [
          "This is the same value as \n\u003ccode\u003ethis.shape().vectorBitSize()\u003c/code\u003e."
        ],
        "return": [
          "the total size, in bits, of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "byteSize",
      "comment": "Returns the total size, in bytes, of this vector.",
      "tagMap": {
        "implSpec": [
          "This is the same value as \n\u003ccode\u003ethis.bitSize()/Byte.SIZE\u003c/code\u003e."
        ],
        "return": [
          "the total size, in bytes, of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Unary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Operates on the lane values of this vector. This is a lane-wise unary operation which applies the selected operation to each lane.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#NEG\"\u003e\u003ccode\u003eVectorOperators.NEG\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#NOT\"\u003e\u003ccode\u003eVectorOperators.NOT\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#SIN\"\u003e\u003ccode\u003eVectorOperators.SIN\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Ternary,Vector,Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the method return type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to process lane values"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Unary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Operates on the lane values of this vector, with selection of lane elements controlled by a mask. This is a lane-wise unary operation which applies the selected operation to each lane.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the method return type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to process lane values",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Binary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Combines the corresponding lane values of this vector with those of a second input vector. This is a lane-wise binary operation which applies the selected operation to each lane.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#ADD\"\u003e\u003ccode\u003eVectorOperators.ADD\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#XOR\"\u003e\u003ccode\u003eVectorOperators.XOR\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#ATAN2\"\u003e\u003ccode\u003eVectorOperators.ATAN2\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Ternary,Vector, Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the method return type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values",
          "\u003ccode\u003ev\u003c/code\u003e - the input vector"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the two input vectors"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Binary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Combines the corresponding lane values of this vector with those of a second input vector, with selection of lane elements controlled by a mask. This is a lane-wise binary operation which applies the selected operation to each lane.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the method return type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values",
          "\u003ccode\u003ev\u003c/code\u003e - the second input vector",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the two input vectors"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Binary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "e"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Combines the lane values of this vector with the value of a broadcast scalar. This is a lane-wise binary operation which applies the selected operation to each lane. The return value will be equal to this expression: this.lanewise(op, this.broadcast(e)).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#broadcast(long)\"\u003e\u003ccode\u003ebroadcast(long)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,long,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,long,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003elong\u003c/code\u003e value \n\u003ccode\u003ee\u003c/code\u003e must be accurately representable by the \n\u003ccode\u003eETYPE\u003c/code\u003e of this vector\u0027s species, so that \n\u003ccode\u003ee\u003d\u003d(long)(ETYPE)e\u003c/code\u003e. This rule is enforced by the implicit call to \n\u003ccode\u003ebroadcast()\u003c/code\u003e. \n\u003cp\u003e Subtypes improve on this method by sharpening the method return type and the type of the scalar parameter \u003ccode\u003ee\u003c/code\u003e.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values",
          "\u003ccode\u003ee\u003c/code\u003e - the input scalar"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given \n\u003ccode\u003elong\u003c/code\u003e value cannot be represented by the right operand type of the vector operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the input vector and the scalar"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Binary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "e"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Combines the corresponding lane values of this vector with those of a second input vector, with selection of lane elements controlled by a mask. This is a lane-wise binary operation which applies the selected operation to each lane. The second operand is a broadcast integral value. The return value will be equal to this expression: this.lanewise(op, this.broadcast(e), m).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#broadcast(long)\"\u003e\u003ccode\u003ebroadcast(long)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003elong\u003c/code\u003e value \n\u003ccode\u003ee\u003c/code\u003e must be accurately representable by the \n\u003ccode\u003eETYPE\u003c/code\u003e of this vector\u0027s species, so that \n\u003ccode\u003ee\u003d\u003d(long)(ETYPE)e\u003c/code\u003e. This rule is enforced by the implicit call to \n\u003ccode\u003ebroadcast()\u003c/code\u003e. \n\u003cp\u003e Subtypes improve on this method by sharpening the method return type and the type of the scalar parameter \u003ccode\u003ee\u003c/code\u003e.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values",
          "\u003ccode\u003ee\u003c/code\u003e - the input scalar",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given \n\u003ccode\u003elong\u003c/code\u003e value cannot be represented by the right operand type of the vector operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the input vector and the scalar"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Ternary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v1"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v2"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Combines the corresponding lane values of this vector with the lanes of a second and a third input vector. This is a lane-wise ternary operation which applies the selected operation to each lane.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#BITWISE_BLEND\"\u003e\u003ccode\u003eVectorOperators.BITWISE_BLEND\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#FMA\"\u003e\u003ccode\u003eVectorOperators.FMA\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the method return type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values",
          "\u003ccode\u003ev1\u003c/code\u003e - the second input vector",
          "\u003ccode\u003ev2\u003c/code\u003e - the third input vector"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the three input vectors"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Ternary",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v1"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v2"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lanewise",
      "comment": "Combines the corresponding lane values of this vector with the lanes of a second and a third input vector, with selection of lane elements controlled by a mask. This is a lane-wise ternary operation which applies the selected operation to each lane.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Ternary,Vector,Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the method return type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values",
          "\u003ccode\u003ev1\u003c/code\u003e - the second input vector",
          "\u003ccode\u003ev2\u003c/code\u003e - the third input vector",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the result of applying the operation lane-wise to the three input vectors"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "add",
      "comment": "Adds this vector to a second input vector. This is a lane-wise binary operation which applies the primitive addition operation (+) to each pair of corresponding lane values. This method is also equivalent to the expression lanewise(ADD, v). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#add(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eadd(Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#add(int)\"\u003e\u003ccode\u003eIntVector.add(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#ADD\"\u003e\u003ccode\u003eVectorOperators.ADD\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,long)\"\u003e\u003ccode\u003eIntVector.lanewise(VectorOperators.Binary,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the result of adding this vector to the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "add",
      "comment": "Adds this vector to a second input vector, selecting lanes under the control of a mask. This is a masked lane-wise binary operation which applies the primitive addition operation (+) to each pair of corresponding lane values. For any lane unset in the mask, the primitive operation is suppressed and this vector retains the original value stored in that lane. This method is also equivalent to the expression lanewise(ADD, v, m). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#add(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eadd(Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#add(int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eIntVector.add(int,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#ADD\"\u003e\u003ccode\u003eVectorOperators.ADD\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eIntVector.lanewise(VectorOperators.Binary,int,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - the second input vector",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "return": [
          "the result of adding this vector to the given vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "sub",
      "comment": "Subtracts a second input vector from this vector. This is a lane-wise binary operation which applies the primitive subtraction operation (-) to each pair of corresponding lane values. This method is also equivalent to the expression lanewise(SUB, v). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#sub(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003esub(Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#sub(int)\"\u003e\u003ccode\u003eIntVector.sub(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#SUB\"\u003e\u003ccode\u003eVectorOperators.SUB\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,long)\"\u003e\u003ccode\u003eIntVector.lanewise(VectorOperators.Binary,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the result of subtracting the second input vector from this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "sub",
      "comment": "Subtracts a second input vector from this vector under the control of a mask. This is a masked lane-wise binary operation which applies the primitive subtraction operation (-) to each pair of corresponding lane values. For any lane unset in the mask, the primitive operation is suppressed and this vector retains the original value stored in that lane. This method is also equivalent to the expression lanewise(SUB, v, m). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#sub(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003esub(Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#sub(int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eIntVector.sub(int,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#SUB\"\u003e\u003ccode\u003eVectorOperators.SUB\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eIntVector.lanewise(VectorOperators.Binary,int,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - the second input vector",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "return": [
          "the result of subtracting the second input vector from this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "mul",
      "comment": "Multiplies this vector by a second input vector. This is a lane-wise binary operation which applies the primitive multiplication operation (*) to each pair of corresponding lane values. This method is also equivalent to the expression lanewise(MUL, v). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#mul(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003emul(Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#mul(int)\"\u003e\u003ccode\u003eIntVector.mul(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#MUL\"\u003e\u003ccode\u003eVectorOperators.MUL\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,long)\"\u003e\u003ccode\u003eIntVector.lanewise(VectorOperators.Binary,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the result of multiplying this vector by the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "mul",
      "comment": "Multiplies this vector by a second input vector under the control of a mask. This is a lane-wise binary operation which applies the primitive multiplication operation (*) to each pair of corresponding lane values. For any lane unset in the mask, the primitive operation is suppressed and this vector retains the original value stored in that lane. This method is also equivalent to the expression lanewise(MUL, v, m). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#mul(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003emul(Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#mul(int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eIntVector.mul(int,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#MUL\"\u003e\u003ccode\u003eVectorOperators.MUL\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eIntVector.lanewise(VectorOperators.Binary,int,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - the second input vector",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "return": [
          "the result of multiplying this vector by the given vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "div",
      "comment": "Divides this vector by a second input vector. This is a lane-wise binary operation which applies the primitive division operation (/) to each pair of corresponding lane values. This method is also equivalent to the expression lanewise(DIV, v). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#div(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003ediv(Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/DoubleVector.html#div(double)\"\u003e\u003ccode\u003eDoubleVector.div(double)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#DIV\"\u003e\u003ccode\u003eVectorOperators.DIV\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,long)\"\u003e\u003ccode\u003eIntVector.lanewise(VectorOperators.Binary,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "If the underlying scalar operator does not support division by zero, but is presented with a zero divisor, an \n\u003ccode\u003eArithmeticException\u003c/code\u003e will be thrown."
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArithmeticException.html\" title\u003d\"class in java.lang\"\u003eArithmeticException\u003c/a\u003e\u003c/code\u003e - if any lane in \n\u003ccode\u003ev\u003c/code\u003e is zero and \n\u003ccode\u003eETYPE\u003c/code\u003e is not \n\u003ccode\u003efloat\u003c/code\u003e or \n\u003ccode\u003edouble\u003c/code\u003e."
        ],
        "return": [
          "the result of dividing this vector by the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "div",
      "comment": "Divides this vector by a second input vector under the control of a mask. This is a lane-wise binary operation which applies the primitive division operation (/) to each pair of corresponding lane values. For any lane unset in the mask, the primitive operation is suppressed and this vector retains the original value stored in that lane. This method is also equivalent to the expression lanewise(DIV, v, m). As a full-service named operation, this method comes in masked and unmasked overloadings, and (in subclasses) also comes in scalar-broadcast overloadings (both masked and unmasked).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#div(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003ediv(Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/DoubleVector.html#div(double,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eDoubleVector.div(double,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#DIV\"\u003e\u003ccode\u003eVectorOperators.DIV\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/DoubleVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,double,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eDoubleVector.lanewise(VectorOperators.Binary,double,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "If the underlying scalar operator does not support division by zero, but is presented with a zero divisor, an \n\u003ccode\u003eArithmeticException\u003c/code\u003e will be thrown."
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArithmeticException.html\" title\u003d\"class in java.lang\"\u003eArithmeticException\u003c/a\u003e\u003c/code\u003e - if any lane selected by \n\u003ccode\u003em\u003c/code\u003e in \n\u003ccode\u003ev\u003c/code\u003e is zero and \n\u003ccode\u003eETYPE\u003c/code\u003e is not \n\u003ccode\u003efloat\u003c/code\u003e or \n\u003ccode\u003edouble\u003c/code\u003e."
        ],
        "return": [
          "the result of dividing this vector by the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "neg",
      "comment": "Negates this vector. This is a lane-wise unary operation which applies the primitive negation operation (-x) to each input lane. This method is also equivalent to the expression lanewise(NEG).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#NEG\"\u003e\u003ccode\u003eVectorOperators.NEG\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method has no masked variant, but the corresponding masked operation can be obtained from the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)\"\u003elanewise method\u003c/a\u003e."
        ],
        "return": [
          "the negation of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "abs",
      "comment": "Returns the absolute value of this vector. This is a lane-wise unary operation which applies the method Math.abs to each input lane. This method is also equivalent to the expression lanewise(ABS).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#ABS\"\u003e\u003ccode\u003eVectorOperators.ABS\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Unary,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method has no masked variant, but the corresponding masked operation can be obtained from the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)\"\u003elanewise method\u003c/a\u003e."
        ],
        "return": [
          "the absolute value of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "min",
      "comment": "Computes the smaller of this vector and a second input vector. This is a lane-wise binary operation which applies the operation Math.min() to each pair of corresponding lane values. This method is also equivalent to the expression lanewise(MIN, v).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#min(int)\"\u003e\u003ccode\u003eIntVector.min(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#MIN\"\u003e\u003ccode\u003eVectorOperators.MIN\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This is not a full-service named operation like \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#add(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eadd()\u003c/code\u003e\u003c/a\u003e. A masked version of this operation is not directly available but may be obtained via the masked version of \n\u003ccode\u003elanewise\u003c/code\u003e. Subclasses define an additional scalar-broadcast overloading of this method."
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the lanewise minimum of this vector and the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "max",
      "comment": "Computes the larger of this vector and a second input vector. This is a lane-wise binary operation which applies the operation Math.max() to each pair of corresponding lane values. This method is also equivalent to the expression lanewise(MAX, v). This is not a full-service named operation like add(). A masked version of this operation is not directly available but may be obtained via the masked version of lanewise. Subclasses define an additional scalar-broadcast overloading of this method.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#max(int)\"\u003e\u003ccode\u003eIntVector.max(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#MAX\"\u003e\u003ccode\u003eVectorOperators.MAX\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003elanewise(VectorOperators.Binary,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the lanewise maximum of this vector and the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Associative",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reduceLanesToLong",
      "comment": "Returns a value accumulated from all the lanes of this vector. This is an associative cross-lane reduction operation which applies the specified operation to all the lane elements. The return value will be equal to this expression: (long) ((EVector)this).reduceLanes(op), where EVector is the vector class specific to this vector\u0027s element type ETYPE. In the case of operations ADD and MUL, when ETYPE is float or double, the precise result, before casting, will reflect the choice of an arbitrary order of operations, which may even vary over time. For further details see the section Operations on floating point vectors.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003ereduceLanesToLong(VectorOperators.Associative,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)\"\u003e\u003ccode\u003eIntVector.reduceLanes(VectorOperators.Associative)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)\"\u003e\u003ccode\u003eFloatVector.reduceLanes(VectorOperators.Associative)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "If the \n\u003ccode\u003eETYPE\u003c/code\u003e is \n\u003ccode\u003efloat\u003c/code\u003e or \n\u003ccode\u003edouble\u003c/code\u003e, this operation can lose precision and/or range, as a normal part of casting the result down to \n\u003ccode\u003elong\u003c/code\u003e. Usually \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)\"\u003estrongly typed access\u003c/a\u003e is preferable, if you are working with a vector subtype that has a known element type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the accumulated result, cast to \n\u003ccode\u003elong\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Associative",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reduceLanesToLong",
      "comment": "Returns a value accumulated from selected lanes of this vector, controlled by a mask. This is an associative cross-lane reduction operation which applies the specified operation to the selected lane elements. The return value will be equal to this expression: (long) ((EVector)this).reduceLanes(op, m), where EVector is the vector class specific to this vector\u0027s element type ETYPE. If no elements are selected, an operation-specific identity value is returned. If the operation is ADD, XOR, or OR, then the identity value is zero. If the operation is MUL, then the identity value is one. If the operation is AND, then the identity value is minus one (all bits set). If the operation is MAX, then the identity value is the MIN_VALUE of the vector\u0027s native ETYPE. (In the case of floating point types, the value NEGATIVE_INFINITY is used, and will appear after casting as Long.MIN_VALUE. If the operation is MIN, then the identity value is the MAX_VALUE of the vector\u0027s native ETYPE. (In the case of floating point types, the value POSITIVE_INFINITY is used, and will appear after casting as Long.MAX_VALUE. In the case of operations ADD and MUL, when ETYPE is float or double, the precise result, before casting, will reflect the choice of an arbitrary order of operations, which may even vary over time. For further details see the section Operations on floating point vectors.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative)\"\u003e\u003ccode\u003ereduceLanesToLong(VectorOperators.Associative)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eIntVector.reduceLanes(VectorOperators.Associative,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eFloatVector.reduceLanes(VectorOperators.Associative,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "If the \n\u003ccode\u003eETYPE\u003c/code\u003e is \n\u003ccode\u003efloat\u003c/code\u003e or \n\u003ccode\u003edouble\u003c/code\u003e, this operation can lose precision and/or range, as a normal part of casting the result down to \n\u003ccode\u003elong\u003c/code\u003e. Usually \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)\"\u003estrongly typed access\u003c/a\u003e is preferable, if you are working with a vector subtype that has a known element type."
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to combine lane values",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this vector does not support the requested operation"
        ],
        "return": [
          "the reduced result accumulated from the selected lane values"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Test",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "test",
      "comment": "Tests the lanes of this vector according to the given operation. This is a lane-wise unary test operation which applies the given test operation to each lane value.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.Comparison.html\" title\u003d\"interface in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorOperators.Comparison\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#test(jdk.incubator.vector.VectorOperators.Test,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003etest(VectorOperators.Test, VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003ecompare(VectorOperators.Comparison, Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to test lane values"
        ],
        "return": [
          "the mask result of testing the lanes of this vector, according to the selected test operator"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Test",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "test",
      "comment": "Test selected lanes of this vector, according to the given operation. This is a masked lane-wise unary test operation which applies the given test operation to each lane value. The returned result is equal to the expression test(op).and(m).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#test(jdk.incubator.vector.VectorOperators.Test)\"\u003e\u003ccode\u003etest(VectorOperators.Test)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to test lane values",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "return": [
          "the mask result of testing the lanes of this vector, according to the selected test operator, and only in the lanes selected by the mask"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "eq",
      "comment": "Tests if this vector is equal to another input vector. This is a lane-wise binary test operation which applies the primitive equals operation (\u003d\u003d) to each pair of corresponding lane values. The result is the same as compare(VectorOperators.EQ, v).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003ecompare(VectorOperators.Comparison,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#EQ\"\u003e\u003ccode\u003eVectorOperators.EQ\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eequals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the mask result of testing lane-wise if this vector equal to the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lt",
      "comment": "Tests if this vector is less than another input vector. This is a lane-wise binary test operation which applies the primitive less-than operation (\u003c) to each lane. The result is the same as compare(VectorOperators.LT, v).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003ecompare(VectorOperators.Comparison,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#LT\"\u003e\u003ccode\u003eVectorOperators.LT\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the mask result of testing lane-wise if this vector is less than the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Comparison",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "compare",
      "comment": "Tests this vector by comparing it with another input vector, according to the given comparison operation. This is a lane-wise binary test operation which applies the given comparison operation to each pair of corresponding lane values.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#eq(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eeq(Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#lt(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elt(Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.Comparison.html\" title\u003d\"interface in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorOperators.Comparison\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003ecompare(VectorOperators.Comparison, Vector, VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#test(jdk.incubator.vector.VectorOperators.Test)\"\u003e\u003ccode\u003etest(VectorOperators.Test)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to compare lane values",
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector"
        ],
        "return": [
          "the mask result of testing lane-wise if this vector compares to the input, according to the selected comparison operator"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Comparison",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "compare",
      "comment": "Tests this vector by comparing it with another input vector, according to the given comparison operation, in lanes selected by a mask. This is a masked lane-wise binary test operation which applies the given comparison operation to each pair of corresponding lane values. The returned result is equal to the expression compare(op,v).and(m).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003ecompare(VectorOperators.Comparison, Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to compare lane values",
          "\u003ccode\u003ev\u003c/code\u003e - a second input vector",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "return": [
          "the mask result of testing lane-wise if this vector compares to the input, according to the selected comparison operator, and only in the lanes selected by the mask"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Comparison",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "e"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "compare",
      "comment": "Tests this vector by comparing it with an input scalar, according to the given comparison operation. This is a lane-wise binary test operation which applies the given comparison operation to each lane value, paired with the broadcast value. The result is the same as this.compare(op, this.broadcast(e)). That is, the scalar may be regarded as broadcast to a vector of the same species, and then compared against the original vector, using the selected comparison operation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#broadcast(long)\"\u003e\u003ccode\u003ebroadcast(long)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003ecompare(VectorOperators.Comparison,Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003elong\u003c/code\u003e value \n\u003ccode\u003ee\u003c/code\u003e must be accurately representable by the \n\u003ccode\u003eETYPE\u003c/code\u003e of this vector\u0027s species, so that \n\u003ccode\u003ee\u003d\u003d(long)(ETYPE)e\u003c/code\u003e. This rule is enforced by the implicit call to \n\u003ccode\u003ebroadcast()\u003c/code\u003e. \n\u003cp\u003e Subtypes improve on this method by sharpening the type of the scalar parameter \u003ccode\u003ee\u003c/code\u003e.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to compare lane values",
          "\u003ccode\u003ee\u003c/code\u003e - the input scalar"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given \n\u003ccode\u003elong\u003c/code\u003e value cannot be represented by the vector\u0027s \n\u003ccode\u003eETYPE\u003c/code\u003e"
        ],
        "return": [
          "the mask result of testing lane-wise if this vector compares to the input, according to the selected comparison operator"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Comparison",
            "type": "Class"
          },
          "field": {
            "name": "op"
          }
        },
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "e"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "compare",
      "comment": "Tests this vector by comparing it with an input scalar, according to the given comparison operation, in lanes selected by a mask. This is a masked lane-wise binary test operation which applies the given comparison operation to each lane value, paired with the broadcast value. The returned result is equal to the expression compare(op,e).and(m).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#broadcast(long)\"\u003e\u003ccode\u003ebroadcast(long)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003ecompare(VectorOperators.Comparison,Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003elong\u003c/code\u003e value \n\u003ccode\u003ee\u003c/code\u003e must be accurately representable by the \n\u003ccode\u003eETYPE\u003c/code\u003e of this vector\u0027s species, so that \n\u003ccode\u003ee\u003d\u003d(long)(ETYPE)e\u003c/code\u003e. This rule is enforced by the implicit call to \n\u003ccode\u003ebroadcast()\u003c/code\u003e. \n\u003cp\u003e Subtypes improve on this method by sharpening the type of the scalar parameter \u003ccode\u003ee\u003c/code\u003e.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - the operation used to compare lane values",
          "\u003ccode\u003ee\u003c/code\u003e - the input scalar",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given \n\u003ccode\u003elong\u003c/code\u003e value cannot be represented by the vector\u0027s \n\u003ccode\u003eETYPE\u003c/code\u003e"
        ],
        "return": [
          "the mask result of testing lane-wise if this vector compares to the input, according to the selected comparison operator, and only in the lanes selected by the mask"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "blend",
      "comment": "Replaces selected lanes of this vector with corresponding lanes from a second input vector under the control of a mask. This is a masked lane-wise binary operation which selects each lane value from one or the other input. For any lane set in the mask, the new lane value is taken from the second input vector, and replaces whatever value was in the that lane of this vector. For any lane unset in the mask, the replacement is suppressed and this vector retains the original value stored in that lane. The following pseudocode illustrates this behavior: \n Vector\u003cE\u003e a \u003d ...;\n VectorSpecies\u003cE\u003e species \u003d a.species();\n Vector\u003cE\u003e b \u003d ...;\n b.check(species);\n VectorMask\u003cE\u003e m \u003d ...;\n ETYPE[] ar \u003d a.toArray();\n for (int i \u003d 0; i \u003c ar.length; i++) {\n     if (m.laneIsSet(i)) {\n         ar[i] \u003d b.lane(i);\n     }\n }\n return EVector.fromArray(s, ar, 0);",
      "tagMap": {
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - the second input vector, containing replacement lane values",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection from the second input vector"
        ],
        "return": [
          "the result of blending the lane elements of this vector with those of the second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "e"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "blend",
      "comment": "Replaces selected lanes of this vector with a scalar value under the control of a mask. This is a masked lane-wise binary operation which selects each lane value from one or the other input. The returned result is equal to the expression blend(broadcast(e),m).",
      "tagMap": {
        "apiNote": [
          "The \n\u003ccode\u003elong\u003c/code\u003e value \n\u003ccode\u003ee\u003c/code\u003e must be accurately representable by the \n\u003ccode\u003eETYPE\u003c/code\u003e of this vector\u0027s species, so that \n\u003ccode\u003ee\u003d\u003d(long)(ETYPE)e\u003c/code\u003e. This rule is enforced by the implicit call to \n\u003ccode\u003ebroadcast()\u003c/code\u003e. \n\u003cp\u003e Subtypes improve on this method by sharpening the type of the scalar parameter \u003ccode\u003ee\u003c/code\u003e.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ee\u003c/code\u003e - the input scalar, containing the replacement lane value",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection of the scalar"
        ],
        "return": [
          "the result of blending the lane elements of this vector with the scalar value"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "scale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "addIndex",
      "comment": "Adds the lanes of this vector to their corresponding lane numbers, scaled by a given constant. This is a lane-wise unary operation which, for each lane N, computes the scaled index value N*scale and adds it to the value already in lane N of the current vector. The scale must not be so large, and the element size must not be so small, that that there would be an overflow when computing any of the N*scale or VLENGTH*scale, when the the result is represented using the vector lane type ETYPE. The following pseudocode illustrates this behavior: \n Vector\u003cE\u003e a \u003d ...;\n VectorSpecies\u003cE\u003e species \u003d a.species();\n ETYPE[] ar \u003d a.toArray();\n for (int i \u003d 0; i \u003c ar.length; i++) {\n     long d \u003d (long)i * scale;\n     if (d !\u003d (ETYPE) d)  throw ...;\n     ar[i] +\u003d (ETYPE) d;\n }\n long d \u003d (long)ar.length * scale;\n if (d !\u003d (ETYPE) d)  throw ...;\n return EVector.fromArray(s, ar, 0);",
      "tagMap": {
        "param": [
          "\u003ccode\u003escale\u003c/code\u003e - the number to multiply by each lane index \n\u003ccode\u003eN\u003c/code\u003e, typically \n\u003ccode\u003e1\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the values in the interval \n\u003ccode\u003e[0..VLENGTH*scale]\u003c/code\u003e are not representable by the \n\u003ccode\u003eETYPE\u003c/code\u003e"
        ],
        "return": [
          "the result of incrementing each lane element by its corresponding lane index \n\u003ccode\u003eN\u003c/code\u003e, scaled by \n\u003ccode\u003escale\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "origin"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v1"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "slice",
      "comment": "Slices a segment of adjacent lanes, starting at a given origin lane in the current vector, and continuing (as needed) into an immediately following vector. The block of VLENGTH lanes is extracted into its own vector and returned. This is a cross-lane operation that shifts lane elements to the front, from the current vector and the second vector. Both vectors can be viewed as a combined \"background\" of length 2*VLENGTH, from which a slice is extracted. The lane numbered N in the output vector is copied from lane origin+N of the input vector, if that lane exists, else from lane origin+N-VLENGTH of the second vector (which is guaranteed to exist). The origin value must be in the inclusive range 0..VLENGTH. As limiting cases, v.slice(0,w) and v.slice(VLENGTH,w) return v and w, respectively.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eslice(int,Vector,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int)\"\u003e\u003ccode\u003eslice(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#unslice(int,jdk.incubator.vector.Vector,int)\"\u003e\u003ccode\u003eunslice(int,Vector,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method may be regarded as the inverse of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#unslice(int,jdk.incubator.vector.Vector,int)\"\u003e\u003ccode\u003eunslice()\u003c/code\u003e\u003c/a\u003e, in that the sliced value could be unsliced back into its original position in the two input vectors, without disturbing unrelated elements, as in the following pseudocode: \n\u003cpre\u003e\u003ccode\u003e\n EVector slice \u003d v1.slice(origin, v2);\n EVector w1 \u003d slice.unslice(origin, v1, 0);\n EVector w2 \u003d slice.unslice(origin, v2, 1);\n assert v1.equals(w1);\n assert v2.equals(w2);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e This method also supports a variety of cross-lane shifts and rotates as follows: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eTo shift lanes forward to the front of the vector, supply a zero vector for the second operand and specify the shift count as the origin. For example: \u003ccode\u003ev.slice(shift, v.broadcast(0))\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eTo shift lanes backward to the back of the vector, supply a zero vector for the \u003cem\u003efirst\u003c/em\u003e operand, and specify the negative shift count as the origin (modulo \u003ccode\u003eVLENGTH\u003c/code\u003e. For example: \u003ccode\u003ev.broadcast(0).slice(v.length()-shift, v)\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eTo rotate lanes forward toward the front end of the vector, cycling the earliest lanes around to the back, supply the same vector for both operands and specify the rotate count as the origin. For example: \u003ccode\u003ev.slice(rotate, v)\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eTo rotate lanes backward toward the back end of the vector, cycling the latest lanes around to the front, supply the same vector for both operands and specify the negative of the rotate count (modulo \u003ccode\u003eVLENGTH\u003c/code\u003e) as the origin. For example: \u003ccode\u003ev.slice(v.length() - rotate, v)\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003e Since \u003ccode\u003eorigin\u003c/code\u003e values less then zero or more than \u003ccode\u003eVLENGTH\u003c/code\u003e will be rejected, if you need to rotate by an unpredictable multiple of \u003ccode\u003eVLENGTH\u003c/code\u003e, be sure to reduce the origin value into the required range. The \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorSpecies.html#loopBound(int)\"\u003e\u003ccode\u003eloopBound()\u003c/code\u003e\u003c/a\u003e method can help with this. For example: \u003ccode\u003ev.slice(rotate - v.species().loopBound(rotate), v)\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eorigin\u003c/code\u003e - the first input lane to transfer into the slice",
          "\u003ccode\u003ev1\u003c/code\u003e - a second vector logically concatenated with the first, before the slice is taken (if omitted it defaults to zero)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eorigin\u003c/code\u003e is negative or greater than \n\u003ccode\u003eVLENGTH\u003c/code\u003e"
        ],
        "return": [
          "a contiguous slice of \n\u003ccode\u003eVLENGTH\u003c/code\u003e lanes, taken from this vector starting at the indicated origin, and continuing (as needed) into the second vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "origin"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v1"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "slice",
      "comment": "Slices a segment of adjacent lanes under the control of a mask, starting at a given origin lane in the current vector, and continuing (as needed) into an immediately following vector. The block of VLENGTH lanes is extracted into its own vector and returned. The resulting vector will be zero in all lanes unset in the given mask. Lanes set in the mask will contain data copied from selected lanes of this or v1. This is a cross-lane operation that shifts lane elements to the front, from the current vector and the second vector. Both vectors can be viewed as a combined \"background\" of length 2*VLENGTH, from which a slice is extracted. The returned result is equal to the expression broadcast(0).blend(slice(origin,v1),m).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eslice(int,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#unslice(int,jdk.incubator.vector.Vector,int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eunslice(int,Vector,int,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method may be regarded as the inverse of \n\u003ccode\u003e#unslice(int,Vector,int,VectorMask) unslice()\u003c/code\u003e, in that the sliced value could be unsliced back into its original position in the two input vectors, without disturbing unrelated elements, as in the following pseudocode: \n\u003cpre\u003e\u003ccode\u003e\n EVector slice \u003d v1.slice(origin, v2, m);\n EVector w1 \u003d slice.unslice(origin, v1, 0, m);\n EVector w2 \u003d slice.unslice(origin, v2, 1, m);\n assert v1.equals(w1);\n assert v2.equals(w2);\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003eorigin\u003c/code\u003e - the first input lane to transfer into the slice",
          "\u003ccode\u003ev1\u003c/code\u003e - a second vector logically concatenated with the first, before the slice is taken (if omitted it defaults to zero)",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection into the resulting vector"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eorigin\u003c/code\u003e is negative or greater than \n\u003ccode\u003eVLENGTH\u003c/code\u003e"
        ],
        "return": [
          "a contiguous slice of \n\u003ccode\u003eVLENGTH\u003c/code\u003e lanes, taken from this vector starting at the indicated origin, and continuing (as needed) into the second vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "origin"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "slice",
      "comment": "Slices a segment of adjacent lanes, starting at a given origin lane in the current vector. A block of VLENGTH lanes, possibly padded with zero lanes, is extracted into its own vector and returned. This is a convenience method which slices from a single vector against an extended background of zero lanes. It is equivalent to slice (origin, broadcast(0)). It may also be viewed simply as a cross-lane shift from later to earlier lanes, with zeroes filling in the vacated lanes at the end of the vector. In this view, the shift count is origin.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eslice(int,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#unslice(int,jdk.incubator.vector.Vector,int)\"\u003e\u003ccode\u003eunslice(int,Vector,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eorigin\u003c/code\u003e - the first input lane to transfer into the slice"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eorigin\u003c/code\u003e is negative or greater than \n\u003ccode\u003eVLENGTH\u003c/code\u003e"
        ],
        "return": [
          "the last \n\u003ccode\u003eVLENGTH-origin\u003c/code\u003e input lanes, placed starting in the first lane of the ouput, padded at the end with zeroes"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "origin"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "w"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "part"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "unslice",
      "comment": "Reverses a slice(), inserting the current vector as a slice within another \"background\" input vector, which is regarded as one or the other input to a hypothetical subsequent slice() operation. This is a cross-lane operation that permutes the lane elements of the current vector toward the back and inserts them into a logical pair of background vectors. Only one of the pair will be returned, however. The background is formed by duplicating the second input vector. (However, the output will never contain two duplicates from the same input lane.) The lane numbered N in the input vector is copied into lane origin+N of the first background vector, if that lane exists, else into lane origin+N-VLENGTH of the second background vector (which is guaranteed to exist). The first or second background vector, updated with the inserted slice, is returned. The part number of zero or one selects the first or second updated background vector. The origin value must be in the inclusive range 0..VLENGTH. As limiting cases, v.unslice(0,w,0) and v.unslice(VLENGTH,w,1) both return v, while v.unslice(0,w,1) and v.unslice(VLENGTH,w,0) both return w.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eslice(int,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#unslice(int,jdk.incubator.vector.Vector,int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eunslice(int,Vector,int,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method supports a variety of cross-lane insertion operations as follows: \n\u003cul\u003e \n \u003cli\u003eTo insert near the end of a background vector \u003ccode\u003ew\u003c/code\u003e at some offset, specify the offset as the origin and select part zero. For example: \u003ccode\u003ev.unslice(offset, w, 0)\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eTo insert near the end of a background vector \u003ccode\u003ew\u003c/code\u003e, but capturing the overflow into the next vector \u003ccode\u003ex\u003c/code\u003e, specify the offset as the origin and select part one. For example: \u003ccode\u003ev.unslice(offset, x, 1)\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eTo insert the last \u003ccode\u003eN\u003c/code\u003e items near the beginning of a background vector \u003ccode\u003ew\u003c/code\u003e, supply a \u003ccode\u003eVLENGTH-N\u003c/code\u003e as the origin and select part one. For example: \u003ccode\u003ev.unslice(v.length()-N, w)\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
        ],
        "param": [
          "\u003ccode\u003eorigin\u003c/code\u003e - the first output lane to receive the slice",
          "\u003ccode\u003ew\u003c/code\u003e - the background vector that (as two copies) will receive the inserted slice",
          "\u003ccode\u003epart\u003c/code\u003e - the part number of the result (either zero or one)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eorigin\u003c/code\u003e is negative or greater than \n\u003ccode\u003eVLENGTH\u003c/code\u003e, or if \n\u003ccode\u003epart\u003c/code\u003e is not zero or one"
        ],
        "return": [
          "either the first or second part of a pair of background vectors \n\u003ccode\u003ew\u003c/code\u003e, updated by inserting this vector at the indicated origin"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "origin"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "w"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "part"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "unslice",
      "comment": "Reverses a slice(), inserting (under the control of a mask) the current vector as a slice within another \"background\" input vector, which is regarded as one or the other input to a hypothetical subsequent slice() operation. This is a cross-lane operation that permutes the lane elements of the current vector forward and inserts its lanes (when selected by the mask) into a logical pair of background vectors. As with the unmasked version of this method, only one of the pair will be returned, as selected by the part number. For each lane N selected by the mask, the lane value is copied into lane origin+N of the first background vector, if that lane exists, else into lane origin+N-VLENGTH of the second background vector (which is guaranteed to exist). Background lanes retain their original values if the corresponding input lanes N are unset in the mask. The first or second background vector, updated with set lanes of the inserted slice, is returned. The part number of zero or one selects the first or second updated background vector.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#unslice(int,jdk.incubator.vector.Vector,int)\"\u003e\u003ccode\u003eunslice(int,Vector,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eslice(int,Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eorigin\u003c/code\u003e - the first output lane to receive the slice",
          "\u003ccode\u003ew\u003c/code\u003e - the background vector that (as two copies) will receive the inserted slice, if they are set in \n\u003ccode\u003em\u003c/code\u003e",
          "\u003ccode\u003epart\u003c/code\u003e - the part number of the result (either zero or one)",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection from the current vector"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eorigin\u003c/code\u003e is negative or greater than \n\u003ccode\u003eVLENGTH\u003c/code\u003e, or if \n\u003ccode\u003epart\u003c/code\u003e is not zero or one"
        ],
        "return": [
          "either the first or second part of a pair of background vectors \n\u003ccode\u003ew\u003c/code\u003e, updated by inserting selected lanes of this vector at the indicated origin"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "origin"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "unslice",
      "comment": "Reverses a slice(), inserting the current vector as a slice within a \"background\" input of zero lane values. Compared to other unslice() methods, this method only returns the first of the pair of background vectors. This is a convenience method which returns the result of unslice (origin, broadcast(0), 0). It may also be viewed simply as a cross-lane shift from earlier to later lanes, with zeroes filling in the vacated lanes at the beginning of the vector. In this view, the shift count is origin.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#unslice(int,jdk.incubator.vector.Vector,int)\"\u003e\u003ccode\u003eunslice(int,Vector,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int)\"\u003e\u003ccode\u003eslice(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eorigin\u003c/code\u003e - the first output lane to receive the slice"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eorigin\u003c/code\u003e is negative or greater than \n\u003ccode\u003eVLENGTH\u003c/code\u003e"
        ],
        "return": [
          "the first \n\u003ccode\u003eVLENGTH-origin\u003c/code\u003e input lanes, placed starting at the given origin, padded at the beginning with zeroes"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorShuffle",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "s"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "rearrange",
      "comment": "Rearranges the lane elements of this vector, selecting lanes under the control of a specific shuffle. This is a cross-lane operation that rearranges the lane elements of this vector. For each lane N of the shuffle, and for each lane source index I\u003ds.laneSource(N) in the shuffle, the output lane N obtains the value from the input vector at lane I.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003erearrange(VectorShuffle,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003erearrange(VectorShuffle,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorShuffle.html#laneIsValid()\"\u003e\u003ccode\u003eVectorShuffle.laneIsValid()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - the shuffle controlling lane index selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if there are any exceptional source indexes in the shuffle"
        ],
        "return": [
          "the rearrangement of the lane elements of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorShuffle",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "s"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "rearrange",
      "comment": "Rearranges the lane elements of this vector, selecting lanes under the control of a specific shuffle and a mask. This is a cross-lane operation that rearranges the lane elements of this vector. For each lane N of the shuffle, and for each lane source index I\u003ds.laneSource(N) in the shuffle, the output lane N obtains the value from the input vector at lane I if the mask is set. Otherwise the output lane N is set to zero. This method returns the value of this pseudocode: \n Vector\u003cE\u003e r \u003d this.rearrange(s.wrapIndexes());\n VectorMask\u003cE\u003e valid \u003d s.laneIsValid();\n if (m.andNot(valid).anyTrue()) throw ...;\n return broadcast(0).blend(r, m);",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle)\"\u003e\u003ccode\u003erearrange(VectorShuffle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003erearrange(VectorShuffle,Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorShuffle.html#laneIsValid()\"\u003e\u003ccode\u003eVectorShuffle.laneIsValid()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - the shuffle controlling lane index selection",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling application of the shuffle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if there are any exceptional source indexes in the shuffle where the mask is set"
        ],
        "return": [
          "the rearrangement of the lane elements of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorShuffle",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "s"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "rearrange",
      "comment": "Rearranges the lane elements of two vectors, selecting lanes under the control of a specific shuffle, using both normal and exceptional indexes in the shuffle to steer data. This is a cross-lane operation that rearranges the lane elements of the two input vectors (the current vector and a second vector v). For each lane N of the shuffle, and for each lane source index I\u003ds.laneSource(N) in the shuffle, the output lane N obtains the value from the first vector at lane I if I\u003e\u003d0. Otherwise, the exceptional index I is wrapped by adding VLENGTH to it and used to index the second vector, at index I+VLENGTH. This method returns the value of this pseudocode: \n Vector\u003cE\u003e r1 \u003d this.rearrange(s.wrapIndexes());\n // or else: r1 \u003d this.rearrange(s, s.laneIsValid());\n Vector\u003cE\u003e r2 \u003d v.rearrange(s.wrapIndexes());\n return r2.blend(r1,s.laneIsValid());",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle)\"\u003e\u003ccode\u003erearrange(VectorShuffle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003erearrange(VectorShuffle,VectorMask)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorShuffle.html#laneIsValid()\"\u003e\u003ccode\u003eVectorShuffle.laneIsValid()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#slice(int,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eslice(int,Vector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - the shuffle controlling lane selection from both input vectors",
          "\u003ccode\u003ev\u003c/code\u003e - the second input vector"
        ],
        "return": [
          "the rearrangement of lane elements of this vector and a second input vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "selectFrom",
      "comment": "Using index values stored in the lanes of this vector, assemble values stored in second vector v. The second vector thus serves as a table, whose elements are selected by indexes in the current vector. This is a cross-lane operation that rearranges the lane elements of the argument vector, under the control of this vector. For each lane N of this vector, and for each lane value I\u003dthis.lane(N) in this vector, the output lane N obtains the value from the argument vector at lane I. In this way, the result contains only values stored in the argument vector v, but presented in an order which depends on the index values in this. The result is the same as the expression v.rearrange(this.toShuffle()).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle)\"\u003e\u003ccode\u003erearrange(VectorShuffle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - the vector supplying the result values"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if any invalid source indexes are found in \n\u003ccode\u003ethis\u003c/code\u003e"
        ],
        "return": [
          "the rearrangement of the lane elements of \n\u003ccode\u003ev\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.Vector",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "v"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "selectFrom",
      "comment": "Using index values stored in the lanes of this vector, assemble values stored in second vector, under the control of a mask. Using index values stored in the lanes of this vector, assemble values stored in second vector v. The second vector thus serves as a table, whose elements are selected by indexes in the current vector. Lanes that are unset in the mask receive a zero rather than a value from the table. This is a cross-lane operation that rearranges the lane elements of the argument vector, under the control of this vector and the mask. The result is the same as the expression v.rearrange(this.toShuffle(), m).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#selectFrom(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eselectFrom(Vector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003erearrange(VectorShuffle,VectorMask)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ev\u003c/code\u003e - the vector supplying the result values",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling selection from \n\u003ccode\u003ev\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if any invalid source indexes are found in \n\u003ccode\u003ethis\u003c/code\u003e, in a lane which is set in the mask"
        ],
        "return": [
          "the rearrangement of the lane elements of \n\u003ccode\u003ev\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "e"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "broadcast",
      "comment": "Returns a vector of the same species as this one where all lane elements are set to the primitive value e. The contents of the current vector are discarded; only the species is relevant to this operation. This method returns the value of this expression: EVector.broadcast(this.species(), (ETYPE)e), where EVector is the vector class specific to this vector\u0027s element type ETYPE. The long value e must be accurately representable by the ETYPE of this vector\u0027s species, so that e\u003d\u003d(long)(ETYPE)e. If this rule is violated the problem is not detected statically, but an IllegalArgumentException is thrown at run-time. Thus, this method somewhat weakens the static type checking of immediate constants and other scalars, but it makes up for this by improving the expressiveness of the generic API. Note that an e value in the range [-128..127] is always acceptable, since every ETYPE will accept every byte value.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorSpecies.html#broadcast(long)\"\u003e\u003ccode\u003eVectorSpecies.broadcast(long)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#broadcast(long)\"\u003e\u003ccode\u003eIntVector.broadcast(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#broadcast(float)\"\u003e\u003ccode\u003eFloatVector.broadcast(float)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the method return type and and the type of the scalar parameter \n\u003ccode\u003ee\u003c/code\u003e."
        ],
        "param": [
          "\u003ccode\u003ee\u003c/code\u003e - the value to broadcast"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given \n\u003ccode\u003elong\u003c/code\u003e value cannot be represented by the vector\u0027s \n\u003ccode\u003eETYPE\u003c/code\u003e"
        ],
        "return": [
          "a vector where all lane elements are set to the primitive value \n\u003ccode\u003ee\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorMask",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "bit"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "maskAll",
      "comment": "Returns a mask of same species as this vector, where each lane is set or unset according to given single boolean, which is broadcast to all lanes. This method returns the value of this expression: species().maskAll(bit).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorSpecies.html#maskAll(boolean)\"\u003e\u003ccode\u003eVectorSpecies.maskAll(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ebit\u003c/code\u003e - the given mask bit to be replicated"
        ],
        "return": [
          "a mask where each lane is set or unset according to the given bit"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.VectorShuffle",
        "parameters": [
          {
            "owner": "jdk.incubator.vector.Vector",
            "name": "E",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "toShuffle",
      "comment": "Converts this vector into a shuffle, converting the lane values to int and regarding them as source indexes. This method behaves as if it returns the result of creating a shuffle given an array of the vector elements, as follows: \n long[] a \u003d this.toLongArray();\n int[] sa \u003d new int[a.length];\n for (int i \u003d 0; i \u003c a.length; i++) {\n     sa[i] \u003d (int) a[i];\n }\n return VectorShuffle.fromValues(this.species(), sa);",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorShuffle.html#fromValues(jdk.incubator.vector.VectorSpecies,int...)\"\u003e\u003ccode\u003eVectorShuffle.fromValues(VectorSpecies,int...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a shuffle representation of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "name": "F",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorSpecies",
            "parameters": [
              {
                "name": "F",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "species"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "part"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "F",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reinterpretShape",
      "comment": "Transforms this vector to a vector of the given species of element type F, reinterpreting the bytes of this vector without performing any value conversions. Depending on the selected species, this operation may either expand or contract its logical result, in which case a non-zero part number can further control the selection and steering of the logical result into the physical output vector. The underlying bits of this vector are copied to the resulting vector without modification, but those bits, before copying, may be truncated if the this vector\u0027s bit-size is greater than desired vector\u0027s bit size, or filled with zero bits if this vector\u0027s bit-size is less than desired vector\u0027s bit-size. If the old and new species have different shape, this is a shape-changing operation, and may have special implementation costs. The method behaves as if this vector is stored into a byte buffer or array using little-endian byte ordering and then the desired vector is loaded from the same byte buffer or array using the same ordering. The following pseudocode illustrates the behavior: \n int domSize \u003d this.byteSize();\n int ranSize \u003d species.vectorByteSize();\n int M \u003d (domSize \u003e ranSize ? domSize / ranSize : ranSize / domSize);\n assert Math.abs(part) \u003c M;\n assert (part \u003d\u003d 0) || (part \u003e 0) \u003d\u003d (domSize \u003e ranSize);\n byte[] ra \u003d new byte[Math.max(domSize, ranSize)];\n if (domSize \u003e ranSize) {  // expansion\n     this.intoByteArray(ra, 0, ByteOrder.native());\n     int origin \u003d part * ranSize;\n     return species.fromByteArray(ra, origin, ByteOrder.native());\n } else {  // contraction or size-invariant\n     int origin \u003d (-part) * domSize;\n     this.intoByteArray(ra, origin, ByteOrder.native());\n     return species.fromByteArray(ra, 0, ByteOrder.native());\n }",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eF\u003c/code\u003e - the boxed element type of the species"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003econvertShape(VectorOperators.Conversion,VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#castShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003ecastShape(VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorSpecies.html#partLimit(jdk.incubator.vector.VectorSpecies,boolean)\"\u003e\u003ccode\u003eVectorSpecies.partLimit(VectorSpecies,boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Although this method is defined as if the vectors in question were loaded or stored into memory, memory semantics has little to do or nothing with the actual implementation. The appeal to little-endian ordering is simply a shorthand for what could otherwise be a large number of detailed rules concerning the mapping between lane-structured vectors and byte-structured vectors."
        ],
        "param": [
          "\u003ccode\u003especies\u003c/code\u003e - the desired vector species",
          "\u003ccode\u003epart\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#expansion\"\u003epart number\u003c/a\u003e of the result, or zero if neither expanding nor contracting"
        ],
        "return": [
          "a vector transformed, by shape and element type, from this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.ByteVector",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reinterpretAsBytes",
      "comment": "Views this vector as a vector of the same shape and contents but a lane type of byte, where the bytes are extracted from the lanes according to little-endian order. It is a convenience method for the expression reinterpretShape(species().withLanes(byte.class)). It may be considered an inverse to the various methods which consolidate bytes into larger lanes within the same vector, such as reinterpretAsInts().",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003ereinterpretShape(VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#intoByteArray(byte%5B%5D,int,java.nio.ByteOrder)\"\u003e\u003ccode\u003eIntVector.intoByteArray(byte[], int, ByteOrder)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#intoByteArray(byte%5B%5D,int,java.nio.ByteOrder)\"\u003e\u003ccode\u003eFloatVector.intoByteArray(byte[], int, ByteOrder)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorSpecies.html#withLanes(java.lang.Class)\"\u003e\u003ccode\u003eVectorSpecies.withLanes(Class)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a \n\u003ccode\u003eByteVector\u003c/code\u003e with the same shape and information content"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.ShortVector",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reinterpretAsShorts",
      "comment": "Reinterprets this vector as a vector of the same shape and contents but a lane type of short, where the lanes are assembled from successive bytes according to little-endian order. It is a convenience method for the expression reinterpretShape(species().withLanes(short.class)). It may be considered an inverse to reinterpretAsBytes().",
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eShortVector\u003c/code\u003e with the same shape and information content"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.IntVector",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reinterpretAsInts",
      "comment": "Reinterprets this vector as a vector of the same shape and contents but a lane type of int, where the lanes are assembled from successive bytes according to little-endian order. It is a convenience method for the expression reinterpretShape(species().withLanes(int.class)). It may be considered an inverse to reinterpretAsBytes().",
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eIntVector\u003c/code\u003e with the same shape and information content"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.LongVector",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reinterpretAsLongs",
      "comment": "Reinterprets this vector as a vector of the same shape and contents but a lane type of long, where the lanes are assembled from successive bytes according to little-endian order. It is a convenience method for the expression reinterpretShape(species().withLanes(long.class)). It may be considered an inverse to reinterpretAsBytes().",
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eLongVector\u003c/code\u003e with the same shape and information content"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.FloatVector",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reinterpretAsFloats",
      "comment": "Reinterprets this vector as a vector of the same shape and contents but a lane type of float, where the lanes are assembled from successive bytes according to little-endian order. It is a convenience method for the expression reinterpretShape(species().withLanes(float.class)). It may be considered an inverse to reinterpretAsBytes().",
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eFloatVector\u003c/code\u003e with the same shape and information content"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.DoubleVector",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "reinterpretAsDoubles",
      "comment": "Reinterprets this vector as a vector of the same shape and contents but a lane type of double, where the lanes are assembled from successive bytes according to little-endian order. It is a convenience method for the expression reinterpretShape(species().withLanes(double.class)). It may be considered an inverse to reinterpretAsBytes().",
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eDoubleVector\u003c/code\u003e with the same shape and information content"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "viewAsIntegralLanes",
      "comment": "Views this vector as a vector of the same shape, length, and contents, but a lane type that is not a floating-point type. This is a lane-wise reinterpretation cast on the lane values. As such, this method does not change VSHAPE or VLENGTH, and there is no change to the bitwise contents of the vector. If the vector\u0027s ETYPE is already an integral type, the same vector is returned unchanged. This method returns the value of this expression: convert(conv,0), where conv is VectorOperators.Conversion.ofReinterpret(E.class,F.class), and F is the non-floating-point type of the same size as E.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.Conversion.html#ofReinterpret(java.lang.Class,java.lang.Class)\"\u003e\u003ccode\u003eVectorOperators.Conversion.ofReinterpret(Class,Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#convert(jdk.incubator.vector.VectorOperators.Conversion,int)\"\u003e\u003ccode\u003econvert(VectorOperators.Conversion,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the return type."
        ],
        "return": [
          "the original vector, reinterpreted as non-floating point"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "viewAsFloatingLanes",
      "comment": "Views this vector as a vector of the same shape, length, and contents, but a lane type that is a floating-point type. This is a lane-wise reinterpretation cast on the lane values. As such, there this method does not change VSHAPE or VLENGTH, and there is no change to the bitwise contents of the vector. If the vector\u0027s ETYPE is already a float-point type, the same vector is returned unchanged. If the vector\u0027s element size does not match any floating point type size, an IllegalArgumentException is thrown. This method returns the value of this expression: convert(conv,0), where conv is VectorOperators.Conversion.ofReinterpret(E.class,F.class), and F is the floating-point type of the same size as E, if any.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.Conversion.html#ofReinterpret(java.lang.Class,java.lang.Class)\"\u003e\u003ccode\u003eVectorOperators.Conversion.ofReinterpret(Class,Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#convert(jdk.incubator.vector.VectorOperators.Conversion,int)\"\u003e\u003ccode\u003econvert(VectorOperators.Conversion,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Subtypes improve on this method by sharpening the return type."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if there is no floating point type the same size as the lanes of this vector"
        ],
        "return": [
          "the original vector, reinterpreted as floating point"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "name": "F",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Conversion",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              },
              {
                "name": "F",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "conv"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "part"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "F",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "convert",
      "comment": "Convert this vector to a vector of the same shape and a new element type, converting lane values from the current ETYPE to a new lane type (called FTYPE here) according to the indicated conversion. This is a lane-wise shape-invariant operation which copies ETYPE values from the input vector to corresponding FTYPE values in the result. Depending on the selected conversion, this operation may either expand or contract its logical result, in which case a non-zero part number can further control the selection and steering of the logical result into the physical output vector. Each specific conversion is described by a conversion constant in the class VectorOperators. Each conversion operator has a specified domain type and range type. The domain type must exactly match the lane type of the input vector, while the range type determines the lane type of the output vectors. A conversion operator may be classified as (respectively) in-place, expanding, or contracting, depending on whether the bit-size of its domain type is (respectively) equal, less than, or greater than the bit-size of its range type. Independently, conversion operations can also be classified as reinterpreting or value-transforming, depending on whether the conversion copies representation bits unchanged, or changes the representation bits in order to retain (part or all of) the logical value of the input value. If a reinterpreting conversion contracts, it will truncate the upper bits of the input. If it expands, it will pad upper bits of the output with zero bits, when there are no corresponding input bits. An expanding conversion such as S2I (short value to int) takes a scalar value and represents it in a larger format (always with some information redundancy). A contracting conversion such as D2F (double value to float) takes a scalar value and represents it in a smaller format (always with some information loss). Some in-place conversions may also include information loss, such as L2D (long value to double) or F2I (float value to int). Reinterpreting in-place conversions are not lossy, unless the bitwise value is somehow not legal in the output type. Converting the bit-pattern of a NaN may discard bits from the NaN\u0027s significand. This classification is important, because, unless otherwise documented, conversion operations never change vector shape, regardless of how they may change lane sizes. Therefore an expanding conversion cannot store all of its results in its output vector, because the output vector has fewer lanes of larger size, in order to have the same overall bit-size as its input. Likewise, a contracting conversion must store its relatively small results into a subset of the lanes of the output vector, defaulting the unused lanes to zero. As an example, a conversion from byte to long (M\u003d8) will discard 87.5% of the input values in order to convert the remaining 12.5% into the roomy long lanes of the output vector. The inverse conversion will convert back all of the large results, but will waste 87.5% of the lanes in the output vector. In-place conversions (M\u003d1) deliver all of their results in one output vector, without wasting lanes. To manage the details of these expansions and contractions, a non-zero part parameter selects partial results from expansions, or steers the results of contractions into corresponding locations, as follows: expanding by M: part must be in the range [0..M-1], and selects the block of VLENGTH/M input lanes starting at the origin lane at part*VLENGTH/M. The VLENGTH/M output lanes represent a partial slice of the whole logical result of the conversion, filling the entire physical output vector. contracting by M: part must be in the range [-M+1..0], and steers all VLENGTH input lanes into the output located at the origin lane -part*VLENGTH. There is a total of VLENGTH*M output lanes, and those not holding converted input values are filled with zeroes. A group of such output vectors, with logical result parts steered to disjoint blocks, can be reassembled using the bitwise or or (for floating point) the FIRST_NONZERO operator. in-place (M\u003d1): part must be zero. Both vectors have the same VLENGTH. The result is always positioned at the origin lane of zero. This method is a restricted version of the more general but less frequently used shape-changing method convertShape(). The result of this method is the same as the expression this.convertShape(conv, rsp, this.broadcast(part)), where the output species is rsp\u003dthis.species().withLanes(FTYPE.class).",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eF\u003c/code\u003e - the boxed element type of the species"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#I2L\"\u003e\u003ccode\u003eVectorOperators.I2L\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.Conversion.html#ofCast(java.lang.Class,java.lang.Class)\"\u003e\u003ccode\u003eVectorOperators.Conversion.ofCast(Class,Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorSpecies.html#partLimit(jdk.incubator.vector.VectorSpecies,boolean)\"\u003e\u003ccode\u003eVectorSpecies.partLimit(VectorSpecies,boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#viewAsFloatingLanes()\"\u003e\u003ccode\u003eviewAsFloatingLanes()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#viewAsIntegralLanes()\"\u003e\u003ccode\u003eviewAsIntegralLanes()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003econvertShape(VectorOperators.Conversion,VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003ereinterpretShape(VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003econv\u003c/code\u003e - the desired scalar conversion to apply lane-wise",
          "\u003ccode\u003epart\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#expansion\"\u003epart number\u003c/a\u003e of the result, or zero if neither expanding nor contracting"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - unless \n\u003ccode\u003epart\u003c/code\u003e is zero, or else the expansion ratio is \n\u003ccode\u003eM\u003c/code\u003e and \n\u003ccode\u003epart\u003c/code\u003e is positive and less than \n\u003ccode\u003eM\u003c/code\u003e, or else the contraction ratio is \n\u003ccode\u003eM\u003c/code\u003e and \n\u003ccode\u003epart\u003c/code\u003e is negative and greater \n\u003ccode\u003e-M\u003c/code\u003e"
        ],
        "return": [
          "a vector converted by shape and element type from this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "name": "F",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorOperators$Conversion",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              },
              {
                "name": "F",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "conv"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorSpecies",
            "parameters": [
              {
                "name": "F",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "rsp"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "part"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "F",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "convertShape",
      "comment": "Converts this vector to a vector of the given species, shape and element type, converting lane values from the current ETYPE to a new lane type (called FTYPE here) according to the indicated conversion. This is a lane-wise operation which copies ETYPE values from the input vector to corresponding FTYPE values in the result. If the old and new species have the same shape, the behavior is exactly the same as the simpler, shape-invariant method convert(). In such cases, the simpler method convert() should be used, to make code easier to reason about. Otherwise, this is a shape-changing operation, and may have special implementation costs. As a combined effect of shape changes and lane size changes, the input and output species may have different lane counts, causing expansion or contraction. In this case a non-zero part parameter selects partial results from an expanded logical result, or steers the results of a contracted logical result into a physical output vector of the required output species. The following pseudocode illustrates the behavior of this method for in-place, expanding, and contracting conversions. (This pseudocode also applies to the shape-invariant method, but with shape restrictions on the output species.) Note that only one of the three code paths is relevant to any particular combination of conversion operator and shapes. \n FTYPE scalar_conversion_op(ETYPE s);\n EVector a \u003d ...;\n VectorSpecies\u003cF\u003e rsp \u003d ...;\n int part \u003d ...;\n VectorSpecies\u003cE\u003e dsp \u003d a.species();\n int domlen \u003d dsp.length();\n int ranlen \u003d rsp.length();\n FTYPE[] logical \u003d new FTYPE[domlen];\n for (int i \u003d 0; i \u003c domlen; i++) {\n   logical[i] \u003d scalar_conversion_op(a.lane(i));\n }\n FTYPE[] physical;\n if (domlen \u003d\u003d ranlen) { // in-place\n     assert part \u003d\u003d 0; //else AIOOBE\n     physical \u003d logical;\n } else if (domlen \u003e ranlen) { // expanding\n     int M \u003d domlen / ranlen;\n     assert 0 \u003c\u003d part \u0026\u0026 part \u003c M; //else AIOOBE\n     int origin \u003d part * ranlen;\n     physical \u003d Arrays.copyOfRange(logical, origin, origin + ranlen);\n } else { // (domlen \u003c ranlen) // contracting\n     int M \u003d ranlen / domlen;\n     assert 0 \u003e\u003d part \u0026\u0026 part \u003e -M; //else AIOOBE\n     int origin \u003d -part * domlen;\n     System.arraycopy(logical, 0, physical, origin, domlen);\n }\n return FVector.fromArray(ran, physical, 0);",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eF\u003c/code\u003e - the boxed element type of the output species"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#convert(jdk.incubator.vector.VectorOperators.Conversion,int)\"\u003e\u003ccode\u003econvert(VectorOperators.Conversion,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#castShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003ecastShape(VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003ereinterpretShape(VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003econv\u003c/code\u003e - the desired scalar conversion to apply lane-wise",
          "\u003ccode\u003ersp\u003c/code\u003e - the desired output species",
          "\u003ccode\u003epart\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#expansion\"\u003epart number\u003c/a\u003e of the result, or zero if neither expanding nor contracting"
        ],
        "return": [
          "a vector converted by element type from this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "name": "F",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorSpecies",
            "parameters": [
              {
                "name": "F",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "rsp"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "part"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "F",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "castShape",
      "comment": "Convenience method for converting a vector from one lane type to another, reshaping as needed when lane sizes change. This method returns the value of this expression: convertShape(conv,rsp,part), where conv is VectorOperators.Conversion.ofCast(E.class,F.class). If the old and new species have different shape, this is a shape-changing operation, and may have special implementation costs.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eF\u003c/code\u003e - the boxed element type of the output species"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.Conversion.html#ofCast(java.lang.Class,java.lang.Class)\"\u003e\u003ccode\u003eVectorOperators.Conversion.ofCast(Class,Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003econvertShape(VectorOperators.Conversion,VectorSpecies,int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ersp\u003c/code\u003e - the desired output species",
          "\u003ccode\u003epart\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#expansion\"\u003epart number\u003c/a\u003e of the result, or zero if neither expanding nor contracting"
        ],
        "return": [
          "a vector converted by element type from this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "name": "F",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "name": "F",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "elementType"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "F",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "check",
      "comment": "Checks that this vector has the given element type, and returns this vector unchanged. The effect is similar to this pseudocode: elementType \u003d\u003d species().elementType() ? this : throw new ClassCastException().",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eF\u003c/code\u003e - the boxed element type of the required lane type"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorSpecies.html#check(java.lang.Class)\"\u003e\u003ccode\u003eVectorSpecies.check(Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorMask.html#check(java.lang.Class)\"\u003e\u003ccode\u003eVectorMask.check(Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#check(jdk.incubator.vector.VectorSpecies)\"\u003e\u003ccode\u003echeck(VectorSpecies)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorShuffle.html#check(jdk.incubator.vector.VectorSpecies)\"\u003e\u003ccode\u003eVectorShuffle.check(VectorSpecies)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eelementType\u003c/code\u003e - the required lane type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the vector has the wrong element type"
        ],
        "return": [
          "the same vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "jdk.incubator.vector.Vector",
        "parameters": [
          {
            "name": "F",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "jdk.incubator.vector.VectorSpecies",
            "parameters": [
              {
                "name": "F",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "species"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "F",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "check",
      "comment": "Checks that this vector has the given species, and returns this vector unchanged. The effect is similar to this pseudocode: species \u003d\u003d species() ? this : throw new ClassCastException().",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eF\u003c/code\u003e - the boxed element type of the required species"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#check(java.lang.Class)\"\u003e\u003ccode\u003echeck(Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorMask.html#check(jdk.incubator.vector.VectorSpecies)\"\u003e\u003ccode\u003eVectorMask.check(VectorSpecies)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorShuffle.html#check(jdk.incubator.vector.VectorSpecies)\"\u003e\u003ccode\u003eVectorShuffle.check(VectorSpecies)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003especies\u003c/code\u003e - the required species"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the vector has the wrong species"
        ],
        "return": [
          "the same vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "a"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "bo"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "intoByteArray",
      "comment": "Stores this vector into a byte array starting at an offset using explicit byte order. Bytes are extracted from primitive lane elements according to the specified byte ordering. The lanes are stored according to their memory ordering. This method behaves as if it calls intoByteBuffer() as follows: \n var bb \u003d ByteBuffer.wrap(a);\n var m \u003d maskAll(true);\n intoByteBuffer(bb, offset, bo, m);",
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the byte array",
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset into the array",
          "\u003ccode\u003ebo\u003c/code\u003e - the intended byte order"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoffset+N*ESIZE \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003eoffset+(N+1)*ESIZE \u0026gt; a.length\u003c/code\u003e for any lane \n\u003ccode\u003eN\u003c/code\u003e in the vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "a"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "bo"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "intoByteArray",
      "comment": "Stores this vector into a byte array starting at an offset using explicit byte order and a mask. Bytes are extracted from primitive lane elements according to the specified byte ordering. The lanes are stored according to their memory ordering. This method behaves as if it calls intoByteBuffer() as follows: \n var bb \u003d ByteBuffer.wrap(a);\n intoByteBuffer(bb, offset, bo, m);",
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the byte array",
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset into the array",
          "\u003ccode\u003ebo\u003c/code\u003e - the intended byte order",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoffset+N*ESIZE \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003eoffset+(N+1)*ESIZE \u0026gt; a.length\u003c/code\u003e for any lane \n\u003ccode\u003eN\u003c/code\u003e in the vector where the mask is set"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "bb"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "bo"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "intoByteBuffer",
      "comment": "Stores this vector into a byte buffer starting at an offset using explicit byte order. Bytes are extracted from primitive lane elements according to the specified byte ordering. The lanes are stored according to their memory ordering. This method behaves as if it calls intoByteBuffer() as follows: \n var m \u003d maskAll(true);\n intoByteBuffer(bb, offset, bo, m);",
      "tagMap": {
        "param": [
          "\u003ccode\u003ebb\u003c/code\u003e - the byte buffer",
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset into the array",
          "\u003ccode\u003ebo\u003c/code\u003e - the intended byte order"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoffset+N*ESIZE \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003eoffset+(N+1)*ESIZE \u0026gt; bb.limit()\u003c/code\u003e for any lane \n\u003ccode\u003eN\u003c/code\u003e in the vector",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the byte buffer is read-only"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "bb"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "bo"
          }
        },
        {
          "type": {
            "name": "jdk.incubator.vector.VectorMask",
            "parameters": [
              {
                "owner": "jdk.incubator.vector.Vector",
                "name": "E",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "intoByteBuffer",
      "comment": "Stores this vector into a byte buffer starting at an offset using explicit byte order and a mask. Bytes are extracted from primitive lane elements according to the specified byte ordering. The lanes are stored according to their memory ordering. The following pseudocode illustrates the behavior, where the primitive element type is not of byte, EBuffer is the primitive buffer type, ETYPE is the primitive element type, and EVector is the primitive vector type for this vector: \n EBuffer eb \u003d bb.duplicate()\n     .position(offset)\n     .order(bo).asEBuffer();\n ETYPE[] a \u003d this.toArray();\n for (int n \u003d 0; n \u003c a.length; n++) {\n     if (m.laneIsSet(n)) {\n         eb.put(n, a[n]);\n     }\n }\n When the primitive element type is of byte the primitive byte buffer is obtained as follows, where operation on the buffer remains the same as in the prior pseudocode: \n ByteBuffer eb \u003d bb.duplicate()\n     .position(offset);",
      "tagMap": {
        "param": [
          "\u003ccode\u003ebb\u003c/code\u003e - the byte buffer",
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset into the array",
          "\u003ccode\u003ebo\u003c/code\u003e - the intended byte order",
          "\u003ccode\u003em\u003c/code\u003e - the mask controlling lane selection"
        ],
        "implNote": [
          "This operation is likely to be more efficient if the specified byte order is the same as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ByteOrder.html#nativeOrder()\"\u003ethe platform native order\u003c/a\u003e, since this method will not need to reorder the bytes of lane values. In the special case where \n\u003ccode\u003eETYPE\u003c/code\u003e is \n\u003ccode\u003ebyte\u003c/code\u003e, the byte order argument is ignored."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoffset+N*ESIZE \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003eoffset+(N+1)*ESIZE \u0026gt; bb.limit()\u003c/code\u003e for any lane \n\u003ccode\u003eN\u003c/code\u003e in the vector where the mask is set",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the byte buffer is read-only"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "toArray",
      "comment": "Returns a packed array containing all the lane values. The array length is the same as the vector length. The element type of the array is the same as the element type of the vector. The array elements are stored in lane order. Overrides of this method on subtypes of Vector which specify the element type have an accurately typed array result.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/ByteVector.html#toArray()\"\u003e\u003ccode\u003eByteVector.toArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#toArray()\"\u003e\u003ccode\u003eIntVector.toArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/DoubleVector.html#toArray()\"\u003e\u003ccode\u003eDoubleVector.toArray()\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Usually \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#toArray()\"\u003estrongly typed access\u003c/a\u003e is preferable, if you are working with a vector subtype that has a known element type."
        ],
        "return": [
          "an accurately typed array containing the lane values of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "toIntArray",
      "comment": "Returns an int[] array containing all the lane values, converted to the type int. The array length is the same as the vector length. The array elements are converted as if by casting and stored in lane order. This operation may fail if the vector element type is float or double, when lanes contain fractional or out-of-range values. If any vector lane value is not representable as an int, an exception is thrown.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toArray()\"\u003e\u003ccode\u003etoArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toLongArray()\"\u003e\u003ccode\u003etoLongArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toDoubleArray()\"\u003e\u003ccode\u003etoDoubleArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#toArray()\"\u003e\u003ccode\u003eIntVector.toArray()\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Usually \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#toArray()\"\u003estrongly typed access\u003c/a\u003e is preferable, if you are working with a vector subtype that has a known element type."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if any lane value cannot be represented as an \n\u003ccode\u003eint\u003c/code\u003e array element"
        ],
        "return": [
          "an \n\u003ccode\u003eint[]\u003c/code\u003e array containing the lane values of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "toLongArray",
      "comment": "Returns a long[] array containing all the lane values, converted to the type long. The array length is the same as the vector length. The array elements are converted as if by casting and stored in lane order. This operation may fail if the vector element type is float or double, when lanes contain fractional or out-of-range values. If any vector lane value is not representable as a long, an exception is thrown.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toArray()\"\u003e\u003ccode\u003etoArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toIntArray()\"\u003e\u003ccode\u003etoIntArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toDoubleArray()\"\u003e\u003ccode\u003etoDoubleArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/LongVector.html#toArray()\"\u003e\u003ccode\u003eLongVector.toArray()\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Usually \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#toArray()\"\u003estrongly typed access\u003c/a\u003e is preferable, if you are working with a vector subtype that has a known element type."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if any lane value cannot be represented as a \n\u003ccode\u003elong\u003c/code\u003e array element"
        ],
        "return": [
          "a \n\u003ccode\u003elong[]\u003c/code\u003e array containing the lane values of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "toDoubleArray",
      "comment": "Returns a double[] array containing all the lane values, converted to the type double. The array length is the same as the vector length. The array elements are converted as if by casting and stored in lane order. This operation can lose precision if the vector element type is long.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toArray()\"\u003e\u003ccode\u003etoArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toIntArray()\"\u003e\u003ccode\u003etoIntArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#toLongArray()\"\u003e\u003ccode\u003etoLongArray()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/DoubleVector.html#toArray()\"\u003e\u003ccode\u003eDoubleVector.toArray()\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Usually \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/FloatVector.html#toArray()\"\u003e\u003ccode\u003estrongly typed access\u003c/code\u003e\u003c/a\u003e is preferable, if you are working with a vector subtype that has a known element type."
        ],
        "return": [
          "a \n\u003ccode\u003edouble[]\u003c/code\u003e array containing the lane values of this vector, possibly rounded to representable \n\u003ccode\u003edouble\u003c/code\u003e values"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "toString",
      "comment": "Returns a string representation of this vector, of the form \"[0,1,2...]\", reporting the lane values of this vector, in lane order. The string is produced as if by a call to Arrays.toString(), as appropriate to the array returned by this.toArray().",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a string of the form \n\u003ccode\u003e\"[0,1,2...]\"\u003c/code\u003e reporting the lane values of this vector"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "obj"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "equals",
      "comment": "Indicates whether this vector is identical to some other object. Two vectors are identical only if they have the same species and same lane values, in the same order. The comparison of lane values is produced as if by a call to Arrays.equals(), as appropriate to the arrays returned by toArray() on both vectors.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#eq(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eeq(jdk.incubator.vector.Vector\u0026lt;E\u0026gt;)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the reference object with which to compare."
        ],
        "return": [
          "whether this vector is identical to some other object"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "hashCode",
      "comment": "Returns a hash code value for the vector. based on the lane values and the vector species.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#identityHashCode(java.lang.Object)\"\u003e\u003ccode\u003eSystem.identityHashCode(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a hash code value for this vector"
        ]
      }
    }
  ],
  "genericParameters": [
    {
      "name": "E",
      "type": "Variable"
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "jdk.incubator.vector.Vector",
  "comment": "A \n\u003c!-- The following paragraphs are shared verbatim\n   -- between Vector.java and package-info.java --\u003e sequence of a fixed number of \n\u003cem\u003elanes\u003c/em\u003e, all of some fixed \n\u003ca href\u003d\"#elementType()\"\u003e\u003cem\u003eelement type\u003c/em\u003e\u003c/a\u003e such as \n\u003ccode\u003ebyte\u003c/code\u003e, \n\u003ccode\u003elong\u003c/code\u003e, or \n\u003ccode\u003efloat\u003c/code\u003e. Each lane contains an independent value of the element type. Operations on vectors are typically \n\u003ca href\u003d\"Vector.html#lane-wise\"\u003e\u003cem\u003elane-wise\u003c/em\u003e\u003c/a\u003e, distributing some scalar operator (such as \n\u003ca href\u003d\"#add(jdk.incubator.vector.Vector)\"\u003eaddition\u003c/a\u003e) across the lanes of the participating vectors, usually generating a vector result whose lanes contain the various scalar results. When run on a supporting platform, lane-wise operations can be executed in parallel by the hardware. This style of parallelism is called \n\u003cem\u003eSingle Instruction Multiple Data\u003c/em\u003e (SIMD) parallelism. \n\u003cp\u003e In the SIMD style of programming, most of the operations within a vector lane are unconditional, but the effect of conditional execution may be achieved using \u003ca href\u003d\"Vector.html#masking\"\u003e\u003cem\u003emasked operations\u003c/em\u003e\u003c/a\u003e such as \u003ca href\u003d\"#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eblend()\u003c/code\u003e\u003c/a\u003e, under the control of an associated \u003ca href\u003d\"VectorMask.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorMask\u003c/code\u003e\u003c/a\u003e. Data motion other than strictly lane-wise flow is achieved using \u003ca href\u003d\"Vector.html#cross-lane\"\u003e\u003cem\u003ecross-lane\u003c/em\u003e\u003c/a\u003e operations, often under the control of an associated \u003ca href\u003d\"VectorShuffle.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorShuffle\u003c/code\u003e\u003c/a\u003e. Lane data and/or whole vectors can be reformatted using various kinds of lane-wise \u003ca href\u003d\"#convert(jdk.incubator.vector.VectorOperators.Conversion,int)\"\u003econversions\u003c/a\u003e, and byte-wise reformatting \u003ca href\u003d\"#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003ereinterpretations\u003c/a\u003e, often under the control of a reflective \u003ca href\u003d\"VectorSpecies.html\" title\u003d\"interface in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorSpecies\u003c/code\u003e\u003c/a\u003e object which selects an alternative vector format different from that of the input vector. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eVector\u0026lt;E\u0026gt;\u003c/code\u003e declares a set of vector operations (methods) that are common to all element types. These common operations include generic access to lane values, data selection and movement, reformatting, and certain arithmetic and logical operations (such as addition or comparison) that are common to all primitive types. \u003c/p\u003e\n\u003cp\u003e \u003ca href\u003d\"Vector.html#subtypes\"\u003ePublic subtypes of \u003ccode\u003eVector\u003c/code\u003e\u003c/a\u003e correspond to specific element types. These declare further operations that are specific to that element type, including unboxed access to lane values, bitwise operations on values of integral element types, or transcendental operations on values of floating point element types. \u003c/p\u003e\n\u003cp\u003e Some lane-wise operations, such as the \u003ccode\u003eadd\u003c/code\u003e operator, are defined as a full-service named operation, where a corresponding method on \u003ccode\u003eVector\u003c/code\u003e comes in masked and unmasked overloadings, and (in subclasses) also comes in covariant overrides (returning the subclass) and additional scalar-broadcast overloadings (both masked and unmasked). Other lane-wise operations, such as the \u003ccode\u003emin\u003c/code\u003e operator, are defined as a partially serviced (not a full-service) named operation, where a corresponding method on \u003ccode\u003eVector\u003c/code\u003e and/or a subclass provide some but all possible overloadings and overrides (commonly the unmasked varient with scalar-broadcast overloadings). Finally, all lane-wise operations (those named as previously described, or otherwise unnamed method-wise) have a corresponding \u003ca href\u003d\"VectorOperators.Operator.html\" title\u003d\"interface in jdk.incubator.vector\"\u003e\u003ccode\u003eoperator token\u003c/code\u003e\u003c/a\u003e declared as a static constant on \u003ca href\u003d\"VectorOperators.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorOperators\u003c/code\u003e\u003c/a\u003e. Each operator token defines a symbolic Java expression for the operation, such as \u003ccode\u003ea + b\u003c/code\u003e for the \u003ca href\u003d\"VectorOperators.html#ADD\"\u003e\u003ccode\u003eADD\u003c/code\u003e\u003c/a\u003e operator token. General lane-wise operation-token accepting methods, such as for a \u003ca href\u003d\"#lanewise(jdk.incubator.vector.VectorOperators.Unary)\"\u003eunary lane-wise\u003c/a\u003e operation, are provided on \u003ccode\u003eVector\u003c/code\u003e and come in the same variants as a full-service named operation. \u003c/p\u003e\n\u003cp\u003eThis package contains a public subtype of \u003ca href\u003d\"Vector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eVector\u003c/code\u003e\u003c/a\u003e corresponding to each supported element type: \u003ca href\u003d\"ByteVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eByteVector\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"ShortVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eShortVector\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"IntVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eIntVector\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"LongVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eLongVector\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"FloatVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eFloatVector\u003c/code\u003e\u003c/a\u003e, and \u003ca href\u003d\"DoubleVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eDoubleVector\u003c/code\u003e\u003c/a\u003e. \n \u003c!-- The preceding paragraphs are shared verbatim\n   -- between Vector.java and package-info.java --\u003e \u003c/p\u003e\n\u003cp\u003e\u003ca id\u003d\"ETYPE\"\u003e\u003c/a\u003e The \u003ca href\u003d\"#elementType()\"\u003eelement type\u003c/a\u003e of a vector, referred to as \u003ccode\u003eETYPE\u003c/code\u003e, is one of the primitive types \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003e float\u003c/code\u003e, or \u003ccode\u003edouble\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e The type \u003ccode\u003eE\u003c/code\u003e in \u003ccode\u003eVector\u0026lt;E\u0026gt;\u003c/code\u003e is the \u003cem\u003eboxed\u003c/em\u003e version of \u003ccode\u003eETYPE\u003c/code\u003e. For example, in the type \u003ccode\u003eVector\u0026lt;Integer\u0026gt;\u003c/code\u003e, the \u003ccode\u003eE\u003c/code\u003e parameter is \u003ccode\u003eInteger\u003c/code\u003e and the \u003ccode\u003eETYPE\u003c/code\u003e is \u003ccode\u003eint\u003c/code\u003e. In such a vector, each lane carries a primitive \u003ccode\u003eint\u003c/code\u003e value. This pattern continues for the other primitive types as well. (See also sections \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-5.html#jls-5.1.7\"\u003e5.1.7\u003c/a\u003e and \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-5.html#jls-5.1.8\"\u003e5.1.8\u003c/a\u003e of the \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.) \u003c/p\u003e\n\u003cp\u003e\u003ca id\u003d\"VLENGTH\"\u003e\u003c/a\u003e The \u003ca href\u003d\"#length()\"\u003elength\u003c/a\u003e of a vector is the lane count, the number of lanes it contains. This number is also called \u003ccode\u003eVLENGTH\u003c/code\u003e when the context makes clear which vector it belongs to. Each vector has its own fixed \u003ccode\u003eVLENGTH\u003c/code\u003e but different instances of vectors may have different lengths. \u003ccode\u003eVLENGTH\u003c/code\u003e is an important number, because it estimates the SIMD performance gain of a single vector operation as compared to scalar execution of the \u003ccode\u003eVLENGTH\u003c/code\u003e scalar operators which underly the vector operation. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"species\"\u003e\u003c/a\u003eShapes and species\u003c/h2\u003e The information capacity of a vector is determined by its \n\u003ca href\u003d\"#shape()\"\u003e\u003cem\u003evector shape\u003c/em\u003e\u003c/a\u003e, also called its \n\u003ccode\u003eVSHAPE\u003c/code\u003e. Each possible \n\u003ccode\u003eVSHAPE\u003c/code\u003e is represented by a member of the \n\u003ca href\u003d\"VectorShape.html\" title\u003d\"enum class in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorShape\u003c/code\u003e\u003c/a\u003e enumeration, and represents an implementation format shared in common by all vectors of that shape. Thus, the \n\u003ca href\u003d\"#bitSize()\"\u003esize in bits\u003c/a\u003e of of a vector is determined by appealing to its vector shape. \n\u003cp\u003e Some Java platforms give special support to only one shape, while others support several. A typical platform is not likely to support all the shapes described by this API. For this reason, most vector operations work on a single input shape and produce the same shape on output. Operations which change shape are clearly documented as such \u003cem\u003eshape-changing\u003c/em\u003e, while the majority of operations are \u003cem\u003eshape-invariant\u003c/em\u003e, to avoid disadvantaging platforms which support only one shape. There are queries to discover, for the current Java platform, the \u003ca href\u003d\"VectorShape.html#preferredShape()\"\u003epreferred shape\u003c/a\u003e for general SIMD computation, or the largest available shape for any given lane type. To be portable, code using this API should start by querying a supported shape, and then process all data with shape-invariant operations, within the selected shape. \u003c/p\u003e\n\u003cp\u003e Each unique combination of element type and vector shape determines a unique \u003ca href\u003d\"#species()\"\u003e\u003cem\u003evector species\u003c/em\u003e\u003c/a\u003e. A vector species is represented by a fixed instance of \u003ca href\u003d\"VectorSpecies.html\" title\u003d\"interface in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorSpecies\u0026lt;E\u0026gt;\u003c/code\u003e\u003c/a\u003e shared in common by all vectors of the same shape and \u003ccode\u003eETYPE\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e Unless otherwise documented, lane-wise vector operations require that all vector inputs have exactly the same \u003ccode\u003eVSHAPE\u003c/code\u003e and \u003ccode\u003eVLENGTH\u003c/code\u003e, which is to say that they must have exactly the same species. This allows corresponding lanes to be paired unambiguously. The \u003ca href\u003d\"#check(jdk.incubator.vector.VectorSpecies)\"\u003e\u003ccode\u003echeck()\u003c/code\u003e\u003c/a\u003e method provides an easy way to perform this check explicitly. \u003c/p\u003e\n\u003cp\u003e Vector shape, \u003ccode\u003eVLENGTH\u003c/code\u003e, and \u003ccode\u003eETYPE\u003c/code\u003e are all mutually constrained, so that \u003ccode\u003eVLENGTH\u003c/code\u003e times the \u003ca href\u003d\"#elementSize()\"\u003ebit-size of each lane\u003c/a\u003e must always match the bit-size of the vector\u0027s shape. Thus, \u003ca href\u003d\"#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003ereinterpreting\u003c/a\u003e a vector may double its length if and only if it either halves the lane size, or else changes the shape. Likewise, reinterpreting a vector may double the lane size if and only if it either halves the length, or else changes the shape of the vector. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"subtypes\"\u003e\u003c/a\u003eVector subtypes\u003c/h2\u003e Vector declares a set of vector operations (methods) that are common to all element types (such as addition). Sub-classes of Vector with a concrete element type declare further operations that are specific to that element type (such as access to element values in lanes, logical operations on values of integral elements types, or transcendental operations on values of floating point element types). There are six abstract sub-classes of Vector corresponding to the supported set of element types, \n\u003ca href\u003d\"ByteVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eByteVector\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"ShortVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eShortVector\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"IntVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eIntVector\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"LongVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eLongVector\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"FloatVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eFloatVector\u003c/code\u003e\u003c/a\u003e, and \n\u003ca href\u003d\"DoubleVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eDoubleVector\u003c/code\u003e\u003c/a\u003e. Along with type-specific operations these classes support creation of vector values (instances of Vector). They expose static constants corresponding to the supported species, and static methods on these types generally take a species as a parameter. For example, \n\u003ca href\u003d\"FloatVector.html#fromArray(jdk.incubator.vector.VectorSpecies,float%5B%5D,int)\"\u003e\u003ccode\u003eFloatVector.fromArray\u003c/code\u003e\u003c/a\u003e creates and returns a float vector of the specified species, with elements loaded from the specified float array. It is recommended that Species instances be held in \n\u003ccode\u003estatic final\u003c/code\u003e fields for optimal creation and usage of Vector values by the runtime compiler. \n\u003cp\u003e As an example of static constants defined by the typed vector classes, constant \u003ca href\u003d\"FloatVector.html#SPECIES_256\"\u003e\u003ccode\u003eFloatVector.SPECIES_256\u003c/code\u003e\u003c/a\u003e is the unique species whose lanes are \u003ccode\u003efloat\u003c/code\u003es and whose vector size is 256 bits. Again, the constant \u003ca href\u003d\"FloatVector.html#SPECIES_PREFERRED\"\u003e\u003ccode\u003eFloatVector.SPECIES_PREFERRED\u003c/code\u003e\u003c/a\u003e is the species which best supports processing of \u003ccode\u003efloat\u003c/code\u003e vector lanes on the currently running Java platform. \u003c/p\u003e\n\u003cp\u003e As another example, a broadcast scalar value of \u003ccode\u003e(double)0.5\u003c/code\u003e can be obtained by calling \u003ca href\u003d\"DoubleVector.html#broadcast(jdk.incubator.vector.VectorSpecies,double)\"\u003e\u003ccode\u003eDoubleVector.broadcast(dsp, 0.5)\u003c/code\u003e\u003c/a\u003e, but the argument \u003ccode\u003edsp\u003c/code\u003e is required to select the species (and hence the shape and length) of the resulting vector. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"lane-wise\"\u003e\u003c/a\u003eLane-wise operations\u003c/h2\u003e We use the term \n\u003cem\u003elanes\u003c/em\u003e when defining operations on vectors. The number of lanes in a vector is the number of scalar elements it holds. For example, a vector of type \n\u003ccode\u003efloat\u003c/code\u003e and shape \n\u003ccode\u003eS_256_BIT\u003c/code\u003e has eight lanes, since \n\u003ccode\u003e32*8\u003d256\u003c/code\u003e. \n\u003cp\u003e Most operations on vectors are lane-wise, which means the operation is composed of an underlying scalar operator, which is repeated for each distinct lane of the input vector. If there are additional vector arguments of the same type, their lanes are aligned with the lanes of the first input vector. (They must all have a common \u003ccode\u003eVLENGTH\u003c/code\u003e.) The output resulting from a lane-wise operation will have a \u003ccode\u003eVLENGTH\u003c/code\u003e which is equal to the \u003ccode\u003eVLENGTH\u003c/code\u003e of the input(s) to the operation. Thus, lane-wise operations are \u003cem\u003elength-invariant\u003c/em\u003e, in their basic definitions. \u003c/p\u003e\n\u003cp\u003e The principle of length-invariance is combined with another basic principle, that lane-wise operations are always \u003cem\u003eshape-invariant\u003c/em\u003e, meaning that the inputs and the output of a lane-wise operation will have a common \u003ccode\u003eVSHAPE\u003c/code\u003e. When the principles conflict, because a logical result (with an invariant \u003ccode\u003eVLENGTH\u003c/code\u003e), does not fit into the invariant \u003ccode\u003eVSHAPE\u003c/code\u003e, the resulting expansions and contractions are handled explicitly with \u003ca href\u003d\"Vector.html#expansion\"\u003especial conventions\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e Vector operations can be grouped into various categories and their behavior can be generally specified in terms of underlying scalar operators. In the examples below, \u003ccode\u003eETYPE\u003c/code\u003e is the element type of the operation (such as \u003ccode\u003eint.class\u003c/code\u003e) and \u003ccode\u003eEVector\u003c/code\u003e is the corresponding concrete vector type (such as \u003ccode\u003eIntVector.class\u003c/code\u003e). \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e A \u003cem\u003elane-wise unary\u003c/em\u003e operation, such as \u003ccode\u003ew \u003d v0.\u003c/code\u003e\u003ca href\u003d\"#neg()\"\u003e\u003ccode\u003eneg\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e()\u003c/code\u003e, takes one input vector, distributing a unary scalar operator across the lanes, and produces a result vector of the same type and shape. For each lane of the input vector \u003ccode\u003ea\u003c/code\u003e, the underlying scalar operator is applied to the lane value. The result is placed into the vector result in the same lane. The following pseudocode illustrates the behavior of this operation category: \u003cpre\u003e\u003ccode\u003e\n ETYPE scalar_unary_op(ETYPE s);\n EVector a \u003d ...;\n VectorSpecies\u0026lt;E\u0026gt; species \u003d a.species();\n ETYPE[] ar \u003d new ETYPE[a.length()];\n for (int i \u003d 0; i \u0026lt; ar.length; i++) {\n     ar[i] \u003d scalar_unary_op(a.lane(i));\n }\n EVector r \u003d EVector.fromArray(species, ar, 0);\n \u003c/code\u003e\u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003e A \u003cem\u003elane-wise binary\u003c/em\u003e operation, such as \u003ccode\u003ew \u003d v0.\u003c/code\u003e\u003ca href\u003d\"#add(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eadd\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(v1)\u003c/code\u003e, takes two input vectors, distributing a binary scalar operator across the lanes, and produces a result vector of the same type and shape. For each lane of the two input vectors \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e, the underlying scalar operator is applied to the lane values. The result is placed into the vector result in the same lane. The following pseudocode illustrates the behavior of this operation category: \u003cpre\u003e\u003ccode\u003e\n ETYPE scalar_binary_op(ETYPE s, ETYPE t);\n EVector a \u003d ...;\n VectorSpecies\u0026lt;E\u0026gt; species \u003d a.species();\n EVector b \u003d ...;\n b.check(species);  // must have same species\n ETYPE[] ar \u003d new ETYPE[a.length()];\n for (int i \u003d 0; i \u0026lt; ar.length; i++) {\n     ar[i] \u003d scalar_binary_op(a.lane(i), b.lane(i));\n }\n EVector r \u003d EVector.fromArray(species, ar, 0);\n \u003c/code\u003e\u003c/pre\u003e \u003c/li\u003e \n \u003cli\u003e Generalizing from unary and binary operations, a \u003cem\u003elane-wise n-ary\u003c/em\u003e operation takes \u003ccode\u003eN\u003c/code\u003e input vectors \u003ccode\u003ev[j]\u003c/code\u003e, distributing an n-ary scalar operator across the lanes, and produces a result vector of the same type and shape. Except for a few ternary operations, such as \u003ccode\u003ew \u003d v0.\u003c/code\u003e\u003ca href\u003d\"FloatVector.html#fma(jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003efma\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(v1,v2)\u003c/code\u003e, this API has no support for lane-wise n-ary operations. For each lane of all of the input vectors \u003ccode\u003ev[j]\u003c/code\u003e, the underlying scalar operator is applied to the lane values. The result is placed into the vector result in the same lane. The following pseudocode illustrates the behavior of this operation category: \u003cpre\u003e\u003ccode\u003e\n ETYPE scalar_nary_op(ETYPE... args);\n EVector[] v \u003d ...;\n int N \u003d v.length;\n VectorSpecies\u0026lt;E\u0026gt; species \u003d v[0].species();\n for (EVector arg : v) {\n     arg.check(species);  // all must have same species\n }\n ETYPE[] ar \u003d new ETYPE[a.length()];\n for (int i \u003d 0; i \u0026lt; ar.length; i++) {\n     ETYPE[] args \u003d new ETYPE[N];\n     for (int j \u003d 0; j \u0026lt; N; j++) {\n         args[j] \u003d v[j].lane(i);\n     }\n     ar[i] \u003d scalar_nary_op(args);\n }\n EVector r \u003d EVector.fromArray(species, ar, 0);\n \u003c/code\u003e\u003c/pre\u003e \u003c/li\u003e \n \u003cli\u003e A \u003cem\u003elane-wise conversion\u003c/em\u003e operation, such as \u003ccode\u003ew0 \u003d v0.\u003c/code\u003e\u003ca href\u003d\"#convert(jdk.incubator.vector.VectorOperators.Conversion,int)\"\u003e\u003ccode\u003econvert\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(VectorOperators.I2D, 0)\u003c/code\u003e, takes one input vector, distributing a unary scalar conversion operator across the lanes, and produces a logical result of the converted values. The logical result (or at least a part of it) is presented in a vector of the same shape as the input vector. \u003cp\u003e Unlike other lane-wise operations, conversions can change lane type, from the input (domain) type to the output (range) type. The lane size may change along with the type. In order to manage the size changes, lane-wise conversion methods can product \u003cem\u003epartial results\u003c/em\u003e, under the control of a \u003ccode\u003epart\u003c/code\u003e parameter, which is \u003ca href\u003d\"Vector.html#expansion\"\u003eexplained elsewhere\u003c/a\u003e. (Following the example above, the second group of converted lane values could be obtained as \u003ccode\u003ew1 \u003d v0.convert(VectorOperators.I2D, 1)\u003c/code\u003e.) \u003c/p\u003e\u003cp\u003e The following pseudocode illustrates the behavior of this operation category in the specific example of a conversion from \u003ccode\u003eint\u003c/code\u003e to \u003ccode\u003edouble\u003c/code\u003e, retaining either lower or upper lanes (depending on \u003ccode\u003epart\u003c/code\u003e) to maintain shape-invariance: \u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\n IntVector a \u003d ...;\n int VLENGTH \u003d a.length();\n int part \u003d ...;  // 0 or 1\n VectorShape VSHAPE \u003d a.shape();\n double[] arlogical \u003d new double[VLENGTH];\n for (int i \u003d 0; i \u0026lt; limit; i++) {\n     int e \u003d a.lane(i);\n     arlogical[i] \u003d (double) e;\n }\n VectorSpecies\u0026lt;Double\u0026gt; rs \u003d VSHAPE.withLanes(double.class);\n int M \u003d Double.BITS / Integer.BITS;  // expansion factor\n int offset \u003d part * (VLENGTH / M);\n DoubleVector r \u003d DoubleVector.fromArray(rs, arlogical, offset);\n assert r.length() \u003d\u003d VLENGTH / M;\n \u003c/code\u003e\u003c/pre\u003e \u003cp\u003e\u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e A \u003cem\u003ecross-lane reduction\u003c/em\u003e operation, such as \u003ccode\u003ee \u003d v0.\u003c/code\u003e\u003ca href\u003d\"IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)\"\u003e\u003ccode\u003ereduceLanes\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(VectorOperators.ADD)\u003c/code\u003e, operates on all the lane elements of an input vector. An accumulation function is applied to all the lane elements to produce a scalar result. If the reduction operation is associative then the result may be accumulated by operating on the lane elements in any order using a specified associative scalar binary operation and identity value. Otherwise, the reduction operation specifies the order of accumulation. The following pseudocode illustrates the behavior of this operation category if it is associative: \u003cpre\u003e\u003ccode\u003e\n ETYPE assoc_scalar_binary_op(ETYPE s, ETYPE t);\n EVector a \u003d ...;\n ETYPE r \u003d \u0026lt;identity value\u0026gt;;\n for (int i \u003d 0; i \u0026lt; a.length(); i++) {\n     r \u003d assoc_scalar_binary_op(r, a.lane(i));\n }\n \u003c/code\u003e\u003c/pre\u003e \u003c/li\u003e \n \u003cli\u003e A \u003cem\u003ecross-lane movement\u003c/em\u003e operation, such as \u003ccode\u003ew \u003d v0.\u003c/code\u003e\u003ca href\u003d\"#rearrange(jdk.incubator.vector.VectorShuffle)\"\u003e\u003ccode\u003erearrange\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(shuffle)\u003c/code\u003e operates on all the lane elements of an input vector and moves them in a data-dependent manner into \u003cem\u003edifferent lanes\u003c/em\u003e in an output vector. The movement is steered by an auxiliary datum, such as a \u003ca href\u003d\"VectorShuffle.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorShuffle\u003c/code\u003e\u003c/a\u003e or a scalar index defining the origin of the movement. The following pseudocode illustrates the behavior of this operation category, in the case of a shuffle: \u003cpre\u003e\u003ccode\u003e\n EVector a \u003d ...;\n Shuffle\u0026lt;E\u0026gt; s \u003d ...;\n ETYPE[] ar \u003d new ETYPE[a.length()];\n for (int i \u003d 0; i \u0026lt; ar.length; i++) {\n     int source \u003d s.laneSource(i);\n     ar[i] \u003d a.lane(source);\n }\n EVector r \u003d EVector.fromArray(a.species(), ar, 0);\n \u003c/code\u003e\u003c/pre\u003e \u003c/li\u003e \n \u003cli\u003e A \u003cem\u003emasked operation\u003c/em\u003e is one which is a variation on one of the previous operations (either lane-wise or cross-lane), where the operation takes an extra trailing \u003ca href\u003d\"VectorMask.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorMask\u003c/code\u003e\u003c/a\u003e argument. In lanes the mask is set, the operation behaves as if the mask argument were absent, but in lanes where the mask is unset, the underlying scalar operation is suppressed. Masked operations are explained in \u003ca href\u003d\"Vector.html#masking\"\u003egreater detail elsewhere\u003c/a\u003e. \u003c/li\u003e \n \u003cli\u003e A very special case of a masked lane-wise binary operation is a \u003ca href\u003d\"#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003eblend\u003c/a\u003e, which operates lane-wise on two input vectors \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e, selecting lane values from one input or the other depending on a mask \u003ccode\u003em\u003c/code\u003e. In lanes where \u003ccode\u003em\u003c/code\u003e is set, the corresponding value from \u003ccode\u003eb\u003c/code\u003e is selected into the result; otherwise the value from \u003ccode\u003ea\u003c/code\u003e is selected. Thus, a blend acts as a vectorized version of Java\u0027s ternary selection expression \u003ccode\u003em?b:a\u003c/code\u003e: \u003cpre\u003e\u003ccode\u003e\n ETYPE[] ar \u003d new ETYPE[a.length()];\n for (int i \u003d 0; i \u0026lt; ar.length; i++) {\n     boolean isSet \u003d m.laneIsSet(i);\n     ar[i] \u003d isSet ? b.lane(i) : a.lane(i);\n }\n EVector r \u003d EVector.fromArray(species, ar, 0);\n \u003c/code\u003e\u003c/pre\u003e \u003c/li\u003e \n \u003cli\u003e A \u003cem\u003elane-wise binary test\u003c/em\u003e operation, such as \u003ccode\u003em \u003d v0.\u003c/code\u003e\u003ca href\u003d\"#lt(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003elt\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(v1)\u003c/code\u003e, takes two input vectors, distributing a binary scalar comparison across the lanes, and produces, not a vector of booleans, but rather a \u003ca href\u003d\"VectorMask.html\" title\u003d\"class in jdk.incubator.vector\"\u003evector mask\u003c/a\u003e. For each lane of the two input vectors \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e, the underlying scalar comparison operator is applied to the lane values. The resulting boolean is placed into the vector mask result in the same lane. The following pseudocode illustrates the behavior of this operation category: \u003cpre\u003e\u003ccode\u003e\n boolean scalar_binary_test_op(ETYPE s, ETYPE t);\n EVector a \u003d ...;\n VectorSpecies\u0026lt;E\u0026gt; species \u003d a.species();\n EVector b \u003d ...;\n b.check(species);  // must have same species\n boolean[] mr \u003d new boolean[a.length()];\n for (int i \u003d 0; i \u0026lt; mr.length; i++) {\n     mr[i] \u003d scalar_binary_test_op(a.lane(i), b.lane(i));\n }\n VectorMask\u0026lt;E\u0026gt; m \u003d VectorMask.fromArray(species, mr, 0);\n \u003c/code\u003e\u003c/pre\u003e \u003c/li\u003e \n \u003cli\u003e Similarly to a binary comparison, a \u003cem\u003elane-wise unary test\u003c/em\u003e operation, such as \u003ccode\u003em \u003d v0.\u003c/code\u003e\u003ca href\u003d\"#test(jdk.incubator.vector.VectorOperators.Test)\"\u003e\u003ccode\u003etest\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(IS_FINITE)\u003c/code\u003e, takes one input vector, distributing a scalar predicate (a test function) across the lanes, and produces a \u003ca href\u003d\"VectorMask.html\" title\u003d\"class in jdk.incubator.vector\"\u003evector mask\u003c/a\u003e. \u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e If a vector operation does not belong to one of the above categories then the method documentation explicitly specifies how it processes the lanes of input vectors, and where appropriate illustrates the behavior using pseudocode. \u003c/p\u003e\n\u003cp\u003e Most lane-wise binary and comparison operations offer convenience overloadings which accept a scalar as the second input, in place of a vector. In this case the scalar value is promoted to a vector by \u003ca href\u003d\"#broadcast(long)\"\u003ebroadcasting it\u003c/a\u003e into the same lane structure as the first input. For example, to multiply all lanes of a \u003ccode\u003edouble\u003c/code\u003e vector by a scalar value \u003ccode\u003e1.1\u003c/code\u003e, the expression \u003ccode\u003ev.mul(1.1)\u003c/code\u003e is easier to work with than an equivalent expression with an explicit broadcast operation, such as \u003ccode\u003ev.mul(v.broadcast(1.1))\u003c/code\u003e or \u003ccode\u003ev.mul(DoubleVector.broadcast(v.species(), 1.1))\u003c/code\u003e. Unless otherwise specified the scalar variant always behaves as if each scalar value is first transformed to a vector of the same species as the first vector input, using the appropriate \u003ccode\u003ebroadcast\u003c/code\u003e operation. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"masking\"\u003e\u003c/a\u003eMasked operations\u003c/h2\u003e \n\u003cp\u003e Many vector operations accept an optional \u003ca href\u003d\"VectorMask.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003emask\u003c/code\u003e\u003c/a\u003e argument, selecting which lanes participate in the underlying scalar operator. If present, the mask argument appears at the end of the method argument list. \u003c/p\u003e\n\u003cp\u003e Each lane of the mask argument is a boolean which is either in the \u003cem\u003eset\u003c/em\u003e or \u003cem\u003eunset\u003c/em\u003e state. For lanes where the mask argument is unset, the underlying scalar operator is suppressed. In this way, masks allow vector operations to emulate scalar control flow operations, without losing SIMD parallelism, except where the mask lane is unset. \u003c/p\u003e\n\u003cp\u003e An operation suppressed by a mask will never cause an exception or side effect of any sort, even if the underlying scalar operator can potentially do so. For example, an unset lane that seems to access an out of bounds array element or divide an integral value by zero will simply be ignored. Values in suppressed lanes never participate or appear in the result of the overall operation. \u003c/p\u003e\n\u003cp\u003e Result lanes corresponding to a suppressed operation will be filled with a default value which depends on the specific operation, as follows: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eIf the masked operation is a unary, binary, or n-ary arithmetic or logical operation, suppressed lanes are filled from the first vector operand (i.e., the vector receiving the method call), as if by a \u003ca href\u003d\"#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003eblend\u003c/a\u003e.\u003c/li\u003e \n \u003cli\u003eIf the masked operation is a memory load or a \u003ccode\u003eslice()\u003c/code\u003e from another vector, suppressed lanes are not loaded, and are filled with the default value for the \u003ccode\u003eETYPE\u003c/code\u003e, which in every case consists of all zero bits. An unset lane can never cause an exception, even if the hypothetical corresponding memory location does not exist (because it is out of an array\u0027s index range).\u003c/li\u003e \n \u003cli\u003eIf the operation is a cross-lane operation with an operand which supplies lane indexes (of type \u003ccode\u003eVectorShuffle\u003c/code\u003e or \u003ccode\u003eVector\u003c/code\u003e, suppressed lanes are not computed, and are filled with the zero default value. Normally, invalid lane indexes elicit an \u003ccode\u003eIndexOutOfBoundsException\u003c/code\u003e, but if a lane is unset, the zero value is quietly substituted, regardless of the index. This rule is similar to the previous rule, for masked memory loads.\u003c/li\u003e \n \u003cli\u003eIf the masked operation is a memory store or an \u003ccode\u003eunslice()\u003c/code\u003e into another vector, suppressed lanes are not stored, and the corresponding memory or vector locations (if any) are unchanged. \u003cp\u003e (Note: Memory effects such as race conditions never occur for suppressed lanes. That is, implementations will not secretly re-write the existing value for unset lanes. In the Java Memory Model, reassigning a memory variable to its current value is not a no-op; it may quietly undo a racing store from another thread.)\u003c/p\u003e \u003c/li\u003e \n \u003cli\u003eIf the masked operation is a reduction, suppressed lanes are ignored in the reduction. If all lanes are suppressed, a suitable neutral value is returned, depending on the specific reduction operation, and documented by the masked variant of that method. (This means that users can obtain the neutral value programmatically by executing the reduction on a dummy vector with an all-unset mask.) \u003c/li\u003e\n \u003cli\u003eIf the masked operation is a comparison operation, suppressed output lanes in the resulting mask are themselves unset, as if the suppressed comparison operation returned \u003ccode\u003efalse\u003c/code\u003e regardless of the suppressed input values. In effect, it is as if the comparison operation were performed unmasked, and then the result intersected with the controlling mask.\u003c/li\u003e \n \u003cli\u003eIn other cases, such as masked \u003ca href\u003d\"Vector.html#cross-lane\"\u003e\u003cem\u003ecross-lane movements\u003c/em\u003e\u003c/a\u003e, the specific effects of masking are documented by the masked variant of the method. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e As an example, a masked binary operation on two input vectors \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e suppresses the binary operation for lanes where the mask is unset, and retains the original lane value from \u003ccode\u003ea\u003c/code\u003e. The following pseudocode illustrates this behavior: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n ETYPE scalar_binary_op(ETYPE s, ETYPE t);\n EVector a \u003d ...;\n VectorSpecies\u0026lt;E\u0026gt; species \u003d a.species();\n EVector b \u003d ...;\n b.check(species);  // must have same species\n VectorMask\u0026lt;E\u0026gt; m \u003d ...;\n m.check(species);  // must have same species\n boolean[] ar \u003d new boolean[a.length()];\n for (int i \u003d 0; i \u0026lt; ar.length; i++) {\n     if (m.laneIsSet(i)) {\n         ar[i] \u003d scalar_binary_op(a.lane(i), b.lane(i));\n     } else {\n         ar[i] \u003d a.lane(i);  // from first input\n     }\n }\n EVector r \u003d EVector.fromArray(species, ar, 0);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"lane-order\"\u003e\u003c/a\u003eLane order and byte order\u003c/h2\u003e The number of lane values stored in a given vector is referred to as its \n\u003ca href\u003d\"#length()\"\u003evector length\u003c/a\u003e or \n\u003ccode\u003eVLENGTH\u003c/code\u003e. It is useful to consider vector lanes as ordered \n\u003cem\u003esequentially\u003c/em\u003e from first to last, with the first lane numbered \n\u003ccode\u003e0\u003c/code\u003e, the next lane numbered \n\u003ccode\u003e1\u003c/code\u003e, and so on to the last lane numbered \n\u003ccode\u003eVLENGTH-1\u003c/code\u003e. This is a temporal order, where lower-numbered lanes are considered earlier than higher-numbered (later) lanes. This API uses these terms in preference to spatial terms such as \"left\", \"right\", \"high\", and \"low\". \n\u003cp\u003e Temporal terminology works well for vectors because they (usually) represent small fixed-sized segments in a long sequence of workload elements, where the workload is conceptually traversed in time order from beginning to end. (This is a mental model: it does not exclude multicore divide-and-conquer techniques.) Thus, when a scalar loop is transformed into a vector loop, adjacent scalar items (one earlier, one later) in the workload end up as adjacent lanes in a single vector (again, one earlier, one later). At a vector boundary, the last lane item in the earlier vector is adjacent to (and just before) the first lane item in the immediately following vector. \u003c/p\u003e\n\u003cp\u003e Vectors are also sometimes thought of in spatial terms, where the first lane is placed at an edge of some virtual paper, and subsequent lanes are presented in order next to it. When using spatial terms, all directions are equally plausible: Some vector notations present lanes from left to right, and others from right to left; still others present from top to bottom or vice versa. Using the language of time (before, after, first, last) instead of space (left, right, high, low) is often more likely to avoid misunderstandings. \u003c/p\u003e\n\u003cp\u003e As second reason to prefer temporal to spatial language about vector lanes is the fact that the terms \"left\", \"right\", \"high\" and \"low\" are widely used to describe the relations between bits in scalar values. The leftmost or highest bit in a given type is likely to be a sign bit, while the rightmost or lowest bit is likely to be the arithmetically least significant, and so on. Applying these terms to vector lanes risks confusion, however, because it is relatively rare to find algorithms where, given two adjacent vector lanes, one lane is somehow more arithmetically significant than its neighbor, and even in those cases, there is no general way to know which neighbor is the the more significant. \u003c/p\u003e\n\u003cp\u003e Putting the terms together, we view the information structure of a vector as a temporal sequence of lanes (\"first\", \"next\", \"earlier\", \"later\", \"last\", etc.) of bit-strings which are internally ordered spatially (either \"low\" to \"high\" or \"right\" to \"left\"). The primitive values in the lanes are decoded from these bit-strings, in the usual way. Most vector operations, like most Java scalar operators, treat primitive values as atomic values, but some operations reveal the internal bit-string structure. \u003c/p\u003e\n\u003cp\u003e When a vector is loaded from or stored into memory, the order of vector lanes is \u003cem\u003ealways consistent \u003c/em\u003e with the inherent ordering of the memory container. This is true whether or not individual lane elements are subject to \"byte swapping\" due to details of byte order. Thus, while the scalar lane elements of vector might be \"byte swapped\", the lanes themselves are never reordered, except by an explicit method call that performs cross-lane reordering. \u003c/p\u003e\n\u003cp\u003e When vector lane values are stored to Java variables of the same type, byte swapping is performed if and only if the implementation of the vector hardware requires such swapping. It is therefore unconditional and invisible. \u003c/p\u003e\n\u003cp\u003e As a useful fiction, this API presents a consistent illusion that vector lane bytes are composed into larger lane scalars in \u003cem\u003elittle endian order\u003c/em\u003e. This means that storing a vector into a Java byte array will reveal the successive bytes of the vector lane values in little-endian order on all platforms, regardless of native memory order, and also regardless of byte order (if any) within vector unit registers. \u003c/p\u003e\n\u003cp\u003e This hypothetical little-endian ordering also appears when a \u003ca href\u003d\"#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003ereinterpretation cast\u003c/a\u003e is applied in such a way that lane boundaries are discarded and redrawn differently, while maintaining vector bits unchanged. In such an operation, two adjacent lanes will contribute bytes to a single new lane (or vice versa), and the sequential order of the two lanes will determine the arithmetic order of the bytes in the single lane. In this case, the little-endian convention provides portable results, so that on all platforms earlier lanes tend to contribute lower (rightward) bits, and later lanes tend to contribute higher (leftward) bits. The \u003ca href\u003d\"#reinterpretAsBytes()\"\u003ereinterpretation casts\u003c/a\u003e between \u003ca href\u003d\"ByteVector.html\" title\u003d\"class in jdk.incubator.vector\"\u003e\u003ccode\u003eByteVector\u003c/code\u003e\u003c/a\u003es and the other non-byte vectors use this convention to clarify their portable semantics. \u003c/p\u003e\n\u003cp\u003e The little-endian fiction for relating lane order to per-lane byte order is slightly preferable to an equivalent big-endian fiction, because some related formulas are much simpler, specifically those which renumber bytes after lane structure changes. The earliest byte is invariantly earliest across all lane structure changes, but only if little-endian convention are used. The root cause of this is that bytes in scalars are numbered from the least significant (rightmost) to the most significant (leftmost), and almost never vice-versa. If we habitually numbered sign bits as zero (as on some computers) then this API would reach for big-endian fictions to create unified addressing of vector bytes. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"memory\"\u003e\u003c/a\u003eMemory operations\u003c/h2\u003e As was already mentioned, vectors can be loaded from memory and stored back. An optional mask can control which individual memory locations are read from or written to. The shape of a vector determines how much memory it will occupy. An implementation typically has the property, in the absence of masking, that lanes are stored as a dense sequence of back-to-back values in memory, the same as a dense (gap-free) series of single scalar values in an array of the scalar type. In such cases memory order corresponds exactly to lane order. The first vector lane value occupies the first position in memory, and so on, up to the length of the vector. Further, the memory order of stored vector lanes corresponds to increasing index values in a Java array or in a \n\u003ca href\u003d\"../../../../java.base/java/nio/ByteBuffer.html\" title\u003d\"class in java.nio\"\u003e\u003ccode\u003eByteBuffer\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003e Byte order for lane storage is chosen such that the stored vector values can be read or written as single primitive values, within the array or buffer that holds the vector, producing the same values as the lane-wise values within the vector. This fact is independent of the convenient fiction that lane values inside of vectors are stored in little-endian order. \u003c/p\u003e\n\u003cp\u003e For example, \u003ca href\u003d\"FloatVector.html#fromArray(jdk.incubator.vector.VectorSpecies,float%5B%5D,int)\"\u003e\u003ccode\u003eFloatVector.fromArray(fsp,fa,i)\u003c/code\u003e\u003c/a\u003e creates and returns a float vector of some particular species \u003ccode\u003efsp\u003c/code\u003e, with elements loaded from some float array \u003ccode\u003efa\u003c/code\u003e. The first lane is loaded from \u003ccode\u003efa[i]\u003c/code\u003e and the last lane is initialized loaded from \u003ccode\u003efa[i+VL-1]\u003c/code\u003e, where \u003ccode\u003eVL\u003c/code\u003e is the length of the vector as derived from the species \u003ccode\u003efsp\u003c/code\u003e. Then, \u003ca href\u003d\"FloatVector.html#add(jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003efv\u003dfv.add(fv2)\u003c/code\u003e\u003c/a\u003e will produce another float vector of that species \u003ccode\u003efsp\u003c/code\u003e, given a vector \u003ccode\u003efv2\u003c/code\u003e of the same species \u003ccode\u003efsp\u003c/code\u003e. Next, \u003ca href\u003d\"FloatVector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,float)\"\u003e\u003ccode\u003emnz\u003dfv.compare(NE, 0.0f)\u003c/code\u003e\u003c/a\u003e tests whether the result is zero, yielding a mask \u003ccode\u003emnz\u003c/code\u003e. The non-zero lanes (and only those lanes) can then be stored back into the original array elements using the statement \u003ca href\u003d\"FloatVector.html#intoArray(float%5B%5D,int,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003efv.intoArray(fa,i,mnz)\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"expansion\"\u003e\u003c/a\u003eExpansions, contractions, and partial results\u003c/h2\u003e Since vectors are fixed in size, occasions often arise where the logical result of an operation is not the same as the physical size of the proposed output vector. To encourage user code that is as portable and predictable as possible, this API has a systematic approach to the design of such \n\u003cem\u003eresizing\u003c/em\u003e vector operations. \n\u003cp\u003e As a basic principle, lane-wise operations are \u003cem\u003elength-invariant\u003c/em\u003e. Length-invariance simply means that if \u003ccode\u003eVLENGTH\u003c/code\u003e lanes go into an operation, the same number of lanes come out, with nothing discarded and no extra padding. \u003c/p\u003e\n\u003cp\u003e As a second principle, sometimes in tension with the first, lane-wise operations are also \u003cem\u003eshape-invariant\u003c/em\u003e, unless clearly marked otherwise. Shape-invariance means that \u003ccode\u003eVSHAPE\u003c/code\u003e is constant for typical computations. Keeping the same shape throughout a computation helps ensure that scarce vector resources are efficiently used. (On some hardware platforms shape changes could cause unwanted effects like extra data movement instructions, round trips through memory, or pipeline bubbles.) \u003c/p\u003e\n\u003cp\u003e Tension between these principles arises when an operation produces a \u003cem\u003elogical result\u003c/em\u003e that is too large for the required output \u003ccode\u003eVSHAPE\u003c/code\u003e. In other cases, when a logical result is smaller than the capacity of the output \u003ccode\u003eVSHAPE\u003c/code\u003e, the positioning of the logical result is open to question, since the physical output vector must contain a mix of logical result and padding. \u003c/p\u003e\n\u003cp\u003e In the first case, of a too-large logical result being crammed into a too-small output \u003ccode\u003eVSHAPE\u003c/code\u003e, we say that data has \u003cem\u003eexpanded\u003c/em\u003e. In other words, an \u003cem\u003eexpansion operation\u003c/em\u003e has caused the output shape to overflow. Symmetrically, in the second case of a small logical result fitting into a roomy output \u003ccode\u003eVSHAPE\u003c/code\u003e, the data has \u003cem\u003econtracted\u003c/em\u003e, and the \u003cem\u003econtraction operation\u003c/em\u003e has required the output shape to pad itself with extra zero lanes. \u003c/p\u003e\n\u003cp\u003e In both cases we can speak of a parameter \u003ccode\u003eM\u003c/code\u003e which measures the \u003cem\u003eexpansion ratio\u003c/em\u003e or \u003cem\u003econtraction ratio\u003c/em\u003e between the logical result size (in bits) and the bit-size of the actual output shape. When vector shapes are changed, and lane sizes are not, \u003ccode\u003eM\u003c/code\u003e is just the integral ratio of the output shape to the logical result. (With the possible exception of the \u003ca href\u003d\"VectorShape.html#S_Max_BIT\"\u003emaximum shape\u003c/a\u003e, all vector sizes are powers of two, and so the ratio \u003ccode\u003eM\u003c/code\u003e is always an integer. In the hypothetical case of a non-integral ratio, the value \u003ccode\u003eM\u003c/code\u003e would be rounded up to the next integer, and then the same general considerations would apply.) \u003c/p\u003e\n\u003cp\u003e If the logical result is larger than the physical output shape, such a shape change must inevitably drop result lanes (all but \u003ccode\u003e1/M\u003c/code\u003e of the logical result). If the logical size is smaller than the output, the shape change must introduce zero-filled lanes of padding (all but \u003ccode\u003e1/M\u003c/code\u003e of the physical output). The first case, with dropped lanes, is an expansion, while the second, with padding lanes added, is a contraction. \u003c/p\u003e\n\u003cp\u003e Similarly, consider a lane-wise conversion operation which leaves the shape invariant but changes the lane size by a ratio of \u003ccode\u003eM\u003c/code\u003e. If the logical result is larger than the output (or input), this conversion must reduce the \u003ccode\u003eVLENGTH\u003c/code\u003e lanes of the output by \u003ccode\u003eM\u003c/code\u003e, dropping all but \u003ccode\u003e1/M\u003c/code\u003e of the logical result lanes. As before, the dropping of lanes is the hallmark of an expansion. A lane-wise operation which contracts lane size by a ratio of \u003ccode\u003eM\u003c/code\u003e must increase the \u003ccode\u003eVLENGTH\u003c/code\u003e by the same factor \u003ccode\u003eM\u003c/code\u003e, filling the extra lanes with a zero padding value; because padding must be added this is a contraction. \u003c/p\u003e\n\u003cp\u003e It is also possible (though somewhat confusing) to change both lane size and container size in one operation which performs both lane conversion \u003cem\u003eand\u003c/em\u003e reshaping. If this is done, the same rules apply, but the logical result size is the product of the input size times any expansion or contraction ratio from the lane change size. \u003c/p\u003e\n\u003cp\u003e For completeness, we can also speak of \u003cem\u003ein-place operations\u003c/em\u003e for the frequent case when resizing does not occur. With an in-place operation, the data is simply copied from logical output to its physical container with no truncation or padding. The ratio parameter \u003ccode\u003eM\u003c/code\u003e in this case is unity. \u003c/p\u003e\n\u003cp\u003e Note that the classification of contraction vs. expansion depends on the relative sizes of the logical result and the physical output container. The size of the input container may be larger or smaller than either of the other two values, without changing the classification. For example, a conversion from a 128-bit shape to a 256-bit shape will be a contraction in many cases, but it would be an expansion if it were combined with a conversion from \u003ccode\u003ebyte\u003c/code\u003e to \u003ccode\u003elong\u003c/code\u003e, since in that case the logical result would be 1024 bits in size. This example also illustrates that a logical result does not need to correspond to any particular platform-supported vector shape. \u003c/p\u003e\n\u003cp\u003e Although lane-wise masked operations can be viewed as producing partial operations, they are not classified (in this API) as expansions or contractions. A masked load from an array surely produces a partial vector, but there is no meaningful \"logical output vector\" that this partial result was contracted from. \u003c/p\u003e\n\u003cp\u003e Some care is required with these terms, because it is the \u003cem\u003edata\u003c/em\u003e, not the \u003cem\u003econtainer size\u003c/em\u003e, that is expanding or contracting, relative to the size of its output container. Thus, resizing a 128-bit input into 512-bit vector has the effect of a \u003cem\u003econtraction\u003c/em\u003e. Though the 128 bits of payload hasn\u0027t changed in size, we can say it \"looks smaller\" in its new 512-bit home, and this will capture the practical details of the situation. \u003c/p\u003e\n\u003cp\u003e If a vector method might expand its data, it accepts an extra \u003ccode\u003eint\u003c/code\u003e parameter called \u003ccode\u003epart\u003c/code\u003e, or the \"part number\". The part number must be in the range \u003ccode\u003e[0..M-1]\u003c/code\u003e, where \u003ccode\u003eM\u003c/code\u003e is the expansion ratio. The part number selects one of \u003ccode\u003eM\u003c/code\u003e contiguous disjoint equally-sized blocks of lanes from the logical result and fills the physical output vector with this block of lanes. \u003c/p\u003e\n\u003cp\u003e Specifically, the lanes selected from the logical result of an expansion are numbered in the range \u003ccode\u003e[R..R+L-1]\u003c/code\u003e, where \u003ccode\u003eL\u003c/code\u003e is the \u003ccode\u003eVLENGTH\u003c/code\u003e of the physical output vector, and the origin of the block, \u003ccode\u003eR\u003c/code\u003e, is \u003ccode\u003epart*L\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e A similar convention applies to any vector method that might contract its data. Such a method also accepts an extra part number parameter (again called \u003ccode\u003epart\u003c/code\u003e) which steers the contracted data lanes one of \u003ccode\u003eM\u003c/code\u003e contiguous disjoint equally-sized blocks of lanes in the physical output vector. The remaining lanes are filled with zero, or as specified by the method. \u003c/p\u003e\n\u003cp\u003e Specifically, the data is steered into the lanes numbered in the range \u003ccode\u003e[R..R+L-1]\u003c/code\u003e, where \u003ccode\u003eL\u003c/code\u003e is the \u003ccode\u003eVLENGTH\u003c/code\u003e of the logical result vector, and the origin of the block, \u003ccode\u003eR\u003c/code\u003e, is again a multiple of \u003ccode\u003eL\u003c/code\u003e selected by the part number, specifically \u003ccode\u003e|part|*L\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e In the case of a contraction, the part number must be in the non-positive range \u003ccode\u003e[-M+1..0]\u003c/code\u003e. This convention is adopted because some methods can perform both expansions and contractions, in a data-dependent manner, and the extra sign on the part number serves as an error check. If vector method takes a part number and is invoked to perform an in-place operation (neither contracting nor expanding), the \u003ccode\u003epart\u003c/code\u003e parameter must be exactly zero. Part numbers outside the allowed ranges will elicit an indexing exception. Note that in all cases a zero part number is valid, and corresponds to an operation which preserves as many lanes as possible from the beginning of the logical result, and places them into the beginning of the physical output container. This is often a desirable default, so a part number of zero is safe in all cases and useful in most cases. \u003c/p\u003e\n\u003cp\u003e The various resizing operations of this API contract or expand their data as follows: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003ca href\u003d\"#convert(jdk.incubator.vector.VectorOperators.Conversion,int)\"\u003e\u003ccode\u003eVector.convert()\u003c/code\u003e\u003c/a\u003e will expand (respectively, contract) its operand by ratio \u003ccode\u003eM\u003c/code\u003e if the \u003ca href\u003d\"#elementSize()\"\u003eelement size\u003c/a\u003e of its output is larger (respectively, smaller) by a factor of \u003ccode\u003eM\u003c/code\u003e. If the element sizes of input and output are the same, then \u003ccode\u003econvert()\u003c/code\u003e is an in-place operation. \u003c/li\u003e\n \u003cli\u003e \u003ca href\u003d\"#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003eVector.convertShape()\u003c/code\u003e\u003c/a\u003e will expand (respectively, contract) its operand by ratio \u003ccode\u003eM\u003c/code\u003e if the bit-size of its logical result is larger (respectively, smaller) than the bit-size of its output shape. The size of the logical result is defined as the \u003ca href\u003d\"#elementSize()\"\u003eelement size\u003c/a\u003e of the output, times the \u003ccode\u003eVLENGTH\u003c/code\u003e of its input. Depending on the ratio of the changed lane sizes, the logical size may be (in various cases) either larger or smaller than the input vector, independently of whether the operation is an expansion or contraction. \u003c/li\u003e\n \u003cli\u003e Since \u003ca href\u003d\"#castShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003eVector.castShape()\u003c/code\u003e\u003c/a\u003e is a convenience method for \u003ccode\u003econvertShape()\u003c/code\u003e, its classification as an expansion or contraction is the same as for \u003ccode\u003econvertShape()\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003e \u003ca href\u003d\"#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003eVector.reinterpretShape()\u003c/code\u003e\u003c/a\u003e is an expansion (respectively, contraction) by ratio \u003ccode\u003eM\u003c/code\u003e if the \u003ca href\u003d\"#bitSize()\"\u003evector bit-size\u003c/a\u003e of its input is crammed into a smaller (respectively, dropped into a larger) output container by a factor of \u003ccode\u003eM\u003c/code\u003e. Otherwise it is an in-place operation. Since this method is a reinterpretation cast that can erase and redraw lane boundaries as well as modify shape, the input vector\u0027s lane size and lane count are irrelevant to its classification as expanding or contracting. \u003c/li\u003e\n \u003cli\u003e The \u003ca href\u003d\"#unslice(int,jdk.incubator.vector.Vector,int)\"\u003e\u003ccode\u003eunslice()\u003c/code\u003e\u003c/a\u003e methods expand by a ratio of \u003ccode\u003eM\u003d2\u003c/code\u003e, because the single input slice is positioned and inserted somewhere within two consecutive background vectors. The part number selects the first or second background vector, as updated by the inserted slice. Note that the corresponding \u003ca href\u003d\"#slice(int,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eslice()\u003c/code\u003e\u003c/a\u003e methods, although inverse to the \u003ccode\u003eunslice()\u003c/code\u003e methods, do not contract their data and thus require no part number. This is because \u003ccode\u003eslice()\u003c/code\u003e delivers a slice of exactly \u003ccode\u003eVLENGTH\u003c/code\u003e lanes extracted from two input vectors. \u003c/li\u003e\n\u003c/ul\u003e The method \n\u003ca href\u003d\"VectorSpecies.html#partLimit(jdk.incubator.vector.VectorSpecies,boolean)\"\u003e\u003ccode\u003epartLimit()\u003c/code\u003e\u003c/a\u003e on \n\u003ca href\u003d\"VectorSpecies.html\" title\u003d\"interface in jdk.incubator.vector\"\u003e\u003ccode\u003eVectorSpecies\u003c/code\u003e\u003c/a\u003e can be used, before any expanding or contracting operation is performed, to query the limiting value on a part parameter for a proposed expansion or contraction. The value returned from \n\u003ccode\u003epartLimit()\u003c/code\u003e is positive for expansions, negative for contractions, and zero for in-place operations. Its absolute value is the parameter \n\u003ccode\u003e M\u003c/code\u003e, and so it serves as an exclusive limit on valid part number arguments for the relevant methods. Thus, for expansions, the \n\u003ccode\u003epartLimit()\u003c/code\u003e value \n\u003ccode\u003eM\u003c/code\u003e is the exclusive upper limit for part numbers, while for contractions the \n\u003ccode\u003epartLimit()\u003c/code\u003e value \n\u003ccode\u003e-M\u003c/code\u003e is the exclusive \n\u003cem\u003elower\u003c/em\u003e limit. \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"cross-lane\"\u003e\u003c/a\u003eMoving data across lane boundaries\u003c/h2\u003e The cross-lane methods which do not redraw lanes or change species are more regularly structured and easier to reason about. These operations are: \n\u003cul\u003e \n \u003cli\u003eThe \u003ca href\u003d\"#slice(int,jdk.incubator.vector.Vector)\"\u003e\u003ccode\u003eslice()\u003c/code\u003e\u003c/a\u003e family of methods, which extract contiguous slice of \u003ccode\u003eVLENGTH\u003c/code\u003e fields from a given origin point within a concatenated pair of vectors. \u003c/li\u003e\n \u003cli\u003eThe \u003ca href\u003d\"#unslice(int,jdk.incubator.vector.Vector,int)\"\u003e\u003ccode\u003eunslice()\u003c/code\u003e\u003c/a\u003e family of methods, which insert a contiguous slice of \u003ccode\u003eVLENGTH\u003c/code\u003e fields into a concatenated pair of vectors at a given origin point. \u003c/li\u003e\n \u003cli\u003eThe \u003ca href\u003d\"#rearrange(jdk.incubator.vector.VectorShuffle)\"\u003e\u003ccode\u003erearrange()\u003c/code\u003e\u003c/a\u003e family of methods, which select an arbitrary set of \u003ccode\u003eVLENGTH\u003c/code\u003e lanes from one or two input vectors, and assemble them in an arbitrary order. The selection and order of lanes is controlled by a \u003ccode\u003eVectorShuffle\u003c/code\u003e object, which acts as an routing table mapping source lanes to destination lanes. A \u003ccode\u003eVectorShuffle\u003c/code\u003e can encode a mathematical permutation as well as many other patterns of data movement. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e Some vector operations are not lane-wise, but rather move data across lane boundaries. Such operations are typically rare in SIMD code, though they are sometimes necessary for specific algorithms that manipulate data formats at a low level, and/or require SIMD data to move in complex local patterns. (Local movement in a small window of a large array of data is relatively unusual, although some highly patterned algorithms call for it.) In this API such methods are always clearly recognizable, so that simpler lane-wise reasoning can be confidently applied to the rest of the code. \u003c/p\u003e\n\u003cp\u003e In some cases, vector lane boundaries are discarded and \"redrawn from scratch\", so that data in a given input lane might appear (in several parts) distributed through several output lanes, or (conversely) data from several input lanes might be consolidated into a single output lane. The fundamental method which can redraw lanes boundaries is \u003ca href\u003d\"#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)\"\u003e\u003ccode\u003ereinterpretShape()\u003c/code\u003e\u003c/a\u003e. Built on top of this method, certain convenience methods such as \u003ca href\u003d\"#reinterpretAsBytes()\"\u003e\u003ccode\u003ereinterpretAsBytes()\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"#reinterpretAsInts()\"\u003e\u003ccode\u003ereinterpretAsInts()\u003c/code\u003e\u003c/a\u003e will (potentially) redraw lane boundaries, while retaining the same overall vector shape. \u003c/p\u003e\n\u003cp\u003e Operations which produce or consume a scalar result can be viewed as very simple cross-lane operations. Methods in the \u003ca href\u003d\"#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative)\"\u003e\u003ccode\u003ereduceLanes()\u003c/code\u003e\u003c/a\u003e family fold together all lanes (or mask-selected lanes) of a method and return a single result. As an inverse, the \u003ca href\u003d\"#broadcast(long)\"\u003e\u003ccode\u003ebroadcast\u003c/code\u003e\u003c/a\u003e family of methods can be thought of as crossing lanes in the other direction, from a scalar to all lanes of the output vector. Single-lane access methods such as \u003ccode\u003elane(I)\u003c/code\u003e or \u003ccode\u003ewithLane(I,E)\u003c/code\u003e might also be regarded as very simple cross-lane operations. \u003c/p\u003e\n\u003cp\u003e Likewise, a method which moves a non-byte vector to or from a byte array could be viewed as a cross-lane operation, because the vector lanes must be distributed into separate bytes, or (in the other direction) consolidated from array bytes.\u003c/p\u003e",
  "tagMap": {
    "implNote": [
      "\u003ch2\u003eHardware platform dependencies and limitations\u003c/h2\u003e The Vector API is to accelerate computations in style of Single Instruction Multiple Data (SIMD), using available hardware resources such as vector hardware registers and vector hardware instructions. The API is designed to make effective use of multiple SIMD hardware platforms. \n\u003cp\u003e This API will also work correctly even on Java platforms which do not include specialized hardware support for SIMD computations. The Vector API is not likely to provide any special performance benefit on such platforms. \u003c/p\u003e\n\u003cp\u003e Currently the implementation is optimized to work best on: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e Intel x64 platforms supporting at least AVX2 up to AVX-512. Masking using mask registers and mask accepting hardware instructions on AVX-512 are not currently supported. \u003c/li\u003e\n \u003cli\u003e ARM AArch64 platforms supporting NEON. Although the API has been designed to ensure ARM SVE instructions can be supported (vector sizes between 128 to 2048 bits) there is currently no implementation of such instructions and the general masking capability. \u003c/li\u003e\n\u003c/ul\u003e The implementation currently supports masked lane-wise operations in a cross-platform manner by composing the unmasked lane-wise operation with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)\"\u003e\u003ccode\u003eblend\u003c/code\u003e\u003c/a\u003e as in the expression \n\u003ccode\u003ea.blend(a.lanewise(op, b), m)\u003c/code\u003e, where \n\u003ccode\u003ea\u003c/code\u003e and \n\u003ccode\u003eb\u003c/code\u003e are vectors, \n\u003ccode\u003eop\u003c/code\u003e is the vector operation, and \n\u003ccode\u003em\u003c/code\u003e is the mask. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The implementation does not currently support optimal vectorized instructions for floating point transcendental functions (such as operators \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#SIN\"\u003e\u003ccode\u003eSIN\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/VectorOperators.html#LOG\"\u003e\u003ccode\u003eLOG\u003c/code\u003e\u003c/a\u003e). \u003c/p\u003e\n\u003ch2\u003eNo boxing of primitives\u003c/h2\u003e Although a vector type like \n\u003ccode\u003eVector\u0026lt;Integer\u0026gt;\u003c/code\u003e may seem to work with boxed \n\u003ccode\u003eInteger\u003c/code\u003e values, the overheads associated with boxing are avoided by having each vector subtype work internally on lane values of the actual \n\u003ccode\u003eETYPE\u003c/code\u003e, such as \n\u003ccode\u003eint\u003c/code\u003e. \n\u003ch2\u003eValue-based classes and identity operations\u003c/h2\u003e \n\u003ccode\u003eVector\u003c/code\u003e, along with all of its subtypes and many of its helper types like \n\u003ccode\u003eVectorMask\u003c/code\u003e and \n\u003ccode\u003eVectorShuffle\u003c/code\u003e, is a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e class. \n\u003cp\u003e Once created, a vector is never mutated, not even if only \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/IntVector.html#withLane(int,int)\"\u003ea single lane is changed\u003c/a\u003e. A new vector is always created to hold a new configuration of lane values. The unavailability of mutative methods is a necessary consequence of suppressing the object identity of all vectors, as value-based classes. \u003c/p\u003e\n\u003cp\u003e With \u003ccode\u003eVector\u003c/code\u003e, \n \u003c!-- The following paragraph is shared verbatim\n   -- between Vector.java and package-info.java --\u003e identity-sensitive operations such as \u003ccode\u003e\u003d\u003d\u003c/code\u003e may yield unpredictable results, or reduced performance. Oddly enough, \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/Vector.html#equals(java.lang.Object)\"\u003e\u003ccode\u003ev.equals(w)\u003c/code\u003e\u003c/a\u003e is likely to be faster than \u003ccode\u003ev\u003d\u003dw\u003c/code\u003e, since \u003ccode\u003eequals\u003c/code\u003e is \u003cem\u003enot\u003c/em\u003e an identity sensitive method. Also, these objects can be stored in locals and parameters and as \u003ccode\u003estatic final\u003c/code\u003e constants, but storing them in other Java fields or in array elements, while semantically valid, may incur performance penalties. \n \u003c!-- The preceding paragraph is shared verbatim\n   -- between Vector.java and package-info.java --\u003e\u003c/p\u003e"
    ]
  }
}