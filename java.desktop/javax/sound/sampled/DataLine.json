{
  "packageName": "javax.sound.sampled",
  "simpleName": "DataLine",
  "moduleName": "java.desktop",
  "type": "INTERFACE",
  "superClass": {
    "name": "javax.sound.sampled.Line",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "drain",
      "comment": "Drains queued data from the line by continuing data I/O until the data line\u0027s internal buffer has been emptied. This method blocks until the draining is complete. Because this is a blocking method, it should be used with care. If drain() is invoked on a stopped line that has data in its queue, the method will block until the line is running and the data queue becomes empty. If drain() is invoked by one thread, and another continues to fill the data queue, the operation will not complete. This method always returns when the data line is closed.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#flush()\"\u003e\u003ccode\u003eflush()\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "flush",
      "comment": "Flushes queued data from the line. The flushed data is discarded. In some cases, not all queued data can be discarded. For example, a mixer can flush data from the buffer for a specific input line, but any unplayed data already in the output buffer (the result of the mix) will still be played. You can invoke this method after pausing a line (the normal case) if you want to skip the \"stale\" data when you restart playback or capture. (It is legal to flush a line that is not stopped, but doing so on an active line is likely to cause a discontinuity in the data, resulting in a perceptible click.)",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#stop()\"\u003e\u003ccode\u003estop()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#drain()\"\u003e\u003ccode\u003edrain()\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "start",
      "comment": "Allows a line to engage in data I/O. If invoked on a line that is already running, this method does nothing. Unless the data in the buffer has been flushed, the line resumes I/O starting with the first frame that was unprocessed at the time the line was stopped. When audio capture or playback starts, a START event is generated.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#stop()\"\u003e\u003ccode\u003estop()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#isRunning()\"\u003e\u003ccode\u003eisRunning()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/LineEvent.html\" title\u003d\"class in javax.sound.sampled\"\u003e\u003ccode\u003eLineEvent\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "stop",
      "comment": "Stops the line. A stopped line should cease I/O activity. If the line is open and running, however, it should retain the resources required to resume activity. A stopped line should retain any audio data in its buffer instead of discarding it, so that upon resumption the I/O can continue where it left off, if possible. (This doesn\u0027t guarantee that there will never be discontinuities beyond the current buffer, of course; if the stopped condition continues for too long, input or output samples might be dropped.) If desired, the retained data can be discarded by invoking the flush method. When audio capture or playback stops, a STOP event is generated.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#start()\"\u003e\u003ccode\u003estart()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#isRunning()\"\u003e\u003ccode\u003eisRunning()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#flush()\"\u003e\u003ccode\u003eflush()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/LineEvent.html\" title\u003d\"class in javax.sound.sampled\"\u003e\u003ccode\u003eLineEvent\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "isRunning",
      "comment": "Indicates whether the line is running. The default is false. An open line begins running when the first data is presented in response to an invocation of the start method, and continues until presentation ceases in response to a call to stop or because playback completes.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#start()\"\u003e\u003ccode\u003estart()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#stop()\"\u003e\u003ccode\u003estop()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the line is running, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "isActive",
      "comment": "Indicates whether the line is engaging in active I/O (such as playback or capture). When an inactive line becomes active, it sends a START event to its listeners. Similarly, when an active line becomes inactive, it sends a STOP event.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/Line.html#isOpen()\"\u003e\u003ccode\u003eLine.isOpen()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/Line.html#addLineListener(javax.sound.sampled.LineListener)\"\u003e\u003ccode\u003eLine.addLineListener(javax.sound.sampled.LineListener)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/Line.html#removeLineListener(javax.sound.sampled.LineListener)\"\u003e\u003ccode\u003eLine.removeLineListener(javax.sound.sampled.LineListener)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/LineEvent.html\" title\u003d\"class in javax.sound.sampled\"\u003e\u003ccode\u003eLineEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/LineListener.html\" title\u003d\"interface in javax.sound.sampled\"\u003e\u003ccode\u003eLineListener\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the line is actively capturing or rendering sound, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.sound.sampled.AudioFormat",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getFormat",
      "comment": "Obtains the current format (encoding, sample rate, number of channels, etc.) of the data line\u0027s audio data. If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the DataLine.Info object, which was used to retrieve this DataLine, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. SourceDataLine.open(AudioFormat)) will override the default format.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/AudioFormat.html\" title\u003d\"class in javax.sound.sampled\"\u003e\u003ccode\u003eAudioFormat\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "current audio data format"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getBufferSize",
      "comment": "Obtains the maximum number of bytes of data that will fit in the data line\u0027s internal buffer. For a source data line, this is the size of the buffer to which data can be written. For a target data line, it is the size of the buffer from which data can be read. Note that the units used are bytes, but will always correspond to an integral number of sample frames of audio data.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the size of the buffer, in bytes"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "available",
      "comment": "Obtains the number of bytes of data currently available to the application for processing in the data line\u0027s internal buffer. For a source data line, this is the amount of data that can be written to the buffer without blocking. For a target data line, this is the amount of data available to be read by the application. For a clip, this value is always 0 because the audio data is loaded into the buffer when the clip is opened, and persists without modification until the clip is closed. Note that the units used are bytes, but will always correspond to an integral number of sample frames of audio data. An application is guaranteed that a read or write operation of up to the number of bytes returned from available() will not block; however, there is no guarantee that attempts to read or write more data will block.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the amount of data available, in bytes"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getFramePosition",
      "comment": "Obtains the current position in the audio data, in sample frames. The frame position measures the number of sample frames captured by, or rendered from, the line since it was opened. This return value will wrap around after 2^31 frames. It is recommended to use getLongFramePosition instead.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/DataLine.html#getLongFramePosition()\"\u003e\u003ccode\u003egetLongFramePosition()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the number of frames already processed since the line was opened"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getLongFramePosition",
      "comment": "Obtains the current position in the audio data, in sample frames. The frame position measures the number of sample frames captured by, or rendered from, the line since it was opened.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the number of frames already processed since the line was opened"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getMicrosecondPosition",
      "comment": "Obtains the current position in the audio data, in microseconds. The microsecond position measures the time corresponding to the number of sample frames captured by, or rendered from, the line since it was opened. The level of precision is not guaranteed. For example, an implementation might calculate the microsecond position from the current frame position and the audio sample frame rate. The precision in microseconds would then be limited to the number of microseconds per sample frame.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the number of microseconds of data processed since the line was opened"
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getLevel",
      "comment": "Obtains the current volume level for the line. This level is a measure of the signal\u0027s current amplitude, and should not be confused with the current setting of a gain control. The range is from 0.0 (silence) to 1.0 (maximum possible amplitude for the sound waveform). The units measure linear amplitude, not decibels.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the current amplitude of the signal in this line, or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/AudioSystem.html#NOT_SPECIFIED\"\u003e\u003ccode\u003eAudioSystem.NOT_SPECIFIED\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    }
  ],
  "innerClasses": [
    "javax.sound.sampled.DataLine$Info"
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "javax.sound.sampled.DataLine",
  "annotations": [],
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/sound/sampled/LineEvent.html\" title\u003d\"class in javax.sound.sampled\"\u003e\u003ccode\u003eLineEvent\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.3"
    ]
  }
}