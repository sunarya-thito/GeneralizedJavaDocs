{
  "packageName": "javax.swing",
  "simpleName": "JFormattedTextField",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "javax.swing.JTextField",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "COMMIT",
      "comment": "Constant identifying that when focus is lost, commitEdit should be invoked. If in committing the new value a ParseException is thrown, the invalid value will remain.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JFormattedTextField.html#setFocusLostBehavior(int)\"\u003e\u003ccode\u003esetFocusLostBehavior(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.swing.JFormattedTextField.COMMIT\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "COMMIT_OR_REVERT",
      "comment": "Constant identifying that when focus is lost, commitEdit should be invoked. If in committing the new value a ParseException is thrown, the value will be reverted.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JFormattedTextField.html#setFocusLostBehavior(int)\"\u003e\u003ccode\u003esetFocusLostBehavior(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.swing.JFormattedTextField.COMMIT_OR_REVERT\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "REVERT",
      "comment": "Constant identifying that when focus is lost, editing value should be reverted to current value set on the JFormattedTextField.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JFormattedTextField.html#setFocusLostBehavior(int)\"\u003e\u003ccode\u003esetFocusLostBehavior(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.swing.JFormattedTextField.REVERT\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "PERSIST",
      "comment": "Constant identifying that when focus is lost, the edited value should be left.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JFormattedTextField.html#setFocusLostBehavior(int)\"\u003e\u003ccode\u003esetFocusLostBehavior(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.swing.JFormattedTextField.PERSIST\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "behavior",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setFocusLostBehavior",
      "comment": "Sets the behavior when focus is lost. This will be one of JFormattedTextField.COMMIT_OR_REVERT, JFormattedTextField.REVERT, JFormattedTextField.COMMIT or JFormattedTextField.PERSIST Note that some AbstractFormatters may push changes as they occur, so that the value of this will have no effect. This will throw an IllegalArgumentException if the object passed in is not one of the afore mentioned values. The default value of this property is JFormattedTextField.COMMIT_OR_REVERT.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "bound",
              "value": true
            },
            {
              "name": "enumerationValues",
              "value": [
                "JFormattedTextField.COMMIT",
                "JFormattedTextField.COMMIT_OR_REVERT",
                "JFormattedTextField.REVERT",
                "JFormattedTextField.PERSIST"
              ]
            },
            {
              "name": "escription",
              "value": "Behavior when component loses focus"
            }
          ]
        }
      ],
      "tagMap": {
        "param": [
          "\u003ccode\u003ebehavior\u003c/code\u003e - Identifies behavior when focus is lost"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if behavior is not one of the known values"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFocusLostBehavior",
      "comment": "Returns the behavior when focus is lost. This will be one of COMMIT_OR_REVERT, COMMIT, REVERT or PERSIST Note that some AbstractFormatters may push changes as they occur, so that the value of this will have no effect.",
      "annotations": [],
      "tagMap": {
        "return": [
          "returns behavior when focus is lost"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.JFormattedTextField$AbstractFormatterFactory",
            "type": "Class"
          },
          "name": "tf",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setFormatterFactory",
      "comment": "Sets the AbstractFormatterFactory. AbstractFormatterFactory is able to return an instance of AbstractFormatter that is used to format a value for display, as well an enforcing an editing policy. If you have not explicitly set an AbstractFormatterFactory by way of this method (or a constructor) an AbstractFormatterFactory and consequently an AbstractFormatter will be used based on the Class of the value. NumberFormatter will be used for Numbers, DateFormatter will be used for Dates, otherwise DefaultFormatter will be used. This is a JavaBeans bound property.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "visualUpdate",
              "value": true
            },
            {
              "name": "escription",
              "value": "AbstractFormatterFactory, responsible for returning an AbstractFormatter that can format the current value."
            }
          ]
        }
      ],
      "tagMap": {
        "param": [
          "\u003ccode\u003etf\u003c/code\u003e - \n\u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e used to lookup instances of \n\u003ccode\u003eAbstractFormatter\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.JFormattedTextField$AbstractFormatterFactory",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFormatterFactory",
      "comment": "Returns the current AbstractFormatterFactory.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JFormattedTextField.html#setFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatterFactory)\"\u003e\u003ccode\u003esetFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatterFactory)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "\u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e used to determine \n\u003ccode\u003eAbstractFormatter\u003c/code\u003es"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.JFormattedTextField$AbstractFormatter",
            "type": "Class"
          },
          "name": "format",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "setFormatter",
      "comment": "Sets the current AbstractFormatter. You should not normally invoke this, instead set the AbstractFormatterFactory or set the value. JFormattedTextField will invoke this as the state of the JFormattedTextField changes and requires the value to be reset. JFormattedTextField passes in the AbstractFormatter obtained from the AbstractFormatterFactory. This is a JavaBeans bound property.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JFormattedTextField.html#setFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatterFactory)\"\u003e\u003ccode\u003esetFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatterFactory)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eformat\u003c/code\u003e - AbstractFormatter to use for formatting"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.JFormattedTextField$AbstractFormatter",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFormatter",
      "comment": "Returns the AbstractFormatter that is used to format and parse the current value.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "visualUpdate",
              "value": true
            },
            {
              "name": "escription",
              "value": "TextFormatter, responsible for formatting the current value"
            }
          ]
        }
      ],
      "tagMap": {
        "return": [
          "AbstractFormatter used for formatting"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "value",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setValue",
      "comment": "Sets the value that will be formatted by an AbstractFormatter obtained from the current AbstractFormatterFactory. If no AbstractFormatterFactory has been specified, this will attempt to create one based on the type of value. The default value of this property is null. This is a JavaBeans bound property.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "visualUpdate",
              "value": true
            },
            {
              "name": "escription",
              "value": "The value to be formatted."
            }
          ]
        }
      ],
      "tagMap": {
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - Current value to display"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getValue",
      "comment": "Returns the last valid value. Based on the editing policy of the AbstractFormatter this may not return the current value. The currently edited value can be obtained by invoking commitEdit followed by getValue.",
      "annotations": [],
      "tagMap": {
        "return": [
          "Last valid value"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.text.ParseException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "commitEdit",
      "comment": "Forces the current value to be taken from the AbstractFormatter and set as the current value. This has no effect if there is no current AbstractFormatter installed.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ParseException.html\" title\u003d\"class in java.text\"\u003eParseException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003eAbstractFormatter\u003c/code\u003e is not able to format the current value"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isEditValid",
      "comment": "Returns true if the current value being edited is valid. The value of this is managed by the current AbstractFormatter, as such there is no public setter for it.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "bound",
              "value": true
            }
          ]
        }
      ],
      "tagMap": {
        "return": [
          "true if the current value being edited is valid."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "invalidEdit",
      "comment": "Invoked when the user inputs an invalid value. This gives the component a chance to provide feedback. The default implementation beeps.",
      "annotations": [],
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.event.InputMethodEvent",
            "type": "Class"
          },
          "name": "e",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "processInputMethodEvent",
      "comment": "Processes any input method events, such as InputMethodEvent.INPUT_METHOD_TEXT_CHANGED or InputMethodEvent.CARET_POSITION_CHANGED.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/event/InputMethodEvent.html\" title\u003d\"class in java.awt.event\"\u003e\u003ccode\u003eInputMethodEvent\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Component.html#processInputMethodEvent(java.awt.event.InputMethodEvent)\"\u003eprocessInputMethodEvent\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Component.html\" title\u003d\"class in java.awt\"\u003eComponent\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ee\u003c/code\u003e - the \n\u003ccode\u003eInputMethodEvent\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.event.FocusEvent",
            "type": "Class"
          },
          "name": "e",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "processFocusEvent",
      "comment": "Processes any focus events, such as FocusEvent.FOCUS_GAINED or FocusEvent.FOCUS_LOST.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/event/FocusEvent.html\" title\u003d\"class in java.awt.event\"\u003e\u003ccode\u003eFocusEvent\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Component.html#processFocusEvent(java.awt.event.FocusEvent)\"\u003eprocessFocusEvent\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Component.html\" title\u003d\"class in java.awt\"\u003eComponent\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ee\u003c/code\u003e - the \n\u003ccode\u003eFocusEvent\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.Action",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getActions",
      "comment": "Fetches the command list for the editor. This is the list of commands supported by the plugged-in UI augmented by the collection of commands that the editor itself supports. These are useful for binding to events, such as in a keymap.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "bound",
              "value": true
            }
          ]
        }
      ],
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JTextField.html#getActions()\"\u003egetActions\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JTextField.html\" title\u003d\"class in javax.swing\"\u003eJTextField\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "the command list"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getUIClassID",
      "comment": "Gets the class ID for a UI.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "bound",
              "value": true
            }
          ]
        }
      ],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JComponent.html#getUIClassID()\"\u003e\u003ccode\u003eJComponent.getUIClassID()\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JTextField.html#getUIClassID()\"\u003egetUIClassID\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JTextField.html\" title\u003d\"class in javax.swing\"\u003eJTextField\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "the string \"FormattedTextFieldUI\""
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.text.Document",
            "type": "Class"
          },
          "name": "doc",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setDocument",
      "comment": "Associates the editor with a text document. The currently registered factory is used to build a view for the document, which gets displayed by the editor after revalidation. A PropertyChange event (\"document\") is propagated to each listener.",
      "annotations": [
        {
          "type": {
            "name": "BeanProperty",
            "type": "Class"
          },
          "values": [
            {
              "name": "expert",
              "value": true
            },
            {
              "name": "escription",
              "value": "the text document model"
            }
          ]
        }
      ],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/JTextComponent.html#getDocument()\"\u003e\u003ccode\u003eJTextComponent.getDocument()\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JTextField.html#setDocument(javax.swing.text.Document)\"\u003esetDocument\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/JTextField.html\" title\u003d\"class in javax.swing\"\u003eJTextField\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003edoc\u003c/code\u003e - the document to display/edit"
        ]
      }
    },
    {
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a JFormattedTextField with no AbstractFormatterFactory. Use setMask or setFormatterFactory to configure the JFormattedTextField to edit a particular type of value.",
      "annotations": [],
      "tagMap": {}
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "value",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a JFormattedTextField with the specified value. This will create an AbstractFormatterFactory based on the type of value.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - Initial value for the JFormattedTextField"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.text.Format",
            "type": "Class"
          },
          "name": "format",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a JFormattedTextField. format is wrapped in an appropriate AbstractFormatter which is then wrapped in an AbstractFormatterFactory.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eformat\u003c/code\u003e - Format used to look up an AbstractFormatter"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.JFormattedTextField$AbstractFormatter",
            "type": "Class"
          },
          "name": "formatter",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a JFormattedTextField with the specified AbstractFormatter. The AbstractFormatter is placed in an AbstractFormatterFactory.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eformatter\u003c/code\u003e - AbstractFormatter to use for formatting."
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.JFormattedTextField$AbstractFormatterFactory",
            "type": "Class"
          },
          "name": "factory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a JFormattedTextField with the specified AbstractFormatterFactory.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003efactory\u003c/code\u003e - AbstractFormatterFactory used for formatting."
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.JFormattedTextField$AbstractFormatterFactory",
            "type": "Class"
          },
          "name": "factory",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "currentValue",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a JFormattedTextField with the specified AbstractFormatterFactory and initial value.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003efactory\u003c/code\u003e - \n\u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e used for formatting.",
          "\u003ccode\u003ecurrentValue\u003c/code\u003e - Initial value to use"
        ]
      }
    }
  ],
  "innerClasses": [
    "javax.swing.JFormattedTextField$AbstractFormatter",
    "javax.swing.JFormattedTextField$AbstractFormatterFactory"
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.swing.JFormattedTextField",
  "comment": "\u003ccode\u003eJFormattedTextField\u003c/code\u003e extends \n\u003ccode\u003eJTextField\u003c/code\u003e adding support for formatting arbitrary values, as well as retrieving a particular object once the user has edited the text. The following illustrates configuring a \n\u003ccode\u003eJFormattedTextField\u003c/code\u003e to edit dates: \n\u003cpre\u003e   JFormattedTextField ftf \u003d new JFormattedTextField();\n   ftf.setValue(new Date());\n \u003c/pre\u003e \n\u003cp\u003e Once a \u003ccode\u003eJFormattedTextField\u003c/code\u003e has been created, you can listen for editing changes by way of adding a \u003ccode\u003ePropertyChangeListener\u003c/code\u003e and listening for \u003ccode\u003ePropertyChangeEvent\u003c/code\u003es with the property name \u003ccode\u003evalue\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eJFormattedTextField\u003c/code\u003e allows configuring what action should be taken when focus is lost. The possible configurations are: \u003c/p\u003e\n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption\u003e\n  Possible JFormattedTextField configurations and their descriptions \n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003eValue \u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003eDescription \u003c/th\u003e\n  \u003c/tr\u003e\n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eJFormattedTextField.REVERT \u003c/th\u003e\n   \u003ctd\u003eRevert the display to match that of \u003ccode\u003egetValue\u003c/code\u003e, possibly losing the current edit. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eJFormattedTextField.COMMIT \u003c/th\u003e\n   \u003ctd\u003eCommits the current value. If the value being edited isn\u0027t considered a legal value by the \u003ccode\u003eAbstractFormatter\u003c/code\u003e that is, a \u003ccode\u003eParseException\u003c/code\u003e is thrown, then the value will not change, and then edited value will persist. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eJFormattedTextField.COMMIT_OR_REVERT \u003c/th\u003e\n   \u003ctd\u003eSimilar to \u003ccode\u003eCOMMIT\u003c/code\u003e, but if the value isn\u0027t legal, behave like \u003ccode\u003eREVERT\u003c/code\u003e. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eJFormattedTextField.PERSIST \u003c/th\u003e\n   \u003ctd\u003eDo nothing, don\u0027t obtain a new \u003ccode\u003eAbstractFormatter\u003c/code\u003e, and don\u0027t update the value. \u003c/td\u003e\n  \u003c/tr\u003e\n \u003c/tbody\u003e \n\u003c/table\u003e The default is \n\u003ccode\u003eJFormattedTextField.COMMIT_OR_REVERT\u003c/code\u003e, refer to \n\u003ca href\u003d\"#setFocusLostBehavior(int)\"\u003e\u003ccode\u003esetFocusLostBehavior(int)\u003c/code\u003e\u003c/a\u003e for more information on this. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eJFormattedTextField\u003c/code\u003e allows the focus to leave, even if the currently edited value is invalid. To lock the focus down while the \u003ccode\u003eJFormattedTextField\u003c/code\u003e is an invalid edit state you can attach an \u003ccode\u003eInputVerifier\u003c/code\u003e. The following code snippet shows a potential implementation of such an \u003ccode\u003eInputVerifier\u003c/code\u003e: \u003c/p\u003e\n\u003cpre\u003e public class FormattedTextFieldVerifier extends InputVerifier {\n     public boolean verify(JComponent input) {\n         if (input instanceof JFormattedTextField) {\n             JFormattedTextField ftf \u003d (JFormattedTextField)input;\n             AbstractFormatter formatter \u003d ftf.getFormatter();\n             if (formatter !\u003d null) {\n                 String text \u003d ftf.getText();\n                 try {\n                      formatter.stringToValue(text);\n                      return true;\n                  } catch (ParseException pe) {\n                      return false;\n                  }\n              }\n          }\n          return true;\n      }\n      public boolean shouldYieldFocus(JComponent input) {\n          return verify(input);\n      }\n  }\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Alternatively, you could invoke \u003ccode\u003ecommitEdit\u003c/code\u003e, which would also commit the value. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eJFormattedTextField\u003c/code\u003e does not do the formatting it self, rather formatting is done through an instance of \u003ccode\u003eJFormattedTextField.AbstractFormatter\u003c/code\u003e which is obtained from an instance of \u003ccode\u003eJFormattedTextField.AbstractFormatterFactory\u003c/code\u003e. Instances of \u003ccode\u003eJFormattedTextField.AbstractFormatter\u003c/code\u003e are notified when they become active by way of the \u003ccode\u003einstall\u003c/code\u003e method, at which point the \u003ccode\u003eJFormattedTextField.AbstractFormatter\u003c/code\u003e can install whatever it needs to, typically a \u003ccode\u003eDocumentFilter\u003c/code\u003e. Similarly when \u003ccode\u003eJFormattedTextField\u003c/code\u003e no longer needs the \u003ccode\u003eAbstractFormatter\u003c/code\u003e, it will invoke \u003ccode\u003euninstall\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eJFormattedTextField\u003c/code\u003e typically queries the \u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e for an \u003ccode\u003eAbstractFormat\u003c/code\u003e when it gains or loses focus. Although this can change based on the focus lost policy. If the focus lost policy is \u003ccode\u003eJFormattedTextField.PERSIST\u003c/code\u003e and the \u003ccode\u003eJFormattedTextField\u003c/code\u003e has been edited, the \u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e will not be queried until the value has been committed. Similarly if the focus lost policy is \u003ccode\u003eJFormattedTextField.COMMIT\u003c/code\u003e and an exception is thrown from \u003ccode\u003estringToValue\u003c/code\u003e, the \u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e will not be queried when focus is lost or gained. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eJFormattedTextField.AbstractFormatter\u003c/code\u003e is also responsible for determining when values are committed to the \u003ccode\u003eJFormattedTextField\u003c/code\u003e. Some \u003ccode\u003eJFormattedTextField.AbstractFormatter\u003c/code\u003es will make new values available on every edit, and others will never commit the value. You can force the current value to be obtained from the current \u003ccode\u003eJFormattedTextField.AbstractFormatter\u003c/code\u003e by way of invoking \u003ccode\u003ecommitEdit\u003c/code\u003e. \u003ccode\u003ecommitEdit\u003c/code\u003e will be invoked whenever return is pressed in the \u003ccode\u003eJFormattedTextField\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e If an \u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e has not been explicitly set, one will be set based on the \u003ccode\u003eClass\u003c/code\u003e of the value type after \u003ccode\u003esetValue\u003c/code\u003e has been invoked (assuming value is non-null). For example, in the following code an appropriate \u003ccode\u003eAbstractFormatterFactory\u003c/code\u003e and \u003ccode\u003eAbstractFormatter\u003c/code\u003e will be created to handle formatting of numbers: \u003c/p\u003e\n\u003cpre\u003e   JFormattedTextField tf \u003d new JFormattedTextField();\n   tf.setValue(100);\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eWarning:\u003c/strong\u003e As the \u003ccode\u003eAbstractFormatter\u003c/code\u003e will typically install a \u003ccode\u003eDocumentFilter\u003c/code\u003e on the \u003ccode\u003eDocument\u003c/code\u003e, and a \u003ccode\u003eNavigationFilter\u003c/code\u003e on the \u003ccode\u003eJFormattedTextField\u003c/code\u003e you should not install your own. If you do, you are likely to see odd behavior in that the editing policy of the \u003ccode\u003eAbstractFormatter\u003c/code\u003e will not be enforced. \u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eWarning:\u003c/strong\u003e Swing is not thread safe. For more information see \u003ca href\u003d\"package-summary.html#threading\"\u003eSwing\u0027s Threading Policy\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eWarning:\u003c/strong\u003e Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeans has been added to the \u003ccode\u003ejava.beans\u003c/code\u003e package. Please see \u003ca href\u003d\"../../java/beans/XMLEncoder.html\" title\u003d\"class in java.beans\"\u003e\u003ccode\u003eXMLEncoder\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.4"
    ]
  }
}