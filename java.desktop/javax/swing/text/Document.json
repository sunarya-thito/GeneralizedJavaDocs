{
  "packageName": "javax.swing.text",
  "simpleName": "Document",
  "moduleName": "java.desktop",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "StreamDescriptionProperty",
      "comment": "The property name for the description of the stream used to initialize the document. This should be used if the document was initialized from a stream and anything is known about the stream.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.swing.text.Document.StreamDescriptionProperty\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "TitleProperty",
      "comment": "The property name for the title of the document, if there is one.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.swing.text.Document.TitleProperty\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getLength",
      "comment": "Returns number of characters of content currently in the document.",
      "annotations": [],
      "tagMap": {
        "return": [
          "number of characters \u0026gt;\u003d 0"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.event.DocumentListener",
            "type": "Class"
          },
          "name": "listener",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addDocumentListener",
      "comment": "Registers the given observer to begin receiving notifications when changes are made to the document.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/Document.html#removeDocumentListener(javax.swing.event.DocumentListener)\"\u003e\u003ccode\u003eremoveDocumentListener(javax.swing.event.DocumentListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - the observer to register"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.event.DocumentListener",
            "type": "Class"
          },
          "name": "listener",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "removeDocumentListener",
      "comment": "Unregisters the given observer from the notification list so it will no longer receive change updates.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/Document.html#addDocumentListener(javax.swing.event.DocumentListener)\"\u003e\u003ccode\u003eaddDocumentListener(javax.swing.event.DocumentListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - the observer to register"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.event.UndoableEditListener",
            "type": "Class"
          },
          "name": "listener",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "addUndoableEditListener",
      "comment": "Registers the given observer to begin receiving notifications when undoable edits are made to the document.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditEvent.html\" title\u003d\"class in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditEvent\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - the observer to register"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.event.UndoableEditListener",
            "type": "Class"
          },
          "name": "listener",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "removeUndoableEditListener",
      "comment": "Unregisters the given observer from the notification list so it will no longer receive updates.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditEvent.html\" title\u003d\"class in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditEvent\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - the observer to register"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getProperty",
      "comment": "Gets the properties associated with the document.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/Document.html#putProperty(java.lang.Object,java.lang.Object)\"\u003e\u003ccode\u003eputProperty(Object, Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ekey\u003c/code\u003e - a non-\n\u003ccode\u003enull\u003c/code\u003e property key"
        ],
        "return": [
          "the properties"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "value",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "putProperty",
      "comment": "Associates a property with the document. Two standard property keys provided are: StreamDescriptionProperty and TitleProperty. Other properties, such as author, may also be defined.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/Document.html#getProperty(java.lang.Object)\"\u003e\u003ccode\u003egetProperty(Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ekey\u003c/code\u003e - the non-\n\u003ccode\u003enull\u003c/code\u003e property key",
          "\u003ccode\u003evalue\u003c/code\u003e - the property value"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.swing.text.BadLocationException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offs",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "len",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "remove",
      "comment": "Removes a portion of the content of the document. This will cause a DocumentEvent of type DocumentEvent.EventType.REMOVE to be sent to the registered DocumentListeners, unless an exception is thrown. The notification will be sent to the listeners by calling the removeUpdate method on the DocumentListeners. To ensure reasonable behavior in the face of concurrency, the event is dispatched after the mutation has occurred. This means that by the time a notification of removal is dispatched, the document has already been updated and any marks created by createPosition have already changed. For a removal, the end of the removal range is collapsed down to the start of the range, and any marks in the removal range are collapsed down to the start of the range. If the Document structure changed as result of the removal, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to a remove. If the Document supports undo/redo, an UndoableEditEvent will also be generated.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/DocumentEvent.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eDocumentEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/DocumentListener.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eDocumentListener\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditEvent.html\" title\u003d\"class in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditListener.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditListener\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eoffs\u003c/code\u003e - the offset from the beginning \u0026gt;\u003d 0",
          "\u003ccode\u003elen\u003c/code\u003e - the number of characters to remove \u0026gt;\u003d 0"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/BadLocationException.html\" title\u003d\"class in javax.swing.text\"\u003eBadLocationException\u003c/a\u003e\u003c/code\u003e - some portion of the removal range was not a valid part of the document. The location in the exception is the first bad position encountered."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.swing.text.BadLocationException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "name": "str",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.text.AttributeSet",
            "type": "Class"
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "insertString",
      "comment": "Inserts a string of content. This will cause a DocumentEvent of type DocumentEvent.EventType.INSERT to be sent to the registered DocumentListers, unless an exception is thrown. The DocumentEvent will be delivered by calling the insertUpdate method on the DocumentListener. The offset and length of the generated DocumentEvent will indicate what change was actually made to the Document. If the Document structure changed as result of the insertion, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to an insertion. If the Document supports undo/redo, an UndoableEditEvent will also be generated.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/DocumentEvent.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eDocumentEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/DocumentListener.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eDocumentListener\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditEvent.html\" title\u003d\"class in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditListener.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditListener\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset into the document to insert the content \u0026gt;\u003d 0. All positions that track change at or after the given location will move.",
          "\u003ccode\u003estr\u003c/code\u003e - the string to insert",
          "\u003ccode\u003ea\u003c/code\u003e - the attributes to associate with the inserted content. This may be null if there are no attributes."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/BadLocationException.html\" title\u003d\"class in javax.swing.text\"\u003eBadLocationException\u003c/a\u003e\u003c/code\u003e - the given insert position is not a valid position within the document"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.swing.text.BadLocationException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "length",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getText",
      "comment": "Fetches the text contained within the given portion of the document.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset into the document representing the desired start of the text \u0026gt;\u003d 0",
          "\u003ccode\u003elength\u003c/code\u003e - the length of the desired string \u0026gt;\u003d 0"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/BadLocationException.html\" title\u003d\"class in javax.swing.text\"\u003eBadLocationException\u003c/a\u003e\u003c/code\u003e - some portion of the given range was not a valid part of the document. The location in the exception is the first bad position encountered."
        ],
        "return": [
          "the text, in a String of length \u0026gt;\u003d 0"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.swing.text.BadLocationException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "length",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "javax.swing.text.Segment",
            "type": "Class"
          },
          "name": "txt",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getText",
      "comment": "Fetches the text contained within the given portion of the document. If the partialReturn property on the txt parameter is false, the data returned in the Segment will be the entire length requested and may or may not be a copy depending upon how the data was stored. If the partialReturn property is true, only the amount of text that can be returned without creating a copy is returned. Using partial returns will give better performance for situations where large parts of the document are being scanned. The following is an example of using the partial return to access the entire document: \n\n   int nleft \u003d doc.getDocumentLength();\n   Segment text \u003d new Segment();\n   int offs \u003d 0;\n   text.setPartialReturn(true);\n   while (nleft \u003e 0) {\n       doc.getText(offs, nleft, text);\n       // do someting with text\n       nleft -\u003d text.count;\n       offs +\u003d text.count;\n   }",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset into the document representing the desired start of the text \u0026gt;\u003d 0",
          "\u003ccode\u003elength\u003c/code\u003e - the length of the desired string \u0026gt;\u003d 0",
          "\u003ccode\u003etxt\u003c/code\u003e - the Segment object to return the text in"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/BadLocationException.html\" title\u003d\"class in javax.swing.text\"\u003eBadLocationException\u003c/a\u003e\u003c/code\u003e - Some portion of the given range was not a valid part of the document. The location in the exception is the first bad position encountered."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.text.Position",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getStartPosition",
      "comment": "Returns a position that represents the start of the document. The position returned can be counted on to track change and stay located at the beginning of the document.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the position"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.text.Position",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getEndPosition",
      "comment": "Returns a position that represents the end of the document. The position returned can be counted on to track change and stay located at the end of the document.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the position"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.text.Position",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.swing.text.BadLocationException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offs",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createPosition",
      "comment": "This method allows an application to mark a place in a sequence of character content. This mark can then be used to tracks change as insertions and removals are made in the content. The policy is that insertions always occur prior to the current position (the most common case) unless the insertion location is zero, in which case the insertion is forced to a position that follows the original position.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffs\u003c/code\u003e - the offset from the start of the document \u0026gt;\u003d 0"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/BadLocationException.html\" title\u003d\"class in javax.swing.text\"\u003eBadLocationException\u003c/a\u003e\u003c/code\u003e - if the given position does not represent a valid location in the associated document"
        ],
        "return": [
          "the position"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.text.Element",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getRootElements",
      "comment": "Returns all of the root elements that are defined. Typically there will be only one document structure, but the interface supports building an arbitrary number of structural projections over the text data. The document can have multiple root elements to support multiple document structures. Some examples might be: Text direction. Lexical token streams. Parse trees. Conversions to formats other than the native format. Modification specifications. Annotations.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the root element"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.swing.text.Element",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getDefaultRootElement",
      "comment": "Returns the root element that views should be based upon, unless some other mechanism for assigning views to element structures is provided.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the root element"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Runnable",
            "type": "Class"
          },
          "name": "r",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "render",
      "comment": "Allows the model to be safely rendered in the presence of concurrency, if the model supports being updated asynchronously. The given runnable will be executed in a way that allows it to safely read the model with no changes while the runnable is being executed. The runnable itself may not make any mutations.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003er\u003c/code\u003e - a \n\u003ccode\u003eRunnable\u003c/code\u003e used to render the model"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "javax.swing.text.Document",
  "comment": "\u003cp\u003e The \u003ccode\u003eDocument\u003c/code\u003e is a container for text that serves as the model for swing text components. The goal for this interface is to scale from very simple needs (a plain text textfield) to complex needs (an HTML or XML document, for example). \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eContent\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003e At the simplest level, text can be modeled as a linear sequence of characters. To support internationalization, the Swing text model uses \u003ca href\u003d\"http://www.unicode.org/\"\u003eunicode\u003c/a\u003e characters. The sequence of characters displayed in a text component is generally referred to as the component\u0027s \u003cem\u003econtent\u003c/em\u003e. \u003c/p\u003e\n\u003cp\u003e To refer to locations within the sequence, the coordinates used are the location between two characters. As the diagram below shows, a location in a text document can be referred to as a position, or an offset. This position is zero-based. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/Document-coord.gif\" alt\u003d\"The following text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e In the example, if the content of a document is the sequence \"The quick brown fox,\" as shown in the preceding diagram, the location just before the word \"The\" is 0, and the location after the word \"The\" and before the whitespace that follows it is 3. The entire sequence of characters in the sequence \"The\" is called a \u003cem\u003erange\u003c/em\u003e. \u003c/p\u003e\n\u003cp\u003eThe following methods give access to the character data that makes up the content. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ca href\u003d\"#getLength()\"\u003e\u003ccode\u003egetLength()\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#getText(int,int)\"\u003e\u003ccode\u003egetText(int, int)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#getText(int,int,javax.swing.text.Segment)\"\u003e\u003ccode\u003egetText(int, int, javax.swing.text.Segment)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eStructure\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003e Text is rarely represented simply as featureless content. Rather, text typically has some sort of structure associated with it. Exactly what structure is modeled is up to a particular Document implementation. It might be as simple as no structure (i.e. a simple text field), or it might be something like diagram below. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/Document-structure.gif\" alt\u003d\"Diagram shows Book-\u003eChapter-\u003eParagraph\"\u003e \u003c/p\u003e\n\u003cp\u003e The unit of structure (i.e. a node of the tree) is referred to by the \u003ca href\u003d\"Element.html\"\u003eElement\u003c/a\u003e interface. Each Element can be tagged with a set of attributes. These attributes (name/value pairs) are defined by the \u003ca href\u003d\"AttributeSet.html\"\u003eAttributeSet\u003c/a\u003e interface. \u003c/p\u003e\n\u003cp\u003eThe following methods give access to the document structure. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ca href\u003d\"#getDefaultRootElement()\"\u003e\u003ccode\u003egetDefaultRootElement()\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#getRootElements()\"\u003e\u003ccode\u003egetRootElements()\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eMutations\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003e All documents need to be able to add and remove simple text. Typically, text is inserted and removed via gestures from a keyboard or a mouse. What effect the insertion or removal has upon the document structure is entirely up to the implementation of the document. \u003c/p\u003e\n\u003cp\u003eThe following methods are related to mutation of the document content: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ca href\u003d\"#insertString(int,java.lang.String,javax.swing.text.AttributeSet)\"\u003e\u003ccode\u003einsertString(int, java.lang.String, javax.swing.text.AttributeSet)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#remove(int,int)\"\u003e\u003ccode\u003eremove(int, int)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#createPosition(int)\"\u003e\u003ccode\u003ecreatePosition(int)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eNotification\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003e Mutations to the \u003ccode\u003eDocument\u003c/code\u003e must be communicated to interested observers. The notification of change follows the event model guidelines that are specified for JavaBeans. In the JavaBeans event model, once an event notification is dispatched, all listeners must be notified before any further mutations occur to the source of the event. Further, order of delivery is not guaranteed. \u003c/p\u003e\n\u003cp\u003e Notification is provided as two separate events, \u003ca href\u003d\"../event/DocumentEvent.html\"\u003eDocumentEvent\u003c/a\u003e, and \u003ca href\u003d\"../event/UndoableEditEvent.html\"\u003eUndoableEditEvent\u003c/a\u003e. If a mutation is made to a \u003ccode\u003eDocument\u003c/code\u003e through its api, a \u003ccode\u003eDocumentEvent\u003c/code\u003e will be sent to all of the registered \u003ccode\u003eDocumentListeners\u003c/code\u003e. If the \u003ccode\u003eDocument\u003c/code\u003e implementation supports undo/redo capabilities, an \u003ccode\u003eUndoableEditEvent\u003c/code\u003e will be sent to all of the registered \u003ccode\u003eUndoableEditListener\u003c/code\u003es. If an undoable edit is undone, a \u003ccode\u003eDocumentEvent\u003c/code\u003e should be fired from the Document to indicate it has changed again. In this case however, there should be no \u003ccode\u003eUndoableEditEvent\u003c/code\u003e generated since that edit is actually the source of the change rather than a mutation to the \u003ccode\u003eDocument\u003c/code\u003e made through its api. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/Document-notification.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e Referring to the above diagram, suppose that the component shown on the left mutates the document object represented by the blue rectangle. The document responds by dispatching a DocumentEvent to both component views and sends an UndoableEditEvent to the listening logic, which maintains a history buffer. \u003c/p\u003e\n\u003cp\u003e Now suppose that the component shown on the right mutates the same document. Again, the document dispatches a DocumentEvent to both component views and sends an UndoableEditEvent to the listening logic that is maintaining the history buffer. \u003c/p\u003e\n\u003cp\u003e If the history buffer is then rolled back (i.e. the last UndoableEdit undone), a DocumentEvent is sent to both views, causing both of them to reflect the undone mutation to the document (that is, the removal of the right component\u0027s mutation). If the history buffer again rolls back another change, another DocumentEvent is sent to both views, causing them to reflect the undone mutation to the document -- that is, the removal of the left component\u0027s mutation. \u003c/p\u003e\n\u003cp\u003e The methods related to observing mutations to the document are: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ca href\u003d\"#addDocumentListener(javax.swing.event.DocumentListener)\"\u003e\u003ccode\u003eaddDocumentListener(DocumentListener)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#removeDocumentListener(javax.swing.event.DocumentListener)\"\u003e\u003ccode\u003eremoveDocumentListener(DocumentListener)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#addUndoableEditListener(javax.swing.event.UndoableEditListener)\"\u003e\u003ccode\u003eaddUndoableEditListener(UndoableEditListener)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#removeUndoableEditListener(javax.swing.event.UndoableEditListener)\"\u003e\u003ccode\u003eremoveUndoableEditListener(UndoableEditListener)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eProperties\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003e Document implementations will generally have some set of properties associated with them at runtime. Two well known properties are the \u003ca href\u003d\"#StreamDescriptionProperty\"\u003eStreamDescriptionProperty\u003c/a\u003e, which can be used to describe where the \u003ccode\u003eDocument\u003c/code\u003e came from, and the \u003ca href\u003d\"#TitleProperty\"\u003eTitleProperty\u003c/a\u003e, which can be used to name the \u003ccode\u003eDocument\u003c/code\u003e. The methods related to the properties are: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ca href\u003d\"#getProperty(java.lang.Object)\"\u003e\u003ccode\u003egetProperty(java.lang.Object)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n \u003cli\u003e\u003ca href\u003d\"#putProperty(java.lang.Object,java.lang.Object)\"\u003e\u003ccode\u003eputProperty(java.lang.Object, java.lang.Object)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eOverview and Programming Tips\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003e\u003cu\u003e\u003ca href\u003d\"Element.html\" title\u003d\"interface in javax.swing.text\"\u003e\u003ccode\u003eElement\u003c/code\u003e\u003c/a\u003e\u003c/u\u003e is an important interface used in constructing a Document. It has the power to describe various structural parts of a document, such as paragraphs, lines of text, or even (in HTML documents) items in lists. Conceptually, the Element interface captures some of the spirit of an SGML document. So if you know SGML, you may already have some understanding of Swing\u0027s Element interface. \u003c/p\u003e\n\u003cp\u003eIn the Swing text API\u0027s document model, the interface Element defines a structural piece of a Document, like a paragraph, a line of text, or a list item in an HTML document. \u003c/p\u003e\n\u003cp\u003eEvery Element is either a \u003ci\u003ebranch\u003c/i\u003e or a \u003ci\u003eleaf\u003c/i\u003e. If an element is a branch, the \u003ccode\u003eisLeaf()\u003c/code\u003e method returns false. If an element is a a leaf, \u003ccode\u003eisLeaf()\u003c/code\u003e returns true. \u003c/p\u003e\n\u003cp\u003eBranches can have any number of children. Leaves do not have children. To determine how many children a branch has, you can call \u003ccode\u003egetElementCount()\u003c/code\u003e. To determine the parent of an Element, you can call \u003ccode\u003egetParentElement()\u003c/code\u003e. Root elements don\u0027t have parents, so calling \u003ccode\u003egetParentElement()\u003c/code\u003e on a root returns null. \u003c/p\u003e\n\u003cp\u003eAn Element represents a specific region in a Document that begins with startOffset and ends just before endOffset. The start offset of a branch Element is usually the start offset of its first child. Similarly, the end offset of a branch Element is usually the end offset of its last child. \u003c/p\u003e\n\u003cp\u003eEvery Element is associated with an AttributeSet that you can access by calling \u003ccode\u003egetAttributes()\u003c/code\u003e. In an Element, and AttributeSet is essentially a set of key/value pairs. These pairs are generally used for markup -- such as determining the Element\u0027s foreground color, font size, and so on. But it is up to the model, and the developer, to determine what is stored in the AttributeSet. \u003c/p\u003e\n\u003cp\u003eYou can obtain the root Element (or Elements) of a Document by calling the methods \u003ccode\u003egetDefaultRootElement()\u003c/code\u003e and \u003ccode\u003egetRootElements()\u003c/code\u003e, which are defined in the Document interface. \u003c/p\u003e\n\u003cp\u003eThe Document interface is responsible for translating a linear view of the characters into Element operations. It is up to each Document implementation to define what the Element structure is. \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eThe PlainDocument class\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eThe \u003cu\u003e\u003ca href\u003d\"PlainDocument.html\" title\u003d\"class in javax.swing.text\"\u003e\u003ccode\u003ePlainDocument\u003c/code\u003e\u003c/a\u003e\u003c/u\u003e class defines an Element structure in which the root node has a child node for each line of text in the model. \u003cu\u003eFigure 1\u003c/u\u003e shows how two lines of text would be modeled by a PlainDocument \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain1.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e\u003cu\u003eFigure 2\u003c/u\u003e shows how how those same two lines of text might map to actual content: \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain2.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eInserting text into a PlainDocument\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eAs just mentioned, a PlainDocument contains a root Element, which in turn contains an Element for each line of text. When text is inserted into a PlainDocument, it creates the Elements that are needed for an Element to exist for each newline. To illustrate, let\u0027s say you wanted to insert a newline at offset 2 in \u003cu\u003eFigure 2\u003c/u\u003e, above. To accomplish this objective, you could use the Document method \u003ccode\u003einsertString()\u003c/code\u003e, using this syntax: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocument.insertString(2, \"\\n\", null);\u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eAfter invoking the \u003ccode\u003einsertString()\u003c/code\u003e method, the Element structure would look like the one shown in \u003cu\u003eFigure 3\u003c/u\u003e. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain3.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003eAs another example, let\u0027s say you wanted to insert the pattern \"new\\ntext\\n\" at offset 2 as shown previously in \u003cu\u003eFigure 2\u003c/u\u003e. This operation would have the result shown in \u003cu\u003eFigure 4\u003c/u\u003e. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain4.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003eIn the preceding illustrations, the name of the line Elements is changed after the insertion to match the line numbers. But notice that when this is done, the AttributeSets remain the same. For example, in \u003cu\u003eFigure 2\u003c/u\u003e, the AttributeSet of Line 2 matches that of the AttributeSet of Line 4 in \u003cu\u003eFigure 4\u003c/u\u003e. \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eRemoving text from a PlainDocument\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eRemoval of text results in a structure change if the deletion spans more than one line. Consider a deletion of seven characters starting at Offset 1 shown previously in \u003cu\u003eFigure 3\u003c/u\u003e. In this case, the Element representing Line 2 is completely removed, as the region it represents is contained in the deleted region. The Elements representing Lines 1 and 3 are joined, as they are partially contained in the deleted region. Thus, we have the result: \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain5.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eThe Default StyledDocument Class\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eThe \u003cu\u003e\u003ca href\u003d\"DefaultStyledDocument.html\" title\u003d\"class in javax.swing.text\"\u003e\u003ccode\u003eDefaultStyledDocument\u003c/code\u003e\u003c/a\u003e\u003c/u\u003e class, used for styled text, contains another level of Elements. This extra level is needed so that each paragraph can contain different styles of text. In the two paragraphs shown in \u003cu\u003eFigure 6\u003c/u\u003e, the first paragraph contains two styles and the second paragraph contains three styles. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain6.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e\u003cu\u003eFigure 7\u003c/u\u003e shows how those same Elements might map to content. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain7.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eInserting text into a DefaultStyledDocument\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eAs previously mentioned, DefaultStyledDocument maintains an Element structure such that the root Element contains a child Element for each paragraph. In turn, each of these paragraph Elements contains an Element for each style of text in the paragraph. As an example, let\u0027s say you had a document containing one paragraph, and that this paragraph contained two styles, as shown in \u003cu\u003eFigure 8\u003c/u\u003e. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain8.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003eIf you then wanted to insert a newline at offset 2, you would again use the method \u003ccode\u003einsertString()\u003c/code\u003e, as follows: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e styledDocument.insertString(2, \"\\n\",\n                styledDocument.getCharacterElement(0).getAttributes());\u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThis operation would have the result shown in \u003cu\u003eFigure 9\u003c/u\u003e. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain9.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003eIt\u0027s important to note that the AttributeSet passed to \u003ccode\u003einsertString()\u003c/code\u003e matches that of the attributes of Style 1. If the AttributeSet passed to \u003ccode\u003einsertString()\u003c/code\u003e did not match, the result would be the situation shown in \u003cu\u003eFigure 10\u003c/u\u003e. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain10.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eRemoving text from a DefaultStyledDocument\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eRemoving text from a DefaultStyledDocument is similar to removing text from a PlainDocument. The only difference is the extra level of Elements. Consider what would happen if you deleted two characters at Offset 1 from Figure 10, above. Since the the second Element of Paragraph 1 is completely contained in the deleted region, it would be removed. Assuming the attributes of Paragraph 1\u0027s first child matched those of Paragraph2\u0027s first child, the results would be those shown in \u003cu\u003eFigure 11\u003c/u\u003e. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain11.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003eIf the attributes did not match, we would get the results shown in \u003cu\u003eFigure 12\u003c/u\u003e. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e\u003cimg src\u003d\"doc-files/plain12.gif\" alt\u003d\"The preceding text describes this graphic.\"\u003e \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eThe StyledDocument Class\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eThe \u003cu\u003e\u003ca href\u003d\"StyledDocument.html\" title\u003d\"interface in javax.swing.text\"\u003e\u003ccode\u003eStyledDocument\u003c/code\u003e\u003c/a\u003e\u003c/u\u003e class provides a method named \u003ccode\u003esetCharacterAttributes()\u003c/code\u003e, which allows you to set the attributes on the character Elements in a given range: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e public void setCharacterAttributes\n          (int offset, int length, AttributeSet s, boolean replace);\u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eRecall that in the diagrams shown in the previous section, all leaf Elements shown in the drawings were also character Elements. That means that the \u003ccode\u003esetCharacterAttributes()\u003c/code\u003e method could be used to set their attributes. \u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003esetCharacterAttributes()\u003c/code\u003e method takes four arguments . The first and second arguments identify a region in the Document that is to be changed. The third argument specifies the new attributes (as an AttributeSet), and the fourth argument determines if the new attributes should be added to the existing attributes (a value of false) or if the character Element should replace its existing attributes with the new attributes (a value of true). \u003c/p\u003e\n\u003cp\u003eAs an example, let\u0027s say you wanted to change the attributes of the first three characters in \u003cu\u003eFigure 9\u003c/u\u003e, shown previously. The first two arguments passed to \u003ccode\u003esetCharacterAttributes()\u003c/code\u003e would be 0 and 3. The third argument would be the AttributeSet containing the new attributes. In the example we are considering, it doesn\u0027t matter what the fourth argument is. \u003c/p\u003e\n\u003cp\u003eAs the start and end offsets of the changed region (0 and 3) fall on character Element boundaries, no structure change is needed. That is, only the attributes of the character Element style 1 will change. \u003c/p\u003e\n\u003cp\u003eNow let\u0027s look at an example that requires a structure change. Instead of changing the first three characters shown in \u003cu\u003eFigure 9\u003c/u\u003e, let\u0027s change the first two characters. Because the end change offset (2) does not fall on a character Element boundary, the Element at offset 2 must be split in such a way that offset 2 is the boundary of two Elements. Invoking \u003ccode\u003esetCharacterAttributes()\u003c/code\u003e with a start offset of 0 and length of 2 has the result shown earlier in \u003cu\u003eFigure 10\u003c/u\u003e. \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eChanging Paragraph Attributes in a StyledDocument\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eThe StyledDocument class provides a method named \u003ccode\u003esetParagraphAttributes()\u003c/code\u003e, which can be used to change the attributes of a paragraph Element: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e public void setParagraphAttributes\n         (int offset, int length, AttributeSet s, boolean replace);\u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThis method is similar to \u003ccode\u003esetCharacterAttributes()\u003c/code\u003e, but it allows you to change the attributes of paragraph Elements. It is up to the implementation of a StyledDocument to define which Elements are paragraphs. DefaultStyledDocument interprets paragraph Elements to be the parent Element of the character Element. Invoking this method does not result in a structure change; only the attributes of the paragraph Element change. \u003c/p\u003e\n\u003cp\u003eIt is recommended to look into \u003ca href\u003d\"EditorKit.html\" title\u003d\"class in javax.swing.text\"\u003e\u003ccode\u003eEditorKit\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"View.html\" title\u003d\"class in javax.swing.text\"\u003e\u003ccode\u003eView\u003c/code\u003e\u003c/a\u003e. View is responsible for rendering a particular Element, and EditorKit is responsible for a ViewFactory that is able to decide what View should be created based on an Element.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/DocumentEvent.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eDocumentEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/DocumentListener.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eDocumentListener\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditEvent.html\" title\u003d\"class in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditEvent\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/event/UndoableEditListener.html\" title\u003d\"interface in javax.swing.event\"\u003e\u003ccode\u003eUndoableEditListener\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/Element.html\" title\u003d\"interface in javax.swing.text\"\u003e\u003ccode\u003eElement\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/Position.html\" title\u003d\"interface in javax.swing.text\"\u003e\u003ccode\u003ePosition\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/AttributeSet.html\" title\u003d\"interface in javax.swing.text\"\u003e\u003ccode\u003eAttributeSet\u003c/code\u003e\u003c/a\u003e"
    ]
  }
}