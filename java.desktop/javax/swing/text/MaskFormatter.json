{
  "packageName": "javax.swing.text",
  "simpleName": "MaskFormatter",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "javax.swing.text.DefaultFormatter",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.text.ParseException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "mask"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setMask",
      "comment": "Sets the mask dictating the legal characters. This will throw a ParseException if mask is not valid.",
      "tagMap": {
        "param": [
          "\u003ccode\u003emask\u003c/code\u003e - the mask"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ParseException.html\" title\u003d\"class in java.text\"\u003eParseException\u003c/a\u003e\u003c/code\u003e - if mask does not contain valid mask characters"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getMask",
      "comment": "Returns the formatting mask.",
      "tagMap": {
        "return": [
          "Mask dictating legal character values."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "validCharacters"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setValidCharacters",
      "comment": "Allows for further restricting of the characters that can be input. Only characters specified in the mask, not in the invalidCharacters, and in validCharacters will be allowed to be input. Passing in null (the default) implies the valid characters are only bound by the mask and the invalid characters.",
      "tagMap": {
        "param": [
          "\u003ccode\u003evalidCharacters\u003c/code\u003e - If non-null, specifies legal characters."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getValidCharacters",
      "comment": "Returns the valid characters that can be input.",
      "tagMap": {
        "return": [
          "Legal characters"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "invalidCharacters"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setInvalidCharacters",
      "comment": "Allows for further restricting of the characters that can be input. Only characters specified in the mask, not in the invalidCharacters, and in validCharacters will be allowed to be input. Passing in null (the default) implies the valid characters are only bound by the mask and the valid characters.",
      "tagMap": {
        "param": [
          "\u003ccode\u003einvalidCharacters\u003c/code\u003e - If non-null, specifies illegal characters."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getInvalidCharacters",
      "comment": "Returns the characters that are not valid for input.",
      "tagMap": {
        "return": [
          "illegal characters."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "placeholder"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setPlaceholder",
      "comment": "Sets the string to use if the value does not completely fill in the mask. A null value implies the placeholder char should be used.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eplaceholder\u003c/code\u003e - String used when formatting if the value does not completely fill the mask"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPlaceholder",
      "comment": "Returns the String to use if the value does not completely fill in the mask.",
      "tagMap": {
        "return": [
          "String used when formatting if the value does not completely fill the mask"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "char",
            "type": "Class"
          },
          "field": {
            "name": "placeholder"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setPlaceholderCharacter",
      "comment": "Sets the character to use in place of characters that are not present in the value, ie the user must fill them in. The default value is a space. This is only applicable if the placeholder string has not been specified, or does not completely fill in the mask.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eplaceholder\u003c/code\u003e - Character used when formatting if the value does not completely fill the mask"
        ]
      }
    },
    {
      "returnType": {
        "name": "char",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPlaceholderCharacter",
      "comment": "Returns the character to use in place of characters that are not present in the value, ie the user must fill them in.",
      "tagMap": {
        "return": [
          "Character used when formatting if the value does not completely fill the mask"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "containsLiteralChars"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setValueContainsLiteralCharacters",
      "comment": "If true, the returned value and set value will also contain the literal characters in mask. For example, if the mask is \u0027(###) ###-####\u0027, the current value is \u0027(415) 555-1212\u0027, and valueContainsLiteralCharacters is true stringToValue will return \u0027(415) 555-1212\u0027. On the other hand, if valueContainsLiteralCharacters is false, stringToValue will return \u00274155551212\u0027.",
      "tagMap": {
        "param": [
          "\u003ccode\u003econtainsLiteralChars\u003c/code\u003e - Used to indicate if literal characters in mask should be returned in stringToValue"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getValueContainsLiteralCharacters",
      "comment": "Returns true if stringToValue should return literal characters in the mask.",
      "tagMap": {
        "return": [
          "True if literal characters in mask should be returned in stringToValue"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.text.ParseException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "stringToValue",
      "comment": "Parses the text, returning the appropriate Object representation of the String value. This strips the literal characters as necessary and invokes supers stringToValue, so that if you have specified a value class (setValueClass) an instance of it will be created. This will throw a ParseException if the value does not match the current mask. Refer to setValueContainsLiteralCharacters(boolean) for details on how literals are treated.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/MaskFormatter.html#setValueContainsLiteralCharacters(boolean)\"\u003e\u003ccode\u003esetValueContainsLiteralCharacters(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/DefaultFormatter.html#stringToValue(java.lang.String)\"\u003estringToValue\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/DefaultFormatter.html\" title\u003d\"class in javax.swing.text\"\u003eDefaultFormatter\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - String to convert"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ParseException.html\" title\u003d\"class in java.text\"\u003eParseException\u003c/a\u003e\u003c/code\u003e - if there is an error in the conversion"
        ],
        "return": [
          "Object representation of text"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.text.ParseException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "valueToString",
      "comment": "Returns a String representation of the Object value based on the mask. Refer to setValueContainsLiteralCharacters(boolean) for details on how literals are treated.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/MaskFormatter.html#setValueContainsLiteralCharacters(boolean)\"\u003e\u003ccode\u003esetValueContainsLiteralCharacters(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/DefaultFormatter.html#valueToString(java.lang.Object)\"\u003evalueToString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/DefaultFormatter.html\" title\u003d\"class in javax.swing.text\"\u003eDefaultFormatter\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - Value to convert"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ParseException.html\" title\u003d\"class in java.text\"\u003eParseException\u003c/a\u003e\u003c/code\u003e - if there is an error in the conversion"
        ],
        "return": [
          "String representation of value"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "javax.swing.JFormattedTextField",
            "type": "Class"
          },
          "field": {
            "name": "ftf"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "install",
      "comment": "Installs the DefaultFormatter onto a particular JFormattedTextField. This will invoke valueToString to convert the current value from the JFormattedTextField to a String. This will then install the Actions from getActions, the DocumentFilter returned from getDocumentFilter and the NavigationFilter returned from getNavigationFilter onto the JFormattedTextField. Subclasses will typically only need to override this if they wish to install additional listeners on the JFormattedTextField. If there is a ParseException in converting the current value to a String, this will set the text to an empty String, and mark the JFormattedTextField as being in an invalid state. While this is a public method, this is typically only useful for subclassers of JFormattedTextField. JFormattedTextField will invoke this method at the appropriate times when the value changes, or its internal state changes.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/DefaultFormatter.html#install(javax.swing.JFormattedTextField)\"\u003einstall\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/text/DefaultFormatter.html\" title\u003d\"class in javax.swing.text\"\u003eDefaultFormatter\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eftf\u003c/code\u003e - JFormattedTextField to format for, may be null indicating uninstall from current JFormattedTextField."
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a MaskFormatter with no mask.",
      "tagMap": {}
    },
    {
      "throwsClasses": [
        {
          "name": "java.text.ParseException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "mask"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a MaskFormatter with the specified mask. A ParseException will be thrown if mask is an invalid mask.",
      "tagMap": {
        "param": [
          "\u003ccode\u003emask\u003c/code\u003e - the mask"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ParseException.html\" title\u003d\"class in java.text\"\u003eParseException\u003c/a\u003e\u003c/code\u003e - if mask does not contain valid mask characters"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.swing.text.MaskFormatter",
  "comment": "\u003ccode\u003eMaskFormatter\u003c/code\u003e is used to format and edit strings. The behavior of a \n\u003ccode\u003eMaskFormatter\u003c/code\u003e is controlled by way of a String mask that specifies the valid characters that can be contained at a particular location in the \n\u003ccode\u003eDocument\u003c/code\u003e model. The following characters can be specified: \n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption\u003e\n  Valid characters and their descriptions\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003eCharacter \u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003eDescription \u003c/th\u003e\n  \u003c/tr\u003e\n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e# \u003c/th\u003e\n   \u003ctd\u003eAny valid number, uses \u003ccode\u003eCharacter.isDigit\u003c/code\u003e. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u0027 \u003c/th\u003e\n   \u003ctd\u003eEscape character, used to escape any of the special formatting characters. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eU \u003c/th\u003e\n   \u003ctd\u003eAny character (\u003ccode\u003eCharacter.isLetter\u003c/code\u003e). All lowercase letters are mapped to upper case. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eL \u003c/th\u003e\n   \u003ctd\u003eAny character (\u003ccode\u003eCharacter.isLetter\u003c/code\u003e). All upper case letters are mapped to lower case. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eA \u003c/th\u003e\n   \u003ctd\u003eAny character or number (\u003ccode\u003eCharacter.isLetter\u003c/code\u003e or \u003ccode\u003eCharacter.isDigit\u003c/code\u003e). \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e? \u003c/th\u003e\n   \u003ctd\u003eAny character (\u003ccode\u003eCharacter.isLetter\u003c/code\u003e). \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e* \u003c/th\u003e\n   \u003ctd\u003eAnything. \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eH \u003c/th\u003e\n   \u003ctd\u003eAny hex character (0-9, a-f or A-F). \u003c/td\u003e\n  \u003c/tr\u003e\n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003e Typically characters correspond to one char, but in certain languages this is not the case. The mask is on a per character basis, and will thus adjust to fit as many chars as are needed. \u003c/p\u003e\n\u003cp\u003e You can further restrict the characters that can be input by the \u003ccode\u003esetInvalidCharacters\u003c/code\u003e and \u003ccode\u003esetValidCharacters\u003c/code\u003e methods. \u003ccode\u003esetInvalidCharacters\u003c/code\u003e allows you to specify which characters are not legal. \u003ccode\u003esetValidCharacters\u003c/code\u003e allows you to specify which characters are valid. For example, the following code block is equivalent to a mask of \u00270xHHH\u0027 with no invalid/valid characters: \u003c/p\u003e\n\u003cpre\u003e MaskFormatter formatter \u003d new MaskFormatter(\"0x***\");\n formatter.setValidCharacters(\"0123456789abcdefABCDEF\");\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e When initially formatting a value if the length of the string is less than the length of the mask, two things can happen. Either the placeholder string will be used, or the placeholder character will be used. Precedence is given to the placeholder string. For example: \u003c/p\u003e\n\u003cpre\u003e   MaskFormatter formatter \u003d new MaskFormatter(\"###-####\");\n   formatter.setPlaceholderCharacter(\u0027_\u0027);\n   formatter.getDisplayValue(tf, \"123\");\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Would result in the string \u0027123-____\u0027. If \u003ccode\u003esetPlaceholder(\"555-1212\")\u003c/code\u003e was invoked \u0027123-1212\u0027 would result. The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used. \u003c/p\u003e\n\u003cp\u003e If a \u003ccode\u003eMaskFormatter\u003c/code\u003e is configured to only allow valid characters (\u003ccode\u003esetAllowsInvalid(false)\u003c/code\u003e) literal characters will be skipped as necessary when editing. Consider a \u003ccode\u003eMaskFormatter\u003c/code\u003e with the mask \"###-####\" and current value \"555-1212\". Using the right arrow key to navigate through the field will result in (| indicates the position of the caret): \u003c/p\u003e\n\u003cpre\u003e   |555-1212\n   5|55-1212\n   55|5-1212\n   555-|1212\n   555-1|212\n \u003c/pre\u003e The \u0027-\u0027 is a literal (non-editable) character, and is skipped. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Similar behavior will result when editing. Consider inserting the string \u0027123-45\u0027 and \u002712345\u0027 into the \u003ccode\u003eMaskFormatter\u003c/code\u003e in the previous example. Both inserts will result in the same String, \u0027123-45__\u0027. When \u003ccode\u003eMaskFormatter\u003c/code\u003e is processing the insert at character position 3 (the \u0027-\u0027), two things can happen: \u003c/p\u003e\n\u003col\u003e \n \u003cli\u003eIf the inserted character is \u0027-\u0027, it is accepted. \u003c/li\u003e\n \u003cli\u003eIf the inserted character matches the mask for the next non-literal character, it is accepted at the new location. \u003c/li\u003e\n \u003cli\u003eAnything else results in an invalid edit \u003c/li\u003e\n\u003c/ol\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e By default \u003ccode\u003eMaskFormatter\u003c/code\u003e will not allow invalid edits, you can change this with the \u003ccode\u003esetAllowsInvalid\u003c/code\u003e method, and will commit edits on valid edits (use the \u003ccode\u003esetCommitsOnValidEdit\u003c/code\u003e to change this). \u003c/p\u003e\n\u003cp\u003e By default, \u003ccode\u003eMaskFormatter\u003c/code\u003e is in overwrite mode. That is as characters are typed a new character is not inserted, rather the character at the current location is replaced with the newly typed character. You can change this behavior by way of the method \u003ccode\u003esetOverwriteMode\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eWarning:\u003c/strong\u003e Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeans has been added to the \u003ccode\u003ejava.beans\u003c/code\u003e package. Please see \u003ca href\u003d\"../../../java/beans/XMLEncoder.html\" title\u003d\"class in java.beans\"\u003e\u003ccode\u003eXMLEncoder\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.4"
    ]
  }
}