{
  "packageName": "javax.swing",
  "simpleName": "SizeSequence",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "sizes"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setSizes",
      "comment": "Resets this SizeSequence object, using the data in the sizes argument. This method reinitializes this object so that it contains as many entries as the sizes array. Each entry\u0027s size is initialized to the value of the corresponding item in sizes.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esizes\u003c/code\u003e - the array of sizes to be contained in this \n\u003ccode\u003eSizeSequence\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getSizes",
      "comment": "Returns the size of all entries.",
      "tagMap": {
        "return": [
          "a new array containing the sizes in this object"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "index"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPosition",
      "comment": "Returns the start position for the specified entry. For example, getPosition(0) returns 0, getPosition(1) is equal to getSize(0), getPosition(2) is equal to getSize(0) + getSize(1), and so on. Note that if index is greater than length the value returned may be meaningless.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eindex\u003c/code\u003e - the index of the entry whose position is desired"
        ],
        "return": [
          "the starting position of the specified entry"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "position"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getIndex",
      "comment": "Returns the index of the entry that corresponds to the specified position. For example, getIndex(0) is 0, since the first entry always starts at position 0.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eposition\u003c/code\u003e - the position of the entry"
        ],
        "return": [
          "the index of the entry that occupies the specified position"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "index"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getSize",
      "comment": "Returns the size of the specified entry. If index is out of the range (0 \u003c\u003d index \u003c getSizes().length) the behavior is unspecified.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eindex\u003c/code\u003e - the index corresponding to the entry"
        ],
        "return": [
          "the size of the entry"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "index"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "size"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setSize",
      "comment": "Sets the size of the specified entry. Note that if the value of index does not fall in the range: (0 \u003c\u003d index \u003c getSizes().length) the behavior is unspecified.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eindex\u003c/code\u003e - the index corresponding to the entry",
          "\u003ccode\u003esize\u003c/code\u003e - the size of the entry"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "start"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "length"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "insertEntries",
      "comment": "Adds a contiguous group of entries to this SizeSequence. Note that the values of start and length must satisfy the following conditions: (0 \u003c\u003d start \u003c getSizes().length) AND (length \u003e\u003d 0). If these conditions are not met, the behavior is unspecified and an exception may be thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003estart\u003c/code\u003e - the index to be assigned to the first entry in the group",
          "\u003ccode\u003elength\u003c/code\u003e - the number of entries in the group",
          "\u003ccode\u003evalue\u003c/code\u003e - the size to be assigned to each new entry"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if the parameters are outside of the range: (\n\u003ccode\u003e0 \u0026lt;\u003d start \u0026lt; (getSizes().length)) AND (length \u0026gt;\u003d 0)\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "start"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "length"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "removeEntries",
      "comment": "Removes a contiguous group of entries from this SizeSequence. Note that the values of start and length must satisfy the following conditions: (0 \u003c\u003d start \u003c getSizes().length) AND (length \u003e\u003d 0). If these conditions are not met, the behavior is unspecified and an exception may be thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003estart\u003c/code\u003e - the index of the first entry to be removed",
          "\u003ccode\u003elength\u003c/code\u003e - the number of entries to be removed"
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new SizeSequence object that contains no entries. To add entries, you can use insertEntries or setSizes.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/SizeSequence.html#insertEntries(int,int,int)\"\u003e\u003ccode\u003einsertEntries(int, int, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/javax/swing/SizeSequence.html#setSizes(int%5B%5D)\"\u003e\u003ccode\u003esetSizes(int[])\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "numEntries"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new SizeSequence object that contains the specified number of entries, all initialized to have size 0.",
      "tagMap": {
        "param": [
          "\u003ccode\u003enumEntries\u003c/code\u003e - the number of sizes to track"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enumEntries \u0026lt; 0\u003c/code\u003e"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "numEntries"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new SizeSequence object that contains the specified number of entries, all initialized to have size value.",
      "tagMap": {
        "param": [
          "\u003ccode\u003enumEntries\u003c/code\u003e - the number of sizes to track",
          "\u003ccode\u003evalue\u003c/code\u003e - the initial value of each size"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "sizes"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new SizeSequence object that contains the specified sizes.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esizes\u003c/code\u003e - the array of sizes to be contained in the \n\u003ccode\u003eSizeSequence\u003c/code\u003e"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.swing.SizeSequence",
  "comment": "A \n\u003ccode\u003eSizeSequence\u003c/code\u003e object efficiently maintains an ordered list of sizes and corresponding positions. One situation for which \n\u003ccode\u003eSizeSequence\u003c/code\u003e might be appropriate is in a component that displays multiple rows of unequal size. In this case, a single \n\u003ccode\u003eSizeSequence\u003c/code\u003e object could be used to track the heights and Y positions of all rows. \n\u003cp\u003e Another example would be a multi-column component, such as a \u003ccode\u003eJTable\u003c/code\u003e, in which the column sizes are not all equal. The \u003ccode\u003eJTable\u003c/code\u003e might use a single \u003ccode\u003eSizeSequence\u003c/code\u003e object to store the widths and X positions of all the columns. The \u003ccode\u003eJTable\u003c/code\u003e could then use the \u003ccode\u003eSizeSequence\u003c/code\u003e object to find the column corresponding to a certain position. The \u003ccode\u003eJTable\u003c/code\u003e could update the \u003ccode\u003eSizeSequence\u003c/code\u003e object whenever one or more column sizes changed. \u003c/p\u003e\n\u003cp\u003e The following figure shows the relationship between size and position data for a multi-column component. \u003c/p\u003e\n\u003cp style\u003d\"text-align:center\"\u003e \u003cimg src\u003d\"doc-files/SizeSequence-1.gif\" width\u003d\"384\" height\u003d\"100\" alt\u003d\"The first item begins at position 0, the second at the position equal\n to the size of the previous item, and so on.\"\u003e \u003c/p\u003e\n\u003cp\u003e In the figure, the first index (0) corresponds to the first column, the second index (1) to the second column, and so on. The first column\u0027s position starts at 0, and the column occupies \u003cem\u003esize\u003csub\u003e0\u003c/sub\u003e\u003c/em\u003e pixels, where \u003cem\u003esize\u003csub\u003e0\u003c/sub\u003e\u003c/em\u003e is the value returned by \u003ccode\u003egetSize(0)\u003c/code\u003e. Thus, the first column ends at \u003cem\u003esize\u003csub\u003e0\u003c/sub\u003e\u003c/em\u003e - 1. The second column then begins at the position \u003cem\u003esize\u003csub\u003e0\u003c/sub\u003e\u003c/em\u003e and occupies \u003cem\u003esize\u003csub\u003e1\u003c/sub\u003e\u003c/em\u003e (\u003ccode\u003egetSize(1)\u003c/code\u003e) pixels. \u003c/p\u003e\n\u003cp\u003e Note that a \u003ccode\u003eSizeSequence\u003c/code\u003e object simply represents intervals along an axis. In our examples, the intervals represent height or width in pixels. However, any other unit of measure (for example, time in days) could be just as valid. \u003c/p\u003e\n\u003ch2\u003eImplementation Notes\u003c/h2\u003e Normally when storing the size and position of entries, one would choose between storing the sizes or storing their positions instead. The two common operations that are needed during rendering are: \n\u003ccode\u003egetIndex(position)\u003c/code\u003e and \n\u003ccode\u003esetSize(index, size)\u003c/code\u003e. Whichever choice of internal format is made one of these operations is costly when the number of entries becomes large. If sizes are stored, finding the index of the entry that encloses a particular position is linear in the number of entries. If positions are stored instead, setting the size of an entry at a particular index requires updating the positions of the affected entries, which is also a linear calculation. \n\u003cp\u003e Like the above techniques this class holds an array of N integers internally but uses a hybrid encoding, which is halfway between the size-based and positional-based approaches. The result is a data structure that takes the same space to store the information but can perform most operations in Log(N) time instead of O(N), where N is the number of entries in the list. \u003c/p\u003e\n\u003cp\u003e Two operations that remain O(N) in the number of entries are the \u003ccode\u003einsertEntries\u003c/code\u003e and \u003ccode\u003eremoveEntries\u003c/code\u003e methods, both of which are implemented by converting the internal array to a set of integer sizes, copying it into the new array, and then reforming the hybrid representation in place.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.3"
    ]
  }
}