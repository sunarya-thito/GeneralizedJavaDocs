{
  "packageName": "javax.print",
  "simpleName": "DocFlavor",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "hostEncoding",
      "comment": "A string representing the host operating system encoding. This will follow the conventions documented in RFC 2278: IANA Charset Registration Procedures except where historical names are returned for compatibility with previous versions of the Java platform. The value returned from method is valid only for the VM which returns it, for use in a DocFlavor. This is the charset for all the \"HOST\" pre-defined DocFlavors in the executing VM.",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getMimeType",
      "comment": "Returns this doc flavor object\u0027s MIME type string based on the canonical form. Each parameter value is enclosed in quotes.",
      "tagMap": {
        "return": [
          "the mime type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getMediaType",
      "comment": "Returns this doc flavor object\u0027s media type (from the MIME type).",
      "tagMap": {
        "return": [
          "the media type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getMediaSubtype",
      "comment": "Returns this doc flavor object\u0027s media subtype (from the MIME type).",
      "tagMap": {
        "return": [
          "the media sub-type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "paramName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getParameter",
      "comment": "Returns a String representing a MIME parameter. Mime types may include parameters which are usually optional. The charset for text types is a commonly useful example. This convenience method will return the value of the specified parameter if one was specified in the mime type for this flavor.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eparamName\u003c/code\u003e - the name of the parameter. This name is internally converted to the canonical lower case format before performing the match."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if paramName is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "a string representing a mime parameter, or \n\u003ccode\u003enull\u003c/code\u003e if that parameter is not in the mime type string"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getRepresentationClassName",
      "comment": "Returns the name of this doc flavor object\u0027s representation class.",
      "tagMap": {
        "return": [
          "the name of the representation class"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Converts this DocFlavor to a string.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "MIME type string based on the canonical form. Each parameter value is enclosed in quotes. A \"class\u003d\" parameter is appended to the MIME type string to indicate the representation class name."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hashCode",
      "comment": "Returns a hash code for this doc flavor object.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#identityHashCode(java.lang.Object)\"\u003e\u003ccode\u003eSystem.identityHashCode(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a hash code value for this object."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "obj"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "equals",
      "comment": "Determines if this doc flavor object is equal to the given object. The two are equal if the given object is not null, is an instance of DocFlavor, has a MIME type equivalent to this doc flavor object\u0027s MIME type (that is, the MIME types have the same media type, media subtype, and parameters), and has the same representation class name as this doc flavor object. Thus, if two doc flavor objects\u0027 MIME types are the same except for comments, they are considered equal. However, two doc flavor objects with MIME types of \"text/plain\" and \"text/plain; charset\u003dUS-ASCII\" are not considered equal, even though they represent the same media type (because the default character set for plain text is US-ASCII).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/HashMap.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eHashMap\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - \n\u003ccode\u003eObject\u003c/code\u003e to test"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this doc flavor object equals \n\u003ccode\u003eobj\u003c/code\u003e, \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "mimeType"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "className"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new doc flavor object from the given MIME type and representation class name. The given MIME type is converted into canonical form and stored internally.",
      "tagMap": {
        "param": [
          "\u003ccode\u003emimeType\u003c/code\u003e - MIME media type string",
          "\u003ccode\u003eclassName\u003c/code\u003e - fully-qualified representation class name"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emimeType\u003c/code\u003e or \n\u003ccode\u003eclassName\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emimeType\u003c/code\u003e does not obey the syntax for a MIME media type string"
        ]
      }
    }
  ],
  "innerClasses": [
    "javax.print.DocFlavor$CHAR_ARRAY",
    "javax.print.DocFlavor$INPUT_STREAM",
    "javax.print.DocFlavor$BYTE_ARRAY",
    "javax.print.DocFlavor$STRING",
    "javax.print.DocFlavor$READER",
    "javax.print.DocFlavor$SERVICE_FORMATTED",
    "javax.print.DocFlavor$URL"
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.print.DocFlavor",
  "comment": "Class \n\u003ccode\u003eDocFlavor\u003c/code\u003e encapsulates an object that specifies the format in which print data is supplied to a \n\u003ca href\u003d\"DocPrintJob.html\" title\u003d\"interface in javax.print\"\u003e\u003ccode\u003eDocPrintJob\u003c/code\u003e\u003c/a\u003e. \"Doc\" is a short, easy-to-pronounce term that means \"a piece of print data.\" The print data format, or \"doc flavor\", consists of two things: \n\u003cul\u003e \n \u003cli\u003e\u003cb\u003eMIME type.\u003c/b\u003e This is a Multipurpose Internet Mail Extensions (MIME) media type (as defined in \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003eRFC 2045\u003c/a\u003e and \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2046.txt\"\u003eRFC 2046\u003c/a\u003e) that specifies how the print data is to be interpreted. The charset of text data should be the IANA MIME-preferred name, or its canonical name if no preferred name is specified. Additionally a few historical names supported by earlier versions of the Java platform may be recognized. See \u003ca href\u003d\"../../../java.base/java/lang/package-summary.html#charenc\"\u003e character encodings\u003c/a\u003e for more information on the character encodings supported on the Java platform. \u003c/li\u003e\n \u003cli\u003e\u003cb\u003eRepresentation class name.\u003c/b\u003e This specifies the fully-qualified name of the class of the object from which the actual print data comes, as returned by the \u003ca href\u003d\"../../../java.base/java/lang/Class.html#getName()\"\u003e\u003ccode\u003eClass.getName()\u003c/code\u003e\u003c/a\u003e method. (Thus the class name for \u003ccode\u003ebyte[]\u003c/code\u003e is \u003ccode\u003e\"[B\"\u003c/code\u003e, for \u003ccode\u003echar[]\u003c/code\u003e it is \u003ccode\u003e\"[C\"\u003c/code\u003e.) \u003c/li\u003e\n\u003c/ul\u003e A \n\u003ccode\u003eDocPrintJob\u003c/code\u003e obtains its print data by means of interface \n\u003ca href\u003d\"Doc.html\" title\u003d\"interface in javax.print\"\u003e\u003ccode\u003eDoc\u003c/code\u003e\u003c/a\u003e. A \n\u003ccode\u003eDoc\u003c/code\u003e object lets the \n\u003ccode\u003eDocPrintJob\u003c/code\u003e determine the doc flavor the client can supply. A \n\u003ccode\u003eDoc\u003c/code\u003e object also lets the \n\u003ccode\u003eDocPrintJob\u003c/code\u003e obtain an instance of the doc flavor\u0027s representation class, from which the \n\u003ccode\u003eDocPrintJob\u003c/code\u003e then obtains the actual print data. \n\u003chr\u003e \n\u003ch2\u003eClient Formatted Print Data\u003c/h2\u003e There are two broad categories of print data, client formatted print data and service formatted print data. \n\u003cp\u003e For \u003cb\u003eclient formatted print data\u003c/b\u003e, the client determines or knows the print data format. For example the client may have a JPEG encoded image, a \u003ccode\u003eURL\u003c/code\u003e for HTML code, or a disk file containing plain text in some encoding, possibly obtained from an external source, and requires a way to describe the data format to the print service. \u003c/p\u003e\n\u003cp\u003e The doc flavor\u0027s representation class is a conduit for the JPS \u003ccode\u003eDocPrintJob\u003c/code\u003e to obtain a sequence of characters or bytes from the client. The doc flavor\u0027s MIME type is one of the standard media types telling how to interpret the sequence of characters or bytes. For a list of standard media types, see the Internet Assigned Numbers Authority\u0027s (IANA\u0027s) \u003ca href\u003d\"http://www.iana.org/assignments/media-types/\"\u003eMedia Types Directory \u003c/a\u003e. Interface \u003ca href\u003d\"Doc.html\" title\u003d\"interface in javax.print\"\u003e\u003ccode\u003eDoc\u003c/code\u003e\u003c/a\u003e provides two utility operations, \u003ca href\u003d\"Doc.html#getReaderForText()\"\u003e\u003ccode\u003egetReaderForText\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"Doc.html#getStreamForBytes()\"\u003e\u003ccode\u003egetStreamForBytes()\u003c/code\u003e\u003c/a\u003e, to help a \u003ccode\u003eDoc\u003c/code\u003e object\u0027s client extract client formatted print data. \u003c/p\u003e\n\u003cp\u003e For client formatted print data, the print data representation class is typically one of the following (although other representation classes are permitted): \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eCharacter array (\u003ccode\u003echar[]\u003c/code\u003e) -- The print data consists of the Unicode characters in the array. \u003c/li\u003e\n \u003cli\u003e\u003ccode\u003eString\u003c/code\u003e -- The print data consists of the Unicode characters in the string. \u003c/li\u003e\n \u003cli\u003eCharacter stream (\u003ca href\u003d\"../../../java.base/java/io/Reader.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003ejava.io.Reader\u003c/code\u003e\u003c/a\u003e) -- The print data consists of the Unicode characters read from the stream up to the end-of-stream. \u003c/li\u003e\n \u003cli\u003eByte array (\u003ccode\u003ebyte[]\u003c/code\u003e) -- The print data consists of the bytes in the array. The bytes are encoded in the character set specified by the doc flavor\u0027s MIME type. If the MIME type does not specify a character set, the default character set is US-ASCII. \u003c/li\u003e\n \u003cli\u003eByte stream (\u003ca href\u003d\"../../../java.base/java/io/InputStream.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003ejava.io.InputStream\u003c/code\u003e\u003c/a\u003e) -- The print data consists of the bytes read from the stream up to the end-of-stream. The bytes are encoded in the character set specified by the doc flavor\u0027s MIME type. If the MIME type does not specify a character set, the default character set is US-ASCII. \u003c/li\u003e\n \u003cli\u003eUniform Resource Locator (\u003ca href\u003d\"../../../java.base/java/net/URL.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eURL\u003c/code\u003e\u003c/a\u003e) -- The print data consists of the bytes read from the URL location. The bytes are encoded in the character set specified by the doc flavor\u0027s MIME type. If the MIME type does not specify a character set, the default character set is US-ASCII. When the representation class is a \u003ccode\u003eURL\u003c/code\u003e, the print service itself accesses and downloads the document directly from its \u003ccode\u003eURL\u003c/code\u003e address, without involving the client. The service may be some form of network print service which is executing in a different environment. This means you should not use a \u003ccode\u003eURL\u003c/code\u003e print data flavor to print a document at a restricted \u003ccode\u003eURL\u003c/code\u003e that the client can see but the printer cannot see. This also means you should not use a \u003ccode\u003eURL\u003c/code\u003e print data flavor to print a document stored in a local file that is not available at a \u003ccode\u003eURL\u003c/code\u003e accessible independently of the client. For example, a file that is not served up by an HTTP server or FTP server. To print such documents, let the client open an input stream on the \u003ccode\u003eURL\u003c/code\u003e or file and use an input stream data flavor. \u003c/li\u003e\n\u003c/ul\u003e \n\u003chr\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eDefault and Platform Encodings\u003c/h2\u003e For byte print data where the doc flavor\u0027s MIME type does not include a \n\u003ccode\u003echarset\u003c/code\u003e parameter, the Java Print Service instance assumes the US-ASCII character set by default. This is in accordance with \n\u003ca href\u003d\"http://www.ietf.org/rfc/rfc2046.txt\"\u003eRFC 2046\u003c/a\u003e, which says the default character set is US-ASCII. Note that US-ASCII is a subset of UTF-8, so in the future this may be widened if a future RFC endorses UTF-8 as the default in a compatible manner. \n\u003cp\u003e Also note that this is different than the behaviour of the Java runtime when interpreting a stream of bytes as text data. That assumes the default encoding for the user\u0027s locale. Thus, when spooling a file in local encoding to a Java Print Service it is important to correctly specify the encoding. Developers working in the English locales should be particularly conscious of this, as their platform encoding corresponds to the default mime charset. By this coincidence that particular case may work without specifying the encoding of platform data. \u003c/p\u003e\n\u003cp\u003e Every instance of the Java virtual machine has a default character encoding determined during virtual-machine startup and typically depends upon the locale and charset being used by the underlying operating system. In a distributed environment there is no guarantee that two VM share the same default encoding. Thus clients which want to stream platform encoded text data from the host platform to a Java Print Service instance must explicitly declare the charset and not rely on defaults. \u003c/p\u003e\n\u003cp\u003e The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform\u0027s encoding. A \u003ccode\u003eCharSet\u003c/code\u003e which corresponds to this and is suitable for use in a mime-type for a \u003ccode\u003eDocFlavor\u003c/code\u003e can be obtained from \u003ca href\u003d\"#hostEncoding\"\u003e\u003ccode\u003eDocFlavor.hostEncoding\u003c/code\u003e\u003c/a\u003e This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST \u003ccode\u003eDocFlavors\u003c/code\u003e may be used. \u003c/p\u003e\n\u003cp\u003e See \u003ca href\u003d\"../../../java.base/java/lang/package-summary.html#charenc\"\u003e character encodings\u003c/a\u003e for more information on the character encodings supported on the Java platform. \u003c/p\u003e\n\u003chr\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eRecommended DocFlavors\u003c/h2\u003e The Java Print Service API does not define any mandatorily supported \n\u003ccode\u003eDocFlavors\u003c/code\u003e. However, here are some examples of MIME types that a Java Print Service instance might support for client formatted print data. Nested classes inside class \n\u003ccode\u003eDocFlavor\u003c/code\u003e declare predefined static constant \n\u003ccode\u003eDocFlavor\u003c/code\u003e objects for these example doc flavors; class \n\u003ccode\u003eDocFlavor\u003c/code\u003e\u0027s constructor can be used to create an arbitrary doc flavor. \n\u003cul\u003e \n \u003cli\u003ePreformatted text \n  \u003ctable class\u003d\"striped\"\u003e \n   \u003ccaption\u003e\n    MIME-Types and their descriptions\n   \u003c/caption\u003e \n   \u003cthead\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"col\"\u003eMIME-Type \u003c/th\u003e\n     \u003cth scope\u003d\"col\"\u003eDescription \u003c/th\u003e\n    \u003c/tr\u003e\n   \u003c/thead\u003e \n   \u003ctbody\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"text/plain\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003ePlain text in the default character set (US-ASCII) \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e \"text/plain; charset\u003d\u003ci\u003exxx\u003c/i\u003e\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003ePlain text in character set \u003ci\u003exxx\u003c/i\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"text/html\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003eHyperText Markup Language in the default character set (US-ASCII) \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e \"text/html; charset\u003d\u003ci\u003exxx\u003c/i\u003e\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003eHyperText Markup Language in character set \u003ci\u003exxx\u003c/i\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n   \u003c/tbody\u003e \n  \u003c/table\u003e In general, preformatted text print data is provided either in a character oriented representation class (character array, String, Reader) or in a byte oriented representation class (byte array, InputStream, URL). \u003c/li\u003e\n \u003cli\u003ePreformatted page description language (PDL) documents \n  \u003ctable class\u003d\"striped\"\u003e \n   \u003ccaption\u003e\n    MIME-Types and their descriptions\n   \u003c/caption\u003e \n   \u003cthead\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"col\"\u003eMIME-Type \u003c/th\u003e\n     \u003cth scope\u003d\"col\"\u003eDescription \u003c/th\u003e\n    \u003c/tr\u003e\n   \u003c/thead\u003e \n   \u003ctbody\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"application/pdf\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003ePortable Document Format document \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"application/postscript\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003ePostScript document \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"application/vnd.hp-PCL\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003ePrinter Control Language document \u003c/td\u003e\n    \u003c/tr\u003e\n   \u003c/tbody\u003e \n  \u003c/table\u003e In general, preformatted PDL print data is provided in a byte oriented representation class (byte array, \u003ccode\u003eInputStream\u003c/code\u003e, \u003ccode\u003eURL\u003c/code\u003e). \u003c/li\u003e\n \u003cli\u003ePreformatted images \n  \u003ctable class\u003d\"striped\"\u003e \n   \u003ccaption\u003e\n    MIME-Types and their descriptions\n   \u003c/caption\u003e \n   \u003cthead\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"col\"\u003eMIME-Type \u003c/th\u003e\n     \u003cth scope\u003d\"col\"\u003eDescription \u003c/th\u003e\n    \u003c/tr\u003e\n   \u003c/thead\u003e \n   \u003ctbody\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"image/gif\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003eGraphics Interchange Format image \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"image/jpeg\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003eJoint Photographic Experts Group image \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"image/png\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003ePortable Network Graphics image \u003c/td\u003e\n    \u003c/tr\u003e\n   \u003c/tbody\u003e \n  \u003c/table\u003e In general, preformatted image print data is provided in a byte oriented representation class (byte array, \u003ccode\u003eInputStream\u003c/code\u003e, \u003ccode\u003eURL\u003c/code\u003e). \u003c/li\u003e\n \u003cli\u003ePreformatted autosense print data \n  \u003ctable class\u003d\"striped\"\u003e \n   \u003ccaption\u003e\n    MIME-Types and their descriptions\n   \u003c/caption\u003e \n   \u003cthead\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"col\"\u003eMIME-Type \u003c/th\u003e\n     \u003cth scope\u003d\"col\"\u003eDescription \u003c/th\u003e\n    \u003c/tr\u003e\n   \u003c/thead\u003e \n   \u003ctbody\u003e \n    \u003ctr\u003e \n     \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e\"application/octet-stream\"\u003c/code\u003e \u003c/th\u003e\n     \u003ctd\u003eThe print data format is unspecified (just an octet stream) \u003c/td\u003e\n    \u003c/tr\u003e\n   \u003c/tbody\u003e \n  \u003c/table\u003e The printer decides how to interpret the print data; the way this \"autosensing\" works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, \u003ccode\u003eInputStream\u003c/code\u003e, \u003ccode\u003eURL\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e \n\u003chr\u003e \n\u003ch2\u003eService Formatted Print Data\u003c/h2\u003e For \n\u003cb\u003eservice formatted print data\u003c/b\u003e, the Java Print Service instance determines the print data format. The doc flavor\u0027s representation class denotes an interface whose methods the \n\u003ccode\u003eDocPrintJob\u003c/code\u003e invokes to determine the content to be printed -- such as a renderable image interface or a Java printable interface. The doc flavor\u0027s MIME type is the special value \n\u003ccode\u003e\"application/x-java-jvm-local-objectref\"\u003c/code\u003e indicating the client will supply a reference to a Java object that implements the interface named as the representation class. This MIME type is just a placeholder; what\u0027s important is the print data representation class. \n\u003cp\u003e For service formatted print data, the print data representation class is typically one of the following (although other representation classes are permitted). Nested classes inside class \u003ccode\u003eDocFlavor\u003c/code\u003e declare predefined static constant \u003ccode\u003eDocFlavor\u003c/code\u003e objects for these example doc flavors; class \u003ccode\u003eDocFlavor\u003c/code\u003e\u0027s constructor can be used to create an arbitrary doc flavor. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eRenderable image object -- The client supplies an object that implements interface \u003ca href\u003d\"../../java/awt/image/renderable/RenderableImage.html\" title\u003d\"interface in java.awt.image.renderable\"\u003e\u003ccode\u003eRenderableImage\u003c/code\u003e\u003c/a\u003e. The printer calls methods in that interface to obtain the image to be printed. \u003c/li\u003e\n \u003cli\u003ePrintable object -- The client supplies an object that implements interface \u003ca href\u003d\"../../java/awt/print/Printable.html\" title\u003d\"interface in java.awt.print\"\u003e\u003ccode\u003ePrintable\u003c/code\u003e\u003c/a\u003e. The printer calls methods in that interface to obtain the pages to be printed, one by one. For each page, the printer supplies a graphics context, and whatever the client draws in that graphics context gets printed. \u003c/li\u003e\n \u003cli\u003ePageable object -- The client supplies an object that implements interface \u003ca href\u003d\"../../java/awt/print/Pageable.html\" title\u003d\"interface in java.awt.print\"\u003e\u003ccode\u003ePageable\u003c/code\u003e\u003c/a\u003e. The printer calls methods in that interface to obtain the pages to be printed, one by one. For each page, the printer supplies a graphics context, and whatever the client draws in that graphics context gets printed. \u003c/li\u003e\n\u003c/ul\u003e \n\u003chr\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003ePre-defined Doc Flavors\u003c/h2\u003e A Java Print Service instance is not \n\u003cb\u003e\u003ci\u003erequired\u003c/i\u003e\u003c/b\u003e to support the following print data formats and print data representation classes. In fact, a developer using this class should \n\u003cb\u003enever\u003c/b\u003e assume that a particular print service supports the document types corresponding to these pre-defined doc flavors. Always query the print service to determine what doc flavors it supports. However, developers who have print services that support these doc flavors are encouraged to refer to the predefined singleton instances created here. \n\u003cul\u003e \n \u003cli\u003ePlain text print data provided through a byte stream. Specifically, the following doc flavors are recommended to be supported: \u003cbr\u003e·\u0026nbsp;\u0026nbsp; \u003ccode\u003e(\"text/plain\", \"java.io.InputStream\")\u003c/code\u003e \u003cbr\u003e·\u0026nbsp;\u0026nbsp; \u003ccode\u003e(\"text/plain; charset\u003dus-ascii\", \"java.io.InputStream\")\u003c/code\u003e \u003cbr\u003e·\u0026nbsp;\u0026nbsp; \u003ccode\u003e(\"text/plain; charset\u003dutf-8\", \"java.io.InputStream\")\u003c/code\u003e \u003c/li\u003e\n \u003cli\u003eRenderable image objects. Specifically, the following doc flavor is recommended to be supported: \u003cbr\u003e·\u0026nbsp;\u0026nbsp; \u003ccode\u003e(\"application/x-java-jvm-local-objectref\", \"java.awt.image.renderable.RenderableImage\")\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e A Java Print Service instance is allowed to support any other doc flavors (or none) in addition to the above mandatory ones, at the implementation\u0027s choice. \n\u003cp\u003e Support for the above doc flavors is desirable so a printing client can rely on being able to print on any JPS printer, regardless of which doc flavors the printer supports. If the printer doesn\u0027t support the client\u0027s preferred doc flavor, the client can at least print plain text, or the client can convert its data to a renderable image and print the image. \u003c/p\u003e\n\u003cp\u003e Furthermore, every Java Print Service instance must fulfill these requirements for processing plain text print data: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eThe character pair carriage return-line feed (CR-LF) means \"go to column 1 of the next line.\" \u003c/li\u003e\n \u003cli\u003eA carriage return (CR) character standing by itself means \"go to column 1 of the next line.\" \u003c/li\u003e\n \u003cli\u003eA line feed (LF) character standing by itself means \"go to column 1 of the next line.\" \u003c/li\u003e\n\u003c/ul\u003e The client must itself perform all plain text print data formatting not addressed by the above requirements. \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eDesign Rationale\u003c/h2\u003e Class \n\u003ccode\u003eDocFlavor\u003c/code\u003e in package \n\u003ccode\u003ejavax.print\u003c/code\u003e is similar to class \n\u003ca href\u003d\"../../../java.datatransfer/java/awt/datatransfer/DataFlavor.html\" title\u003d\"class in java.awt.datatransfer\"\u003e\u003ccode\u003eDataFlavor\u003c/code\u003e\u003c/a\u003e. Class \n\u003ccode\u003eDataFlavor\u003c/code\u003e is not used in the Java Print Service (JPS) API for three reasons which are all rooted in allowing the JPS API to be shared by other print services APIs which may need to run on Java profiles which do not include all of the Java Platform, Standard Edition. \n\u003col type\u003d\"1\"\u003e \n \u003cli\u003eThe JPS API is designed to be used in Java profiles which do not support AWT. \u003c/li\u003e\n \u003cli\u003eThe implementation of class \u003ccode\u003ejava.awt.datatransfer.DataFlavor\u003c/code\u003e does not guarantee that equivalent data flavors will have the same serialized representation. \u003ccode\u003eDocFlavor\u003c/code\u003e does, and can be used in services which need this. \u003c/li\u003e\n \u003cli\u003eThe implementation of class \u003ccode\u003ejava.awt.datatransfer.DataFlavor\u003c/code\u003e includes a human presentable name as part of the serialized representation. This is not appropriate as part of a service matching constraint. \u003c/li\u003e\n\u003c/ol\u003e Class \n\u003ccode\u003eDocFlavor\u003c/code\u003e\u0027s serialized representation uses the following canonical form of a MIME type string. Thus, two doc flavors with MIME types that are not identical but that are equivalent (that have the same canonical form) may be considered equal. \n\u003cul\u003e \n \u003cli\u003eThe media type, media subtype, and parameters are retained, but all comments and whitespace characters are discarded. \u003c/li\u003e\n \u003cli\u003eThe media type, media subtype, and parameter names are converted to lowercase. \u003c/li\u003e\n \u003cli\u003eThe parameter values retain their original case, except a charset parameter value for a text media type is converted to lowercase. \u003c/li\u003e\n \u003cli\u003eQuote characters surrounding parameter values are removed. \u003c/li\u003e\n \u003cli\u003eQuoting backslash characters inside parameter values are removed. \u003c/li\u003e\n \u003cli\u003eThe parameters are arranged in ascending order of parameter name. \u003c/li\u003e\n\u003c/ul\u003e Class \n\u003ccode\u003eDocFlavor\u003c/code\u003e\u0027s serialized representation also contains the fully-qualified class \n\u003ci\u003ename\u003c/i\u003e of the representation class (a \n\u003ccode\u003eString\u003c/code\u003e object), rather than the representation class itself (a \n\u003ccode\u003eClass\u003c/code\u003e object). This allows a client to examine the doc flavors a Java Print Service instance supports without having to load the representation classes, which may be problematic for limited-resource clients.",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#javax.print.DocFlavor\"\u003eSerialized Form\u003c/a\u003e"
    ]
  }
}