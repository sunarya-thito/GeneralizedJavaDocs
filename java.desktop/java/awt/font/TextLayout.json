{
  "packageName": "java.awt.font",
  "simpleName": "TextLayout",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "java.awt.font.TextLayout$CaretPolicy",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "DEFAULT_CARET_POLICY",
      "comment": "This CaretPolicy is used when a policy is not specified by the client. With this policy, a hit on a character whose direction is the same as the line direction is stronger than a hit on a counterdirectional character. If the characters\u0027 directions are the same, a hit on the leading edge of a character is stronger than a hit on the trailing edge of a character.",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "clone",
      "comment": "Creates a copy of this TextLayout.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Cloneable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eCloneable\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#clone()\"\u003eclone\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a clone of this instance."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextLayout",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "justificationWidth"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getJustifiedLayout",
      "comment": "Creates a copy of this TextLayout justified to the specified width. If this TextLayout has already been justified, an exception is thrown. If this TextLayout object\u0027s justification ratio is zero, a TextLayout identical to this TextLayout is returned.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ejustificationWidth\u003c/code\u003e - the width to use when justifying the line. For best results, it should not be too different from the current advance of the line."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Error.html\" title\u003d\"class in java.lang\"\u003eError\u003c/a\u003e\u003c/code\u003e - if this layout has already been justified, an Error is thrown."
        ],
        "return": [
          "a \n\u003ccode\u003eTextLayout\u003c/code\u003e justified to the specified width."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "justificationWidth"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "handleJustify",
      "comment": "Justify this layout. Overridden by subclassers to control justification (if there were subclassers, that is...) The layout will only justify if the paragraph attributes (from the source text, possibly defaulted by the layout attributes) indicate a non-zero justification ratio. The text will be justified to the indicated width. The current implementation also adjusts hanging punctuation and trailing whitespace to overhang the justification width. Once justified, the layout may not be rejustified. Some code may rely on immutability of layouts. Subclassers should not call this directly, but instead should call getJustifiedLayout, which will call this method on a clone of this layout, preserving the original.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getJustifiedLayout(float)\"\u003e\u003ccode\u003egetJustifiedLayout(float)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ejustificationWidth\u003c/code\u003e - the width to use when justifying the line. For best results, it should not be too different from the current advance of the line."
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getBaseline",
      "comment": "Returns the baseline for this TextLayout. The baseline is one of the values defined in Font, which are roman, centered and hanging. Ascent and descent are relative to this baseline. The baselineOffsets are also relative to this baseline.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getBaselineOffsets()\"\u003e\u003ccode\u003egetBaselineOffsets()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Font.html\" title\u003d\"class in java.awt\"\u003e\u003ccode\u003eFont\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the baseline of this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getBaselineOffsets",
      "comment": "Returns the offsets array for the baselines used for this TextLayout. The array is indexed by one of the values defined in Font, which are roman, centered and hanging. The values are relative to this TextLayout object\u0027s baseline, so that getBaselineOffsets[getBaseline()] \u003d\u003d 0. Offsets are added to the position of the TextLayout object\u0027s baseline to get the position for the new baseline.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getBaseline()\"\u003e\u003ccode\u003egetBaseline()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Font.html\" title\u003d\"class in java.awt\"\u003e\u003ccode\u003eFont\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the offsets array containing the baselines used for this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getAdvance",
      "comment": "Returns the advance of this TextLayout. The advance is the distance from the origin to the advance of the rightmost (bottommost) character. This is in baseline-relative coordinates.",
      "tagMap": {
        "return": [
          "the advance of this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getVisibleAdvance",
      "comment": "Returns the advance of this TextLayout, minus trailing whitespace. This is in baseline-relative coordinates.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getAdvance()\"\u003e\u003ccode\u003egetAdvance()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the advance of this \n\u003ccode\u003eTextLayout\u003c/code\u003e without the trailing whitespace."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getAscent",
      "comment": "Returns the ascent of this TextLayout. The ascent is the distance from the top (right) of the TextLayout to the baseline. It is always either positive or zero. The ascent is sufficient to accommodate superscripted text and is the maximum of the sum of the ascent, offset, and baseline of each glyph. The ascent is the maximum ascent from the baseline of all the text in the TextLayout. It is in baseline-relative coordinates.",
      "tagMap": {
        "return": [
          "the ascent of this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getDescent",
      "comment": "Returns the descent of this TextLayout. The descent is the distance from the baseline to the bottom (left) of the TextLayout. It is always either positive or zero. The descent is sufficient to accommodate subscripted text and is the maximum of the sum of the descent, offset, and baseline of each glyph. This is the maximum descent from the baseline of all the text in the TextLayout. It is in baseline-relative coordinates.",
      "tagMap": {
        "return": [
          "the descent of this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLeading",
      "comment": "Returns the leading of the TextLayout. The leading is the suggested interline spacing for this TextLayout. This is in baseline-relative coordinates. The leading is computed from the leading, descent, and baseline of all glyphvectors in the TextLayout. The algorithm is roughly as follows:  maxD \u003d 0;\n maxDL \u003d 0;\n for (GlyphVector g in all glyphvectors) {\n    maxD \u003d max(maxD, g.getDescent() + offsets[g.getBaseline()]);\n    maxDL \u003d max(maxDL, g.getDescent() + g.getLeading() +\n                       offsets[g.getBaseline()]);\n }\n return maxDL - maxD;",
      "tagMap": {
        "return": [
          "the leading of this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.Rectangle2D",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getBounds",
      "comment": "Returns the bounds of this TextLayout. The bounds are in standard coordinates. Due to rasterization effects, this bounds might not enclose all of the pixels rendered by the TextLayout. It might not coincide exactly with the ascent, descent, origin or advance of the TextLayout.",
      "tagMap": {
        "return": [
          "a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Rectangle2D.html\" title\u003d\"class in java.awt.geom\"\u003e\u003ccode\u003eRectangle2D\u003c/code\u003e\u003c/a\u003e that is the bounds of this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Rectangle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.FontRenderContext",
            "type": "Class"
          },
          "field": {
            "name": "frc"
          }
        },
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPixelBounds",
      "comment": "Returns the pixel bounds of this TextLayout when rendered in a graphics with the given FontRenderContext at the given location. The graphics render context need not be the same as the FontRenderContext used to create this TextLayout, and can be null. If it is null, the FontRenderContext of this TextLayout is used.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/GlyphVector.html#getPixelBounds(java.awt.font.FontRenderContext,float,float)\"\u003e\u003ccode\u003eGlyphVector.getPixelBounds(java.awt.font.FontRenderContext, float, float)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003efrc\u003c/code\u003e - the \n\u003ccode\u003eFontRenderContext\u003c/code\u003e of the \n\u003ccode\u003eGraphics\u003c/code\u003e.",
          "\u003ccode\u003ex\u003c/code\u003e - the x-coordinate at which to render this \n\u003ccode\u003eTextLayout\u003c/code\u003e.",
          "\u003ccode\u003ey\u003c/code\u003e - the y-coordinate at which to render this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ],
        "return": [
          "a \n\u003ccode\u003eRectangle\u003c/code\u003e bounding the pixels that would be affected."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isLeftToRight",
      "comment": "Returns true if this TextLayout has a left-to-right base direction or false if it has a right-to-left base direction. The TextLayout has a base direction of either left-to-right (LTR) or right-to-left (RTL). The base direction is independent of the actual direction of text on the line, which may be either LTR, RTL, or mixed. Left-to-right layouts by default should position flush left. If the layout is on a tabbed line, the tabs run left to right, so that logically successive layouts position left to right. The opposite is true for RTL layouts. By default they should position flush left, and tabs run right-to-left.",
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the base direction of this \n\u003ccode\u003eTextLayout\u003c/code\u003e is left-to-right; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isVertical",
      "comment": "Returns true if this TextLayout is vertical.",
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this \n\u003ccode\u003eTextLayout\u003c/code\u003e is vertical; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCharacterCount",
      "comment": "Returns the number of characters represented by this TextLayout.",
      "tagMap": {
        "return": [
          "the number of characters in this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "bounds"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCaretInfo",
      "comment": "Returns information about the caret corresponding to hit. The first element of the array is the intersection of the caret with the baseline, as a distance along the baseline. The second element of the array is the inverse slope (run/rise) of the caret, measured with respect to the baseline at that point. This method is meant for informational use. To display carets, it is better to use getCaretShapes.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getCaretShapes(int,java.awt.geom.Rectangle2D,java.awt.font.TextLayout.CaretPolicy)\"\u003e\u003ccode\u003egetCaretShapes(int, Rectangle2D, TextLayout.CaretPolicy)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Font.html#getItalicAngle()\"\u003e\u003ccode\u003eFont.getItalicAngle()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - a hit on a character in this \n\u003ccode\u003eTextLayout\u003c/code\u003e",
          "\u003ccode\u003ebounds\u003c/code\u003e - the bounds to which the caret info is constructed. The bounds is in baseline-relative coordinates."
        ],
        "return": [
          "a two-element array containing the position and slope of the caret. The returned caret info is in baseline-relative coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCaretInfo",
      "comment": "Returns information about the caret corresponding to hit. This method is a convenience overload of getCaretInfo and uses the natural bounds of this TextLayout.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - a hit on a character in this \n\u003ccode\u003eTextLayout\u003c/code\u003e"
        ],
        "return": [
          "the information about a caret corresponding to a hit. The returned caret info is in baseline-relative coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getNextRightHit",
      "comment": "Returns the hit for the next caret to the right (bottom); if there is no such hit, returns null. If the hit character index is out of bounds, an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - a hit on a character in this layout"
        ],
        "return": [
          "a hit whose caret appears at the next position to the right (bottom) of the caret of the provided hit or \n\u003ccode\u003enull\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.awt.font.TextLayout$CaretPolicy",
            "type": "Class"
          },
          "field": {
            "name": "policy"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getNextRightHit",
      "comment": "Returns the hit for the next caret to the right (bottom); if no such hit, returns null. The hit is to the right of the strong caret at the specified offset, as determined by the specified policy. The returned hit is the stronger of the two possible hits, as determined by the specified policy.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - an insertion offset in this \n\u003ccode\u003eTextLayout\u003c/code\u003e. Cannot be less than 0 or greater than this \n\u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s character count.",
          "\u003ccode\u003epolicy\u003c/code\u003e - the policy used to select the strong caret"
        ],
        "return": [
          "a hit whose caret appears at the next position to the right (bottom) of the caret of the provided hit, or \n\u003ccode\u003enull\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getNextRightHit",
      "comment": "Returns the hit for the next caret to the right (bottom); if no such hit, returns null. The hit is to the right of the strong caret at the specified offset, as determined by the default policy. The returned hit is the stronger of the two possible hits, as determined by the default policy.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - an insertion offset in this \n\u003ccode\u003eTextLayout\u003c/code\u003e. Cannot be less than 0 or greater than the \n\u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s character count."
        ],
        "return": [
          "a hit whose caret appears at the next position to the right (bottom) of the caret of the provided hit, or \n\u003ccode\u003enull\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getNextLeftHit",
      "comment": "Returns the hit for the next caret to the left (top); if no such hit, returns null. If the hit character index is out of bounds, an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - a hit on a character in this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ],
        "return": [
          "a hit whose caret appears at the next position to the left (top) of the caret of the provided hit, or \n\u003ccode\u003enull\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.awt.font.TextLayout$CaretPolicy",
            "type": "Class"
          },
          "field": {
            "name": "policy"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getNextLeftHit",
      "comment": "Returns the hit for the next caret to the left (top); if no such hit, returns null. The hit is to the left of the strong caret at the specified offset, as determined by the specified policy. The returned hit is the stronger of the two possible hits, as determined by the specified policy.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - an insertion offset in this \n\u003ccode\u003eTextLayout\u003c/code\u003e. Cannot be less than 0 or greater than this \n\u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s character count.",
          "\u003ccode\u003epolicy\u003c/code\u003e - the policy used to select the strong caret"
        ],
        "return": [
          "a hit whose caret appears at the next position to the left (top) of the caret of the provided hit, or \n\u003ccode\u003enull\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getNextLeftHit",
      "comment": "Returns the hit for the next caret to the left (top); if no such hit, returns null. The hit is to the left of the strong caret at the specified offset, as determined by the default policy. The returned hit is the stronger of the two possible hits, as determined by the default policy.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - an insertion offset in this \n\u003ccode\u003eTextLayout\u003c/code\u003e. Cannot be less than 0 or greater than this \n\u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s character count."
        ],
        "return": [
          "a hit whose caret appears at the next position to the left (top) of the caret of the provided hit, or \n\u003ccode\u003enull\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getVisualOtherHit",
      "comment": "Returns the hit on the opposite side of the specified hit\u0027s caret.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - the specified hit"
        ],
        "return": [
          "a hit that is on the opposite side of the specified hit\u0027s caret."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "bounds"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCaretShape",
      "comment": "Returns a Shape representing the caret at the specified hit inside the specified bounds.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - the hit at which to generate the caret",
          "\u003ccode\u003ebounds\u003c/code\u003e - the bounds of the \n\u003ccode\u003eTextLayout\u003c/code\u003e to use in generating the caret. The bounds is in baseline-relative coordinates."
        ],
        "return": [
          "a \n\u003ccode\u003eShape\u003c/code\u003e representing the caret. The returned shape is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCaretShape",
      "comment": "Returns a Shape representing the caret at the specified hit inside the natural bounds of this TextLayout.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - the hit at which to generate the caret"
        ],
        "return": [
          "a \n\u003ccode\u003eShape\u003c/code\u003e representing the caret. The returned shape is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "index"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCharacterLevel",
      "comment": "Returns the level of the character at index. Indices -1 and characterCount are assigned the base level of this TextLayout.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eindex\u003c/code\u003e - the index of the character from which to get the level"
        ],
        "return": [
          "the level of the character at the specified index."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "bounds"
          }
        },
        {
          "type": {
            "name": "java.awt.font.TextLayout$CaretPolicy",
            "type": "Class"
          },
          "field": {
            "name": "policy"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCaretShapes",
      "comment": "Returns two paths corresponding to the strong and weak caret.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - an offset in this \n\u003ccode\u003eTextLayout\u003c/code\u003e",
          "\u003ccode\u003ebounds\u003c/code\u003e - the bounds to which to extend the carets. The bounds is in baseline-relative coordinates.",
          "\u003ccode\u003epolicy\u003c/code\u003e - the specified \n\u003ccode\u003eCaretPolicy\u003c/code\u003e"
        ],
        "return": [
          "an array of two paths. Element zero is the strong caret. If there are two carets, element one is the weak caret, otherwise it is \n\u003ccode\u003enull\u003c/code\u003e. The returned shapes are in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "bounds"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCaretShapes",
      "comment": "Returns two paths corresponding to the strong and weak caret. This method is a convenience overload of getCaretShapes that uses the default caret policy.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - an offset in this \n\u003ccode\u003eTextLayout\u003c/code\u003e",
          "\u003ccode\u003ebounds\u003c/code\u003e - the bounds to which to extend the carets. This is in baseline-relative coordinates."
        ],
        "return": [
          "two paths corresponding to the strong and weak caret as defined by the \n\u003ccode\u003eDEFAULT_CARET_POLICY\u003c/code\u003e. These are in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCaretShapes",
      "comment": "Returns two paths corresponding to the strong and weak caret. This method is a convenience overload of getCaretShapes that uses the default caret policy and this TextLayout object\u0027s natural bounds.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - an offset in this \n\u003ccode\u003eTextLayout\u003c/code\u003e"
        ],
        "return": [
          "two paths corresponding to the strong and weak caret as defined by the \n\u003ccode\u003eDEFAULT_CARET_POLICY\u003c/code\u003e. These are in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "firstEndpoint"
          }
        },
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "secondEndpoint"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLogicalRangesForVisualSelection",
      "comment": "Returns the logical ranges of text corresponding to a visual selection.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo,java.awt.font.TextHitInfo,java.awt.geom.Rectangle2D)\"\u003e\u003ccode\u003egetVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003efirstEndpoint\u003c/code\u003e - an endpoint of the visual range",
          "\u003ccode\u003esecondEndpoint\u003c/code\u003e - the other endpoint of the visual range. This endpoint can be less than \n\u003ccode\u003efirstEndpoint\u003c/code\u003e."
        ],
        "return": [
          "an array of integers representing start/limit pairs for the selected ranges."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "firstEndpoint"
          }
        },
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "secondEndpoint"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "bounds"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getVisualHighlightShape",
      "comment": "Returns a path enclosing the visual selection in the specified range, extended to bounds. If the selection includes the leftmost (topmost) position, the selection is extended to the left (top) of bounds. If the selection includes the rightmost (bottommost) position, the selection is extended to the right (bottom) of the bounds. The height (width on vertical lines) of the selection is always extended to bounds. Although the selection is always contiguous, the logically selected text can be discontiguous on lines with mixed-direction text. The logical ranges of text selected can be retrieved using getLogicalRangesForVisualSelection. For example, consider the text \u0027ABCdef\u0027 where capital letters indicate right-to-left text, rendered on a right-to-left line, with a visual selection from 0L (the leading edge of \u0027A\u0027) to 3T (the trailing edge of \u0027d\u0027). The text appears as follows, with bold underlined areas representing the selection:     defCBA  \n The logical selection ranges are 0-3, 4-6 (ABC, ef) because the visually contiguous text is logically discontiguous. Also note that since the rightmost position on the layout (to the right of \u0027A\u0027) is selected, the selection is extended to the right of the bounds.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo,java.awt.font.TextHitInfo)\"\u003e\u003ccode\u003egetLogicalRangesForVisualSelection(TextHitInfo, TextHitInfo)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getLogicalHighlightShape(int,int,java.awt.geom.Rectangle2D)\"\u003e\u003ccode\u003egetLogicalHighlightShape(int, int, Rectangle2D)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003efirstEndpoint\u003c/code\u003e - one end of the visual selection",
          "\u003ccode\u003esecondEndpoint\u003c/code\u003e - the other end of the visual selection",
          "\u003ccode\u003ebounds\u003c/code\u003e - the bounding rectangle to which to extend the selection. This is in baseline-relative coordinates."
        ],
        "return": [
          "a \n\u003ccode\u003eShape\u003c/code\u003e enclosing the selection. This is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "firstEndpoint"
          }
        },
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "secondEndpoint"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getVisualHighlightShape",
      "comment": "Returns a Shape enclosing the visual selection in the specified range, extended to the bounds. This method is a convenience overload of getVisualHighlightShape that uses the natural bounds of this TextLayout.",
      "tagMap": {
        "param": [
          "\u003ccode\u003efirstEndpoint\u003c/code\u003e - one end of the visual selection",
          "\u003ccode\u003esecondEndpoint\u003c/code\u003e - the other end of the visual selection"
        ],
        "return": [
          "a \n\u003ccode\u003eShape\u003c/code\u003e enclosing the selection. This is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "firstEndpoint"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "secondEndpoint"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "bounds"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLogicalHighlightShape",
      "comment": "Returns a Shape enclosing the logical selection in the specified range, extended to the specified bounds. If the selection range includes the first logical character, the selection is extended to the portion of bounds before the start of this TextLayout. If the range includes the last logical character, the selection is extended to the portion of bounds after the end of this TextLayout. The height (width on vertical lines) of the selection is always extended to bounds. The selection can be discontiguous on lines with mixed-direction text. Only those characters in the logical range between start and limit appear selected. For example, consider the text \u0027ABCdef\u0027 where capital letters indicate right-to-left text, rendered on a right-to-left line, with a logical selection from 0 to 4 (\u0027ABCd\u0027). The text appears as follows, with bold standing in for the selection, and underlining for the extension:     defCBA  \n The selection is discontiguous because the selected characters are visually discontiguous. Also note that since the range includes the first logical character (A), the selection is extended to the portion of the bounds before the start of the layout, which in this case (a right-to-left line) is the right portion of the bounds.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo,java.awt.font.TextHitInfo,java.awt.geom.Rectangle2D)\"\u003e\u003ccode\u003egetVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003efirstEndpoint\u003c/code\u003e - an endpoint in the range of characters to select",
          "\u003ccode\u003esecondEndpoint\u003c/code\u003e - the other endpoint of the range of characters to select. Can be less than \n\u003ccode\u003efirstEndpoint\u003c/code\u003e. The range includes the character at min(firstEndpoint, secondEndpoint), but excludes max(firstEndpoint, secondEndpoint).",
          "\u003ccode\u003ebounds\u003c/code\u003e - the bounding rectangle to which to extend the selection. This is in baseline-relative coordinates."
        ],
        "return": [
          "an area enclosing the selection. This is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "firstEndpoint"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "secondEndpoint"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLogicalHighlightShape",
      "comment": "Returns a Shape enclosing the logical selection in the specified range, extended to the natural bounds of this TextLayout. This method is a convenience overload of getLogicalHighlightShape that uses the natural bounds of this TextLayout.",
      "tagMap": {
        "param": [
          "\u003ccode\u003efirstEndpoint\u003c/code\u003e - an endpoint in the range of characters to select",
          "\u003ccode\u003esecondEndpoint\u003c/code\u003e - the other endpoint of the range of characters to select. Can be less than \n\u003ccode\u003efirstEndpoint\u003c/code\u003e. The range includes the character at min(firstEndpoint, secondEndpoint), but excludes max(firstEndpoint, secondEndpoint)."
        ],
        "return": [
          "a \n\u003ccode\u003eShape\u003c/code\u003e enclosing the selection. This is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "firstEndpoint"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "secondEndpoint"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getBlackBoxBounds",
      "comment": "Returns the black box bounds of the characters in the specified range. The black box bounds is an area consisting of the union of the bounding boxes of all the glyphs corresponding to the characters between start and limit. This area can be disjoint.",
      "tagMap": {
        "param": [
          "\u003ccode\u003efirstEndpoint\u003c/code\u003e - one end of the character range",
          "\u003ccode\u003esecondEndpoint\u003c/code\u003e - the other end of the character range. Can be less than \n\u003ccode\u003efirstEndpoint\u003c/code\u003e."
        ],
        "return": [
          "a \n\u003ccode\u003eShape\u003c/code\u003e enclosing the black box bounds. This is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "bounds"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hitTestChar",
      "comment": "Returns a TextHitInfo corresponding to the specified point. Coordinates outside the bounds of the TextLayout map to hits on the leading edge of the first logical character, or the trailing edge of the last logical character, as appropriate, regardless of the position of that character in the line. Only the direction along the baseline is used to make this evaluation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the x offset from the origin of this \n\u003ccode\u003eTextLayout\u003c/code\u003e. This is in standard coordinates.",
          "\u003ccode\u003ey\u003c/code\u003e - the y offset from the origin of this \n\u003ccode\u003eTextLayout\u003c/code\u003e. This is in standard coordinates.",
          "\u003ccode\u003ebounds\u003c/code\u003e - the bounds of the \n\u003ccode\u003eTextLayout\u003c/code\u003e. This is in baseline-relative coordinates."
        ],
        "return": [
          "a hit describing the character and edge (leading or trailing) under the specified point."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextHitInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hitTestChar",
      "comment": "Returns a TextHitInfo corresponding to the specified point. This method is a convenience overload of hitTestChar that uses the natural bounds of this TextLayout.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the x offset from the origin of this \n\u003ccode\u003eTextLayout\u003c/code\u003e. This is in standard coordinates.",
          "\u003ccode\u003ey\u003c/code\u003e - the y offset from the origin of this \n\u003ccode\u003eTextLayout\u003c/code\u003e. This is in standard coordinates."
        ],
        "return": [
          "a hit describing the character and edge (leading or trailing) under the specified point."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextLayout",
            "type": "Class"
          },
          "field": {
            "name": "rhs"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "equals",
      "comment": "Returns true if the two layouts are equal. Obeys the general contract of equals(Object).",
      "tagMap": {
        "param": [
          "\u003ccode\u003erhs\u003c/code\u003e - the \n\u003ccode\u003eTextLayout\u003c/code\u003e to compare to this \n\u003ccode\u003eTextLayout\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified \n\u003ccode\u003eTextLayout\u003c/code\u003e equals this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns debugging information for this TextLayout.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "the \n\u003ccode\u003etextLine\u003c/code\u003e of this \n\u003ccode\u003eTextLayout\u003c/code\u003e as a \n\u003ccode\u003eString\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.Graphics2D",
            "type": "Class"
          },
          "field": {
            "name": "g2"
          }
        },
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "draw",
      "comment": "Renders this TextLayout at the specified location in the specified Graphics2D context. The origin of the layout is placed at x, y. Rendering may touch any point within getBounds() of this position. This leaves the g2 unchanged. Text is rendered along the baseline path.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html#getBounds()\"\u003e\u003ccode\u003egetBounds()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eg2\u003c/code\u003e - the \n\u003ccode\u003eGraphics2D\u003c/code\u003e context into which to render the layout",
          "\u003ccode\u003ex\u003c/code\u003e - the X coordinate of the origin of this \n\u003ccode\u003eTextLayout\u003c/code\u003e",
          "\u003ccode\u003ey\u003c/code\u003e - the Y coordinate of the origin of this \n\u003ccode\u003eTextLayout\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "field": {
            "name": "tx"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getOutline",
      "comment": "Returns a Shape representing the outline of this TextLayout.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etx\u003c/code\u003e - an optional \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html\" title\u003d\"class in java.awt.geom\"\u003e\u003ccode\u003eAffineTransform\u003c/code\u003e\u003c/a\u003e to apply to the outline of this \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ],
        "return": [
          "a \n\u003ccode\u003eShape\u003c/code\u003e that is the outline of this \n\u003ccode\u003eTextLayout\u003c/code\u003e. This is in standard coordinates."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.LayoutPath",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLayoutPath",
      "comment": "Return the LayoutPath, or null if the layout path is the default path (x maps to advance, y maps to offset).",
      "tagMap": {
        "return": [
          "the layout path"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.font.TextHitInfo",
            "type": "Class"
          },
          "field": {
            "name": "hit"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "field": {
            "name": "point"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hitToPoint",
      "comment": "Convert a hit to a point in standard coordinates. The point is on the baseline of the character at the leading or trailing edge of the character, as appropriate. If the path is broken at the side of the character represented by the hit, the point will be adjacent to the character.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ehit\u003c/code\u003e - the hit to check. This must be a valid hit on the TextLayout.",
          "\u003ccode\u003epoint\u003c/code\u003e - the returned point. The point is in standard coordinates."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the hit is not valid for the TextLayout.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if hit or point is null."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "string"
          }
        },
        {
          "type": {
            "name": "java.awt.Font",
            "type": "Class"
          },
          "field": {
            "name": "font"
          }
        },
        {
          "type": {
            "name": "java.awt.font.FontRenderContext",
            "type": "Class"
          },
          "field": {
            "name": "frc"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a TextLayout from a String and a Font. All the text is styled using the specified Font. The String must specify a single paragraph of text, because an entire paragraph is required for the bidirectional algorithm.",
      "tagMap": {
        "param": [
          "\u003ccode\u003estring\u003c/code\u003e - the text to display",
          "\u003ccode\u003efont\u003c/code\u003e - a \n\u003ccode\u003eFont\u003c/code\u003e used to style the text",
          "\u003ccode\u003efrc\u003c/code\u003e - contains information about a graphics device which is needed to measure the text correctly. Text measurements can vary slightly depending on the device resolution, and attributes such as antialiasing. This parameter does not specify a translation between the \n\u003ccode\u003eTextLayout\u003c/code\u003e and user space."
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "string"
          }
        },
        {
          "type": {
            "name": "java.util.Map",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "java.text.AttributedCharacterIterator$Attribute",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "attributes"
          }
        },
        {
          "type": {
            "name": "java.awt.font.FontRenderContext",
            "type": "Class"
          },
          "field": {
            "name": "frc"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a TextLayout from a String and an attribute set. All the text is styled using the provided attributes. string must specify a single paragraph of text because an entire paragraph is required for the bidirectional algorithm.",
      "tagMap": {
        "param": [
          "\u003ccode\u003estring\u003c/code\u003e - the text to display",
          "\u003ccode\u003eattributes\u003c/code\u003e - the attributes used to style the text",
          "\u003ccode\u003efrc\u003c/code\u003e - contains information about a graphics device which is needed to measure the text correctly. Text measurements can vary slightly depending on the device resolution, and attributes such as antialiasing. This parameter does not specify a translation between the \n\u003ccode\u003eTextLayout\u003c/code\u003e and user space."
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.text.AttributedCharacterIterator",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        },
        {
          "type": {
            "name": "java.awt.font.FontRenderContext",
            "type": "Class"
          },
          "field": {
            "name": "frc"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a TextLayout from an iterator over styled text. The iterator must specify a single paragraph of text because an entire paragraph is required for the bidirectional algorithm.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the styled text to display",
          "\u003ccode\u003efrc\u003c/code\u003e - contains information about a graphics device which is needed to measure the text correctly. Text measurements can vary slightly depending on the device resolution, and attributes such as antialiasing. This parameter does not specify a translation between the \n\u003ccode\u003eTextLayout\u003c/code\u003e and user space."
        ]
      }
    }
  ],
  "innerClasses": [
    "java.awt.font.TextLayout$CaretPolicy"
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.awt.font.TextLayout",
  "comment": "\u003ccode\u003eTextLayout\u003c/code\u003e is an immutable graphical representation of styled character data. \n\u003cp\u003e It provides the following capabilities: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eimplicit bidirectional analysis and reordering, \u003c/li\u003e\n \u003cli\u003ecursor positioning and movement, including split cursors for mixed directional text, \u003c/li\u003e\n \u003cli\u003ehighlighting, including both logical and visual highlighting for mixed directional text, \u003c/li\u003e\n \u003cli\u003emultiple baselines (roman, hanging, and centered), \u003c/li\u003e\n \u003cli\u003ehit testing, \u003c/li\u003e\n \u003cli\u003ejustification, \u003c/li\u003e\n \u003cli\u003edefault font substitution, \u003c/li\u003e\n \u003cli\u003emetric information such as ascent, descent, and advance, and \u003c/li\u003e\n \u003cli\u003erendering \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e A \u003ccode\u003eTextLayout\u003c/code\u003e object can be rendered using its \u003ccode\u003edraw\u003c/code\u003e method. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eTextLayout\u003c/code\u003e can be constructed either directly or through the use of a \u003ca href\u003d\"LineBreakMeasurer.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e\u003c/a\u003e. When constructed directly, the source text represents a single paragraph. \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e allows styled text to be broken into lines that fit within a particular width. See the \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e documentation for more information. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eTextLayout\u003c/code\u003e construction logically proceeds as follows: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eparagraph attributes are extracted and examined, \u003c/li\u003e\n \u003cli\u003etext is analyzed for bidirectional reordering, and reordering information is computed if needed, \u003c/li\u003e\n \u003cli\u003etext is segmented into style runs \u003c/li\u003e\n \u003cli\u003efonts are chosen for style runs, first by using a font if the attribute \u003ca href\u003d\"TextAttribute.html#FONT\"\u003e\u003ccode\u003eTextAttribute.FONT\u003c/code\u003e\u003c/a\u003e is present, otherwise by computing a default font using the attributes that have been defined \u003c/li\u003e\n \u003cli\u003eif text is on multiple baselines, the runs or subruns are further broken into subruns sharing a common baseline, \u003c/li\u003e\n \u003cli\u003eglyphvectors are generated for each run using the chosen font, \u003c/li\u003e\n \u003cli\u003efinal bidirectional reordering is performed on the glyphvectors \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e All graphical information returned from a \u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s methods is relative to the origin of the \u003ccode\u003eTextLayout\u003c/code\u003e, which is the intersection of the \u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s baseline with its left edge. Also, coordinates passed into a \u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s methods are assumed to be relative to the \u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s origin. Clients usually need to translate between a \u003ccode\u003eTextLayout\u003c/code\u003e object\u0027s coordinate system and the coordinate system in another object (such as a \u003ca href\u003d\"../Graphics.html\" title\u003d\"class in java.awt\"\u003e\u003ccode\u003eGraphics\u003c/code\u003e\u003c/a\u003e object). \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eTextLayout\u003c/code\u003e objects are constructed from styled text, but they do not retain a reference to their source text. Thus, changes in the text previously used to generate a \u003ccode\u003eTextLayout\u003c/code\u003e do not affect the \u003ccode\u003eTextLayout\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e Three methods on a \u003ccode\u003eTextLayout\u003c/code\u003e object (\u003ccode\u003egetNextRightHit\u003c/code\u003e, \u003ccode\u003egetNextLeftHit\u003c/code\u003e, and \u003ccode\u003ehitTestChar\u003c/code\u003e) return instances of \u003ca href\u003d\"TextHitInfo.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eTextHitInfo\u003c/code\u003e\u003c/a\u003e. The offsets contained in these \u003ccode\u003eTextHitInfo\u003c/code\u003e objects are relative to the start of the \u003ccode\u003eTextLayout\u003c/code\u003e, \u003cb\u003enot\u003c/b\u003e to the text used to create the \u003ccode\u003eTextLayout\u003c/code\u003e. Similarly, \u003ccode\u003eTextLayout\u003c/code\u003e methods that accept \u003ccode\u003eTextHitInfo\u003c/code\u003e instances as parameters expect the \u003ccode\u003eTextHitInfo\u003c/code\u003e object\u0027s offsets to be relative to the \u003ccode\u003eTextLayout\u003c/code\u003e, not to any underlying text storage model. \u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eExamples\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003e Constructing and drawing a \u003ccode\u003eTextLayout\u003c/code\u003e and its bounding rectangle: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e   Graphics2D g \u003d ...;\n   Point2D loc \u003d ...;\n   Font font \u003d Font.getFont(\"Helvetica-bold-italic\");\n   FontRenderContext frc \u003d g.getFontRenderContext();\n   TextLayout layout \u003d new TextLayout(\"This is a string\", font, frc);\n   layout.draw(g, (float)loc.getX(), (float)loc.getY());\n\n   Rectangle2D bounds \u003d layout.getBounds();\n   bounds.setRect(bounds.getX()+loc.getX(),\n                  bounds.getY()+loc.getY(),\n                  bounds.getWidth(),\n                  bounds.getHeight());\n   g.draw(bounds);\n \u003c/pre\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Hit-testing a \u003ccode\u003eTextLayout\u003c/code\u003e (determining which character is at a particular graphical location): \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e   Point2D click \u003d ...;\n   TextHitInfo hit \u003d layout.hitTestChar(\n                         (float) (click.getX() - loc.getX()),\n                         (float) (click.getY() - loc.getY()));\n \u003c/pre\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Responding to a right-arrow key press: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e   int insertionIndex \u003d ...;\n   TextHitInfo next \u003d layout.getNextRightHit(insertionIndex);\n   if (next !\u003d null) {\n       // translate graphics to origin of layout on screen\n       g.translate(loc.getX(), loc.getY());\n       Shape[] carets \u003d layout.getCaretShapes(next.getInsertionIndex());\n       g.draw(carets[0]);\n       if (carets[1] !\u003d null) {\n           g.draw(carets[1]);\n       }\n   }\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Drawing a selection range corresponding to a substring in the source text. The selected area may not be visually contiguous: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e   // selStart, selLimit should be relative to the layout,\n   // not to the source text\n\n   int selStart \u003d ..., selLimit \u003d ...;\n   Color selectionColor \u003d ...;\n   Shape selection \u003d layout.getLogicalHighlightShape(selStart, selLimit);\n   // selection may consist of disjoint areas\n   // graphics is assumed to be translated to origin of layout\n   g.setColor(selectionColor);\n   g.fill(selection);\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Drawing a visually contiguous selection range. The selection range may correspond to more than one substring in the source text. The ranges of the corresponding source text substrings can be obtained with \u003ccode\u003egetLogicalRangesForVisualSelection()\u003c/code\u003e: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e   TextHitInfo selStart \u003d ..., selLimit \u003d ...;\n   Shape selection \u003d layout.getVisualHighlightShape(selStart, selLimit);\n   g.setColor(selectionColor);\n   g.fill(selection);\n   int[] ranges \u003d getLogicalRangesForVisualSelection(selStart, selLimit);\n   // ranges[0], ranges[1] is the first selection range,\n   // ranges[2], ranges[3] is the second selection range, etc.\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Note: Font rotations can cause text baselines to be rotated, and multiple runs with different rotations can cause the baseline to bend or zig-zag. In order to account for this (rare) possibility, some APIs are specified to return metrics and take parameters \u0027in baseline-relative coordinates\u0027 (e.g. ascent, advance), and others are in \u0027in standard coordinates\u0027 (e.g. getBounds). Values in baseline-relative coordinates map the \u0027x\u0027 coordinate to the distance along the baseline, (positive x is forward along the baseline), and the \u0027y\u0027 coordinate to a distance along the perpendicular to the baseline at \u0027x\u0027 (positive y is 90 degrees clockwise from the baseline vector). Values in standard coordinates are measured along the x and y axes, with 0,0 at the origin of the TextLayout. Documentation for each relevant API indicates what values are in what coordinate system. In general, measurement-related APIs are in baseline-relative coordinates, while display-related APIs are in standard coordinates.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextAttribute.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eTextAttribute\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextHitInfo.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eTextHitInfo\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LayoutPath.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eLayoutPath\u003c/code\u003e\u003c/a\u003e"
    ]
  }
}