{
  "packageName": "java.awt.font",
  "simpleName": "LineBreakMeasurer",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "wrappingWidth"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextOffset",
      "comment": "Returns the position at the end of the next layout. Does NOT update the current position of this LineBreakMeasurer.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ewrappingWidth\u003c/code\u003e - the maximum visible advance permitted for the text in the next layout"
        ],
        "return": [
          "an offset in the text representing the limit of the next \n\u003ccode\u003eTextLayout\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "wrappingWidth"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offsetLimit"
          }
        },
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "requireNextWord"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextOffset",
      "comment": "Returns the position at the end of the next layout. Does NOT update the current position of this LineBreakMeasurer.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ewrappingWidth\u003c/code\u003e - the maximum visible advance permitted for the text in the next layout",
          "\u003ccode\u003eoffsetLimit\u003c/code\u003e - the first character that can not be included in the next layout, even if the text after the limit would fit within the wrapping width; \n\u003ccode\u003eoffsetLimit\u003c/code\u003e must be greater than the current position",
          "\u003ccode\u003erequireNextWord\u003c/code\u003e - if \n\u003ccode\u003etrue\u003c/code\u003e, the current position that is returned if the entire next word does not fit within \n\u003ccode\u003ewrappingWidth\u003c/code\u003e; if \n\u003ccode\u003efalse\u003c/code\u003e, the offset returned is at least one greater than the current position"
        ],
        "return": [
          "an offset in the text representing the limit of the next \n\u003ccode\u003eTextLayout\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextLayout",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "wrappingWidth"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextLayout",
      "comment": "Returns the next layout, and updates the current position.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ewrappingWidth\u003c/code\u003e - the maximum visible advance permitted for the text in the next layout"
        ],
        "return": [
          "a \n\u003ccode\u003eTextLayout\u003c/code\u003e, beginning at the current position, which represents the next line fitting within \n\u003ccode\u003ewrappingWidth\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.font.TextLayout",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "float",
            "type": "Class"
          },
          "field": {
            "name": "wrappingWidth"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offsetLimit"
          }
        },
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "requireNextWord"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextLayout",
      "comment": "Returns the next layout, and updates the current position.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ewrappingWidth\u003c/code\u003e - the maximum visible advance permitted for the text in the next layout",
          "\u003ccode\u003eoffsetLimit\u003c/code\u003e - the first character that can not be included in the next layout, even if the text after the limit would fit within the wrapping width; \n\u003ccode\u003eoffsetLimit\u003c/code\u003e must be greater than the current position",
          "\u003ccode\u003erequireNextWord\u003c/code\u003e - if \n\u003ccode\u003etrue\u003c/code\u003e, and if the entire word at the current position does not fit within the wrapping width, \n\u003ccode\u003enull\u003c/code\u003e is returned. If \n\u003ccode\u003efalse\u003c/code\u003e, a valid layout is returned that includes at least the character at the current position"
        ],
        "return": [
          "a \n\u003ccode\u003eTextLayout\u003c/code\u003e, beginning at the current position, that represents the next line fitting within \n\u003ccode\u003ewrappingWidth\u003c/code\u003e. If the current position is at the end of the text used by this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e, \n\u003ccode\u003enull\u003c/code\u003e is returned"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPosition",
      "comment": "Returns the current position of this LineBreakMeasurer.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#setPosition(int)\"\u003e\u003ccode\u003esetPosition(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the current position of this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "newPosition"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setPosition",
      "comment": "Sets the current position of this LineBreakMeasurer.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#getPosition()\"\u003e\u003ccode\u003egetPosition()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003enewPosition\u003c/code\u003e - the current position of this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e; the position should be within the text used to construct this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e (or in the text most recently passed to \n\u003ccode\u003einsertChar\u003c/code\u003e or \n\u003ccode\u003edeleteChar\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.text.AttributedCharacterIterator",
            "type": "Class"
          },
          "field": {
            "name": "newParagraph"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "insertPos"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "insertChar",
      "comment": "Updates this LineBreakMeasurer after a single character is inserted into the text, and sets the current position to the beginning of the paragraph.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator,int)\"\u003e\u003ccode\u003edeleteChar(java.text.AttributedCharacterIterator, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003enewParagraph\u003c/code\u003e - the text after the insertion",
          "\u003ccode\u003einsertPos\u003c/code\u003e - the position in the text at which the character is inserted"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003einsertPos\u003c/code\u003e is less than the start of \n\u003ccode\u003enewParagraph\u003c/code\u003e or greater than or equal to the end of \n\u003ccode\u003enewParagraph\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewParagraph\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.text.AttributedCharacterIterator",
            "type": "Class"
          },
          "field": {
            "name": "newParagraph"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "deletePos"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deleteChar",
      "comment": "Updates this LineBreakMeasurer after a single character is deleted from the text, and sets the current position to the beginning of the paragraph.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator,int)\"\u003e\u003ccode\u003einsertChar(java.text.AttributedCharacterIterator, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003enewParagraph\u003c/code\u003e - the text after the deletion",
          "\u003ccode\u003edeletePos\u003c/code\u003e - the position in the text at which the character is deleted"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003edeletePos\u003c/code\u003e is less than the start of \n\u003ccode\u003enewParagraph\u003c/code\u003e or greater than the end of \n\u003ccode\u003enewParagraph\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewParagraph\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.text.AttributedCharacterIterator",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        },
        {
          "type": {
            "name": "java.awt.font.FontRenderContext",
            "type": "Class"
          },
          "field": {
            "name": "frc"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a LineBreakMeasurer for the specified text.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator,int)\"\u003e\u003ccode\u003einsertChar(java.text.AttributedCharacterIterator, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator,int)\"\u003e\u003ccode\u003edeleteChar(java.text.AttributedCharacterIterator, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the text for which this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e produces \n\u003ccode\u003eTextLayout\u003c/code\u003e objects; the text must contain at least one character; if the text available through \n\u003ccode\u003eiter\u003c/code\u003e changes, further calls to this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e instance are undefined (except, in some cases, when \n\u003ccode\u003einsertChar\u003c/code\u003e or \n\u003ccode\u003edeleteChar\u003c/code\u003e are invoked afterward - see below)",
          "\u003ccode\u003efrc\u003c/code\u003e - contains information about a graphics device which is needed to measure the text correctly; text measurements can vary slightly depending on the device resolution, and attributes such as antialiasing; this parameter does not specify a translation between the \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e and user space"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.text.AttributedCharacterIterator",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        },
        {
          "type": {
            "name": "java.text.BreakIterator",
            "type": "Class"
          },
          "field": {
            "name": "breakIter"
          }
        },
        {
          "type": {
            "name": "java.awt.font.FontRenderContext",
            "type": "Class"
          },
          "field": {
            "name": "frc"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a LineBreakMeasurer for the specified text.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator,int)\"\u003e\u003ccode\u003einsertChar(java.text.AttributedCharacterIterator, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator,int)\"\u003e\u003ccode\u003edeleteChar(java.text.AttributedCharacterIterator, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the text for which this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e produces \n\u003ccode\u003eTextLayout\u003c/code\u003e objects; the text must contain at least one character; if the text available through \n\u003ccode\u003eiter\u003c/code\u003e changes, further calls to this \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e instance are undefined (except, in some cases, when \n\u003ccode\u003einsertChar\u003c/code\u003e or \n\u003ccode\u003edeleteChar\u003c/code\u003e are invoked afterward - see below)",
          "\u003ccode\u003ebreakIter\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/BreakIterator.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eBreakIterator\u003c/code\u003e\u003c/a\u003e which defines line breaks",
          "\u003ccode\u003efrc\u003c/code\u003e - contains information about a graphics device which is needed to measure the text correctly; text measurements can vary slightly depending on the device resolution, and attributes such as antialiasing; this parameter does not specify a translation between the \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e and user space"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the text has less than one character"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.awt.font.LineBreakMeasurer",
  "comment": "The \n\u003ccode\u003eLineBreakMeasurer\u003c/code\u003e class allows styled text to be broken into lines (or segments) that fit within a particular visual advance. This is useful for clients who wish to display a paragraph of text that fits within a specific width, called the \n\u003cb\u003ewrapping width\u003c/b\u003e. \n\u003cp\u003e \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e is constructed with an iterator over styled text. The iterator\u0027s range should be a single paragraph in the text. \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e maintains a position in the text for the start of the next text segment. Initially, this position is the start of text. Paragraphs are assigned an overall direction (either left-to-right or right-to-left) according to the bidirectional formatting rules. All segments obtained from a paragraph have the same direction as the paragraph. \u003c/p\u003e\n\u003cp\u003e Segments of text are obtained by calling the method \u003ccode\u003enextLayout\u003c/code\u003e, which returns a \u003ca href\u003d\"TextLayout.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eTextLayout\u003c/code\u003e\u003c/a\u003e representing the text that fits within the wrapping width. The \u003ccode\u003enextLayout\u003c/code\u003e method moves the current position to the end of the layout returned from \u003ccode\u003enextLayout\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e implements the most commonly used line-breaking policy: Every word that fits within the wrapping width is placed on the line. If the first word does not fit, then all of the characters that fit within the wrapping width are placed on the line. At least one character is placed on each line. \u003c/p\u003e\n\u003cp\u003e The \u003ccode\u003eTextLayout\u003c/code\u003e instances returned by \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e treat tabs like 0-width spaces. Clients who wish to obtain tab-delimited segments for positioning should use the overload of \u003ccode\u003enextLayout\u003c/code\u003e which takes a limiting offset in the text. The limiting offset should be the first character after the tab. The \u003ccode\u003eTextLayout\u003c/code\u003e objects returned from this method end at the limit provided (or before, if the text between the current position and the limit won\u0027t fit entirely within the wrapping width). \u003c/p\u003e\n\u003cp\u003e Clients who are laying out tab-delimited text need a slightly different line-breaking policy after the first segment has been placed on a line. Instead of fitting partial words in the remaining space, they should place words which don\u0027t fit in the remaining space entirely on the next line. This change of policy can be requested in the overload of \u003ccode\u003enextLayout\u003c/code\u003e which takes a \u003ccode\u003eboolean\u003c/code\u003e parameter. If this parameter is \u003ccode\u003etrue\u003c/code\u003e, \u003ccode\u003enextLayout\u003c/code\u003e returns \u003ccode\u003enull\u003c/code\u003e if the first word won\u0027t fit in the given space. See the tab sample below. \u003c/p\u003e\n\u003cp\u003e In general, if the text used to construct the \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e changes, a new \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e must be constructed to reflect the change. (The old \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e continues to function properly, but it won\u0027t be aware of the text change.) Nevertheless, if the text change is the insertion or deletion of a single character, an existing \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e can be \u0027updated\u0027 by calling \u003ccode\u003einsertChar\u003c/code\u003e or \u003ccode\u003edeleteChar\u003c/code\u003e. Updating an existing \u003ccode\u003eLineBreakMeasurer\u003c/code\u003e is much faster than creating a new one. Clients who modify text based on user typing should take advantage of these methods. \u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eExamples\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003e Rendering a paragraph in a component \u003c/p\u003e\n\u003cblockquote\u003e \n \u003cpre\u003e\u003ccode\u003e\n public void paint(Graphics graphics) {\n\n     float dx \u003d 0f, dy \u003d 5f;\n     Graphics2D g2d \u003d (Graphics2D)graphics;\n     FontRenderContext frc \u003d g2d.getFontRenderContext();\n\n     AttributedString text \u003d new AttributedString(\".....\");\n     AttributedCharacterIterator paragraph \u003d text.getIterator();\n\n     LineBreakMeasurer measurer \u003d new LineBreakMeasurer(paragraph, frc);\n     measurer.setPosition(paragraph.getBeginIndex());\n     float wrappingWidth \u003d (float)getSize().width;\n\n     while (measurer.getPosition() \u0026lt; paragraph.getEndIndex()) {\n\n         TextLayout layout \u003d measurer.nextLayout(wrappingWidth);\n\n         dy +\u003d (layout.getAscent());\n         float dx \u003d layout.isLeftToRight() ?\n             0 : (wrappingWidth - layout.getAdvance());\n\n         layout.draw(graphics, dx, dy);\n         dy +\u003d layout.getDescent() + layout.getLeading();\n     }\n }\n \u003c/code\u003e\u003c/pre\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Rendering text with tabs. For simplicity, the overall text direction is assumed to be left-to-right \u003c/p\u003e\n\u003cblockquote\u003e \n \u003cpre\u003e\u003ccode\u003e\n public void paint(Graphics graphics) {\n\n     float leftMargin \u003d 10, rightMargin \u003d 310;\n     float[] tabStops \u003d { 100, 250 };\n\n     // assume styledText is an AttributedCharacterIterator, and the number\n     // of tabs in styledText is tabCount\n\n     int[] tabLocations \u003d new int[tabCount+1];\n\n     int i \u003d 0;\n     for (char c \u003d styledText.first(); c !\u003d styledText.DONE; c \u003d styledText.next()) {\n         if (c \u003d\u003d \u0027\\t\u0027) {\n             tabLocations[i++] \u003d styledText.getIndex();\n         }\n     }\n     tabLocations[tabCount] \u003d styledText.getEndIndex() - 1;\n\n     // Now tabLocations has an entry for every tab\u0027s offset in\n     // the text.  For convenience, the last entry is tabLocations\n     // is the offset of the last character in the text.\n\n     LineBreakMeasurer measurer \u003d new LineBreakMeasurer(styledText);\n     int currentTab \u003d 0;\n     float verticalPos \u003d 20;\n\n     while (measurer.getPosition() \u0026lt; styledText.getEndIndex()) {\n\n         // Lay out and draw each line.  All segments on a line\n         // must be computed before any drawing can occur, since\n         // we must know the largest ascent on the line.\n         // TextLayouts are computed and stored in a Vector;\n         // their horizontal positions are stored in a parallel\n         // Vector.\n\n         // lineContainsText is true after first segment is drawn\n         boolean lineContainsText \u003d false;\n         boolean lineComplete \u003d false;\n         float maxAscent \u003d 0, maxDescent \u003d 0;\n         float horizontalPos \u003d leftMargin;\n         Vector layouts \u003d new Vector(1);\n         Vector penPositions \u003d new Vector(1);\n\n         while (!lineComplete) {\n             float wrappingWidth \u003d rightMargin - horizontalPos;\n             TextLayout layout \u003d\n                     measurer.nextLayout(wrappingWidth,\n                                         tabLocations[currentTab]+1,\n                                         lineContainsText);\n\n             // layout can be null if lineContainsText is true\n             if (layout !\u003d null) {\n                 layouts.addElement(layout);\n                 penPositions.addElement(new Float(horizontalPos));\n                 horizontalPos +\u003d layout.getAdvance();\n                 maxAscent \u003d Math.max(maxAscent, layout.getAscent());\n                 maxDescent \u003d Math.max(maxDescent,\n                     layout.getDescent() + layout.getLeading());\n             } else {\n                 lineComplete \u003d true;\n             }\n\n             lineContainsText \u003d true;\n\n             if (measurer.getPosition() \u003d\u003d tabLocations[currentTab]+1) {\n                 currentTab++;\n             }\n\n             if (measurer.getPosition() \u003d\u003d styledText.getEndIndex())\n                 lineComplete \u003d true;\n             else if (horizontalPos \u0026gt;\u003d tabStops[tabStops.length-1])\n                 lineComplete \u003d true;\n\n             if (!lineComplete) {\n                 // move to next tab stop\n                 int j;\n                 for (j\u003d0; horizontalPos \u0026gt;\u003d tabStops[j]; j++) {}\n                 horizontalPos \u003d tabStops[j];\n             }\n         }\n\n         verticalPos +\u003d maxAscent;\n\n         Enumeration layoutEnum \u003d layouts.elements();\n         Enumeration positionEnum \u003d penPositions.elements();\n\n         // now iterate through layouts and draw them\n         while (layoutEnum.hasMoreElements()) {\n             TextLayout nextLayout \u003d (TextLayout) layoutEnum.nextElement();\n             Float nextPosition \u003d (Float) positionEnum.nextElement();\n             nextLayout.draw(graphics, nextPosition.floatValue(), verticalPos);\n         }\n\n         verticalPos +\u003d maxDescent;\n     }\n }\n \u003c/code\u003e\u003c/pre\u003e \n\u003c/blockquote\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/font/TextLayout.html\" title\u003d\"class in java.awt.font\"\u003e\u003ccode\u003eTextLayout\u003c/code\u003e\u003c/a\u003e"
    ]
  }
}