{
  "packageName": "java.awt.geom",
  "simpleName": "Path2D",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "WIND_EVEN_ODD",
      "comment": "An even-odd winding rule for determining the interior of a path.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/PathIterator.html#WIND_EVEN_ODD\"\u003e\u003ccode\u003ePathIterator.WIND_EVEN_ODD\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.Path2D.WIND_EVEN_ODD\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "WIND_NON_ZERO",
      "comment": "A non-zero winding rule for determining the interior of a path.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/PathIterator.html#WIND_NON_ZERO\"\u003e\u003ccode\u003ePathIterator.WIND_NON_ZERO\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.Path2D.WIND_NON_ZERO\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "moveTo",
      "comment": "Adds a point to the path by moving to the specified coordinates specified in double precision.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the specified X coordinate",
          "\u003ccode\u003ey\u003c/code\u003e - the specified Y coordinate"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "lineTo",
      "comment": "Adds a point to the path by drawing a straight line from the current coordinates to the new specified coordinates specified in double precision.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the specified X coordinate",
          "\u003ccode\u003ey\u003c/code\u003e - the specified Y coordinate"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x1"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y1"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x2"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y2"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "quadTo",
      "comment": "Adds a curved segment, defined by two new points, to the path by drawing a Quadratic curve that intersects both the current coordinates and the specified coordinates (x2,y2), using the specified point (x1,y1) as a quadratic parametric control point. All coordinates are specified in double precision.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ex1\u003c/code\u003e - the X coordinate of the quadratic control point",
          "\u003ccode\u003ey1\u003c/code\u003e - the Y coordinate of the quadratic control point",
          "\u003ccode\u003ex2\u003c/code\u003e - the X coordinate of the final end point",
          "\u003ccode\u003ey2\u003c/code\u003e - the Y coordinate of the final end point"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x1"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y1"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x2"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y2"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x3"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y3"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "curveTo",
      "comment": "Adds a curved segment, defined by three new points, to the path by drawing a Bézier curve that intersects both the current coordinates and the specified coordinates (x3,y3), using the specified points (x1,y1) and (x2,y2) as Bézier control points. All coordinates are specified in double precision.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ex1\u003c/code\u003e - the X coordinate of the first Bézier control point",
          "\u003ccode\u003ey1\u003c/code\u003e - the Y coordinate of the first Bézier control point",
          "\u003ccode\u003ex2\u003c/code\u003e - the X coordinate of the second Bézier control point",
          "\u003ccode\u003ey2\u003c/code\u003e - the Y coordinate of the second Bézier control point",
          "\u003ccode\u003ex3\u003c/code\u003e - the X coordinate of the final end point",
          "\u003ccode\u003ey3\u003c/code\u003e - the Y coordinate of the final end point"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "closePath",
      "comment": "Closes the current subpath by drawing a straight line back to the coordinates of the last moveTo. If the path is already closed then this method has no effect.",
      "tagMap": {
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.Shape",
            "type": "Class"
          },
          "field": {
            "name": "s"
          }
        },
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "connect"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "append",
      "comment": "Appends the geometry of the specified Shape object to the path, possibly connecting the new geometry to the existing path segments with a line segment. If the connect parameter is true and the path is not empty then any initial moveTo in the geometry of the appended Shape is turned into a lineTo segment. If the destination coordinates of such a connecting lineTo segment match the ending coordinates of a currently open subpath then the segment is omitted as superfluous. The winding rule of the specified Shape is ignored and the appended geometry is governed by the winding rule specified for this path.",
      "tagMap": {
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - the \n\u003ccode\u003eShape\u003c/code\u003e whose geometry is appended to this path",
          "\u003ccode\u003econnect\u003c/code\u003e - a boolean to control whether or not to turn an initial \n\u003ccode\u003emoveTo\u003c/code\u003e segment into a \n\u003ccode\u003elineTo\u003c/code\u003e segment to connect the new geometry to the existing path"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.PathIterator",
            "type": "Class"
          },
          "field": {
            "name": "pi"
          }
        },
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "connect"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "append",
      "comment": "Appends the geometry of the specified PathIterator object to the path, possibly connecting the new geometry to the existing path segments with a line segment. If the connect parameter is true and the path is not empty then any initial moveTo in the geometry of the appended Shape is turned into a lineTo segment. If the destination coordinates of such a connecting lineTo segment match the ending coordinates of a currently open subpath then the segment is omitted as superfluous. The winding rule of the specified Shape is ignored and the appended geometry is governed by the winding rule specified for this path.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epi\u003c/code\u003e - the \n\u003ccode\u003ePathIterator\u003c/code\u003e whose geometry is appended to this path",
          "\u003ccode\u003econnect\u003c/code\u003e - a boolean to control whether or not to turn an initial \n\u003ccode\u003emoveTo\u003c/code\u003e segment into a \n\u003ccode\u003elineTo\u003c/code\u003e segment to connect the new geometry to the existing path"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getWindingRule",
      "comment": "Returns the fill style winding rule.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Path2D.html#WIND_EVEN_ODD\"\u003e\u003ccode\u003eWIND_EVEN_ODD\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Path2D.html#WIND_NON_ZERO\"\u003e\u003ccode\u003eWIND_NON_ZERO\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Path2D.html#setWindingRule(int)\"\u003e\u003ccode\u003esetWindingRule(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an integer representing the current winding rule."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "rule"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "setWindingRule",
      "comment": "Sets the winding rule for this path to the specified value.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Path2D.html#getWindingRule()\"\u003e\u003ccode\u003egetWindingRule()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003erule\u003c/code\u003e - an integer representing the specified winding rule"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003erule\u003c/code\u003e is not either \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Path2D.html#WIND_EVEN_ODD\"\u003e\u003ccode\u003eWIND_EVEN_ODD\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Path2D.html#WIND_NON_ZERO\"\u003e\u003ccode\u003eWIND_NON_ZERO\u003c/code\u003e\u003c/a\u003e"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.Point2D",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getCurrentPoint",
      "comment": "Returns the coordinates most recently added to the end of the path as a Point2D object.",
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003ePoint2D\u003c/code\u003e object containing the ending coordinates of the path or \n\u003ccode\u003enull\u003c/code\u003e if there are no points in the path."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "reset",
      "comment": "Resets the path to empty. The append position is set back to the beginning of the path and all coordinates and point types are forgotten.",
      "tagMap": {
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "field": {
            "name": "at"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "transform",
      "comment": "Transforms the geometry of this path using the specified AffineTransform. The geometry is transformed in place, which permanently changes the boundary defined by this object.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eat\u003c/code\u003e - the \n\u003ccode\u003eAffineTransform\u003c/code\u003e used to transform the area"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "field": {
            "name": "at"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "createTransformedShape",
      "comment": "Returns a new Shape representing a transformed version of this Path2D. Note that the exact type and coordinate precision of the return value is not specified for this method. The method will return a Shape that contains no less precision for the transformed geometry than this Path2D currently maintains, but it may contain no more precision either. If the tradeoff of precision vs. storage size in the result is important then the convenience constructors in the Path2D.Float and Path2D.Double subclasses should be used to make the choice explicit.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eat\u003c/code\u003e - the \n\u003ccode\u003eAffineTransform\u003c/code\u003e used to transform a new \n\u003ccode\u003eShape\u003c/code\u003e."
        ],
        "return": [
          "a new \n\u003ccode\u003eShape\u003c/code\u003e, transformed with the specified \n\u003ccode\u003eAffineTransform\u003c/code\u003e."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Rectangle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getBounds",
      "comment": "Returns an integer Rectangle that completely encloses the Shape. Note that there is no guarantee that the returned Rectangle is the smallest bounding box that encloses the Shape, only that the Shape lies entirely within the indicated Rectangle. The returned Rectangle might also fail to completely enclose the Shape if the Shape overflows the limited range of the integer data type. The getBounds2D method generally returns a tighter bounding box due to its greater flexibility in representation. Note that the definition of insideness can lead to situations where points on the defining outline of the shape may not be considered contained in the returned bounds object, but only in cases where those points are also not considered contained in the original shape. If a point is inside the shape according to the contains(point) method, then it must be inside the returned Rectangle bounds object according to the contains(point) method of the bounds. Specifically: shape.contains(x,y) requires bounds.contains(x,y) If a point is not inside the shape, then it might still be contained in the bounds object: bounds.contains(x,y) does not imply shape.contains(x,y)",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#getBounds2D()\"\u003e\u003ccode\u003eShape.getBounds2D()\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#getBounds()\"\u003egetBounds\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "an integer \n\u003ccode\u003eRectangle\u003c/code\u003e that completely encloses the \n\u003ccode\u003eShape\u003c/code\u003e."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.PathIterator",
            "type": "Class"
          },
          "field": {
            "name": "pi"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "contains",
      "comment": "Tests if the specified coordinates are inside the closed boundary of the specified PathIterator. This method provides a basic facility for implementors of the Shape interface to implement support for the Shape.contains(double, double) method.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epi\u003c/code\u003e - the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e",
          "\u003ccode\u003ex\u003c/code\u003e - the specified X coordinate",
          "\u003ccode\u003ey\u003c/code\u003e - the specified Y coordinate"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified coordinates are inside the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.PathIterator",
            "type": "Class"
          },
          "field": {
            "name": "pi"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "field": {
            "name": "p"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "contains",
      "comment": "Tests if the specified Point2D is inside the closed boundary of the specified PathIterator. This method provides a basic facility for implementors of the Shape interface to implement support for the Shape.contains(Point2D) method.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epi\u003c/code\u003e - the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e",
          "\u003ccode\u003ep\u003c/code\u003e - the specified \n\u003ccode\u003ePoint2D\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified coordinates are inside the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "contains",
      "comment": "Tests if the specified coordinates are inside the boundary of the Shape, as described by the definition of insideness.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#contains(double,double)\"\u003econtains\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the specified X coordinate to be tested",
          "\u003ccode\u003ey\u003c/code\u003e - the specified Y coordinate to be tested"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified coordinates are inside the \n\u003ccode\u003eShape\u003c/code\u003e boundary; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "field": {
            "name": "p"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "contains",
      "comment": "Tests if a specified Point2D is inside the boundary of the Shape, as described by the definition of insideness.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#contains(java.awt.geom.Point2D)\"\u003econtains\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ep\u003c/code\u003e - the specified \n\u003ccode\u003ePoint2D\u003c/code\u003e to be tested"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified \n\u003ccode\u003ePoint2D\u003c/code\u003e is inside the boundary of the \n\u003ccode\u003eShape\u003c/code\u003e; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.PathIterator",
            "type": "Class"
          },
          "field": {
            "name": "pi"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "w"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "h"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "contains",
      "comment": "Tests if the specified rectangular area is entirely inside the closed boundary of the specified PathIterator. This method provides a basic facility for implementors of the Shape interface to implement support for the Shape.contains(double, double, double, double) method. This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a WIND_NON_ZERO winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epi\u003c/code\u003e - the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e",
          "\u003ccode\u003ex\u003c/code\u003e - the specified X coordinate",
          "\u003ccode\u003ey\u003c/code\u003e - the specified Y coordinate",
          "\u003ccode\u003ew\u003c/code\u003e - the width of the specified rectangular area",
          "\u003ccode\u003eh\u003c/code\u003e - the height of the specified rectangular area"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e contains the specified rectangular area; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.PathIterator",
            "type": "Class"
          },
          "field": {
            "name": "pi"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "r"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "contains",
      "comment": "Tests if the specified Rectangle2D is entirely inside the closed boundary of the specified PathIterator. This method provides a basic facility for implementors of the Shape interface to implement support for the Shape.contains(Rectangle2D) method. This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a WIND_NON_ZERO winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epi\u003c/code\u003e - the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e",
          "\u003ccode\u003er\u003c/code\u003e - a specified \n\u003ccode\u003eRectangle2D\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e contains the specified \n\u003ccode\u003eRectangle2D\u003c/code\u003e; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "w"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "h"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "contains",
      "comment": "Tests if the interior of the Shape entirely contains the specified rectangular area. All coordinates that lie inside the rectangular area must lie within the Shape for the entire rectangular area to be considered contained within the Shape. The Shape.contains() method allows a Shape implementation to conservatively return false when: the intersect method returns true and the calculations to determine whether or not the Shape entirely contains the rectangular area are prohibitively expensive. This means that for some Shapes this method might return false even though the Shape contains the rectangular area. The Area class performs more accurate geometric computations than most Shape objects and therefore can be used if a more precise answer is required. This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a WIND_NON_ZERO winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Area.html\" title\u003d\"class in java.awt.geom\"\u003e\u003ccode\u003eArea\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#intersects(double,double,double,double)\"\u003e\u003ccode\u003eShape.intersects(double, double, double, double)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#contains(double,double,double,double)\"\u003econtains\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the X coordinate of the upper-left corner of the specified rectangular area",
          "\u003ccode\u003ey\u003c/code\u003e - the Y coordinate of the upper-left corner of the specified rectangular area",
          "\u003ccode\u003ew\u003c/code\u003e - the width of the specified rectangular area",
          "\u003ccode\u003eh\u003c/code\u003e - the height of the specified rectangular area"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the interior of the \n\u003ccode\u003eShape\u003c/code\u003e entirely contains the specified rectangular area; \n\u003ccode\u003efalse\u003c/code\u003e otherwise or, if the \n\u003ccode\u003eShape\u003c/code\u003e contains the rectangular area and the \n\u003ccode\u003eintersects\u003c/code\u003e method returns \n\u003ccode\u003etrue\u003c/code\u003e and the containment calculations would be too expensive to perform."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "r"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "contains",
      "comment": "Tests if the interior of the Shape entirely contains the specified Rectangle2D. The Shape.contains() method allows a Shape implementation to conservatively return false when: the intersect method returns true and the calculations to determine whether or not the Shape entirely contains the Rectangle2D are prohibitively expensive. This means that for some Shapes this method might return false even though the Shape contains the Rectangle2D. The Area class performs more accurate geometric computations than most Shape objects and therefore can be used if a more precise answer is required. This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a WIND_NON_ZERO winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#contains(double,double,double,double)\"\u003e\u003ccode\u003eShape.contains(double, double, double, double)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#contains(java.awt.geom.Rectangle2D)\"\u003econtains\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003er\u003c/code\u003e - The specified \n\u003ccode\u003eRectangle2D\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the interior of the \n\u003ccode\u003eShape\u003c/code\u003e entirely contains the \n\u003ccode\u003eRectangle2D\u003c/code\u003e; \n\u003ccode\u003efalse\u003c/code\u003e otherwise or, if the \n\u003ccode\u003eShape\u003c/code\u003e contains the \n\u003ccode\u003eRectangle2D\u003c/code\u003e and the \n\u003ccode\u003eintersects\u003c/code\u003e method returns \n\u003ccode\u003etrue\u003c/code\u003e and the containment calculations would be too expensive to perform."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.PathIterator",
            "type": "Class"
          },
          "field": {
            "name": "pi"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "w"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "h"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "intersects",
      "comment": "Tests if the interior of the specified PathIterator intersects the interior of a specified set of rectangular coordinates. This method provides a basic facility for implementors of the Shape interface to implement support for the Shape.intersects(double, double, double, double) method. This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epi\u003c/code\u003e - the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e",
          "\u003ccode\u003ex\u003c/code\u003e - the specified X coordinate",
          "\u003ccode\u003ey\u003c/code\u003e - the specified Y coordinate",
          "\u003ccode\u003ew\u003c/code\u003e - the width of the specified rectangular coordinates",
          "\u003ccode\u003eh\u003c/code\u003e - the height of the specified rectangular coordinates"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e and the interior of the specified set of rectangular coordinates intersect each other; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.PathIterator",
            "type": "Class"
          },
          "field": {
            "name": "pi"
          }
        },
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "r"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "intersects",
      "comment": "Tests if the interior of the specified PathIterator intersects the interior of a specified Rectangle2D. This method provides a basic facility for implementors of the Shape interface to implement support for the Shape.intersects(Rectangle2D) method. This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epi\u003c/code\u003e - the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e",
          "\u003ccode\u003er\u003c/code\u003e - the specified \n\u003ccode\u003eRectangle2D\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the specified \n\u003ccode\u003ePathIterator\u003c/code\u003e and the interior of the specified \n\u003ccode\u003eRectangle2D\u003c/code\u003e intersect each other; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "y"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "w"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "h"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "intersects",
      "comment": "Tests if the interior of the Shape intersects the interior of a specified rectangular area. The rectangular area is considered to intersect the Shape if any point is contained in both the interior of the Shape and the specified rectangular area. The Shape.intersects() method allows a Shape implementation to conservatively return true when: there is a high probability that the rectangular area and the Shape intersect, but the calculations to accurately determine this intersection are prohibitively expensive. This means that for some Shapes this method might return true even though the rectangular area does not intersect the Shape. The Area class performs more accurate computations of geometric intersection than most Shape objects and therefore can be used if a more precise answer is required. This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/Area.html\" title\u003d\"class in java.awt.geom\"\u003e\u003ccode\u003eArea\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#intersects(double,double,double,double)\"\u003eintersects\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the X coordinate of the upper-left corner of the specified rectangular area",
          "\u003ccode\u003ey\u003c/code\u003e - the Y coordinate of the upper-left corner of the specified rectangular area",
          "\u003ccode\u003ew\u003c/code\u003e - the width of the specified rectangular area",
          "\u003ccode\u003eh\u003c/code\u003e - the height of the specified rectangular area"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the interior of the \n\u003ccode\u003eShape\u003c/code\u003e and the interior of the rectangular area intersect, or are both highly likely to intersect and intersection calculations would be too expensive to perform; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.Rectangle2D",
            "type": "Class"
          },
          "field": {
            "name": "r"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "intersects",
      "comment": "Tests if the interior of the Shape intersects the interior of a specified Rectangle2D. The Shape.intersects() method allows a Shape implementation to conservatively return true when: there is a high probability that the Rectangle2D and the Shape intersect, but the calculations to accurately determine this intersection are prohibitively expensive. This means that for some Shapes this method might return true even though the Rectangle2D does not intersect the Shape. The Area class performs more accurate computations of geometric intersection than most Shape objects and therefore can be used if a more precise answer is required. This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#intersects(double,double,double,double)\"\u003e\u003ccode\u003eShape.intersects(double, double, double, double)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#intersects(java.awt.geom.Rectangle2D)\"\u003eintersects\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003er\u003c/code\u003e - the specified \n\u003ccode\u003eRectangle2D\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the interior of the \n\u003ccode\u003eShape\u003c/code\u003e and the interior of the specified \n\u003ccode\u003eRectangle2D\u003c/code\u003e intersect, or are both highly likely to intersect and intersection calculations would be too expensive to perform; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.PathIterator",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "field": {
            "name": "at"
          }
        },
        {
          "type": {
            "name": "double",
            "type": "Class"
          },
          "field": {
            "name": "flatness"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getPathIterator",
      "comment": "Returns an iterator object that iterates along the Shape boundary and provides access to a flattened view of the Shape outline geometry. Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the iterator. If an optional AffineTransform is specified, the coordinates returned in the iteration are transformed accordingly. The amount of subdivision of the curved segments is controlled by the flatness parameter, which specifies the maximum distance that any point on the unflattened transformed curve can deviate from the returned flattened path segments. Note that a limit on the accuracy of the flattened path might be silently imposed, causing very small flattening parameters to be treated as larger values. This limit, if there is one, is defined by the particular implementation that is used. Each call to this method returns a fresh PathIterator object that traverses the Shape object geometry independently from any other PathIterator objects in use at the same time. It is recommended, but not guaranteed, that objects implementing the Shape interface isolate iterations that are in process from any changes that might occur to the original object\u0027s geometry during such iterations. The iterator for this class is not multi-threaded safe, which means that this Path2D class does not guarantee that modifications to the geometry of this Path2D object do not affect any iterations of that geometry that are already in process.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html#getPathIterator(java.awt.geom.AffineTransform,double)\"\u003egetPathIterator\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Shape.html\" title\u003d\"interface in java.awt\"\u003eShape\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eat\u003c/code\u003e - an optional \n\u003ccode\u003eAffineTransform\u003c/code\u003e to be applied to the coordinates as they are returned in the iteration, or \n\u003ccode\u003enull\u003c/code\u003e if untransformed coordinates are desired",
          "\u003ccode\u003eflatness\u003c/code\u003e - the maximum distance that the line segments used to approximate the curved segments are allowed to deviate from any point on the original curve"
        ],
        "return": [
          "a new \n\u003ccode\u003ePathIterator\u003c/code\u003e that independently traverses a flattened view of the geometry of the \n\u003ccode\u003eShape\u003c/code\u003e."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "clone",
      "comment": "Creates a new object of the same class as this object.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Cloneable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eCloneable\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#clone()\"\u003eclone\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/OutOfMemoryError.html\" title\u003d\"class in java.lang\"\u003eOutOfMemoryError\u003c/a\u003e\u003c/code\u003e - if there is not enough memory."
        ],
        "return": [
          "a clone of this instance."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "trimToSize",
      "comment": "Trims the capacity of this Path2D instance to its current size. An application can use this operation to minimize the storage of a path.",
      "tagMap": {
        "since": [
          "10"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.awt.geom.Path2D$Float",
    "java.awt.geom.Path2D$Double"
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.awt.geom.Path2D",
  "comment": "The \n\u003ccode\u003ePath2D\u003c/code\u003e class provides a simple, yet flexible shape which represents an arbitrary geometric path. It can fully represent any path which can be iterated by the \n\u003ca href\u003d\"PathIterator.html\" title\u003d\"interface in java.awt.geom\"\u003e\u003ccode\u003ePathIterator\u003c/code\u003e\u003c/a\u003e interface including all of its segment types and winding rules and it implements all of the basic hit testing methods of the \n\u003ca href\u003d\"../Shape.html\" title\u003d\"interface in java.awt\"\u003e\u003ccode\u003eShape\u003c/code\u003e\u003c/a\u003e interface. \n\u003cp\u003e Use \u003ca href\u003d\"Path2D.Float.html\" title\u003d\"class in java.awt.geom\"\u003e\u003ccode\u003ePath2D.Float\u003c/code\u003e\u003c/a\u003e when dealing with data that can be represented and used with floating point precision. Use \u003ca href\u003d\"Path2D.Double.html\" title\u003d\"class in java.awt.geom\"\u003e\u003ccode\u003ePath2D.Double\u003c/code\u003e\u003c/a\u003e for data that requires the accuracy or range of double precision. \u003c/p\u003e\n\u003cp\u003e \u003ccode\u003ePath2D\u003c/code\u003e provides exactly those facilities required for basic construction and management of a geometric path and implementation of the above interfaces with little added interpretation. If it is useful to manipulate the interiors of closed geometric shapes beyond simple hit testing then the \u003ca href\u003d\"Area.html\" title\u003d\"class in java.awt.geom\"\u003e\u003ccode\u003eArea\u003c/code\u003e\u003c/a\u003e class provides additional capabilities specifically targeted at closed figures. While both classes nominally implement the \u003ccode\u003eShape\u003c/code\u003e interface, they differ in purpose and together they provide two useful views of a geometric shape where \u003ccode\u003ePath2D\u003c/code\u003e deals primarily with a trajectory formed by path segments and \u003ccode\u003eArea\u003c/code\u003e deals more with interpretation and manipulation of enclosed regions of 2D geometric space. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"PathIterator.html\" title\u003d\"interface in java.awt.geom\"\u003e\u003ccode\u003ePathIterator\u003c/code\u003e\u003c/a\u003e interface has more detailed descriptions of the types of segments that make up a path and the winding rules that control how to determine which regions are inside or outside the path.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.6"
    ]
  }
}