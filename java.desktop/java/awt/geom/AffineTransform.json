{
  "packageName": "java.awt.geom",
  "simpleName": "AffineTransform",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_IDENTITY",
      "comment": "This constant indicates that the transform defined by this object is an identity transform. An identity transform is one in which the output coordinates are always the same as the input coordinates. If this transform is anything other than the identity transform, the type will either be the constant GENERAL_TRANSFORM or a combination of the appropriate flag bits for the various coordinate conversions that this transform performs.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_FLIP\"\u003e\u003ccode\u003eTYPE_FLIP\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_IDENTITY\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_TRANSLATION",
      "comment": "This flag bit indicates that the transform defined by this object performs a translation in addition to the conversions indicated by other flag bits. A translation moves the coordinates by a constant amount in x and y without changing the length or angle of vectors.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_FLIP\"\u003e\u003ccode\u003eTYPE_FLIP\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_TRANSLATION\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_UNIFORM_SCALE",
      "comment": "This flag bit indicates that the transform defined by this object performs a uniform scale in addition to the conversions indicated by other flag bits. A uniform scale multiplies the length of vectors by the same amount in both the x and y directions without changing the angle between vectors. This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_FLIP\"\u003e\u003ccode\u003eTYPE_FLIP\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_UNIFORM_SCALE\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_GENERAL_SCALE",
      "comment": "This flag bit indicates that the transform defined by this object performs a general scale in addition to the conversions indicated by other flag bits. A general scale multiplies the length of vectors by different amounts in the x and y directions without changing the angle between perpendicular vectors. This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_FLIP\"\u003e\u003ccode\u003eTYPE_FLIP\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_SCALE\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_MASK_SCALE",
      "comment": "This constant is a bit mask for any of the scale flag bits.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_MASK_SCALE\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_FLIP",
      "comment": "This flag bit indicates that the transform defined by this object performs a mirror image flip about some axis which changes the normally right handed coordinate system into a left handed system in addition to the conversions indicated by other flag bits. A right handed coordinate system is one where the positive X axis rotates counterclockwise to overlay the positive Y axis similar to the direction that the fingers on your right hand curl when you stare end on at your thumb. A left handed coordinate system is one where the positive X axis rotates clockwise to overlay the positive Y axis similar to the direction that the fingers on your left hand curl. There is no mathematical way to determine the angle of the original flipping or mirroring transformation since all angles of flip are identical given an appropriate adjusting rotation.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_FLIP\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_QUADRANT_ROTATION",
      "comment": "This flag bit indicates that the transform defined by this object performs a quadrant rotation by some multiple of 90 degrees in addition to the conversions indicated by other flag bits. A rotation changes the angles of vectors by the same amount regardless of the original direction of the vector and without changing the length of the vector. This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_FLIP\"\u003e\u003ccode\u003eTYPE_FLIP\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_QUADRANT_ROTATION\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_GENERAL_ROTATION",
      "comment": "This flag bit indicates that the transform defined by this object performs a rotation by an arbitrary angle in addition to the conversions indicated by other flag bits. A rotation changes the angles of vectors by the same amount regardless of the original direction of the vector and without changing the length of the vector. This flag bit is mutually exclusive with the TYPE_QUADRANT_ROTATION flag.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_FLIP\"\u003e\u003ccode\u003eTYPE_FLIP\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_ROTATION\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_MASK_ROTATION",
      "comment": "This constant is a bit mask for any of the rotation flag bits.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_MASK_ROTATION\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "TYPE_GENERAL_TRANSFORM",
      "comment": "This constant indicates that the transform defined by this object performs an arbitrary conversion of the input coordinates. If this transform can be classified by any of the above constants, the type will either be the constant TYPE_IDENTITY or a combination of the appropriate flag bits for the various coordinate conversions that this transform performs.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_FLIP\"\u003e\u003ccode\u003eTYPE_FLIP\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_TRANSFORM\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "tx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "ty",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getTranslateInstance",
      "comment": "Returns a transform representing a translation transformation. The matrix representing the returned transform is:           [   1    0    tx  ]\n          [   0    1    ty  ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etx\u003c/code\u003e - the distance by which coordinates are translated in the X axis direction",
          "\u003ccode\u003ety\u003c/code\u003e - the distance by which coordinates are translated in the Y axis direction"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that represents a translation transformation, created with the specified vector."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "theta",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getRotateInstance",
      "comment": "Returns a transform representing a rotation transformation. The matrix representing the returned transform is:           [   cos(theta)    -sin(theta)    0   ]\n          [   sin(theta)     cos(theta)    0   ]\n          [       0              0         1   ]\n Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etheta\u003c/code\u003e - the angle of rotation measured in radians"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that is a rotation transformation, created with the specified angle of rotation."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "theta",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getRotateInstance",
      "comment": "Returns a transform that rotates coordinates around an anchor point. This operation is equivalent to translating the coordinates so that the anchor point is at the origin (S1), then rotating them about the new origin (S2), and finally translating so that the intermediate origin is restored to the coordinates of the original anchor point (S3). This operation is equivalent to the following sequence of calls:      AffineTransform Tx \u003d new AffineTransform();\n     Tx.translate(anchorx, anchory);    // S3: final translation\n     Tx.rotate(theta);                  // S2: rotate around anchor\n     Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin\n The matrix representing the returned transform is:           [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]\n          [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]\n          [       0              0               1        ]\n Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etheta\u003c/code\u003e - the angle of rotation measured in radians",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that rotates coordinates around the specified point by the specified angle of rotation."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getRotateInstance",
      "comment": "Returns a transform that rotates coordinates according to a rotation vector. All coordinates rotate about the origin by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, an identity transform is returned. This operation is equivalent to calling:      AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evecx\u003c/code\u003e - the X coordinate of the rotation vector",
          "\u003ccode\u003evecy\u003c/code\u003e - the Y coordinate of the rotation vector"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that rotates coordinates according to the specified rotation vector."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecy",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getRotateInstance",
      "comment": "Returns a transform that rotates coordinates around an anchor point according to a rotation vector. All coordinates rotate about the specified anchor coordinates by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, an identity transform is returned. This operation is equivalent to calling:      AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),\n                                       anchorx, anchory);",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evecx\u003c/code\u003e - the X coordinate of the rotation vector",
          "\u003ccode\u003evecy\u003c/code\u003e - the Y coordinate of the rotation vector",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that rotates coordinates around the specified point according to the specified rotation vector."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numquadrants",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getQuadrantRotateInstance",
      "comment": "Returns a transform that rotates coordinates by the specified number of quadrants. This operation is equivalent to calling:      AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);\n Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enumquadrants\u003c/code\u003e - the number of 90 degree arcs to rotate by"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that rotates coordinates by the specified number of quadrants."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numquadrants",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getQuadrantRotateInstance",
      "comment": "Returns a transform that rotates coordinates by the specified number of quadrants around the specified anchor point. This operation is equivalent to calling:      AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,\n                                       anchorx, anchory);\n Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enumquadrants\u003c/code\u003e - the number of 90 degree arcs to rotate by",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that rotates coordinates by the specified number of quadrants around the specified anchor point."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "sx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "sy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getScaleInstance",
      "comment": "Returns a transform representing a scaling transformation. The matrix representing the returned transform is:           [   sx   0    0   ]\n          [   0    sy   0   ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esx\u003c/code\u003e - the factor by which coordinates are scaled along the X axis direction",
          "\u003ccode\u003esy\u003c/code\u003e - the factor by which coordinates are scaled along the Y axis direction"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that scales coordinates by the specified factors."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "shx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "shy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getShearInstance",
      "comment": "Returns a transform representing a shearing transformation. The matrix representing the returned transform is:           [   1   shx   0   ]\n          [  shy   1    0   ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eshx\u003c/code\u003e - the multiplier by which coordinates are shifted in the direction of the positive X axis as a factor of their Y coordinate",
          "\u003ccode\u003eshy\u003c/code\u003e - the multiplier by which coordinates are shifted in the direction of the positive Y axis as a factor of their X coordinate"
        ],
        "return": [
          "an \n\u003ccode\u003eAffineTransform\u003c/code\u003e object that shears coordinates by the specified multipliers."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getType",
      "comment": "Retrieves the flag bits describing the conversion properties of this transform. The return value is either one of the constants TYPE_IDENTITY or TYPE_GENERAL_TRANSFORM, or a combination of the appropriate flag bits. A valid combination of flag bits is an exclusive OR operation that can combine the TYPE_TRANSLATION flag bit in addition to either of the TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits as well as either of the TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_IDENTITY\"\u003e\u003ccode\u003eTYPE_IDENTITY\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_TRANSLATION\"\u003e\u003ccode\u003eTYPE_TRANSLATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE\"\u003e\u003ccode\u003eTYPE_GENERAL_SCALE\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION\"\u003e\u003ccode\u003eTYPE_QUADRANT_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION\"\u003e\u003ccode\u003eTYPE_GENERAL_ROTATION\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM\"\u003e\u003ccode\u003eTYPE_GENERAL_TRANSFORM\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the OR combination of any of the indicated flags that apply to this transform"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getDeterminant",
      "comment": "Returns the determinant of the matrix representation of the transform. The determinant is useful both to determine if the transform can be inverted and to get a single value representing the combined X and Y scaling of the transform. If the determinant is non-zero, then this transform is invertible and the various methods that depend on the inverse transform do not need to throw a NoninvertibleTransformException. If the determinant is zero then this transform can not be inverted since the transform maps all input coordinates onto a line or a point. If the determinant is near enough to zero then inverse transform operations might not carry enough precision to produce meaningful results. If this transform represents a uniform scale, as indicated by the getType method then the determinant also represents the square of the uniform scale factor by which all of the points are expanded from or contracted towards the origin. If this transform represents a non-uniform scale or more general transform then the determinant is not likely to represent a value useful for any purpose other than determining if inverse transforms are possible. Mathematically, the determinant is calculated using the formula:           |  m00  m01  m02  |\n          |  m10  m11  m12  |  \u003d  m00 * m11 - m01 * m10\n          |   0    0    1   |",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getType()\"\u003e\u003ccode\u003egetType()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#createInverse()\"\u003e\u003ccode\u003ecreateInverse()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#inverseTransform(java.awt.geom.Point2D,java.awt.geom.Point2D)\"\u003e\u003ccode\u003einverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE\"\u003e\u003ccode\u003eTYPE_UNIFORM_SCALE\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the determinant of the matrix used to transform the coordinates."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "flatmatrix",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getMatrix",
      "comment": "Retrieves the 6 specifiable values in the 3x3 affine transformation matrix and places them into an array of double precisions values. The values are stored in the array as { m00 m10 m01 m11 m02 m12 }. An array of 4 doubles can also be specified, in which case only the first four elements representing the non-transform parts of the array are retrieved and the values are stored into the array as { m00 m10 m01 m11 }",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getScaleX()\"\u003e\u003ccode\u003egetScaleX()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getScaleY()\"\u003e\u003ccode\u003egetScaleY()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getShearX()\"\u003e\u003ccode\u003egetShearX()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getShearY()\"\u003e\u003ccode\u003egetShearY()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getTranslateX()\"\u003e\u003ccode\u003egetTranslateX()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getTranslateY()\"\u003e\u003ccode\u003egetTranslateY()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eflatmatrix\u003c/code\u003e - the double array used to store the returned values."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getScaleX",
      "comment": "Returns the m00 element of the 3x3 affine transformation matrix. This matrix factor determines how input X coordinates will affect output X coordinates and is one element of the scale of the transform. To measure the full amount by which X coordinates are stretched or contracted by this transform, use the following code:      Point2D p \u003d new Point2D.Double(1, 0);\n     p \u003d tx.deltaTransform(p, p);\n     double scaleX \u003d p.distance(0, 0);",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getMatrix(double%5B%5D)\"\u003e\u003ccode\u003egetMatrix(double[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a double value that is \n\u003ccode\u003em00\u003c/code\u003e element of the 3x3 affine transformation matrix."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getScaleY",
      "comment": "Returns the m11 element of the 3x3 affine transformation matrix. This matrix factor determines how input Y coordinates will affect output Y coordinates and is one element of the scale of the transform. To measure the full amount by which Y coordinates are stretched or contracted by this transform, use the following code:      Point2D p \u003d new Point2D.Double(0, 1);\n     p \u003d tx.deltaTransform(p, p);\n     double scaleY \u003d p.distance(0, 0);",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getMatrix(double%5B%5D)\"\u003e\u003ccode\u003egetMatrix(double[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a double value that is \n\u003ccode\u003em11\u003c/code\u003e element of the 3x3 affine transformation matrix."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getShearX",
      "comment": "Returns the X coordinate shearing element (m01) of the 3x3 affine transformation matrix.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getMatrix(double%5B%5D)\"\u003e\u003ccode\u003egetMatrix(double[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a double value that is the X coordinate of the shearing element of the affine transformation matrix."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getShearY",
      "comment": "Returns the Y coordinate shearing element (m10) of the 3x3 affine transformation matrix.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getMatrix(double%5B%5D)\"\u003e\u003ccode\u003egetMatrix(double[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a double value that is the Y coordinate of the shearing element of the affine transformation matrix."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getTranslateX",
      "comment": "Returns the X coordinate of the translation element (m02) of the 3x3 affine transformation matrix.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getMatrix(double%5B%5D)\"\u003e\u003ccode\u003egetMatrix(double[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a double value that is the X coordinate of the translation element of the affine transformation matrix."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getTranslateY",
      "comment": "Returns the Y coordinate of the translation element (m12) of the 3x3 affine transformation matrix.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getMatrix(double%5B%5D)\"\u003e\u003ccode\u003egetMatrix(double[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a double value that is the Y coordinate of the translation element of the affine transformation matrix."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "tx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "ty",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "translate",
      "comment": "Concatenates this transform with a translation transformation. This is equivalent to calling concatenate(T), where T is an AffineTransform represented by the following matrix:           [   1    0    tx  ]\n          [   0    1    ty  ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etx\u003c/code\u003e - the distance by which coordinates are translated in the X axis direction",
          "\u003ccode\u003ety\u003c/code\u003e - the distance by which coordinates are translated in the Y axis direction"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "theta",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "rotate",
      "comment": "Concatenates this transform with a rotation transformation. This is equivalent to calling concatenate(R), where R is an AffineTransform represented by the following matrix:           [   cos(theta)    -sin(theta)    0   ]\n          [   sin(theta)     cos(theta)    0   ]\n          [       0              0         1   ]\n Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etheta\u003c/code\u003e - the angle of rotation measured in radians"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "theta",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "rotate",
      "comment": "Concatenates this transform with a transform that rotates coordinates around an anchor point. This operation is equivalent to translating the coordinates so that the anchor point is at the origin (S1), then rotating them about the new origin (S2), and finally translating so that the intermediate origin is restored to the coordinates of the original anchor point (S3). This operation is equivalent to the following sequence of calls:      translate(anchorx, anchory);      // S3: final translation\n     rotate(theta);                    // S2: rotate around anchor\n     translate(-anchorx, -anchory);    // S1: translate anchor to origin\n Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etheta\u003c/code\u003e - the angle of rotation measured in radians",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "rotate",
      "comment": "Concatenates this transform with a transform that rotates coordinates according to a rotation vector. All coordinates rotate about the origin by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, no additional rotation is added to this transform. This operation is equivalent to calling:           rotate(Math.atan2(vecy, vecx));",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evecx\u003c/code\u003e - the X coordinate of the rotation vector",
          "\u003ccode\u003evecy\u003c/code\u003e - the Y coordinate of the rotation vector"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecy",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "rotate",
      "comment": "Concatenates this transform with a transform that rotates coordinates around an anchor point according to a rotation vector. All coordinates rotate about the specified anchor coordinates by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, the transform is not modified in any way. This method is equivalent to calling:      rotate(Math.atan2(vecy, vecx), anchorx, anchory);",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evecx\u003c/code\u003e - the X coordinate of the rotation vector",
          "\u003ccode\u003evecy\u003c/code\u003e - the Y coordinate of the rotation vector",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numquadrants",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "quadrantRotate",
      "comment": "Concatenates this transform with a transform that rotates coordinates by the specified number of quadrants. This is equivalent to calling:      rotate(numquadrants * Math.PI / 2.0);\n Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enumquadrants\u003c/code\u003e - the number of 90 degree arcs to rotate by"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numquadrants",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "quadrantRotate",
      "comment": "Concatenates this transform with a transform that rotates coordinates by the specified number of quadrants around the specified anchor point. This method is equivalent to calling:      rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);\n Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enumquadrants\u003c/code\u003e - the number of 90 degree arcs to rotate by",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "sx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "sy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "scale",
      "comment": "Concatenates this transform with a scaling transformation. This is equivalent to calling concatenate(S), where S is an AffineTransform represented by the following matrix:           [   sx   0    0   ]\n          [   0    sy   0   ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esx\u003c/code\u003e - the factor by which coordinates are scaled along the X axis direction",
          "\u003ccode\u003esy\u003c/code\u003e - the factor by which coordinates are scaled along the Y axis direction"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "shx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "shy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "shear",
      "comment": "Concatenates this transform with a shearing transformation. This is equivalent to calling concatenate(SH), where SH is an AffineTransform represented by the following matrix:           [   1   shx   0   ]\n          [  shy   1    0   ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eshx\u003c/code\u003e - the multiplier by which coordinates are shifted in the direction of the positive X axis as a factor of their Y coordinate",
          "\u003ccode\u003eshy\u003c/code\u003e - the multiplier by which coordinates are shifted in the direction of the positive Y axis as a factor of their X coordinate"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToIdentity",
      "comment": "Resets this transform to the Identity transform.",
      "annotations": [],
      "tagMap": {
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "tx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "ty",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToTranslation",
      "comment": "Sets this transform to a translation transformation. The matrix representing this transform becomes:           [   1    0    tx  ]\n          [   0    1    ty  ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etx\u003c/code\u003e - the distance by which coordinates are translated in the X axis direction",
          "\u003ccode\u003ety\u003c/code\u003e - the distance by which coordinates are translated in the Y axis direction"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "theta",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToRotation",
      "comment": "Sets this transform to a rotation transformation. The matrix representing this transform becomes:           [   cos(theta)    -sin(theta)    0   ]\n          [   sin(theta)     cos(theta)    0   ]\n          [       0              0         1   ]\n Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etheta\u003c/code\u003e - the angle of rotation measured in radians"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "theta",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToRotation",
      "comment": "Sets this transform to a translated rotation transformation. This operation is equivalent to translating the coordinates so that the anchor point is at the origin (S1), then rotating them about the new origin (S2), and finally translating so that the intermediate origin is restored to the coordinates of the original anchor point (S3). This operation is equivalent to the following sequence of calls:      setToTranslation(anchorx, anchory); // S3: final translation\n     rotate(theta);                      // S2: rotate around anchor\n     translate(-anchorx, -anchory);      // S1: translate anchor to origin\n The matrix representing this transform becomes:           [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]\n          [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]\n          [       0              0               1        ]\n Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etheta\u003c/code\u003e - the angle of rotation measured in radians",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToRotation",
      "comment": "Sets this transform to a rotation transformation that rotates coordinates according to a rotation vector. All coordinates rotate about the origin by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, the transform is set to an identity transform. This operation is equivalent to calling:      setToRotation(Math.atan2(vecy, vecx));",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evecx\u003c/code\u003e - the X coordinate of the rotation vector",
          "\u003ccode\u003evecy\u003c/code\u003e - the Y coordinate of the rotation vector"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "vecy",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToRotation",
      "comment": "Sets this transform to a rotation transformation that rotates coordinates around an anchor point according to a rotation vector. All coordinates rotate about the specified anchor coordinates by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, the transform is set to an identity transform. This operation is equivalent to calling:      setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evecx\u003c/code\u003e - the X coordinate of the rotation vector",
          "\u003ccode\u003evecy\u003c/code\u003e - the Y coordinate of the rotation vector",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numquadrants",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToQuadrantRotation",
      "comment": "Sets this transform to a rotation transformation that rotates coordinates by the specified number of quadrants. This operation is equivalent to calling:      setToRotation(numquadrants * Math.PI / 2.0);\n Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enumquadrants\u003c/code\u003e - the number of 90 degree arcs to rotate by"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numquadrants",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchorx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "anchory",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToQuadrantRotation",
      "comment": "Sets this transform to a translated rotation transformation that rotates coordinates by the specified number of quadrants around the specified anchor point. This operation is equivalent to calling:      setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);\n Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enumquadrants\u003c/code\u003e - the number of 90 degree arcs to rotate by",
          "\u003ccode\u003eanchorx\u003c/code\u003e - the X coordinate of the rotation anchor point",
          "\u003ccode\u003eanchory\u003c/code\u003e - the Y coordinate of the rotation anchor point"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "sx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "sy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToScale",
      "comment": "Sets this transform to a scaling transformation. The matrix representing this transform becomes:           [   sx   0    0   ]\n          [   0    sy   0   ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esx\u003c/code\u003e - the factor by which coordinates are scaled along the X axis direction",
          "\u003ccode\u003esy\u003c/code\u003e - the factor by which coordinates are scaled along the Y axis direction"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "shx",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "shy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setToShear",
      "comment": "Sets this transform to a shearing transformation. The matrix representing this transform becomes:           [   1   shx   0   ]\n          [  shy   1    0   ]\n          [   0    0    1   ]",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eshx\u003c/code\u003e - the multiplier by which coordinates are shifted in the direction of the positive X axis as a factor of their Y coordinate",
          "\u003ccode\u003eshy\u003c/code\u003e - the multiplier by which coordinates are shifted in the direction of the positive Y axis as a factor of their X coordinate"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "name": "Tx",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setTransform",
      "comment": "Sets this transform to a copy of the transform in the specified AffineTransform object.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eTx\u003c/code\u003e - the \n\u003ccode\u003eAffineTransform\u003c/code\u003e object from which to copy the transform"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m00",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m10",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m01",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m11",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m02",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m12",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setTransform",
      "comment": "Sets this transform to the matrix specified by the 6 double precision values.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003em00\u003c/code\u003e - the X coordinate scaling element of the 3x3 matrix",
          "\u003ccode\u003em10\u003c/code\u003e - the Y coordinate shearing element of the 3x3 matrix",
          "\u003ccode\u003em01\u003c/code\u003e - the X coordinate shearing element of the 3x3 matrix",
          "\u003ccode\u003em11\u003c/code\u003e - the Y coordinate scaling element of the 3x3 matrix",
          "\u003ccode\u003em02\u003c/code\u003e - the X coordinate translation element of the 3x3 matrix",
          "\u003ccode\u003em12\u003c/code\u003e - the Y coordinate translation element of the 3x3 matrix"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "name": "Tx",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "concatenate",
      "comment": "Concatenates an AffineTransform Tx to this AffineTransform Cx in the most commonly useful way to provide a new user space that is mapped to the former user space by Tx. Cx is updated to perform the combined transformation. Transforming a point p by the updated transform Cx\u0027 is equivalent to first transforming p by Tx and then transforming the result by the original transform Cx like this: Cx\u0027(p) \u003d Cx(Tx(p)) In matrix notation, if this transform Cx is represented by the matrix [this] and Tx is represented by the matrix [Tx] then this method does the following:           [this] \u003d [this] x [Tx]",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#preConcatenate(java.awt.geom.AffineTransform)\"\u003e\u003ccode\u003epreConcatenate(java.awt.geom.AffineTransform)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eTx\u003c/code\u003e - the \n\u003ccode\u003eAffineTransform\u003c/code\u003e object to be concatenated with this \n\u003ccode\u003eAffineTransform\u003c/code\u003e object."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "name": "Tx",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "preConcatenate",
      "comment": "Concatenates an AffineTransform Tx to this AffineTransform Cx in a less commonly used way such that Tx modifies the coordinate transformation relative to the absolute pixel space rather than relative to the existing user space. Cx is updated to perform the combined transformation. Transforming a point p by the updated transform Cx\u0027 is equivalent to first transforming p by the original transform Cx and then transforming the result by Tx like this: Cx\u0027(p) \u003d Tx(Cx(p)) In matrix notation, if this transform Cx is represented by the matrix [this] and Tx is represented by the matrix [Tx] then this method does the following:           [this] \u003d [Tx] x [this]",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#concatenate(java.awt.geom.AffineTransform)\"\u003e\u003ccode\u003econcatenate(java.awt.geom.AffineTransform)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eTx\u003c/code\u003e - the \n\u003ccode\u003eAffineTransform\u003c/code\u003e object to be concatenated with this \n\u003ccode\u003eAffineTransform\u003c/code\u003e object."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.AffineTransform",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.awt.geom.NoninvertibleTransformException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "createInverse",
      "comment": "Returns an AffineTransform object representing the inverse transformation. The inverse transform Tx\u0027 of this transform Tx maps coordinates transformed by Tx back to their original coordinates. In other words, Tx\u0027(Tx(p)) \u003d p \u003d Tx(Tx\u0027(p)). If this transform maps all coordinates onto a point or a line then it will not have an inverse, since coordinates that do not lie on the destination point or line will not have an inverse mapping. The getDeterminant method can be used to determine if this transform has no inverse, in which case an exception will be thrown if the createInverse method is called.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getDeterminant()\"\u003e\u003ccode\u003egetDeterminant()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/NoninvertibleTransformException.html\" title\u003d\"class in java.awt.geom\"\u003eNoninvertibleTransformException\u003c/a\u003e\u003c/code\u003e - if the matrix cannot be inverted."
        ],
        "return": [
          "a new \n\u003ccode\u003eAffineTransform\u003c/code\u003e object representing the inverse transformation."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.awt.geom.NoninvertibleTransformException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "invert",
      "comment": "Sets this transform to the inverse of itself. The inverse transform Tx\u0027 of this transform Tx maps coordinates transformed by Tx back to their original coordinates. In other words, Tx\u0027(Tx(p)) \u003d p \u003d Tx(Tx\u0027(p)). If this transform maps all coordinates onto a point or a line then it will not have an inverse, since coordinates that do not lie on the destination point or line will not have an inverse mapping. The getDeterminant method can be used to determine if this transform has no inverse, in which case an exception will be thrown if the invert method is called.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/AffineTransform.html#getDeterminant()\"\u003e\u003ccode\u003egetDeterminant()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/NoninvertibleTransformException.html\" title\u003d\"class in java.awt.geom\"\u003eNoninvertibleTransformException\u003c/a\u003e\u003c/code\u003e - if the matrix cannot be inverted."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.Point2D",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "name": "ptSrc",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "name": "ptDst",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "transform",
      "comment": "Transforms the specified ptSrc and stores the result in ptDst. If ptDst is null, a new Point2D object is allocated and then the result of the transformation is stored in this object. In either case, ptDst, which contains the transformed point, is returned for convenience. If ptSrc and ptDst are the same object, the input point is correctly overwritten with the transformed point.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eptSrc\u003c/code\u003e - the specified \n\u003ccode\u003ePoint2D\u003c/code\u003e to be transformed",
          "\u003ccode\u003eptDst\u003c/code\u003e - the specified \n\u003ccode\u003ePoint2D\u003c/code\u003e that stores the result of transforming \n\u003ccode\u003eptSrc\u003c/code\u003e"
        ],
        "return": [
          "the \n\u003ccode\u003eptDst\u003c/code\u003e after transforming \n\u003ccode\u003eptSrc\u003c/code\u003e and storing the result in \n\u003ccode\u003eptDst\u003c/code\u003e."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "ptSrc",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "srcOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "ptDst",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "dstOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numPts",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "transform",
      "comment": "Transforms an array of point objects by this transform. If any element of the ptDst array is null, a new Point2D object is allocated and stored into that element before storing the results of the transformation. Note that this method does not take any precautions to avoid problems caused by storing results into Point2D objects that will be used as the source for calculations further down the source array. This method does guarantee that if a specified Point2D object is both the source and destination for the same single point transform operation then the results will not be stored until the calculations are complete to avoid storing the results on top of the operands. If, however, the destination Point2D object for one operation is the same object as the source Point2D object for another operation further down the source array then the original coordinates in that point are overwritten before they can be converted.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eptSrc\u003c/code\u003e - the array containing the source point objects",
          "\u003ccode\u003eptDst\u003c/code\u003e - the array into which the transform point objects are returned",
          "\u003ccode\u003esrcOff\u003c/code\u003e - the offset to the first point object to be transformed in the source array",
          "\u003ccode\u003edstOff\u003c/code\u003e - the offset to the location of the first transformed point object that is stored in the destination array",
          "\u003ccode\u003enumPts\u003c/code\u003e - the number of point objects to be transformed"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "srcPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "srcOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dstPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "dstOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numPts",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "transform",
      "comment": "Transforms an array of floating point coordinates by this transform. The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrcPts\u003c/code\u003e - the array containing the source point coordinates. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003edstPts\u003c/code\u003e - the array into which the transformed point coordinates are returned. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003esrcOff\u003c/code\u003e - the offset to the first point to be transformed in the source array",
          "\u003ccode\u003edstOff\u003c/code\u003e - the offset to the location of the first transformed point that is stored in the destination array",
          "\u003ccode\u003enumPts\u003c/code\u003e - the number of points to be transformed"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "srcPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "srcOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dstPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "dstOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numPts",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "transform",
      "comment": "Transforms an array of double precision coordinates by this transform. The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the indicated offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrcPts\u003c/code\u003e - the array containing the source point coordinates. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003edstPts\u003c/code\u003e - the array into which the transformed point coordinates are returned. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003esrcOff\u003c/code\u003e - the offset to the first point to be transformed in the source array",
          "\u003ccode\u003edstOff\u003c/code\u003e - the offset to the location of the first transformed point that is stored in the destination array",
          "\u003ccode\u003enumPts\u003c/code\u003e - the number of point objects to be transformed"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "srcPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "srcOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dstPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "dstOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numPts",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "transform",
      "comment": "Transforms an array of floating point coordinates by this transform and stores the results into an array of doubles. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrcPts\u003c/code\u003e - the array containing the source point coordinates. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003edstPts\u003c/code\u003e - the array into which the transformed point coordinates are returned. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003esrcOff\u003c/code\u003e - the offset to the first point to be transformed in the source array",
          "\u003ccode\u003edstOff\u003c/code\u003e - the offset to the location of the first transformed point that is stored in the destination array",
          "\u003ccode\u003enumPts\u003c/code\u003e - the number of points to be transformed"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "srcPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "srcOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dstPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "dstOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numPts",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "transform",
      "comment": "Transforms an array of double precision coordinates by this transform and stores the results into an array of floats. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrcPts\u003c/code\u003e - the array containing the source point coordinates. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003edstPts\u003c/code\u003e - the array into which the transformed point coordinates are returned. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003esrcOff\u003c/code\u003e - the offset to the first point to be transformed in the source array",
          "\u003ccode\u003edstOff\u003c/code\u003e - the offset to the location of the first transformed point that is stored in the destination array",
          "\u003ccode\u003enumPts\u003c/code\u003e - the number of point objects to be transformed"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.Point2D",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.awt.geom.NoninvertibleTransformException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "name": "ptSrc",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "name": "ptDst",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "inverseTransform",
      "comment": "Inverse transforms the specified ptSrc and stores the result in ptDst. If ptDst is null, a new Point2D object is allocated and then the result of the transform is stored in this object. In either case, ptDst, which contains the transformed point, is returned for convenience. If ptSrc and ptDst are the same object, the input point is correctly overwritten with the transformed point.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eptSrc\u003c/code\u003e - the point to be inverse transformed",
          "\u003ccode\u003eptDst\u003c/code\u003e - the resulting transformed point"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/NoninvertibleTransformException.html\" title\u003d\"class in java.awt.geom\"\u003eNoninvertibleTransformException\u003c/a\u003e\u003c/code\u003e - if the matrix cannot be inverted."
        ],
        "return": [
          "\u003ccode\u003eptDst\u003c/code\u003e, which contains the result of the inverse transform."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.awt.geom.NoninvertibleTransformException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "srcPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "srcOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dstPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "dstOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numPts",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "inverseTransform",
      "comment": "Inverse transforms an array of double precision coordinates by this transform. The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrcPts\u003c/code\u003e - the array containing the source point coordinates. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003edstPts\u003c/code\u003e - the array into which the transformed point coordinates are returned. Each point is stored as a pair of x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003esrcOff\u003c/code\u003e - the offset to the first point to be transformed in the source array",
          "\u003ccode\u003edstOff\u003c/code\u003e - the offset to the location of the first transformed point that is stored in the destination array",
          "\u003ccode\u003enumPts\u003c/code\u003e - the number of point objects to be transformed"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/geom/NoninvertibleTransformException.html\" title\u003d\"class in java.awt.geom\"\u003eNoninvertibleTransformException\u003c/a\u003e\u003c/code\u003e - if the matrix cannot be inverted."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.geom.Point2D",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "name": "ptSrc",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.Point2D",
            "type": "Class"
          },
          "name": "ptDst",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deltaTransform",
      "comment": "Transforms the relative distance vector specified by ptSrc and stores the result in ptDst. A relative distance vector is transformed without applying the translation components of the affine transformation matrix using the following equations:   [  x\u0027 ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]\n  [  y\u0027 ] \u003d [  m10  m11 (m12) ] [  y  ] \u003d [ m10x + m11y ]\n  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]\n If ptDst is null, a new Point2D object is allocated and then the result of the transform is stored in this object. In either case, ptDst, which contains the transformed point, is returned for convenience. If ptSrc and ptDst are the same object, the input point is correctly overwritten with the transformed point.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eptSrc\u003c/code\u003e - the distance vector to be delta transformed",
          "\u003ccode\u003eptDst\u003c/code\u003e - the resulting transformed distance vector"
        ],
        "return": [
          "\u003ccode\u003eptDst\u003c/code\u003e, which contains the result of the transformation."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "srcPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "srcOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dstPts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "dstOff",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "numPts",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deltaTransform",
      "comment": "Transforms an array of relative distance vectors by this transform. A relative distance vector is transformed without applying the translation components of the affine transformation matrix using the following equations:   [  x\u0027 ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]\n  [  y\u0027 ] \u003d [  m10  m11 (m12) ] [  y  ] \u003d [ m10x + m11y ]\n  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]\n The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the indicated offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrcPts\u003c/code\u003e - the array containing the source distance vectors. Each vector is stored as a pair of relative x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003edstPts\u003c/code\u003e - the array into which the transformed distance vectors are returned. Each vector is stored as a pair of relative x,\u0026nbsp;y coordinates.",
          "\u003ccode\u003esrcOff\u003c/code\u003e - the offset to the first vector to be transformed in the source array",
          "\u003ccode\u003edstOff\u003c/code\u003e - the offset to the location of the first transformed vector that is stored in the destination array",
          "\u003ccode\u003enumPts\u003c/code\u003e - the number of vector coordinate pairs to be transformed"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.awt.Shape",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.Shape",
            "type": "Class"
          },
          "name": "pSrc",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "createTransformedShape",
      "comment": "Returns a new Shape object defined by the geometry of the specified Shape after it has been transformed by this transform.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003epSrc\u003c/code\u003e - the specified \n\u003ccode\u003eShape\u003c/code\u003e object to be transformed by this transform."
        ],
        "return": [
          "a new \n\u003ccode\u003eShape\u003c/code\u003e object that defines the geometry of the transformed \n\u003ccode\u003eShape\u003c/code\u003e, or null if \n\u003ccode\u003epSrc\u003c/code\u003e is null."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a String that represents the value of this Object.",
      "annotations": [],
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a \n\u003ccode\u003eString\u003c/code\u003e representing the value of this \n\u003ccode\u003eObject\u003c/code\u003e."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isIdentity",
      "comment": "Returns true if this AffineTransform is an identity transform.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this \n\u003ccode\u003eAffineTransform\u003c/code\u003e is an identity transform; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "clone",
      "comment": "Returns a copy of this AffineTransform object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Cloneable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eCloneable\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#clone()\"\u003eclone\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "an \n\u003ccode\u003eObject\u003c/code\u003e that is a copy of this \n\u003ccode\u003eAffineTransform\u003c/code\u003e object."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hashCode",
      "comment": "Returns the hashcode for this transform.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#identityHashCode(java.lang.Object)\"\u003e\u003ccode\u003eSystem.identityHashCode(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a hash code for this transform."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "obj",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "equals",
      "comment": "Returns true if this AffineTransform represents the same affine coordinate transform as the specified argument.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/HashMap.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eHashMap\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the \n\u003ccode\u003eObject\u003c/code\u003e to test for equality with this \n\u003ccode\u003eAffineTransform\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if \n\u003ccode\u003eobj\u003c/code\u003e equals this \n\u003ccode\u003eAffineTransform\u003c/code\u003e object; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new AffineTransform representing the Identity transformation.",
      "annotations": [],
      "tagMap": {
        "since": [
          "1.2"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.awt.geom.AffineTransform",
            "type": "Class"
          },
          "name": "Tx",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new AffineTransform that is a copy of the specified AffineTransform object.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eTx\u003c/code\u003e - the \n\u003ccode\u003eAffineTransform\u003c/code\u003e object to copy"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "m00",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "m10",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "m01",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "m11",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "m02",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "m12",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new AffineTransform from 6 floating point values representing the 6 specifiable entries of the 3x3 transformation matrix.",
      "annotations": [
        {
          "type": {
            "name": "ConstructorProperties",
            "type": "Class"
          },
          "values": [
            {
              "name": "value",
              "value": [
                "scaleX",
                "shearY",
                "shearX",
                "scaleY",
                "translateX",
                "translateY"
              ]
            }
          ]
        }
      ],
      "tagMap": {
        "param": [
          "\u003ccode\u003em00\u003c/code\u003e - the X coordinate scaling element of the 3x3 matrix",
          "\u003ccode\u003em10\u003c/code\u003e - the Y coordinate shearing element of the 3x3 matrix",
          "\u003ccode\u003em01\u003c/code\u003e - the X coordinate shearing element of the 3x3 matrix",
          "\u003ccode\u003em11\u003c/code\u003e - the Y coordinate scaling element of the 3x3 matrix",
          "\u003ccode\u003em02\u003c/code\u003e - the X coordinate translation element of the 3x3 matrix",
          "\u003ccode\u003em12\u003c/code\u003e - the Y coordinate translation element of the 3x3 matrix"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "flatmatrix",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new AffineTransform from an array of floating point values representing either the 4 non-translation entries or the 6 specifiable entries of the 3x3 transformation matrix. The values are retrieved from the array as { m00 m10 m01 m11 [m02 m12]}.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eflatmatrix\u003c/code\u003e - the float array containing the values to be set in the new \n\u003ccode\u003eAffineTransform\u003c/code\u003e object. The length of the array is assumed to be at least 4. If the length of the array is less than 6, only the first 4 values are taken. If the length of the array is greater than 6, the first 6 values are taken."
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m00",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m10",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m01",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m11",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m02",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "m12",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new AffineTransform from 6 double precision values representing the 6 specifiable entries of the 3x3 transformation matrix.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003em00\u003c/code\u003e - the X coordinate scaling element of the 3x3 matrix",
          "\u003ccode\u003em10\u003c/code\u003e - the Y coordinate shearing element of the 3x3 matrix",
          "\u003ccode\u003em01\u003c/code\u003e - the X coordinate shearing element of the 3x3 matrix",
          "\u003ccode\u003em11\u003c/code\u003e - the Y coordinate scaling element of the 3x3 matrix",
          "\u003ccode\u003em02\u003c/code\u003e - the X coordinate translation element of the 3x3 matrix",
          "\u003ccode\u003em12\u003c/code\u003e - the Y coordinate translation element of the 3x3 matrix"
        ],
        "since": [
          "1.2"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "flatmatrix",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new AffineTransform from an array of double precision values representing either the 4 non-translation entries or the 6 specifiable entries of the 3x3 transformation matrix. The values are retrieved from the array as { m00 m10 m01 m11 [m02 m12]}.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eflatmatrix\u003c/code\u003e - the double array containing the values to be set in the new \n\u003ccode\u003eAffineTransform\u003c/code\u003e object. The length of the array is assumed to be at least 4. If the length of the array is less than 6, only the first 4 values are taken. If the length of the array is greater than 6, the first 6 values are taken."
        ],
        "since": [
          "1.2"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.awt.geom.AffineTransform",
  "comment": "The \n\u003ccode\u003eAffineTransform\u003c/code\u003e class represents a 2D affine transform that performs a linear mapping from 2D coordinates to other 2D coordinates that preserves the \"straightness\" and \"parallelness\" of lines. Affine transformations can be constructed using sequences of translations, scales, flips, rotations, and shears. \n\u003cp\u003e Such a coordinate transformation can be represented by a 3 row by 3 column matrix with an implied last row of [ 0 0 1 ]. This matrix transforms source coordinates \u003ccode\u003e(x,y)\u003c/code\u003e into destination coordinates \u003ccode\u003e(x\u0027,y\u0027)\u003c/code\u003e by considering them to be a column vector and multiplying the coordinate vector by the matrix according to the following process: \u003c/p\u003e\n\u003cpre\u003e      [ x\u0027]   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]\n      [ y\u0027] \u003d [  m10  m11  m12  ] [ y ] \u003d [ m10x + m11y + m12 ]\n      [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"quadrantapproximation\"\u003eHandling 90-Degree Rotations\u003c/a\u003e\u003c/h2\u003e \n\u003cp\u003e In some variations of the \u003ccode\u003erotate\u003c/code\u003e methods in the \u003ccode\u003eAffineTransform\u003c/code\u003e class, a double-precision argument specifies the angle of rotation in radians. These methods have special handling for rotations of approximately 90 degrees (including multiples such as 180, 270, and 360 degrees), so that the common case of quadrant rotation is handled more efficiently. This special handling can cause angles very close to multiples of 90 degrees to be treated as if they were exact multiples of 90 degrees. For small multiples of 90 degrees the range of angles treated as a quadrant rotation is approximately 0.00000121 degrees wide. This section explains why such special care is needed and how it is implemented. \u003c/p\u003e\n\u003cp\u003e Since 90 degrees is represented as \u003ccode\u003ePI/2\u003c/code\u003e in radians, and since PI is a transcendental (and therefore irrational) number, it is not possible to exactly represent a multiple of 90 degrees as an exact double precision value measured in radians. As a result it is theoretically impossible to describe quadrant rotations (90, 180, 270 or 360 degrees) using these values. Double precision floating point values can get very close to non-zero multiples of \u003ccode\u003ePI/2\u003c/code\u003e but never close enough for the sine or cosine to be exactly 0.0, 1.0 or -1.0. The implementations of \u003ccode\u003eMath.sin()\u003c/code\u003e and \u003ccode\u003eMath.cos()\u003c/code\u003e correspondingly never return 0.0 for any case other than \u003ccode\u003eMath.sin(0.0)\u003c/code\u003e. These same implementations do, however, return exactly 1.0 and -1.0 for some range of numbers around each multiple of 90 degrees since the correct answer is so close to 1.0 or -1.0 that the double precision significand cannot represent the difference as accurately as it can for numbers that are near 0.0. \u003c/p\u003e\n\u003cp\u003e The net result of these issues is that if the \u003ccode\u003eMath.sin()\u003c/code\u003e and \u003ccode\u003eMath.cos()\u003c/code\u003e methods are used to directly generate the values for the matrix modifications during these radian-based rotation operations then the resulting transform is never strictly classifiable as a quadrant rotation even for a simple case like \u003ccode\u003erotate(Math.PI/2.0)\u003c/code\u003e, due to minor variations in the matrix caused by the non-0.0 values obtained for the sine and cosine. If these transforms are not classified as quadrant rotations then subsequent code which attempts to optimize further operations based upon the type of the transform will be relegated to its most general implementation. \u003c/p\u003e\n\u003cp\u003e Because quadrant rotations are fairly common, this class should handle these cases reasonably quickly, both in applying the rotations to the transform and in applying the resulting transform to the coordinates. To facilitate this optimal handling, the methods which take an angle of rotation measured in radians attempt to detect angles that are intended to be quadrant rotations and treat them as such. These methods therefore treat an angle \u003cem\u003etheta\u003c/em\u003e as a quadrant rotation if either \u003ccode\u003eMath.sin(\u003cem\u003etheta\u003c/em\u003e)\u003c/code\u003e or \u003ccode\u003eMath.cos(\u003cem\u003etheta\u003c/em\u003e)\u003c/code\u003e returns exactly 1.0 or -1.0. As a rule of thumb, this property holds true for a range of approximately 0.0000000211 radians (or 0.00000121 degrees) around small multiples of \u003ccode\u003eMath.PI/2.0\u003c/code\u003e.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#java.awt.geom.AffineTransform\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "since": [
      "1.2"
    ]
  }
}