{
  "packageName": "java.beans",
  "simpleName": "PersistenceDelegate",
  "moduleName": "java.desktop",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "oldInstance"
          }
        },
        {
          "type": {
            "name": "java.beans.Encoder",
            "type": "Class"
          },
          "field": {
            "name": "out"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "writeObject",
      "comment": "The writeObject is a single entry point to the persistence and is used by an Encoder in the traditional mode of delegation. Although this method is not final, it should not need to be subclassed under normal circumstances. This implementation first checks to see if the stream has already encountered this object. Next the mutatesTo method is called to see if that candidate returned from the stream can be mutated into an accurate copy of oldInstance. If it can, the initialize method is called to perform the initialization. If not, the candidate is removed from the stream, and the instantiate method is called to create a new candidate for this object.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoldInstance\u003c/code\u003e - The instance that will be created by this expression.",
          "\u003ccode\u003eout\u003c/code\u003e - The stream to which this expression will be written."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eout\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "oldInstance"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "newInstance"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "mutatesTo",
      "comment": "Returns true if an equivalent copy of oldInstance may be created by applying a series of statements to newInstance. In the specification of this method, we mean by equivalent that the modified instance is indistinguishable from oldInstance in the behavior of the relevant methods in its public API. [Note: we use the phrase relevant methods rather than all methods here only because, to be strictly correct, methods like hashCode and toString prevent most classes from producing truly indistinguishable copies of their instances]. The default behavior returns true if the classes of the two instances are the same.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoldInstance\u003c/code\u003e - The instance to be copied.",
          "\u003ccode\u003enewInstance\u003c/code\u003e - The instance that is to be modified."
        ],
        "return": [
          "True if an equivalent copy of \n\u003ccode\u003enewInstance\u003c/code\u003e may be created by applying a series of mutations to \n\u003ccode\u003eoldInstance\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.beans.Expression",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "oldInstance"
          }
        },
        {
          "type": {
            "name": "java.beans.Encoder",
            "type": "Class"
          },
          "field": {
            "name": "out"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "instantiate",
      "comment": "Returns an expression whose value is oldInstance. This method is used to characterize the constructor or factory method that should be used to create the given object. For example, the instantiate method of the persistence delegate for the Field class could be defined as follows:  Field f \u003d (Field)oldInstance;\n return new Expression(f, f.getDeclaringClass(), \"getField\", new Object[]{f.getName()});\n Note that we declare the value of the returned expression so that the value of the expression (as returned by getValue) will be identical to oldInstance.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoldInstance\u003c/code\u003e - The instance that will be created by this expression.",
          "\u003ccode\u003eout\u003c/code\u003e - The stream to which this expression will be written."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eout\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e and this value is used in the method"
        ],
        "return": [
          "An expression whose value is \n\u003ccode\u003eoldInstance\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "oldInstance"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "newInstance"
          }
        },
        {
          "type": {
            "name": "java.beans.Encoder",
            "type": "Class"
          },
          "field": {
            "name": "out"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "initialize",
      "comment": "Produce a series of statements with side effects on newInstance so that the new instance becomes equivalent to oldInstance. In the specification of this method, we mean by equivalent that, after the method returns, the modified instance is indistinguishable from newInstance in the behavior of all methods in its public API. The implementation typically achieves this goal by producing a series of \"what happened\" statements involving the oldInstance and its publicly available state. These statements are sent to the output stream using its writeExpression method which returns an expression involving elements in a cloned environment simulating the state of an input stream during reading. Each statement returned will have had all instances the old environment replaced with objects which exist in the new one. In particular, references to the target of these statements, which start out as references to oldInstance are returned as references to the newInstance instead. Executing these statements effects an incremental alignment of the state of the two objects as a series of modifications to the objects in the new environment. By the time the initialize method returns it should be impossible to tell the two instances apart by using their public APIs. Most importantly, the sequence of steps that were used to make these objects appear equivalent will have been recorded by the output stream and will form the actual output when the stream is flushed. The default implementation, calls the initialize method of the type\u0027s superclass.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the type of the instances",
          "\u003ccode\u003eoldInstance\u003c/code\u003e - The instance to be copied.",
          "\u003ccode\u003enewInstance\u003c/code\u003e - The instance that is to be modified.",
          "\u003ccode\u003eout\u003c/code\u003e - The stream to which any initialization statements should be written."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eout\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Constructs a PersistenceDelegate.",
      "tagMap": {}
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.beans.PersistenceDelegate",
  "comment": "The PersistenceDelegate class takes the responsibility for expressing the state of an instance of a given class in terms of the methods in the class\u0027s public API. Instead of associating the responsibility of persistence with the class itself as is done, for example, by the \n\u003ccode\u003ereadObject\u003c/code\u003e and \n\u003ccode\u003ewriteObject\u003c/code\u003e methods used by the \n\u003ccode\u003eObjectOutputStream\u003c/code\u003e, streams like the \n\u003ccode\u003eXMLEncoder\u003c/code\u003e which use this delegation model can have their behavior controlled independently of the classes themselves. Normally, the class is the best place to put such information and conventions can easily be expressed in this delegation scheme to do just that. Sometimes however, it is the case that a minor problem in a single class prevents an entire object graph from being written and this can leave the application developer with no recourse but to attempt to shadow the problematic classes locally or use alternative persistence techniques. In situations like these, the delegation model gives a relatively clean mechanism for the application developer to intervene in all parts of the serialization process without requiring that modifications be made to the implementation of classes which are not part of the application itself. \n\u003cp\u003e In addition to using a delegation model, this persistence scheme differs from traditional serialization schemes in requiring an analog of the \u003ccode\u003ewriteObject\u003c/code\u003e method without a corresponding \u003ccode\u003ereadObject\u003c/code\u003e method. The \u003ccode\u003ewriteObject\u003c/code\u003e analog encodes each instance in terms of its public API and there is no need to define a \u003ccode\u003ereadObject\u003c/code\u003e analog since the procedure for reading the serialized form is defined by the semantics of method invocation as laid out in the Java Language Specification. Breaking the dependency between \u003ccode\u003ewriteObject\u003c/code\u003e and \u003ccode\u003ereadObject\u003c/code\u003e implementations, which may change from version to version, is the key factor in making the archives produced by this technique immune to changes in the private implementations of the classes to which they refer. \u003c/p\u003e\n\u003cp\u003e A persistence delegate, may take control of all aspects of the persistence of an object including: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e Deciding whether or not an instance can be mutated into another instance of the same class. \u003c/li\u003e\n \u003cli\u003e Instantiating the object, either by calling a public constructor or a public factory method. \u003c/li\u003e\n \u003cli\u003e Performing the initialization of the object. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/beans/XMLEncoder.html\" title\u003d\"class in java.beans\"\u003e\u003ccode\u003eXMLEncoder\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.4"
    ]
  }
}