{
  "packageName": "javax.annotation.processing",
  "simpleName": "Filer",
  "moduleName": "java.compiler",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "javax.tools.JavaFileObject",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "name",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "javax.lang.model.element.Element",
            "type": "Class"
          },
          "name": "originatingElements",
          "varargs": true
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createSourceFile",
      "comment": "Creates a new source file and returns an object to allow writing to it. A source file for a class, interface, or a package can be created. The file\u0027s name and path (relative to the root output location for source files) are based on the name of the item to be declared in that file as well as the specified module for the item (if any). If more than one class or interface is being declared in a single file (that is, a single compilation unit), the name of the file should correspond to the name of the principal top-level class or interface (the public one, for example). A source file can also be created to hold information about a package, including package annotations. To create a source file for a named package, have the name argument be the package\u0027s name followed by \".package-info\"; to create a source file for an unnamed package, use \"package-info\". The optional module name is prefixed to the type name or package name and separated using a \"/\" character. For example, to create a source file for class a.B in module foo, use a name argument of \"foo/a.B\". If no explicit module prefix is given and modules are supported in the environment, a suitable module is inferred. If a suitable module cannot be inferred FilerException is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference. Creating a source file in or for an unnamed package in a named module is not supported.",
      "annotations": [],
      "tagMap": {
        "See Java Language Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-7.html#jls-7.3\"\u003e7.3 Compilation Units\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "apiNote": [
          "To use a particular \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/charset/Charset.html\" title\u003d\"class in java.nio.charset\"\u003echarset\u003c/a\u003e to encode the contents of the file, an \n\u003ccode\u003eOutputStreamWriter\u003c/code\u003e with the chosen charset can be created from the \n\u003ccode\u003eOutputStream\u003c/code\u003e from the returned object. If the \n\u003ccode\u003eWriter\u003c/code\u003e from the returned object is directly used for writing, its charset is determined by the implementation. An annotation processing tool may have an \n\u003ccode\u003e-encoding\u003c/code\u003e flag or analogous option for specifying this; otherwise, it will typically be the platform\u0027s default encoding. \n\u003cp\u003eTo avoid subsequent errors, the contents of the source file should be compatible with the \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/annotation/processing/ProcessingEnvironment.html#getSourceVersion()\"\u003esource version\u003c/a\u003e being used for this run.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - canonical (fully qualified) name of the principal class or interface being declared in this file or a package name followed by \n\u003ccode\u003e\".package-info\"\u003c/code\u003e for a package information file",
          "\u003ccode\u003eoriginatingElements\u003c/code\u003e - class, interface, package, or module elements causally associated with the creation of this file, may be elided or \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "implNote": [
          "In the reference implementation, if the annotation processing tool is processing a single module \n\u003ci\u003eM\u003c/i\u003e, then \n\u003ci\u003eM\u003c/i\u003e is used as the module for files created without an explicit module prefix. If the tool is processing multiple modules, and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/lang/model/util/Elements.html#getPackageElement(java.lang.CharSequence)\"\u003e\u003ccode\u003eElements.getPackageElement(package-of(name))\u003c/code\u003e\u003c/a\u003e returns a package, the module that owns the returned package is used as the target module. A separate option may be used to provide the target module if it cannot be determined using the above rules."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/annotation/processing/FilerException.html\" title\u003d\"class in javax.annotation.processing\"\u003eFilerException\u003c/a\u003e\u003c/code\u003e - if the same pathname has already been created, the same class or interface has already been created, the name is otherwise not valid for the entity requested to being created, if the target module cannot be determined, if the target module is not writable, or a module is specified when the environment doesn\u0027t support modules.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if the file cannot be created"
        ],
        "return": [
          "a \n\u003ccode\u003eJavaFileObject\u003c/code\u003e to write the new source file"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.tools.JavaFileObject",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "name",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "javax.lang.model.element.Element",
            "type": "Class"
          },
          "name": "originatingElements",
          "varargs": true
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createClassFile",
      "comment": "Creates a new class file, and returns an object to allow writing to it. A class file for a class, interface, or a package can be created. The file\u0027s name and path (relative to the root output location for class files) are based on the name of the item to be declared as well as the specified module for the item (if any). A class file can also be created to hold information about a package, including package annotations. To create a class file for a named package, have the name argument be the package\u0027s name followed by \".package-info\"; creating a class file for an unnamed package is not supported. The optional module name is prefixed to the type name or package name and separated using a \"/\" character. For example, to create a class file for class a.B in module foo, use a name argument of \"foo/a.B\". If no explicit module prefix is given and modules are supported in the environment, a suitable module is inferred. If a suitable module cannot be inferred FilerException is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference. Creating a class file in or for an unnamed package in a named module is not supported.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "To avoid subsequent errors, the contents of the class file should be compatible with the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/annotation/processing/ProcessingEnvironment.html#getSourceVersion()\"\u003esource version\u003c/a\u003e being used for this run."
        ],
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - binary name of the class or interface being written or a package name followed by \n\u003ccode\u003e\".package-info\"\u003c/code\u003e for a package information file",
          "\u003ccode\u003eoriginatingElements\u003c/code\u003e - class or interface or package or module elements causally associated with the creation of this file, may be elided or \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "implNote": [
          "In the reference implementation, if the annotation processing tool is processing a single module \n\u003ci\u003eM\u003c/i\u003e, then \n\u003ci\u003eM\u003c/i\u003e is used as the module for files created without an explicit module prefix. If the tool is processing multiple modules, and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/lang/model/util/Elements.html#getPackageElement(java.lang.CharSequence)\"\u003e\u003ccode\u003eElements.getPackageElement(package-of(name))\u003c/code\u003e\u003c/a\u003e returns a package, the module that owns the returned package is used as the target module. A separate option may be used to provide the target module if it cannot be determined using the above rules."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/annotation/processing/FilerException.html\" title\u003d\"class in javax.annotation.processing\"\u003eFilerException\u003c/a\u003e\u003c/code\u003e - if the same pathname has already been created, the same class or interface has already been created, the name is not valid for a class or interface, if the target module cannot be determined, if the target module is not writable, or a module is specified when the environment doesn\u0027t support modules.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if the file cannot be created"
        ],
        "return": [
          "a \n\u003ccode\u003eJavaFileObject\u003c/code\u003e to write the new class file"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.tools.FileObject",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.tools.JavaFileManager$Location",
            "type": "Class"
          },
          "name": "location",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "moduleAndPkg",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "relativeName",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "javax.lang.model.element.Element",
            "type": "Class"
          },
          "name": "originatingElements",
          "varargs": true
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "createResource",
      "comment": "Creates a new auxiliary resource file for writing and returns a file object for it. The file may be located along with the newly created source files, newly created binary files, or other supported location. The locations CLASS_OUTPUT and SOURCE_OUTPUT must be supported. The resource may be named relative to some module and/or package (as are source and class files), and from there by a relative pathname. In a loose sense, the full pathname of the new file will be the concatenation of location, moduleAndPkg, and relativeName. If moduleAndPkg contains a \"/\" character, the prefix before the \"/\" character is the module name and the suffix after the \"/\" character is the package name. The package suffix may be empty. If moduleAndPkg does not contain a \"/\" character, the entire argument is interpreted as a package name. If the given location is neither a module oriented location, nor an output location containing multiple modules, and the explicit module prefix is given, FilerException is thrown. If the given location is either a module oriented location, or an output location containing multiple modules, and no explicit modules prefix is given, a suitable module is inferred. If a suitable module cannot be inferred FilerException is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference. Files created via this method are not registered for annotation processing, even if the full pathname of the file would correspond to the full pathname of a new source file or new class file.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003elocation\u003c/code\u003e - location of the new file",
          "\u003ccode\u003emoduleAndPkg\u003c/code\u003e - module and/or package relative to which the file should be named, or the empty string if none",
          "\u003ccode\u003erelativeName\u003c/code\u003e - final pathname components of the file",
          "\u003ccode\u003eoriginatingElements\u003c/code\u003e - class or interface or package or module elements causally associated with the creation of this file, may be elided or \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "implNote": [
          "In the reference implementation, if the annotation processing tool is processing a single module \n\u003ci\u003eM\u003c/i\u003e, then \n\u003ci\u003eM\u003c/i\u003e is used as the module for files created without an explicit module prefix. If the tool is processing multiple modules, and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/lang/model/util/Elements.html#getPackageElement(java.lang.CharSequence)\"\u003e\u003ccode\u003eElements.getPackageElement(package-of(name))\u003c/code\u003e\u003c/a\u003e returns a package, the module that owns the returned package is used as the target module. A separate option may be used to provide the target module if it cannot be determined using the above rules."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if the file cannot be created",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/annotation/processing/FilerException.html\" title\u003d\"class in javax.annotation.processing\"\u003eFilerException\u003c/a\u003e\u003c/code\u003e - if the same pathname has already been created, if the target module cannot be determined, or if the target module is not writable, or if an explicit target module is specified and the location does not support it.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - for an unsupported location",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emoduleAndPkg\u003c/code\u003e is ill-formed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003erelativeName\u003c/code\u003e is not relative"
        ],
        "return": [
          "a \n\u003ccode\u003eFileObject\u003c/code\u003e to write the new resource"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.tools.FileObject",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.tools.JavaFileManager$Location",
            "type": "Class"
          },
          "name": "location",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "moduleAndPkg",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "relativeName",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getResource",
      "comment": "Returns an object for reading an existing resource. The locations CLASS_OUTPUT and SOURCE_OUTPUT must be supported. If moduleAndPkg contains a \"/\" character, the prefix before the \"/\" character is the module name and the suffix after the \"/\" character is the package name. The package suffix may be empty; however, if a module name is present, it must be nonempty. If moduleAndPkg does not contain a \"/\" character, the entire argument is interpreted as a package name. If the given location is neither a module oriented location, nor an output location containing multiple modules, and the explicit module prefix is given, FilerException is thrown. If the given location is either a module oriented location, or an output location containing multiple modules, and no explicit modules prefix is given, a suitable module is inferred. If a suitable module cannot be inferred FilerException is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003elocation\u003c/code\u003e - location of the file",
          "\u003ccode\u003emoduleAndPkg\u003c/code\u003e - module and/or package relative to which the file should be searched for, or the empty string if none",
          "\u003ccode\u003erelativeName\u003c/code\u003e - final pathname components of the file"
        ],
        "implNote": [
          "In the reference implementation, if the annotation processing tool is processing a single module \n\u003ci\u003eM\u003c/i\u003e, then \n\u003ci\u003eM\u003c/i\u003e is used as the module for files read without an explicit module prefix. If the tool is processing multiple modules, and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/lang/model/util/Elements.html#getPackageElement(java.lang.CharSequence)\"\u003e\u003ccode\u003eElements.getPackageElement(package-of(name))\u003c/code\u003e\u003c/a\u003e returns a package, the module that owns the returned package is used as the source module. A separate option may be used to provide the target module if it cannot be determined using the above rules."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.compiler/javax/annotation/processing/FilerException.html\" title\u003d\"class in javax.annotation.processing\"\u003eFilerException\u003c/a\u003e\u003c/code\u003e - if the same pathname has already been opened for writing, if the source module cannot be determined, or if the target module is not writable, or if an explicit target module is specified and the location does not support it.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if the file cannot be opened",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - for an unsupported location",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emoduleAndPkg\u003c/code\u003e is ill-formed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003erelativeName\u003c/code\u003e is not relative"
        ],
        "return": [
          "an object to read the file"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "javax.annotation.processing.Filer",
  "annotations": [],
  "tagMap": {
    "apiNote": [
      "Some of the effect of overwriting a file can be achieved by using a \n\u003ci\u003edecorator\u003c/i\u003e-style pattern. Instead of modifying a class directly, the class is designed so that either its superclass is generated by annotation processing or subclasses of the class are generated by annotation processing. If the subclasses are generated, the parent class may be designed to use factories instead of public constructors so that only subclass instances would be presented to clients of the parent class."
    ],
    "since": [
      "1.6"
    ]
  }
}