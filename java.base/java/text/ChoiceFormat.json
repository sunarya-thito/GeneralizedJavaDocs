{
  "packageName": "java.text",
  "simpleName": "ChoiceFormat",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.text.NumberFormat",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "applyPattern",
      "comment": "Sets the pattern.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enewPattern\u003c/code\u003e - See the class description."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewPattern\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toPattern",
      "comment": "Gets the pattern.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the pattern string"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setChoices",
      "comment": "Set the choices to be used in formatting.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003elimits\u003c/code\u003e - contains the top value that you want parsed with that format, and should be in ascending sorted order. When formatting X, the choice will be the i, where limit[i] â‰¤ X \u0026lt; limit[i+1]. If the limit array is not in ascending order, the results of formatting will be incorrect.",
          "\u003ccode\u003eformats\u003c/code\u003e - are the formats you want to use for each limit. They can be either Format objects or Strings. When formatting with object Y, if the object is a NumberFormat, then ((NumberFormat) Y).format(X) is called. Otherwise Y.toString() is called."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003elimits\u003c/code\u003e or \n\u003ccode\u003eformats\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLimits",
      "comment": "Get the limits passed in the constructor.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the limits."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFormats",
      "comment": "Get the formats passed in the constructor.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the formats."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.StringBuffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "format",
      "comment": "Specialization of format. This method really calls format(double, StringBuffer, FieldPosition) thus the range of longs that are supported is only equal to the range that can be stored by double. This will never be a practical limitation.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html#format(java.lang.Object)\"\u003e\u003ccode\u003eFormat.format(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#format(long,java.lang.StringBuffer,java.text.FieldPosition)\"\u003eformat\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html\" title\u003d\"class in java.text\"\u003eNumberFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003enumber\u003c/code\u003e - the long number to format",
          "\u003ccode\u003etoAppendTo\u003c/code\u003e - the StringBuffer to which the formatted text is to be appended",
          "\u003ccode\u003estatus\u003c/code\u003e - keeps track on the position of the field within the returned string. For example, for formatting a number \n\u003ccode\u003e123456789\u003c/code\u003e in \n\u003ccode\u003eLocale.US\u003c/code\u003e locale, if the given \n\u003ccode\u003efieldPosition\u003c/code\u003e is \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#INTEGER_FIELD\"\u003e\u003ccode\u003eNumberFormat.INTEGER_FIELD\u003c/code\u003e\u003c/a\u003e, the begin index and end index of \n\u003ccode\u003efieldPosition\u003c/code\u003e will be set to 0 and 11, respectively for the output string \n\u003ccode\u003e123,456,789\u003c/code\u003e."
        ],
        "return": [
          "the formatted StringBuffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.StringBuffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "format",
      "comment": "Returns pattern with formatted double.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html#format(java.lang.Object)\"\u003e\u003ccode\u003eFormat.format(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#format(double,java.lang.StringBuffer,java.text.FieldPosition)\"\u003eformat\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html\" title\u003d\"class in java.text\"\u003eNumberFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003enumber\u003c/code\u003e - number to be formatted and substituted.",
          "\u003ccode\u003etoAppendTo\u003c/code\u003e - where text is appended.",
          "\u003ccode\u003estatus\u003c/code\u003e - ignore no useful status is returned."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etoAppendTo\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the formatted StringBuffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Number",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parse",
      "comment": "Parses a Number from the input text.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#isParseIntegerOnly()\"\u003e\u003ccode\u003eNumberFormat.isParseIntegerOnly()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html#parseObject(java.lang.String,java.text.ParsePosition)\"\u003e\u003ccode\u003eFormat.parseObject(java.lang.String, java.text.ParsePosition)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#parse(java.lang.String,java.text.ParsePosition)\"\u003eparse\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html\" title\u003d\"class in java.text\"\u003eNumberFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the source text.",
          "\u003ccode\u003estatus\u003c/code\u003e - an input-output parameter. On input, the status.index field indicates the first character of the source text that should be parsed. On exit, if no error occurred, status.index is set to the first unparsed character in the source text. On exit, if an error did occur, status.index is unchanged and status.errorIndex is set to the first index of the character that caused the parse to fail."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estatus\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e or if \n\u003ccode\u003etext\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e and the list of choice strings is not empty."
        ],
        "return": [
          "A Number representing the value of the number parsed."
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "nextDouble",
      "comment": "Finds the least double greater than d. If NaN, returns same value. Used to make half-open intervals.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ChoiceFormat.html#previousDouble(double)\"\u003e\u003ccode\u003epreviousDouble(double)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ed\u003c/code\u003e - the reference value"
        ],
        "implNote": [
          "This is equivalent to calling \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#nextUp(double)\"\u003e\u003ccode\u003eMath.nextUp(d)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the least double value greather than \n\u003ccode\u003ed\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "previousDouble",
      "comment": "Finds the greatest double less than d. If NaN, returns same value.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ChoiceFormat.html#nextDouble(double)\"\u003e\u003ccode\u003enextDouble(double)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ed\u003c/code\u003e - the reference value"
        ],
        "implNote": [
          "This is equivalent to calling \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#nextDown(double)\"\u003e\u003ccode\u003eMath.nextDown(d)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the greatest double value less than \n\u003ccode\u003ed\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "clone",
      "comment": "Overrides Cloneable",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Cloneable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eCloneable\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#clone()\"\u003eclone\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html\" title\u003d\"class in java.text\"\u003eNumberFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a clone of this instance."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hashCode",
      "comment": "Generates a hash code for the message format object.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#identityHashCode(java.lang.Object)\"\u003e\u003ccode\u003eSystem.identityHashCode(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html\" title\u003d\"class in java.text\"\u003eNumberFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a hash code value for this object."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "equals",
      "comment": "Equality comparison between two",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/HashMap.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eHashMap\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html\" title\u003d\"class in java.text\"\u003eNumberFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the reference object with which to compare."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this object is the same as the obj argument; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "nextDouble",
      "comment": "Finds the least double greater than d (if positive is true), or the greatest double less than d (if positive is false). If NaN, returns same value.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ed\u003c/code\u003e - the reference value",
          "\u003ccode\u003epositive\u003c/code\u003e - \n\u003ccode\u003etrue\u003c/code\u003e if the least double is desired; \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ],
        "implNote": [
          "This is equivalent to calling \n\u003ccode\u003epositive ? Math.nextUp(d) : Math.nextDown(d)\u003c/code\u003e"
        ],
        "return": [
          "the least or greater double value"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "name": "newPattern",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs with limits and corresponding formats based on the pattern.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ChoiceFormat.html#applyPattern(java.lang.String)\"\u003e\u003ccode\u003eapplyPattern(java.lang.String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003enewPattern\u003c/code\u003e - the new pattern string"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewPattern\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "limits",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "formats",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs with the limits and the corresponding formats.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ChoiceFormat.html#setChoices(double%5B%5D,java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetChoices(double[], java.lang.String[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elimits\u003c/code\u003e - limits in ascending order",
          "\u003ccode\u003eformats\u003c/code\u003e - corresponding format strings"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003elimits\u003c/code\u003e or \n\u003ccode\u003eformats\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.text.ChoiceFormat",
  "comment": "A \n\u003ccode\u003eChoiceFormat\u003c/code\u003e allows you to attach a format to a range of numbers. It is generally used in a \n\u003ccode\u003eMessageFormat\u003c/code\u003e for handling plurals. The choice is specified with an ascending list of doubles, where each item specifies a half-open interval up to the next item: \n\u003cblockquote\u003e \n \u003cpre\u003e X matches j if and only if limit[j] â‰¤ X \u0026lt; limit[j+1]\n \u003c/pre\u003e \n\u003c/blockquote\u003e If there is no match, then either the first or last index is used, depending on whether the number (X) is too low or too high. If the limit array is not in ascending order, the results of formatting will be incorrect. ChoiceFormat also accepts \n\u003ccode\u003e\\u221E\u003c/code\u003e as equivalent to infinity(INF). \n\u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e \u003ccode\u003eChoiceFormat\u003c/code\u003e differs from the other \u003ccode\u003eFormat\u003c/code\u003e classes in that you create a \u003ccode\u003eChoiceFormat\u003c/code\u003e object with a constructor (not with a \u003ccode\u003egetInstance\u003c/code\u003e style factory method). The factory methods aren\u0027t necessary because \u003ccode\u003eChoiceFormat\u003c/code\u003e doesn\u0027t require any complex setup for a given locale. In fact, \u003ccode\u003eChoiceFormat\u003c/code\u003e doesn\u0027t implement any locale specific behavior. \u003c/p\u003e\n\u003cp\u003e When creating a \u003ccode\u003eChoiceFormat\u003c/code\u003e, you must specify an array of formats and an array of limits. The length of these arrays must be the same. For example, \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cem\u003elimits\u003c/em\u003e \u003d {1,2,3,4,5,6,7}\u003cbr\u003e \u003cem\u003eformats\u003c/em\u003e \u003d {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"} \u003c/li\u003e\n \u003cli\u003e \u003cem\u003elimits\u003c/em\u003e \u003d {0, 1, ChoiceFormat.nextDouble(1)}\u003cbr\u003e \u003cem\u003eformats\u003c/em\u003e \u003d {\"no files\", \"one file\", \"many files\"}\u003cbr\u003e (\u003ccode\u003enextDouble\u003c/code\u003e can be used to get the next higher double, to make the half-open interval.) \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Here is a simple example that shows formatting and parsing: \u003c/p\u003e\n\u003cblockquote\u003e \n \u003cpre\u003e\u003ccode\u003e\n double[] limits \u003d {1,2,3,4,5,6,7};\n String[] dayOfWeekNames \u003d {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n ChoiceFormat form \u003d new ChoiceFormat(limits, dayOfWeekNames);\n ParsePosition status \u003d new ParsePosition(0);\n for (double i \u003d 0.0; i \u0026lt;\u003d 8.0; ++i) {\n     status.setIndex(0);\n     System.out.println(i + \" -\u0026gt; \" + form.format(i) + \" -\u0026gt; \"\n                              + form.parse(form.format(i),status));\n }\n \u003c/code\u003e\u003c/pre\u003e \n\u003c/blockquote\u003e Here is a more complex example, with a pattern format: \n\u003cblockquote\u003e \n \u003cpre\u003e\u003ccode\u003e\n double[] filelimits \u003d {0,1,2};\n String[] filepart \u003d {\"are no files\",\"is one file\",\"are {2} files\"};\n ChoiceFormat fileform \u003d new ChoiceFormat(filelimits, filepart);\n Format[] testFormats \u003d {fileform, null, NumberFormat.getInstance()};\n MessageFormat pattform \u003d new MessageFormat(\"There {0} on {1}\");\n pattform.setFormats(testFormats);\n Object[] testArgs \u003d {null, \"ADisk\", null};\n for (int i \u003d 0; i \u0026lt; 4; ++i) {\n     testArgs[0] \u003d new Integer(i);\n     testArgs[2] \u003d testArgs[0];\n     System.out.println(pattform.format(testArgs));\n }\n \u003c/code\u003e\u003c/pre\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Specifying a pattern for ChoiceFormat objects is fairly straightforward. For example: \u003c/p\u003e\n\u003cblockquote\u003e \n \u003cpre\u003e\u003ccode\u003e\n ChoiceFormat fmt \u003d new ChoiceFormat(\n      \"-1#is negative| 0#is zero or fraction | 1#is one |1.0\u0026lt;is 1+ |2#is two |2\u0026lt;is more than 2.\");\n System.out.println(\"Formatter Pattern : \" + fmt.toPattern());\n\n System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0));\n System.out.println(\"Format with 0 : \" + fmt.format(0));\n System.out.println(\"Format with 0.9 : \" + fmt.format(0.9));\n System.out.println(\"Format with 1.0 : \" + fmt.format(1));\n System.out.println(\"Format with 1.5 : \" + fmt.format(1.5));\n System.out.println(\"Format with 2 : \" + fmt.format(2));\n System.out.println(\"Format with 2.1 : \" + fmt.format(2.1));\n System.out.println(\"Format with NaN : \" + fmt.format(Double.NaN));\n System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n \u003c/code\u003e\u003c/pre\u003e \n\u003c/blockquote\u003e And the output result would be like the following: \n\u003cblockquote\u003e \n \u003cpre\u003e\u003ccode\u003e\n Format with -INF : is negative\n Format with -1.0 : is negative\n Format with 0 : is zero or fraction\n Format with 0.9 : is zero or fraction\n Format with 1.0 : is one\n Format with 1.5 : is 1+\n Format with 2 : is two\n Format with 2.1 : is more than 2.\n Format with NaN : is negative\n Format with +INF : is more than 2.\n \u003c/code\u003e\u003c/pre\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"synchronization\"\u003eSynchronization\u003c/a\u003e\u003c/h2\u003e \n\u003cp\u003e Choice formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/DecimalFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eDecimalFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/MessageFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eMessageFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#java.text.ChoiceFormat\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "since": [
      "1.1"
    ]
  }
}