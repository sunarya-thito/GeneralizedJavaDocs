{
  "packageName": "java.text",
  "simpleName": "MessageFormat",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.text.Format",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Locale",
            "type": "Class"
          },
          "field": {
            "name": "locale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setLocale",
      "comment": "Sets the locale to be used when creating or comparing subformats. This affects subsequent calls to the applyPattern and toPattern methods if format elements specify a format type and therefore have the subformats created in the applyPattern method, as well as to the format and formatToCharacterIterator methods if format elements do not specify a format type and therefore have the subformats created in the formatting methods. Subformats that have already been created are not affected.",
      "tagMap": {
        "param": [
          "\u003ccode\u003elocale\u003c/code\u003e - the locale to be used when creating or comparing subformats"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Locale",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLocale",
      "comment": "Gets the locale that\u0027s used when creating or comparing subformats.",
      "tagMap": {
        "return": [
          "the locale used when creating or comparing subformats"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "applyPattern",
      "comment": "Sets the pattern used by this message format. The method parses the pattern and creates a list of subformats for the format elements contained in it. Patterns and their interpretation are specified in the class description.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern for this message format"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the pattern is invalid",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epattern\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toPattern",
      "comment": "Returns a pattern representing the current state of the message format. The string is constructed from internal information and therefore does not necessarily equal the previously applied pattern.",
      "tagMap": {
        "return": [
          "a pattern representing the current state of the message format"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.text.Format",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "newFormats"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setFormatsByArgumentIndex",
      "comment": "Sets the formats to use for the values passed into format methods or returned from parse methods. The indices of elements in newFormats correspond to the argument indices used in the previously set pattern string. The order of formats in newFormats thus corresponds to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods. If an argument index is used for more than one format element in the pattern string, then the corresponding new format is used for all such format elements. If an argument index is not used for any format element in the pattern string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the formats for argument indices less than newFormats.length are replaced.",
      "tagMap": {
        "param": [
          "\u003ccode\u003enewFormats\u003c/code\u003e - the new formats to use"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewFormats\u003c/code\u003e is null"
        ],
        "since": [
          "1.4"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.text.Format",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "newFormats"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setFormats",
      "comment": "Sets the formats to use for the format elements in the previously set pattern string. The order of formats in newFormats corresponds to the order of format elements in the pattern string. If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats are provided than needed, then only the first newFormats.length formats are replaced. Since the order of format elements in a pattern string often changes during localization, it is generally better to use the setFormatsByArgumentIndex method, which assumes an order of formats corresponding to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods.",
      "tagMap": {
        "param": [
          "\u003ccode\u003enewFormats\u003c/code\u003e - the new formats to use"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewFormats\u003c/code\u003e is null"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "argumentIndex"
          }
        },
        {
          "type": {
            "name": "java.text.Format",
            "type": "Class"
          },
          "field": {
            "name": "newFormat"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setFormatByArgumentIndex",
      "comment": "Sets the format to use for the format elements within the previously set pattern string that use the given argument index. The argument index is part of the format element definition and represents an index into the arguments array passed to the format methods or the result array returned by the parse methods. If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargumentIndex\u003c/code\u003e - the argument index for which to use the new format",
          "\u003ccode\u003enewFormat\u003c/code\u003e - the new format to use"
        ],
        "since": [
          "1.4"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "formatElementIndex"
          }
        },
        {
          "type": {
            "name": "java.text.Format",
            "type": "Class"
          },
          "field": {
            "name": "newFormat"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setFormat",
      "comment": "Sets the format to use for the format element with the given format element index within the previously set pattern string. The format element index is the zero-based number of the format element counting from the start of the pattern string. Since the order of format elements in a pattern string often changes during localization, it is generally better to use the setFormatByArgumentIndex method, which accesses format elements based on the argument index they specify.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eformatElementIndex\u003c/code\u003e - the index of a format element within the pattern",
          "\u003ccode\u003enewFormat\u003c/code\u003e - the format to use for the specified format element"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eformatElementIndex\u003c/code\u003e is equal to or larger than the number of format elements in the pattern string"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.text.Format",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFormatsByArgumentIndex",
      "comment": "Gets the formats used for the values passed into format methods or returned from parse methods. The indices of elements in the returned array correspond to the argument indices used in the previously set pattern string. The order of formats in the returned array thus corresponds to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods. If an argument index is used for more than one format element in the pattern string, then the format used for the last such format element is returned in the array. If an argument index is not used for any format element in the pattern string, then null is returned in the array.",
      "tagMap": {
        "return": [
          "the formats used for the arguments within the pattern"
        ],
        "since": [
          "1.4"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.text.Format",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFormats",
      "comment": "Gets the formats used for the format elements in the previously set pattern string. The order of formats in the returned array corresponds to the order of format elements in the pattern string. Since the order of format elements in a pattern string often changes during localization, it\u0027s generally better to use the getFormatsByArgumentIndex method, which assumes an order of formats corresponding to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods.",
      "tagMap": {
        "return": [
          "the formats used for the format elements in the pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.StringBuffer",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "arguments"
          }
        },
        {
          "type": {
            "name": "java.lang.StringBuffer",
            "type": "Class"
          },
          "field": {
            "name": "result"
          }
        },
        {
          "type": {
            "name": "java.text.FieldPosition",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "format",
      "comment": "Formats an array of objects and appends the MessageFormat\u0027s pattern, with format elements replaced by the formatted objects, to the provided StringBuffer. The text substituted for the individual format elements is derived from the current subformat of the format element and the arguments element at the format element\u0027s argument index as indicated by the first matching line of the following table. An argument is unavailable if arguments is null or has fewer than argumentIndex+1 elements. Examples of subformat,argument,and formatted text Subformat Argument Formatted Text any unavailable \"{\" + argumentIndex + \"}\" null \"null\" instanceof ChoiceFormat any subformat.format(argument).indexOf(\u0027{\u0027) \u003e\u003d 0 ? (new MessageFormat(subformat.format(argument), getLocale())).format(argument) : subformat.format(argument) !\u003d null any subformat.format(argument) null instanceof Number NumberFormat.getInstance(getLocale()).format(argument) instanceof Date DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument) instanceof String argument any argument.toString() If pos is non-null, and refers to Field.ARGUMENT, the location of the first formatted string will be returned.",
      "tagMap": {
        "param": [
          "\u003ccode\u003earguments\u003c/code\u003e - an array of objects to be formatted and substituted.",
          "\u003ccode\u003eresult\u003c/code\u003e - where text is appended.",
          "\u003ccode\u003epos\u003c/code\u003e - keeps track on the position of the first replaced argument in the output string."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if an argument in the \n\u003ccode\u003earguments\u003c/code\u003e array is not of the type expected by the format element(s) that use it.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eresult\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the string buffer passed in as \n\u003ccode\u003eresult\u003c/code\u003e, with formatted text appended"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "arguments"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "format",
      "comment": "Creates a MessageFormat with the given pattern and uses it to format the given arguments. This is equivalent to (new MessageFormat(pattern)).format(arguments, new StringBuffer(), null).toString()",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern string",
          "\u003ccode\u003earguments\u003c/code\u003e - object(s) to format"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the pattern is invalid, or if an argument in the \n\u003ccode\u003earguments\u003c/code\u003e array is not of the type expected by the format element(s) that use it.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epattern\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the formatted string"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.StringBuffer",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "arguments"
          }
        },
        {
          "type": {
            "name": "java.lang.StringBuffer",
            "type": "Class"
          },
          "field": {
            "name": "result"
          }
        },
        {
          "type": {
            "name": "java.text.FieldPosition",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "format",
      "comment": "Formats an array of objects and appends the MessageFormat\u0027s pattern, with format elements replaced by the formatted objects, to the provided StringBuffer. This is equivalent to format((Object[]) arguments, result, pos)",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html#format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)\"\u003eformat\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html\" title\u003d\"class in java.text\"\u003eFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003earguments\u003c/code\u003e - an array of objects to be formatted and substituted.",
          "\u003ccode\u003eresult\u003c/code\u003e - where text is appended.",
          "\u003ccode\u003epos\u003c/code\u003e - keeps track on the position of the first replaced argument in the output string."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if an argument in the \n\u003ccode\u003earguments\u003c/code\u003e array is not of the type expected by the format element(s) that use it.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eresult\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the string buffer passed in as \n\u003ccode\u003etoAppendTo\u003c/code\u003e, with formatted text appended"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.text.AttributedCharacterIterator",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "arguments"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "formatToCharacterIterator",
      "comment": "Formats an array of objects and inserts them into the MessageFormat\u0027s pattern, producing an AttributedCharacterIterator. You can use the returned AttributedCharacterIterator to build the resulting String, as well as to determine information about the resulting String. The text of the returned AttributedCharacterIterator is the same that would be returned by format(arguments, new StringBuffer(), null).toString() In addition, the AttributedCharacterIterator contains at least attributes indicating where text was generated from an argument in the arguments array. The keys of these attributes are of type MessageFormat.Field, their values are Integer objects indicating the index in the arguments array of the argument from which the text was generated. The attributes/value from the underlying Format instances that MessageFormat uses will also be placed in the resulting AttributedCharacterIterator. This allows you to not only find where an argument is placed in the resulting String, but also which fields it contains in turn.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html#formatToCharacterIterator(java.lang.Object)\"\u003eformatToCharacterIterator\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html\" title\u003d\"class in java.text\"\u003eFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003earguments\u003c/code\u003e - an array of objects to be formatted and substituted."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earguments\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if an argument in the \n\u003ccode\u003earguments\u003c/code\u003e array is not of the type expected by the format element(s) that use it."
        ],
        "return": [
          "AttributedCharacterIterator describing the formatted value."
        ],
        "since": [
          "1.4"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.text.ParsePosition",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parse",
      "comment": "Parses the string. Caveats: The parse may fail in a number of circumstances. For example: If one of the arguments does not occur in the pattern. If the format of an argument loses information, such as with a choice format where a large number formats to \"many\". Does not yet handle recursion (where the substituted strings contain {n} references.) Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern \"{1},{2}\" is used with the string arguments {\"a,b\", \"c\"}, it will format as \"a,b,c\". When the result is parsed, it will return {\"a\", \"b,c\"}. If a single argument is parsed more than once in the string, then the later parse wins. When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed. The returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if the parsing string \"AAA {0} BBB\" is comparing against the pattern \"AAD {0} BBB\", the error index is 0. When an error occurs, the call to this method will return null. If the source is null, return an empty array.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - the string to parse",
          "\u003ccode\u003epos\u003c/code\u003e - the parse position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epos\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e for a non-null \n\u003ccode\u003esource\u003c/code\u003e string."
        ],
        "return": [
          "an array of parsed objects"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "throwsClasses": [
        {
          "name": "java.text.ParseException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parse",
      "comment": "Parses text from the beginning of the given string to produce an object array. The method may not use the entire text of the given string. See the parse(String, ParsePosition) method for more information on message parsing.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A \n\u003ccode\u003eString\u003c/code\u003e whose beginning should be parsed."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ParseException.html\" title\u003d\"class in java.text\"\u003eParseException\u003c/a\u003e\u003c/code\u003e - if the beginning of the specified string cannot be parsed."
        ],
        "return": [
          "An \n\u003ccode\u003eObject\u003c/code\u003e array parsed from the string."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.text.ParsePosition",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parseObject",
      "comment": "Parses text from a string to produce an object array. The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of pos is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object array is returned. The updated pos can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of pos is not changed, the error index of pos is set to the index of the character where the error occurred, and null is returned. See the parse(String, ParsePosition) method for more information on message parsing.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html#parseObject(java.lang.String,java.text.ParsePosition)\"\u003eparseObject\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html\" title\u003d\"class in java.text\"\u003eFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A \n\u003ccode\u003eString\u003c/code\u003e, part of which should be parsed.",
          "\u003ccode\u003epos\u003c/code\u003e - A \n\u003ccode\u003eParsePosition\u003c/code\u003e object with index and error index information as described above."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epos\u003c/code\u003e is null."
        ],
        "return": [
          "An \n\u003ccode\u003eObject\u003c/code\u003e array parsed from the string. In case of error, returns null."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "clone",
      "comment": "Creates and returns a copy of this object.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Cloneable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eCloneable\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html#clone()\"\u003eclone\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html\" title\u003d\"class in java.text\"\u003eFormat\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a clone of this instance."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "obj"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "equals",
      "comment": "Equality comparison between two message format objects",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/HashMap.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eHashMap\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the reference object with which to compare."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this object is the same as the obj argument; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hashCode",
      "comment": "Generates a hash code for the message format object.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#identityHashCode(java.lang.Object)\"\u003e\u003ccode\u003eSystem.identityHashCode(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a hash code value for this object."
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a MessageFormat for the default FORMAT locale and the specified pattern. The constructor first sets the locale, then parses the pattern and creates a list of subformats for the format elements contained in it. Patterns and their interpretation are specified in the class description.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern for this message format"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the pattern is invalid",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epattern\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        },
        {
          "type": {
            "name": "java.util.Locale",
            "type": "Class"
          },
          "field": {
            "name": "locale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a MessageFormat for the specified locale and pattern. The constructor first sets the locale, then parses the pattern and creates a list of subformats for the format elements contained in it. Patterns and their interpretation are specified in the class description.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern for this message format",
          "\u003ccode\u003elocale\u003c/code\u003e - the locale for this message format"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the pattern is invalid",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epattern\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "since": [
          "1.4"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.text.MessageFormat$Field"
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.text.MessageFormat",
  "comment": "\u003ccode\u003eMessageFormat\u003c/code\u003e provides a means to produce concatenated messages in a language-neutral way. Use this to construct messages displayed for end users. \n\u003cp\u003e \u003ccode\u003eMessageFormat\u003c/code\u003e takes a set of objects, formats them, then inserts the formatted strings into the pattern at the appropriate places. \u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e \u003ccode\u003eMessageFormat\u003c/code\u003e differs from the other \u003ccode\u003eFormat\u003c/code\u003e classes in that you create a \u003ccode\u003eMessageFormat\u003c/code\u003e object with one of its constructors (not with a \u003ccode\u003egetInstance\u003c/code\u003e style factory method). The factory methods aren\u0027t necessary because \u003ccode\u003eMessageFormat\u003c/code\u003e itself doesn\u0027t implement locale specific behavior. Any locale specific behavior is defined by the pattern that you provide as well as the subformats used for inserted arguments. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"patterns\"\u003ePatterns and Their Interpretation\u003c/a\u003e\u003c/h2\u003e \n\u003ccode\u003eMessageFormat\u003c/code\u003e uses patterns of the following form: \n\u003cblockquote\u003e\n \u003cpre\u003e \u003ci\u003eMessageFormatPattern:\u003c/i\u003e\n         \u003ci\u003eString\u003c/i\u003e\n         \u003ci\u003eMessageFormatPattern\u003c/i\u003e \u003ci\u003eFormatElement\u003c/i\u003e \u003ci\u003eString\u003c/i\u003e\n\n \u003ci\u003eFormatElement:\u003c/i\u003e\n         { \u003ci\u003eArgumentIndex\u003c/i\u003e }\n         { \u003ci\u003eArgumentIndex\u003c/i\u003e , \u003ci\u003eFormatType\u003c/i\u003e }\n         { \u003ci\u003eArgumentIndex\u003c/i\u003e , \u003ci\u003eFormatType\u003c/i\u003e , \u003ci\u003eFormatStyle\u003c/i\u003e }\n\n \u003ci\u003eFormatType: one of \u003c/i\u003e\n         number date time choice\n\n \u003ci\u003eFormatStyle:\u003c/i\u003e\n         short\n         medium\n         long\n         full\n         integer\n         currency\n         percent\n         \u003ci\u003eSubformatPattern\u003c/i\u003e\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003eWithin a \u003ci\u003eString\u003c/i\u003e, a pair of single quotes can be used to quote any arbitrary characters except single quotes. For example, pattern string \u003ccode\u003e\"\u0027{0}\u0027\"\u003c/code\u003e represents string \u003ccode\u003e\"{0}\"\u003c/code\u003e, not a \u003ci\u003eFormatElement\u003c/i\u003e. A single quote itself must be represented by doubled single quotes \u003ccode\u003e\u0027\u0027\u003c/code\u003e throughout a \u003ci\u003eString\u003c/i\u003e. For example, pattern string \u003ccode\u003e\"\u0027{\u0027\u0027}\u0027\"\u003c/code\u003e is interpreted as a sequence of \u003ccode\u003e\u0027{\u003c/code\u003e (start of quoting and a left curly brace), \u003ccode\u003e\u0027\u0027\u003c/code\u003e (a single quote), and \u003ccode\u003e}\u0027\u003c/code\u003e (a right curly brace and end of quoting), \u003cem\u003enot\u003c/em\u003e \u003ccode\u003e\u0027{\u0027\u003c/code\u003e and \u003ccode\u003e\u0027}\u0027\u003c/code\u003e (quoted left and right curly braces): representing string \u003ccode\u003e\"{\u0027}\"\u003c/code\u003e, \u003cem\u003enot\u003c/em\u003e \u003ccode\u003e\"{}\"\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003eA \u003ci\u003eSubformatPattern\u003c/i\u003e is interpreted by its corresponding subformat, and subformat-dependent pattern rules apply. For example, pattern string \u003ccode\u003e\"{1,number,\u003cu\u003e$\u0027#\u0027,##\u003c/u\u003e}\"\u003c/code\u003e (\u003ci\u003eSubformatPattern\u003c/i\u003e with underline) will produce a number format with the pound-sign quoted, with a result such as: \u003ccode\u003e \"$#31,45\"\u003c/code\u003e. Refer to each \u003ccode\u003eFormat\u003c/code\u003e subclass documentation for details. \u003c/p\u003e\n\u003cp\u003eAny unmatched quote is treated as closed at the end of the given pattern. For example, pattern string \u003ccode\u003e\"\u0027{0}\"\u003c/code\u003e is treated as pattern \u003ccode\u003e\"\u0027{0}\u0027\"\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003eAny curly braces within an unquoted pattern must be balanced. For example, \u003ccode\u003e\"ab {0} de\"\u003c/code\u003e and \u003ccode\u003e\"ab \u0027}\u0027 de\"\u003c/code\u003e are valid patterns, but \u003ccode\u003e\"ab {0\u0027}\u0027 de\"\u003c/code\u003e, \u003ccode\u003e\"ab } de\"\u003c/code\u003e and \u003ccode\u003e\"\u0027\u0027{\u0027\u0027\"\u003c/code\u003e are not. \u003c/p\u003e\n\u003cdl\u003e\n \u003cdt\u003e\n  \u003cb\u003eWarning:\u003c/b\u003e\n \u003c/dt\u003e\n \u003cdd\u003e\n  The rules for using quotes within message format patterns unfortunately have shown to be somewhat confusing. In particular, it isn\u0027t always obvious to localizers whether single quotes need to be doubled or not. Make sure to inform localizers about the rules, and tell them (for example, by using comments in resource bundle source files) which strings will be processed by \n  \u003ccode\u003eMessageFormat\u003c/code\u003e. Note that localizers may need to use single quotes in translated strings where the original version doesn\u0027t have them. \n \u003c/dd\u003e\n\u003c/dl\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The \u003ci\u003eArgumentIndex\u003c/i\u003e value is a non-negative integer written using the digits \u003ccode\u003e\u00270\u0027\u003c/code\u003e through \u003ccode\u003e\u00279\u0027\u003c/code\u003e, and represents an index into the \u003ccode\u003earguments\u003c/code\u003e array passed to the \u003ccode\u003eformat\u003c/code\u003e methods or the result array returned by the \u003ccode\u003eparse\u003c/code\u003e methods. \u003c/p\u003e\n\u003cp\u003e The \u003ci\u003eFormatType\u003c/i\u003e and \u003ci\u003eFormatStyle\u003c/i\u003e values are used to create a \u003ccode\u003eFormat\u003c/code\u003e instance for the format element. The following table shows how the values map to \u003ccode\u003eFormat\u003c/code\u003e instances. Combinations not shown in the table are illegal. A \u003ci\u003eSubformatPattern\u003c/i\u003e must be a valid pattern string for the \u003ccode\u003eFormat\u003c/code\u003e subclass used. \u003c/p\u003e\n\u003ctable class\u003d\"plain\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n  Shows how FormatType and FormatStyle values map to Format instances\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\" class\u003d\"TableHeadingColor\"\u003eFormatType \u003c/th\u003e\n   \u003cth scope\u003d\"col\" class\u003d\"TableHeadingColor\"\u003eFormatStyle \u003c/th\u003e\n   \u003cth scope\u003d\"col\" class\u003d\"TableHeadingColor\"\u003eSubformat Created \u003c/th\u003e\n  \u003c/tr\u003e\n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003e(none)\u003c/i\u003e \u003c/th\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003e(none)\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\" rowspan\u003d\"5\"\u003e\u003ccode\u003enumber\u003c/code\u003e \u003c/th\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003e(none)\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"NumberFormat.html#getInstance(java.util.Locale)\"\u003e\u003ccode\u003eNumberFormat.getInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003einteger\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"NumberFormat.html#getIntegerInstance(java.util.Locale)\"\u003e\u003ccode\u003eNumberFormat.getIntegerInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003ecurrency\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"NumberFormat.html#getCurrencyInstance(java.util.Locale)\"\u003e\u003ccode\u003eNumberFormat.getCurrencyInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003epercent\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"NumberFormat.html#getPercentInstance(java.util.Locale)\"\u003e\u003ccode\u003eNumberFormat.getPercentInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003enew\u003c/code\u003e \u003ca href\u003d\"DecimalFormat.html#%3Cinit%3E(java.lang.String,java.text.DecimalFormatSymbols)\"\u003e\u003ccode\u003eDecimalFormat\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(subformatPattern,\u003c/code\u003e \u003ca href\u003d\"DecimalFormatSymbols.html#getInstance(java.util.Locale)\"\u003e\u003ccode\u003eDecimalFormatSymbols.getInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(getLocale()))\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\" rowspan\u003d\"6\"\u003e\u003ccode\u003edate\u003c/code\u003e \u003c/th\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003e(none)\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getDateInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getDateInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#DEFAULT\"\u003e\u003ccode\u003eDateFormat.DEFAULT\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003eshort\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getDateInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getDateInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#SHORT\"\u003e\u003ccode\u003eDateFormat.SHORT\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003emedium\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getDateInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getDateInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#DEFAULT\"\u003e\u003ccode\u003eDateFormat.DEFAULT\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003elong\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getDateInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getDateInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#LONG\"\u003e\u003ccode\u003eDateFormat.LONG\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003efull\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getDateInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getDateInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#FULL\"\u003e\u003ccode\u003eDateFormat.FULL\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003enew\u003c/code\u003e \u003ca href\u003d\"SimpleDateFormat.html#%3Cinit%3E(java.lang.String,java.util.Locale)\"\u003e\u003ccode\u003eSimpleDateFormat\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(subformatPattern, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\" rowspan\u003d\"6\"\u003e\u003ccode\u003etime\u003c/code\u003e \u003c/th\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003e(none)\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getTimeInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getTimeInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#DEFAULT\"\u003e\u003ccode\u003eDateFormat.DEFAULT\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003eshort\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getTimeInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getTimeInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#SHORT\"\u003e\u003ccode\u003eDateFormat.SHORT\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003emedium\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getTimeInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getTimeInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#DEFAULT\"\u003e\u003ccode\u003eDateFormat.DEFAULT\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003elong\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getTimeInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getTimeInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#LONG\"\u003e\u003ccode\u003eDateFormat.LONG\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003efull\u003c/code\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ca href\u003d\"DateFormat.html#getTimeInstance(int,java.util.Locale)\"\u003e\u003ccode\u003eDateFormat.getTimeInstance\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(\u003c/code\u003e\u003ca href\u003d\"DateFormat.html#FULL\"\u003e\u003ccode\u003eDateFormat.FULL\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003enew\u003c/code\u003e \u003ca href\u003d\"SimpleDateFormat.html#%3Cinit%3E(java.lang.String,java.util.Locale)\"\u003e\u003ccode\u003eSimpleDateFormat\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(subformatPattern, getLocale())\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ccode\u003echoice\u003c/code\u003e \u003c/th\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"text-weight: normal\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e \u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003enew\u003c/code\u003e \u003ca href\u003d\"ChoiceFormat.html#%3Cinit%3E(java.lang.String)\"\u003e\u003ccode\u003eChoiceFormat\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(subformatPattern)\u003c/code\u003e \u003c/td\u003e\n  \u003c/tr\u003e\n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch3\u003eUsage Information\u003c/h3\u003e \n\u003cp\u003e Here are some examples of usage. In real internationalized programs, the message format pattern and other static strings will, of course, be obtained from resource bundles. Other parameters will be dynamically determined at runtime. \u003c/p\u003e\n\u003cp\u003e The first example uses the static method \u003ccode\u003eMessageFormat.format\u003c/code\u003e, which internally creates a \u003ccode\u003eMessageFormat\u003c/code\u003e for one-time use: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e int planet \u003d 7;\n String event \u003d \"a disturbance in the Force\";\n\n String result \u003d MessageFormat.format(\n     \"At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.\",\n     planet, new Date(), event);\n \u003c/pre\u003e\n\u003c/blockquote\u003e The output is: \n\u003cblockquote\u003e\n \u003cpre\u003e At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The following example creates a \u003ccode\u003eMessageFormat\u003c/code\u003e instance that can be used repeatedly: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e int fileCount \u003d 1273;\n String diskName \u003d \"MyDisk\";\n Object[] testArgs \u003d {new Long(fileCount), diskName};\n\n MessageFormat form \u003d new MessageFormat(\n     \"The disk \\\"{1}\\\" contains {0} file(s).\");\n\n System.out.println(form.format(testArgs));\n \u003c/pre\u003e\n\u003c/blockquote\u003e The output with different values for \n\u003ccode\u003efileCount\u003c/code\u003e: \n\u003cblockquote\u003e\n \u003cpre\u003e The disk \"MyDisk\" contains 0 file(s).\n The disk \"MyDisk\" contains 1 file(s).\n The disk \"MyDisk\" contains 1,273 file(s).\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e For more sophisticated patterns, you can use a \u003ccode\u003eChoiceFormat\u003c/code\u003e to produce correct forms for singular and plural: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e MessageFormat form \u003d new MessageFormat(\"The disk \\\"{1}\\\" contains {0}.\");\n double[] filelimits \u003d {0,1,2};\n String[] filepart \u003d {\"no files\",\"one file\",\"{0,number} files\"};\n ChoiceFormat fileform \u003d new ChoiceFormat(filelimits, filepart);\n form.setFormatByArgumentIndex(0, fileform);\n\n int fileCount \u003d 1273;\n String diskName \u003d \"MyDisk\";\n Object[] testArgs \u003d {new Long(fileCount), diskName};\n\n System.out.println(form.format(testArgs));\n \u003c/pre\u003e\n\u003c/blockquote\u003e The output with different values for \n\u003ccode\u003efileCount\u003c/code\u003e: \n\u003cblockquote\u003e\n \u003cpre\u003e The disk \"MyDisk\" contains no files.\n The disk \"MyDisk\" contains one file.\n The disk \"MyDisk\" contains 1,273 files.\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e You can create the \u003ccode\u003eChoiceFormat\u003c/code\u003e programmatically, as in the above example, or by using a pattern. See \u003ca href\u003d\"ChoiceFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eChoiceFormat\u003c/code\u003e\u003c/a\u003e for more information. \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n form.applyPattern(\n    \"There {0,choice,0#are no files|1#is one file|1\u0026lt;are {0,number,integer} files}.\");\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003cstrong\u003eNote:\u003c/strong\u003e As we see above, the string produced by a \u003ccode\u003eChoiceFormat\u003c/code\u003e in \u003ccode\u003eMessageFormat\u003c/code\u003e is treated as special; occurrences of \u0027{\u0027 are used to indicate subformats, and cause recursion. If you create both a \u003ccode\u003eMessageFormat\u003c/code\u003e and \u003ccode\u003eChoiceFormat\u003c/code\u003e programmatically (instead of using the string patterns), then be careful not to produce a format that recurses on itself, which will cause an infinite loop. \u003c/p\u003e\n\u003cp\u003e When a single argument is parsed more than once in the string, the last match will be the final result of the parsing. For example, \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e MessageFormat mf \u003d new MessageFormat(\"{0,number,#.##}, {0,number,#.#}\");\n Object[] objs \u003d {new Double(3.1415)};\n String result \u003d mf.format( objs );\n // result now equals \"3.14, 3.1\"\n objs \u003d null;\n objs \u003d mf.parse(result, new ParsePosition(0));\n // objs now equals {new Double(3.1)}\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Likewise, parsing with a \u003ccode\u003eMessageFormat\u003c/code\u003e object using patterns containing multiple occurrences of the same argument would return the last match. For example, \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e MessageFormat mf \u003d new MessageFormat(\"{0}, {0}, {0}\");\n String forParsing \u003d \"x, y, z\";\n Object[] objs \u003d mf.parse(forParsing, new ParsePosition(0));\n // result now equals {new String(\"z\")}\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch3\u003e\u003ca id\u003d\"synchronization\"\u003eSynchronization\u003c/a\u003e\u003c/h3\u003e \n\u003cp\u003e Message formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Locale.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eLocale\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/Format.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/NumberFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eNumberFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/DecimalFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eDecimalFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/DecimalFormatSymbols.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/ChoiceFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eChoiceFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/DateFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eDateFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/text/SimpleDateFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eSimpleDateFormat\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#java.text.MessageFormat\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "since": [
      "1.1"
    ]
  }
}