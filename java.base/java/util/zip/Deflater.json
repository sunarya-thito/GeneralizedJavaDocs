{
  "packageName": "java.util.zip",
  "simpleName": "Deflater",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "DEFLATED",
      "comment": "Compression method for the deflate algorithm (the only one currently supported).",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.DEFLATED\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "NO_COMPRESSION",
      "comment": "Compression level for no compression.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.NO_COMPRESSION\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "BEST_SPEED",
      "comment": "Compression level for fastest compression.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.BEST_SPEED\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "BEST_COMPRESSION",
      "comment": "Compression level for best compression.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.BEST_COMPRESSION\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "DEFAULT_COMPRESSION",
      "comment": "Default compression level.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.DEFAULT_COMPRESSION\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "FILTERED",
      "comment": "Compression strategy best used for data consisting mostly of small values with a somewhat random distribution. Forces more Huffman coding and less string matching.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.FILTERED\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "HUFFMAN_ONLY",
      "comment": "Compression strategy for Huffman coding only.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.HUFFMAN_ONLY\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "DEFAULT_STRATEGY",
      "comment": "Default compression strategy.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.DEFAULT_STRATEGY\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "NO_FLUSH",
      "comment": "Compression flush mode used to achieve best compression result.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Deflater.html#deflate(byte%5B%5D,int,int,int)\"\u003e\u003ccode\u003edeflate(byte[], int, int, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.NO_FLUSH\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "SYNC_FLUSH",
      "comment": "Compression flush mode used to flush out all pending output; may degrade compression for some compression algorithms.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Deflater.html#deflate(byte%5B%5D,int,int,int)\"\u003e\u003ccode\u003edeflate(byte[], int, int, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.SYNC_FLUSH\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "FULL_FLUSH",
      "comment": "Compression flush mode used to flush out all pending output and reset the deflater. Using this mode too often can seriously degrade compression.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Deflater.html#deflate(byte%5B%5D,int,int,int)\"\u003e\u003ccode\u003edeflate(byte[], int, int, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.util.zip.Deflater.FULL_FLUSH\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "input",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "off",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "len",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setInput",
      "comment": "Sets input data for compression. One of the setInput() methods should be called whenever needsInput() returns true indicating that more input data is required.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Deflater.html#needsInput()\"\u003e\u003ccode\u003eneedsInput()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input data bytes",
          "\u003ccode\u003eoff\u003c/code\u003e - the start offset of the data",
          "\u003ccode\u003elen\u003c/code\u003e - the length of the data"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "input",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setInput",
      "comment": "Sets input data for compression. One of the setInput() methods should be called whenever needsInput() returns true indicating that more input data is required.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Deflater.html#needsInput()\"\u003e\u003ccode\u003eneedsInput()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input data bytes"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "input",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setInput",
      "comment": "Sets input data for compression. One of the setInput() methods should be called whenever needsInput() returns true indicating that more input data is required. The given buffer\u0027s position will be advanced as deflate operations are performed, up to the buffer\u0027s limit. The input buffer may be modified (refilled) between deflate operations; doing so is equivalent to creating a new buffer and setting it with this method. Modifying the input buffer\u0027s contents, position, or limit concurrently with an deflate operation will result in undefined behavior, which may include incorrect operation results or operation failure.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Deflater.html#needsInput()\"\u003e\u003ccode\u003eneedsInput()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input data bytes"
        ],
        "since": [
          "11"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dictionary",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "off",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "len",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setDictionary",
      "comment": "Sets preset dictionary for compression. A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Inflater.html#inflate(byte%5B%5D,int,int)\"\u003e\u003ccode\u003eInflater.inflate(byte[], int, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Inflater.html#getAdler()\"\u003e\u003ccode\u003eInflater.getAdler()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003edictionary\u003c/code\u003e - the dictionary data bytes",
          "\u003ccode\u003eoff\u003c/code\u003e - the start offset of the data",
          "\u003ccode\u003elen\u003c/code\u003e - the length of the data"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dictionary",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setDictionary",
      "comment": "Sets preset dictionary for compression. A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Inflater.html#inflate(byte%5B%5D,int,int)\"\u003e\u003ccode\u003eInflater.inflate(byte[], int, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Inflater.html#getAdler()\"\u003e\u003ccode\u003eInflater.getAdler()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003edictionary\u003c/code\u003e - the dictionary data bytes"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "dictionary",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setDictionary",
      "comment": "Sets preset dictionary for compression. A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression. The bytes in given byte buffer will be fully consumed by this method. On return, its position will equal its limit.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Inflater.html#inflate(byte%5B%5D,int,int)\"\u003e\u003ccode\u003eInflater.inflate(byte[], int, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Inflater.html#getAdler()\"\u003e\u003ccode\u003eInflater.getAdler()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003edictionary\u003c/code\u003e - the dictionary data bytes"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "strategy",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setStrategy",
      "comment": "Sets the compression strategy to the specified value. If the compression strategy is changed, the next invocation of deflate will compress the input available so far with the old strategy (and may be flushed); the new strategy will take effect only after that invocation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003estrategy\u003c/code\u003e - the new compression strategy"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the compression strategy is invalid"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "level",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setLevel",
      "comment": "Sets the compression level to the specified value. If the compression level is changed, the next invocation of deflate will compress the input available so far with the old level (and may be flushed); the new level will take effect only after that invocation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003elevel\u003c/code\u003e - the new compression level (0-9)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the compression level is invalid"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "needsInput",
      "comment": "Returns true if no data remains in the input buffer. This can be used to determine if one of the setInput() methods should be called in order to provide more input.",
      "annotations": [],
      "tagMap": {
        "return": [
          "true if the input data buffer is empty and setInput() should be called in order to provide more input"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "finish",
      "comment": "When called, indicates that compression should end with the current contents of the input buffer.",
      "annotations": [],
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "finished",
      "comment": "Returns true if the end of the compressed data output stream has been reached.",
      "annotations": [],
      "tagMap": {
        "return": [
          "true if the end of the compressed data output stream has been reached"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "output",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "off",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "len",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deflate",
      "comment": "Compresses the input data and fills specified buffer with compressed data. Returns actual number of bytes of compressed data. A return value of 0 indicates that needsInput should be called in order to determine if more input data is required. This method uses NO_FLUSH as its compression flush mode. An invocation of this method of the form deflater.deflate(b, off, len) yields the same result as the invocation of deflater.deflate(b, off, len, Deflater.NO_FLUSH).",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the compressed data",
          "\u003ccode\u003eoff\u003c/code\u003e - the start offset of the data",
          "\u003ccode\u003elen\u003c/code\u003e - the maximum number of bytes of compressed data"
        ],
        "return": [
          "the actual number of bytes of compressed data written to the output buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "output",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deflate",
      "comment": "Compresses the input data and fills specified buffer with compressed data. Returns actual number of bytes of compressed data. A return value of 0 indicates that needsInput should be called in order to determine if more input data is required. This method uses NO_FLUSH as its compression flush mode. An invocation of this method of the form deflater.deflate(b) yields the same result as the invocation of deflater.deflate(b, 0, b.length, Deflater.NO_FLUSH).",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the compressed data"
        ],
        "return": [
          "the actual number of bytes of compressed data written to the output buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "output",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deflate",
      "comment": "Compresses the input data and fills specified buffer with compressed data. Returns actual number of bytes of compressed data. A return value of 0 indicates that needsInput should be called in order to determine if more input data is required. This method uses NO_FLUSH as its compression flush mode. An invocation of this method of the form deflater.deflate(output) yields the same result as the invocation of deflater.deflate(output, Deflater.NO_FLUSH).",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the compressed data"
        ],
        "return": [
          "the actual number of bytes of compressed data written to the output buffer"
        ],
        "since": [
          "11"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "output",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "off",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "len",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "flush",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deflate",
      "comment": "Compresses the input data and fills the specified buffer with compressed data. Returns actual number of bytes of data compressed. Compression flush mode is one of the following three modes: NO_FLUSH: allows the deflater to decide how much data to accumulate, before producing output, in order to achieve the best compression (should be used in normal use scenario). A return value of 0 in this flush mode indicates that needsInput() should be called in order to determine if more input data is required. SYNC_FLUSH: all pending output in the deflater is flushed, to the specified output buffer, so that an inflater that works on compressed data can get all input data available so far (In particular the needsInput() returns true after this invocation if enough output space is provided). Flushing with SYNC_FLUSH may degrade compression for some compression algorithms and so it should be used only when necessary. FULL_FLUSH: all pending output is flushed out as with SYNC_FLUSH. The compression state is reset so that the inflater that works on the compressed output data can restart from this point if previous compressed data has been damaged or if random access is desired. Using FULL_FLUSH too often can seriously degrade compression. In the case of FULL_FLUSH or SYNC_FLUSH, if the return value is len, the space available in output buffer b, this method should be invoked again with the same flush parameter and more output space. Make sure that len is greater than 6 to avoid flush marker (5 bytes) being repeatedly output to the output buffer every time this method is invoked. If the setInput(ByteBuffer) method was called to provide a buffer for input, the input buffer\u0027s position will be advanced by the number of bytes consumed by this operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the compressed data",
          "\u003ccode\u003eoff\u003c/code\u003e - the start offset of the data",
          "\u003ccode\u003elen\u003c/code\u003e - the maximum number of bytes of compressed data",
          "\u003ccode\u003eflush\u003c/code\u003e - the compression flush mode"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the flush mode is invalid"
        ],
        "return": [
          "the actual number of bytes of compressed data written to the output buffer"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "output",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "flush",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "deflate",
      "comment": "Compresses the input data and fills the specified buffer with compressed data. Returns actual number of bytes of data compressed. Compression flush mode is one of the following three modes: NO_FLUSH: allows the deflater to decide how much data to accumulate, before producing output, in order to achieve the best compression (should be used in normal use scenario). A return value of 0 in this flush mode indicates that needsInput() should be called in order to determine if more input data is required. SYNC_FLUSH: all pending output in the deflater is flushed, to the specified output buffer, so that an inflater that works on compressed data can get all input data available so far (In particular the needsInput() returns true after this invocation if enough output space is provided). Flushing with SYNC_FLUSH may degrade compression for some compression algorithms and so it should be used only when necessary. FULL_FLUSH: all pending output is flushed out as with SYNC_FLUSH. The compression state is reset so that the inflater that works on the compressed output data can restart from this point if previous compressed data has been damaged or if random access is desired. Using FULL_FLUSH too often can seriously degrade compression. In the case of FULL_FLUSH or SYNC_FLUSH, if the return value is equal to the remaining space of the buffer, this method should be invoked again with the same flush parameter and more output space. Make sure that the buffer has at least 6 bytes of remaining space to avoid the flush marker (5 bytes) being repeatedly output to the output buffer every time this method is invoked. On success, the position of the given output byte buffer will be advanced by as many bytes as were produced by the operation, which is equal to the number returned by this method. If the setInput(ByteBuffer) method was called to provide a buffer for input, the input buffer\u0027s position will be advanced by the number of bytes consumed by this operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the compressed data",
          "\u003ccode\u003eflush\u003c/code\u003e - the compression flush mode"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the flush mode is invalid"
        ],
        "return": [
          "the actual number of bytes of compressed data written to the output buffer"
        ],
        "since": [
          "11"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getAdler",
      "comment": "Returns the ADLER-32 value of the uncompressed data.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the ADLER-32 value of the uncompressed data"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getTotalIn",
      "comment": "Returns the total number of uncompressed bytes input so far. Since the number of bytes may be greater than Integer.MAX_VALUE, the getBytesRead() method is now the preferred means of obtaining this information.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the total number of uncompressed bytes input so far"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getBytesRead",
      "comment": "Returns the total number of uncompressed bytes input so far.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the total (non-negative) number of uncompressed bytes input so far"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getTotalOut",
      "comment": "Returns the total number of compressed bytes output so far. Since the number of bytes may be greater than Integer.MAX_VALUE, the getBytesWritten() method is now the preferred means of obtaining this information.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the total number of compressed bytes output so far"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getBytesWritten",
      "comment": "Returns the total number of compressed bytes output so far.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the total (non-negative) number of compressed bytes output so far"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "reset",
      "comment": "Resets deflater so that a new set of input data can be processed. Keeps current compression level and strategy settings.",
      "annotations": [],
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "end",
      "comment": "Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used. Once this method is called, the behavior of the Deflater object is undefined.",
      "annotations": [],
      "tagMap": {}
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "level",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "name": "nowrap",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new compressor using the specified compression level. If \u0027nowrap\u0027 is true then the ZLIB header and checksum fields will not be used in order to support the compression format used in both GZIP and PKZIP.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003elevel\u003c/code\u003e - the compression level (0-9)",
          "\u003ccode\u003enowrap\u003c/code\u003e - if true then use GZIP compatible compression"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "level",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new compressor using the specified compression level. Compressed data will be generated in ZLIB format.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003elevel\u003c/code\u003e - the compression level (0-9)"
        ]
      }
    },
    {
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new compressor with the default compression level. Compressed data will be generated in ZLIB format.",
      "annotations": [],
      "tagMap": {}
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.util.zip.Deflater",
  "comment": "This class provides support for general purpose compression using the popular ZLIB compression library. The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents. It is fully described in the specifications at the \n\u003ca href\u003d\"package-summary.html#package.description\"\u003ejava.util.zip package description\u003c/a\u003e. \n\u003cp\u003e This class deflates sequences of bytes into ZLIB compressed data format. The input byte sequence is provided in either byte array or byte buffer, via one of the \u003ccode\u003esetInput()\u003c/code\u003e methods. The output byte sequence is written to the output byte array or byte buffer passed to the \u003ccode\u003edeflate()\u003c/code\u003e methods. \u003c/p\u003e\n\u003cp\u003e The following code fragment demonstrates a trivial compression and decompression of a string using \u003ccode\u003eDeflater\u003c/code\u003e and \u003ccode\u003eInflater\u003c/code\u003e. \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e try {\n     // Encode a String into bytes\n     String inputString \u003d \"blahblahblah\";\n     byte[] input \u003d inputString.getBytes(\"UTF-8\");\n\n     // Compress the bytes\n     byte[] output \u003d new byte[100];\n     Deflater compresser \u003d new Deflater();\n     compresser.setInput(input);\n     compresser.finish();\n     int compressedDataLength \u003d compresser.deflate(output);\n     compresser.end();\n\n     // Decompress the bytes\n     Inflater decompresser \u003d new Inflater();\n     decompresser.setInput(output, 0, compressedDataLength);\n     byte[] result \u003d new byte[100];\n     int resultLength \u003d decompresser.inflate(result);\n     decompresser.end();\n\n     // Decode the bytes into a String\n     String outputString \u003d new String(result, 0, resultLength, \"UTF-8\");\n } catch (java.io.UnsupportedEncodingException ex) {\n     // handle\n } catch (java.util.zip.DataFormatException ex) {\n     // handle\n }\n \u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Inflater.html\" title\u003d\"class in java.util.zip\"\u003e\u003ccode\u003eInflater\u003c/code\u003e\u003c/a\u003e"
    ],
    "apiNote": [
      "To release resources used by this \n\u003ccode\u003eDeflater\u003c/code\u003e, the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/zip/Deflater.html#end()\"\u003e\u003ccode\u003eend()\u003c/code\u003e\u003c/a\u003e method should be called explicitly. Subclasses are responsible for the cleanup of resources acquired by the subclass. Subclasses that override \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#finalize()\"\u003e\u003ccode\u003eObject.finalize()\u003c/code\u003e\u003c/a\u003e in order to perform cleanup should be modified to use alternative cleanup mechanisms such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ref/Cleaner.html\" title\u003d\"class in java.lang.ref\"\u003e\u003ccode\u003eCleaner\u003c/code\u003e\u003c/a\u003e and remove the overriding \n\u003ccode\u003efinalize\u003c/code\u003e method."
    ],
    "since": [
      "1.1"
    ]
  }
}