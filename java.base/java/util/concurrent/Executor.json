{
  "packageName": "java.util.concurrent",
  "simpleName": "Executor",
  "moduleName": "java.base",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Runnable",
            "type": "Class"
          },
          "field": {
            "name": "command"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "execute",
      "comment": "Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ecommand\u003c/code\u003e - the runnable task"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/RejectedExecutionException.html\" title\u003d\"class in java.util.concurrent\"\u003eRejectedExecutionException\u003c/a\u003e\u003c/code\u003e - if this task cannot be accepted for execution",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if command is null"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "java.util.concurrent.Executor",
  "comment": "An object that executes submitted \n\u003ca href\u003d\"../../lang/Runnable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eRunnable\u003c/code\u003e\u003c/a\u003e tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An \n\u003ccode\u003eExecutor\u003c/code\u003e is normally used instead of explicitly creating threads. For example, rather than invoking \n\u003ccode\u003enew Thread(new RunnableTask()).start()\u003c/code\u003e for each of a set of tasks, you might use: \n\u003cpre\u003e \u003ccode\u003e\n Executor executor \u003d anExecutor();\n executor.execute(new RunnableTask1());\n executor.execute(new RunnableTask2());\n ...\u003c/code\u003e\u003c/pre\u003e However, the \n\u003ccode\u003eExecutor\u003c/code\u003e interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller\u0027s thread: \n\u003cpre\u003e \u003ccode\u003e\n class DirectExecutor implements Executor {\n   public void execute(Runnable r) {\n     r.run();\n   }\n }\u003c/code\u003e\u003c/pre\u003e More typically, tasks are executed in some thread other than the caller\u0027s thread. The executor below spawns a new thread for each task. \n\u003cpre\u003e \u003ccode\u003e\n class ThreadPerTaskExecutor implements Executor {\n   public void execute(Runnable r) {\n     new Thread(r).start();\n   }\n }\u003c/code\u003e\u003c/pre\u003e Many \n\u003ccode\u003eExecutor\u003c/code\u003e implementations impose some sort of limitation on how and when tasks are scheduled. The executor below serializes the submission of tasks to a second executor, illustrating a composite executor. \n\u003cpre\u003e \u003ccode\u003e\n class SerialExecutor implements Executor {\n   final Queue\u0026lt;Runnable\u0026gt; tasks \u003d new ArrayDeque\u0026lt;\u0026gt;();\n   final Executor executor;\n   Runnable active;\n\n   SerialExecutor(Executor executor) {\n     this.executor \u003d executor;\n   }\n\n   public synchronized void execute(Runnable r) {\n     tasks.add(() -\u0026gt; {\n       try {\n         r.run();\n       } finally {\n         scheduleNext();\n       }\n     });\n     if (active \u003d\u003d null) {\n       scheduleNext();\n     }\n   }\n\n   protected synchronized void scheduleNext() {\n     if ((active \u003d tasks.poll()) !\u003d null) {\n       executor.execute(active);\n     }\n   }\n }\u003c/code\u003e\u003c/pre\u003e The \n\u003ccode\u003eExecutor\u003c/code\u003e implementations provided in this package implement \n\u003ca href\u003d\"ExecutorService.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eExecutorService\u003c/code\u003e\u003c/a\u003e, which is a more extensive interface. The \n\u003ca href\u003d\"ThreadPoolExecutor.html\" title\u003d\"class in java.util.concurrent\"\u003e\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e\u003c/a\u003e class provides an extensible thread pool implementation. The \n\u003ca href\u003d\"Executors.html\" title\u003d\"class in java.util.concurrent\"\u003e\u003ccode\u003eExecutors\u003c/code\u003e\u003c/a\u003e class provides convenient factory methods for these Executors. \n\u003cp\u003eMemory consistency effects: Actions in a thread prior to submitting a \u003ccode\u003eRunnable\u003c/code\u003e object to an \u003ccode\u003eExecutor\u003c/code\u003e \u003ca href\u003d\"package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappen-before\u003c/i\u003e\u003c/a\u003e its execution begins, perhaps in another thread.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.5"
    ]
  }
}