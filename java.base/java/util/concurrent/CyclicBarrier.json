{
  "packageName": "java.util.concurrent",
  "simpleName": "CyclicBarrier",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getParties",
      "comment": "Returns the number of parties required to trip this barrier.",
      "tagMap": {
        "return": [
          "the number of parties required to trip this barrier"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.InterruptedException",
          "type": "Class"
        },
        {
          "name": "java.util.concurrent.BrokenBarrierException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "await",
      "comment": "Waits until all parties have invoked await on this barrier. If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens: The last thread arrives; or Some other thread interrupts the current thread; or Some other thread interrupts one of the other waiting threads; or Some other thread times out while waiting for barrier; or Some other thread invokes reset() on this barrier. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting then InterruptedException is thrown and the current thread\u0027s interrupted status is cleared. If the barrier is reset() while any thread is waiting, or if the barrier is broken when await is invoked, or while any thread is waiting, then BrokenBarrierException is thrown. If any thread is interrupted while waiting, then all other waiting threads will throw BrokenBarrierException and the barrier is placed in the broken state. If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/InterruptedException.html\" title\u003d\"class in java.lang\"\u003eInterruptedException\u003c/a\u003e\u003c/code\u003e - if the current thread was interrupted while waiting",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/BrokenBarrierException.html\" title\u003d\"class in java.util.concurrent\"\u003eBrokenBarrierException\u003c/a\u003e\u003c/code\u003e - if \n\u003cem\u003eanother\u003c/em\u003e thread was interrupted or timed out while the current thread was waiting, or the barrier was reset, or the barrier was broken when \n\u003ccode\u003eawait\u003c/code\u003e was called, or the barrier action (if present) failed due to an exception"
        ],
        "return": [
          "the arrival index of the current thread, where index \n\u003ccode\u003egetParties() - 1\u003c/code\u003e indicates the first to arrive and zero indicates the last to arrive"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.InterruptedException",
          "type": "Class"
        },
        {
          "name": "java.util.concurrent.BrokenBarrierException",
          "type": "Class"
        },
        {
          "name": "java.util.concurrent.TimeoutException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "timeout"
          }
        },
        {
          "type": {
            "name": "java.util.concurrent.TimeUnit",
            "type": "Class"
          },
          "field": {
            "name": "unit"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "await",
      "comment": "Waits until all parties have invoked await on this barrier, or the specified waiting time elapses. If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens: The last thread arrives; or The specified timeout elapses; or Some other thread interrupts the current thread; or Some other thread interrupts one of the other waiting threads; or Some other thread times out while waiting for barrier; or Some other thread invokes reset() on this barrier. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting then InterruptedException is thrown and the current thread\u0027s interrupted status is cleared. If the specified waiting time elapses then TimeoutException is thrown. If the time is less than or equal to zero, the method will not wait at all. If the barrier is reset() while any thread is waiting, or if the barrier is broken when await is invoked, or while any thread is waiting, then BrokenBarrierException is thrown. If any thread is interrupted while waiting, then all other waiting threads will throw BrokenBarrierException and the barrier is placed in the broken state. If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etimeout\u003c/code\u003e - the time to wait for the barrier",
          "\u003ccode\u003eunit\u003c/code\u003e - the time unit of the timeout parameter"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/InterruptedException.html\" title\u003d\"class in java.lang\"\u003eInterruptedException\u003c/a\u003e\u003c/code\u003e - if the current thread was interrupted while waiting",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/TimeoutException.html\" title\u003d\"class in java.util.concurrent\"\u003eTimeoutException\u003c/a\u003e\u003c/code\u003e - if the specified timeout elapses. In this case the barrier will be broken.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/BrokenBarrierException.html\" title\u003d\"class in java.util.concurrent\"\u003eBrokenBarrierException\u003c/a\u003e\u003c/code\u003e - if \n\u003cem\u003eanother\u003c/em\u003e thread was interrupted or timed out while the current thread was waiting, or the barrier was reset, or the barrier was broken when \n\u003ccode\u003eawait\u003c/code\u003e was called, or the barrier action (if present) failed due to an exception"
        ],
        "return": [
          "the arrival index of the current thread, where index \n\u003ccode\u003egetParties() - 1\u003c/code\u003e indicates the first to arrive and zero indicates the last to arrive"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isBroken",
      "comment": "Queries if this barrier is in a broken state.",
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if one or more parties broke out of this barrier due to interruption or timeout since construction or the last reset, or a barrier action failed due to an exception; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "reset",
      "comment": "Resets the barrier to its initial state. If any parties are currently waiting at the barrier, they will return with a BrokenBarrierException. Note that resets after a breakage has occurred for other reasons can be complicated to carry out; threads need to re-synchronize in some other way, and choose one to perform the reset. It may be preferable to instead create a new barrier for subsequent use.",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getNumberWaiting",
      "comment": "Returns the number of parties currently waiting at the barrier. This method is primarily useful for debugging and assertions.",
      "tagMap": {
        "return": [
          "the number of parties currently blocked in \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/CyclicBarrier.html#await()\"\u003e\u003ccode\u003eawait()\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "parties"
          }
        },
        {
          "type": {
            "name": "java.lang.Runnable",
            "type": "Class"
          },
          "field": {
            "name": "barrierAction"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new CyclicBarrier that will trip when the given number of parties (threads) are waiting upon it, and which will execute the given barrier action when the barrier is tripped, performed by the last thread entering the barrier.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eparties\u003c/code\u003e - the number of threads that must invoke \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/CyclicBarrier.html#await()\"\u003e\u003ccode\u003eawait()\u003c/code\u003e\u003c/a\u003e before the barrier is tripped",
          "\u003ccode\u003ebarrierAction\u003c/code\u003e - the command to execute when the barrier is tripped, or \n\u003ccode\u003enull\u003c/code\u003e if there is no action"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eparties\u003c/code\u003e is less than 1"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "parties"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new CyclicBarrier that will trip when the given number of parties (threads) are waiting upon it, and does not perform a predefined action when the barrier is tripped.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eparties\u003c/code\u003e - the number of threads that must invoke \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/CyclicBarrier.html#await()\"\u003e\u003ccode\u003eawait()\u003c/code\u003e\u003c/a\u003e before the barrier is tripped"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eparties\u003c/code\u003e is less than 1"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.util.concurrent.CyclicBarrier",
  "comment": "A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called \n\u003cem\u003ecyclic\u003c/em\u003e because it can be re-used after the waiting threads are released. \n\u003cp\u003eA \u003ccode\u003eCyclicBarrier\u003c/code\u003e supports an optional \u003ca href\u003d\"../../lang/Runnable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eRunnable\u003c/code\u003e\u003c/a\u003e command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This \u003cem\u003ebarrier action\u003c/em\u003e is useful for updating shared-state before any of the parties continue. \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eSample usage:\u003c/b\u003e Here is an example of using a barrier in a parallel decomposition design: \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n class Solver {\n   final int N;\n   final float[][] data;\n   final CyclicBarrier barrier;\n\n   class Worker implements Runnable {\n     int myRow;\n     Worker(int row) { myRow \u003d row; }\n     public void run() {\n       while (!done()) {\n         processRow(myRow);\n\n         try {\n           barrier.await();\n         } catch (InterruptedException ex) {\n           return;\n         } catch (BrokenBarrierException ex) {\n           return;\n         }\n       }\n     }\n   }\n\n   public Solver(float[][] matrix) {\n     data \u003d matrix;\n     N \u003d matrix.length;\n     Runnable barrierAction \u003d () -\u0026gt; mergeRows(...);\n     barrier \u003d new CyclicBarrier(N, barrierAction);\n\n     List\u0026lt;Thread\u0026gt; threads \u003d new ArrayList\u0026lt;\u0026gt;(N);\n     for (int i \u003d 0; i \u0026lt; N; i++) {\n       Thread thread \u003d new Thread(new Worker(i));\n       threads.add(thread);\n       thread.start();\n     }\n\n     // wait until done\n     for (Thread thread : threads)\n       thread.join();\n   }\n }\u003c/code\u003e\u003c/pre\u003e Here, each worker thread processes a row of the matrix, then waits at the barrier until all rows have been processed. When all rows are processed the supplied \n\u003ca href\u003d\"../../lang/Runnable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eRunnable\u003c/code\u003e\u003c/a\u003e barrier action is executed and merges the rows. If the merger determines that a solution has been found then \n\u003ccode\u003edone()\u003c/code\u003e will return \n\u003ccode\u003etrue\u003c/code\u003e and each worker will terminate. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eIf the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of \u003ca href\u003d\"#await()\"\u003e\u003ccode\u003eawait()\u003c/code\u003e\u003c/a\u003e returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example: \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n if (barrier.await() \u003d\u003d 0) {\n   // log the completion of this iteration\n }\u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eCyclicBarrier\u003c/code\u003e uses an all-or-none breakage model for failed synchronization attempts: If a thread leaves a barrier point prematurely because of interruption, failure, or timeout, all other threads waiting at that barrier point will also leave abnormally via \u003ca href\u003d\"BrokenBarrierException.html\" title\u003d\"class in java.util.concurrent\"\u003e\u003ccode\u003eBrokenBarrierException\u003c/code\u003e\u003c/a\u003e (or \u003ca href\u003d\"../../lang/InterruptedException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eInterruptedException\u003c/code\u003e\u003c/a\u003e if they too were interrupted at about the same time). \u003c/p\u003e\n\u003cp\u003eMemory consistency effects: Actions in a thread prior to calling \u003ccode\u003eawait()\u003c/code\u003e \u003ca href\u003d\"package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappen-before\u003c/i\u003e\u003c/a\u003e actions that are part of the barrier action, which in turn \u003ci\u003ehappen-before\u003c/i\u003e actions following a successful return from the corresponding \u003ccode\u003eawait()\u003c/code\u003e in other threads.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/CountDownLatch.html\" title\u003d\"class in java.util.concurrent\"\u003e\u003ccode\u003eCountDownLatch\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/Phaser.html\" title\u003d\"class in java.util.concurrent\"\u003e\u003ccode\u003ePhaser\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.5"
    ]
  }
}