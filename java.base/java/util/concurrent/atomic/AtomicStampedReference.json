{
  "packageName": "java.util.concurrent.atomic",
  "simpleName": "AtomicStampedReference",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "owner": "java.util.concurrent.atomic.AtomicStampedReference",
        "name": "V",
        "type": "Variable"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getReference",
      "comment": "Returns the current value of the reference.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the current value of the reference"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getStamp",
      "comment": "Returns the current value of the stamp.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the current value of the stamp"
        ]
      }
    },
    {
      "returnType": {
        "owner": "java.util.concurrent.atomic.AtomicStampedReference",
        "name": "V",
        "type": "Variable"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "stampHolder",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "get",
      "comment": "Returns the current values of both the reference and the stamp. Typical usage is int[1] holder; ref \u003d v.get(holder); .",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003estampHolder\u003c/code\u003e - an array of size of at least one. On return, \n\u003ccode\u003estampHolder[0]\u003c/code\u003e will hold the value of the stamp."
        ],
        "return": [
          "the current value of the reference"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "owner": "java.util.concurrent.atomic.AtomicStampedReference",
            "name": "V",
            "type": "Variable"
          },
          "name": "expectedReference",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "owner": "java.util.concurrent.atomic.AtomicStampedReference",
            "name": "V",
            "type": "Variable"
          },
          "name": "newReference",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "expectedStamp",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newStamp",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "weakCompareAndSet",
      "comment": "Atomically sets the value of both the reference and stamp to the given update values if the current reference is \u003d\u003d to the expected reference and the current stamp is equal to the expected stamp. This operation may fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eexpectedReference\u003c/code\u003e - the expected value of the reference",
          "\u003ccode\u003enewReference\u003c/code\u003e - the new value for the reference",
          "\u003ccode\u003eexpectedStamp\u003c/code\u003e - the expected value of the stamp",
          "\u003ccode\u003enewStamp\u003c/code\u003e - the new value for the stamp"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "owner": "java.util.concurrent.atomic.AtomicStampedReference",
            "name": "V",
            "type": "Variable"
          },
          "name": "expectedReference",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "owner": "java.util.concurrent.atomic.AtomicStampedReference",
            "name": "V",
            "type": "Variable"
          },
          "name": "newReference",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "expectedStamp",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newStamp",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "compareAndSet",
      "comment": "Atomically sets the value of both the reference and stamp to the given update values if the current reference is \u003d\u003d to the expected reference and the current stamp is equal to the expected stamp.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eexpectedReference\u003c/code\u003e - the expected value of the reference",
          "\u003ccode\u003enewReference\u003c/code\u003e - the new value for the reference",
          "\u003ccode\u003eexpectedStamp\u003c/code\u003e - the expected value of the stamp",
          "\u003ccode\u003enewStamp\u003c/code\u003e - the new value for the stamp"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "owner": "java.util.concurrent.atomic.AtomicStampedReference",
            "name": "V",
            "type": "Variable"
          },
          "name": "newReference",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newStamp",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "set",
      "comment": "Unconditionally sets the value of both the reference and stamp.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enewReference\u003c/code\u003e - the new value for the reference",
          "\u003ccode\u003enewStamp\u003c/code\u003e - the new value for the stamp"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "owner": "java.util.concurrent.atomic.AtomicStampedReference",
            "name": "V",
            "type": "Variable"
          },
          "name": "expectedReference",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newStamp",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "attemptStamp",
      "comment": "Atomically sets the value of the stamp to the given update value if the current reference is \u003d\u003d to the expected reference. Any given invocation of this operation may fail (return false) spuriously, but repeated invocation when the current value holds the expected value and no other thread is also attempting to set the value will eventually succeed.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eexpectedReference\u003c/code\u003e - the expected value of the reference",
          "\u003ccode\u003enewStamp\u003c/code\u003e - the new value for the stamp"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "owner": "java.util.concurrent.atomic.AtomicStampedReference",
            "name": "V",
            "type": "Variable"
          },
          "name": "initialRef",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "initialStamp",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a new AtomicStampedReference with the given initial values.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einitialRef\u003c/code\u003e - the initial reference",
          "\u003ccode\u003einitialStamp\u003c/code\u003e - the initial stamp"
        ]
      }
    }
  ],
  "genericParameters": [
    {
      "name": "V",
      "type": "Variable"
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.util.concurrent.atomic.AtomicStampedReference",
  "annotations": [],
  "tagMap": {
    "since": [
      "1.5"
    ]
  }
}