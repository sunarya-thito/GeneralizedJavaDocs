{
  "packageName": "java.util.concurrent",
  "simpleName": "Flow",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "defaultBufferSize",
      "comment": "Returns a default value for Publisher or Subscriber buffering, that may be used in the absence of other constraints.",
      "annotations": [],
      "tagMap": {
        "implNote": [
          "The current value returned is 256."
        ],
        "return": [
          "the buffer size value"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.util.concurrent.Flow$Processor",
    "java.util.concurrent.Flow$Subscriber",
    "java.util.concurrent.Flow$Publisher",
    "java.util.concurrent.Flow$Subscription"
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.util.concurrent.Flow",
  "comment": "Interrelated interfaces and static methods for establishing flow-controlled components in which \n\u003ca href\u003d\"Flow.Publisher.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003ePublishers\u003c/code\u003e\u003c/a\u003e produce items consumed by one or more \n\u003ca href\u003d\"Flow.Subscriber.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eSubscribers\u003c/code\u003e\u003c/a\u003e, each managed by a \n\u003ca href\u003d\"Flow.Subscription.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eSubscription\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003eThese interfaces correspond to the \u003ca href\u003d\"http://www.reactive-streams.org/\"\u003e reactive-streams\u003c/a\u003e specification. They apply in both concurrent and distributed asynchronous settings: All (seven) methods are defined in \u003ccode\u003e void\u003c/code\u003e \"one-way\" message style. Communication relies on a simple form of flow control (method \u003ca href\u003d\"Flow.Subscription.html#request(long)\"\u003e\u003ccode\u003eFlow.Subscription.request(long)\u003c/code\u003e\u003c/a\u003e) that can be used to avoid resource management problems that may otherwise occur in \"push\" based systems. \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eExamples.\u003c/b\u003e A \u003ca href\u003d\"Flow.Publisher.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eFlow.Publisher\u003c/code\u003e\u003c/a\u003e usually defines its own \u003ca href\u003d\"Flow.Subscription.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eFlow.Subscription\u003c/code\u003e\u003c/a\u003e implementation; constructing one in method \u003ccode\u003esubscribe\u003c/code\u003e and issuing it to the calling \u003ca href\u003d\"Flow.Subscriber.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eFlow.Subscriber\u003c/code\u003e\u003c/a\u003e. It publishes items to the subscriber asynchronously, normally using an \u003ca href\u003d\"Executor.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eExecutor\u003c/code\u003e\u003c/a\u003e. For example, here is a very simple publisher that only issues (when requested) a single \u003ccode\u003e TRUE\u003c/code\u003e item to a single subscriber. Because the subscriber receives only a single item, this class does not use buffering and ordering control required in most implementations (for example \u003ca href\u003d\"SubmissionPublisher.html\" title\u003d\"class in java.util.concurrent\"\u003e\u003ccode\u003eSubmissionPublisher\u003c/code\u003e\u003c/a\u003e). \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n class OneShotPublisher implements Publisher\u0026lt;Boolean\u0026gt; {\n   private final ExecutorService executor \u003d ForkJoinPool.commonPool(); // daemon-based\n   private boolean subscribed; // true after first subscribe\n   public synchronized void subscribe(Subscriber\u0026lt;? super Boolean\u0026gt; subscriber) {\n     if (subscribed)\n       subscriber.onError(new IllegalStateException()); // only one allowed\n     else {\n       subscribed \u003d true;\n       subscriber.onSubscribe(new OneShotSubscription(subscriber, executor));\n     }\n   }\n   static class OneShotSubscription implements Subscription {\n     private final Subscriber\u0026lt;? super Boolean\u0026gt; subscriber;\n     private final ExecutorService executor;\n     private Future\u0026lt;?\u0026gt; future; // to allow cancellation\n     private boolean completed;\n     OneShotSubscription(Subscriber\u0026lt;? super Boolean\u0026gt; subscriber,\n                         ExecutorService executor) {\n       this.subscriber \u003d subscriber;\n       this.executor \u003d executor;\n     }\n     public synchronized void request(long n) {\n       if (!completed) {\n         completed \u003d true;\n         if (n \u0026lt;\u003d 0) {\n           IllegalArgumentException ex \u003d new IllegalArgumentException();\n           executor.execute(() -\u0026gt; subscriber.onError(ex));\n         } else {\n           future \u003d executor.submit(() -\u0026gt; {\n             subscriber.onNext(Boolean.TRUE);\n             subscriber.onComplete();\n           });\n         }\n       }\n     }\n     public synchronized void cancel() {\n       completed \u003d true;\n       if (future !\u003d null) future.cancel(false);\n     }\n   }\n }\u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eA \u003ca href\u003d\"Flow.Subscriber.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eFlow.Subscriber\u003c/code\u003e\u003c/a\u003e arranges that items be requested and processed. Items (invocations of \u003ca href\u003d\"Flow.Subscriber.html#onNext(T)\"\u003e\u003ccode\u003eFlow.Subscriber.onNext(T)\u003c/code\u003e\u003c/a\u003e) are not issued unless requested, but multiple items may be requested. Many Subscriber implementations can arrange this in the style of the following example, where a buffer size of 1 single-steps, and larger sizes usually allow for more efficient overlapped processing with less communication; for example with a value of 64, this keeps total outstanding requests between 32 and 64. Because Subscriber method invocations for a given \u003ca href\u003d\"Flow.Subscription.html\" title\u003d\"interface in java.util.concurrent\"\u003e\u003ccode\u003eFlow.Subscription\u003c/code\u003e\u003c/a\u003e are strictly ordered, there is no need for these methods to use locks or volatiles unless a Subscriber maintains multiple Subscriptions (in which case it is better to instead define multiple Subscribers, each with its own Subscription). \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n class SampleSubscriber\u0026lt;T\u0026gt; implements Subscriber\u0026lt;T\u0026gt; {\n   final Consumer\u0026lt;? super T\u0026gt; consumer;\n   Subscription subscription;\n   final long bufferSize;\n   long count;\n   SampleSubscriber(long bufferSize, Consumer\u0026lt;? super T\u0026gt; consumer) {\n     this.bufferSize \u003d bufferSize;\n     this.consumer \u003d consumer;\n   }\n   public void onSubscribe(Subscription subscription) {\n     long initialRequestSize \u003d bufferSize;\n     count \u003d bufferSize - bufferSize / 2; // re-request when half consumed\n     (this.subscription \u003d subscription).request(initialRequestSize);\n   }\n   public void onNext(T item) {\n     if (--count \u0026lt;\u003d 0)\n       subscription.request(count \u003d bufferSize - bufferSize / 2);\n     consumer.accept(item);\n   }\n   public void onError(Throwable ex) { ex.printStackTrace(); }\n   public void onComplete() {}\n }\u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe default value of \u003ca href\u003d\"#defaultBufferSize()\"\u003e\u003ccode\u003edefaultBufferSize()\u003c/code\u003e\u003c/a\u003e may provide a useful starting point for choosing request sizes and capacities in Flow components based on expected rates, resources, and usages. Or, when flow control is never needed, a subscriber may initially request an effectively unbounded number of items, as in: \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n class UnboundedSubscriber\u0026lt;T\u0026gt; implements Subscriber\u0026lt;T\u0026gt; {\n   public void onSubscribe(Subscription subscription) {\n     subscription.request(Long.MAX_VALUE); // effectively unbounded\n   }\n   public void onNext(T item) { use(item); }\n   public void onError(Throwable ex) { ex.printStackTrace(); }\n   public void onComplete() {}\n   void use(T item) { ... }\n }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "since": [
      "9"
    ]
  }
}