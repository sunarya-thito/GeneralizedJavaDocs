{
  "packageName": "java.util.regex",
  "simpleName": "Matcher",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.util.regex.Pattern",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "pattern",
      "comment": "Returns the pattern that is interpreted by this matcher.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The pattern for which this matcher was created"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.MatchResult",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toMatchResult",
      "comment": "Returns the match state of this matcher as a MatchResult. The result is unaffected by subsequent operations performed upon this matcher.",
      "annotations": [],
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eMatchResult\u003c/code\u003e with the state of this matcher"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "usePattern",
      "comment": "Changes the Pattern that this Matcher uses to find matches with. This method causes this matcher to lose information about the groups of the last match that occurred. The matcher\u0027s position in the input is maintained and its last append position is unaffected.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enewPattern\u003c/code\u003e - The new pattern used by this matcher"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If newPattern is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "This matcher"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "reset",
      "comment": "Resets this matcher. Resetting a matcher discards all of its explicit state information and sets its append position to zero. The matcher\u0027s region is set to the default region, which is its entire character sequence. The anchoring and transparency of this matcher\u0027s region boundaries are unaffected.",
      "annotations": [],
      "tagMap": {
        "return": [
          "This matcher"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "reset",
      "comment": "Resets this matcher with a new input sequence. Resetting a matcher discards all of its explicit state information and sets its append position to zero. The matcher\u0027s region is set to the default region, which is its entire character sequence. The anchoring and transparency of this matcher\u0027s region boundaries are unaffected.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - The new input character sequence"
        ],
        "return": [
          "This matcher"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "start",
      "comment": "Returns the start index of the previous match.",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html#start()\"\u003estart\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html\" title\u003d\"interface in java.util.regex\"\u003eMatchResult\u003c/a\u003e\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed"
        ],
        "return": [
          "The index of the first character matched"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "start",
      "comment": "Returns the start index of the subsequence captured by the given group during the previous match operation. Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.start(0) is equivalent to m.start().",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html#start(int)\"\u003estart\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html\" title\u003d\"interface in java.util.regex\"\u003eMatchResult\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003egroup\u003c/code\u003e - The index of a capturing group in this matcher\u0027s pattern"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If there is no capturing group in the pattern with the given index"
        ],
        "return": [
          "The index of the first character captured by the group, or \n\u003ccode\u003e-1\u003c/code\u003e if the match was successful but the group itself did not match anything"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "start",
      "comment": "Returns the start index of the subsequence captured by the given named-capturing group during the previous match operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - The name of a named-capturing group in this matcher\u0027s pattern"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If there is no capturing group in the pattern with the given name"
        ],
        "return": [
          "The index of the first character captured by the group, or \n\u003ccode\u003e-1\u003c/code\u003e if the match was successful but the group itself did not match anything"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "end",
      "comment": "Returns the offset after the last character matched.",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html#end()\"\u003eend\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html\" title\u003d\"interface in java.util.regex\"\u003eMatchResult\u003c/a\u003e\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed"
        ],
        "return": [
          "The offset after the last character matched"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "end",
      "comment": "Returns the offset after the last character of the subsequence captured by the given group during the previous match operation. Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.end(0) is equivalent to m.end().",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html#end(int)\"\u003eend\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html\" title\u003d\"interface in java.util.regex\"\u003eMatchResult\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003egroup\u003c/code\u003e - The index of a capturing group in this matcher\u0027s pattern"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If there is no capturing group in the pattern with the given index"
        ],
        "return": [
          "The offset after the last character captured by the group, or \n\u003ccode\u003e-1\u003c/code\u003e if the match was successful but the group itself did not match anything"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "end",
      "comment": "Returns the offset after the last character of the subsequence captured by the given named-capturing group during the previous match operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - The name of a named-capturing group in this matcher\u0027s pattern"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If there is no capturing group in the pattern with the given name"
        ],
        "return": [
          "The offset after the last character captured by the group, or \n\u003ccode\u003e-1\u003c/code\u003e if the match was successful but the group itself did not match anything"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "group",
      "comment": "Returns the input subsequence matched by the previous match. For a matcher m with input sequence s, the expressions m.group() and s.substring(m.start(), m. end()) are equivalent. Note that some patterns, for example a*, match the empty string. This method will return the empty string when the pattern successfully matches the empty string in the input.",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html#group()\"\u003egroup\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html\" title\u003d\"interface in java.util.regex\"\u003eMatchResult\u003c/a\u003e\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed"
        ],
        "return": [
          "The (possibly empty) subsequence matched by the previous match, in string form"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "group",
      "comment": "Returns the input subsequence captured by the given group during the previous match operation. For a matcher m, input sequence s, and group index g, the expressions m.group(g) and s.substring(m.start(g ), m.end(g)) are equivalent. Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.group(0) is equivalent to m.group(). If the match was successful but the group specified failed to match any part of the input sequence, then null is returned. Note that some groups, for example (a*), match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html#group(int)\"\u003egroup\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html\" title\u003d\"interface in java.util.regex\"\u003eMatchResult\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003egroup\u003c/code\u003e - The index of a capturing group in this matcher\u0027s pattern"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If there is no capturing group in the pattern with the given index"
        ],
        "return": [
          "The (possibly empty) subsequence captured by the group during the previous match, or \n\u003ccode\u003enull\u003c/code\u003e if the group failed to match part of the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "group",
      "comment": "Returns the input subsequence captured by the given named-capturing group during the previous match operation. If the match was successful but the group specified failed to match any part of the input sequence, then null is returned. Note that some groups, for example (a*), match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - The name of a named-capturing group in this matcher\u0027s pattern"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If there is no capturing group in the pattern with the given name"
        ],
        "return": [
          "The (possibly empty) subsequence captured by the named group during the previous match, or \n\u003ccode\u003enull\u003c/code\u003e if the group failed to match part of the input"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "groupCount",
      "comment": "Returns the number of capturing groups in this matcher\u0027s pattern. Group zero denotes the entire pattern by convention. It is not included in this count. Any non-negative integer smaller than or equal to the value returned by this method is guaranteed to be a valid group index for this matcher.",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html#groupCount()\"\u003egroupCount\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/MatchResult.html\" title\u003d\"interface in java.util.regex\"\u003eMatchResult\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "The number of capturing groups in this matcher\u0027s pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "matches",
      "comment": "Attempts to match the entire region against the pattern. If the match succeeds then more information can be obtained via the start, end, and group methods.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, the entire region sequence matches this matcher\u0027s pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "find",
      "comment": "Attempts to find the next subsequence of the input sequence that matches the pattern. This method starts at the beginning of this matcher\u0027s region, or, if a previous invocation of the method was successful and the matcher has not since been reset, at the first character not matched by the previous match. If the match succeeds then more information can be obtained via the start, end, and group methods.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, a subsequence of the input sequence matches this matcher\u0027s pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "find",
      "comment": "Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index. If the match succeeds then more information can be obtained via the start, end, and group methods, and subsequent invocations of the find() method will start at the first character not matched by this match.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003estart\u003c/code\u003e - the index to start searching for a match"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If start is less than zero or if start is greater than the length of the input sequence."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, a subsequence of the input sequence starting at the given index matches this matcher\u0027s pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "lookingAt",
      "comment": "Attempts to match the input sequence, starting at the beginning of the region, against the pattern. Like the matches method, this method always starts at the beginning of the region; unlike that method, it does not require that the entire region be matched. If the match succeeds then more information can be obtained via the start, end, and group methods.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, a prefix of the input sequence matches this matcher\u0027s pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "quoteReplacement",
      "comment": "Returns a literal replacement String for the specified String. This method produces a String that will work as a literal replacement s in the appendReplacement method of the Matcher class. The String produced will match the sequence of characters in s treated as a literal sequence. Slashes (\u0027\\\u0027) and dollar signs (\u0027$\u0027) will be given no special meaning.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - The string to be literalized"
        ],
        "return": [
          "A literal string replacement"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "appendReplacement",
      "comment": "Implements a non-terminal append-and-replace step. This method performs the following actions: It reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. It stops after reading the last character preceding the previous match, that is, the character at index start() - 1. It appends the given replacement string to the string buffer. It sets the append position of this matcher to the index of the last character matched, plus one, that is, to end(). The replacement string may contain references to subsequences captured during the previous match: Each occurrence of ${name} or $g will be replaced by the result of evaluating the corresponding group(name) or group(g) respectively. For $g, the first number after the $ is always treated as part of the group reference. Subsequent numbers are incorporated into g if they would form a legal group reference. Only the numerals \u00270\u0027 through \u00279\u0027 are considered as potential components of the group reference. If the second group matched the string \"foo\", for example, then passing the replacement string \"$2bar\" would cause \"foobar\" to be appended to the string buffer. A dollar sign ($) may be included as a literal in the replacement string by preceding it with a backslash (\\$). Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. This method is intended to be used in a loop together with the appendTail and find methods. The following code, for example, writes one dog two dogs in the yard to the standard-output stream:  Pattern p \u003d Pattern.compile(\"cat\");\n Matcher m \u003d p.matcher(\"one cat two cats in the yard\");\n StringBuffer sb \u003d new StringBuffer();\n while (m.find()) {\n     m.appendReplacement(sb, \"dog\");\n }\n m.appendTail(sb);\n System.out.println(sb.toString());",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esb\u003c/code\u003e - The target string buffer",
          "\u003ccode\u003ereplacement\u003c/code\u003e - The replacement string"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the replacement string refers to a named-capturing group that does not exist in the pattern",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If the replacement string refers to a capturing group that does not exist in the pattern"
        ],
        "return": [
          "This matcher"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "appendReplacement",
      "comment": "Implements a non-terminal append-and-replace step. This method performs the following actions: It reads characters from the input sequence, starting at the append position, and appends them to the given string builder. It stops after reading the last character preceding the previous match, that is, the character at index start() - 1. It appends the given replacement string to the string builder. It sets the append position of this matcher to the index of the last character matched, plus one, that is, to end(). The replacement string may contain references to subsequences captured during the previous match: Each occurrence of $g will be replaced by the result of evaluating group(g). The first number after the $ is always treated as part of the group reference. Subsequent numbers are incorporated into g if they would form a legal group reference. Only the numerals \u00270\u0027 through \u00279\u0027 are considered as potential components of the group reference. If the second group matched the string \"foo\", for example, then passing the replacement string \"$2bar\" would cause \"foobar\" to be appended to the string builder. A dollar sign ($) may be included as a literal in the replacement string by preceding it with a backslash (\\$). Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. This method is intended to be used in a loop together with the appendTail and find methods. The following code, for example, writes one dog two dogs in the yard to the standard-output stream:  Pattern p \u003d Pattern.compile(\"cat\");\n Matcher m \u003d p.matcher(\"one cat two cats in the yard\");\n StringBuilder sb \u003d new StringBuilder();\n while (m.find()) {\n     m.appendReplacement(sb, \"dog\");\n }\n m.appendTail(sb);\n System.out.println(sb.toString());",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esb\u003c/code\u003e - The target string builder",
          "\u003ccode\u003ereplacement\u003c/code\u003e - The replacement string"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match has yet been attempted, or if the previous match operation failed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the replacement string refers to a named-capturing group that does not exist in the pattern",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If the replacement string refers to a capturing group that does not exist in the pattern"
        ],
        "return": [
          "This matcher"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.StringBuffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "appendTail",
      "comment": "Implements a terminal append-and-replace step. This method reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. It is intended to be invoked after one or more invocations of the appendReplacement method in order to copy the remainder of the input sequence.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esb\u003c/code\u003e - The target string buffer"
        ],
        "return": [
          "The target string buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.StringBuilder",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "appendTail",
      "comment": "Implements a terminal append-and-replace step. This method reads characters from the input sequence, starting at the append position, and appends them to the given string builder. It is intended to be invoked after one or more invocations of the appendReplacement method in order to copy the remainder of the input sequence.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esb\u003c/code\u003e - The target string builder"
        ],
        "return": [
          "The target string builder"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "replaceAll",
      "comment": "Replaces every subsequence of the input sequence that matches the pattern with the given replacement string. This method first resets this matcher. It then scans the input sequence looking for matches of the pattern. Characters that are not part of any match are appended directly to the result string; each match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method. Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. Given the regular expression a*b, the input \"aabfooaabfooabfoob\", and the replacement string \"-\", an invocation of this method on a matcher for that expression would yield the string \"-foo-foo-foo-\". Invoking this method changes this matcher\u0027s state. If the matcher is to be used in further matching operations then it should first be reset.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ereplacement\u003c/code\u003e - The replacement string"
        ],
        "return": [
          "The string constructed by replacing each matching subsequence by the replacement string, substituting captured subsequences as needed"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "replaceAll",
      "comment": "Replaces every subsequence of the input sequence that matches the pattern with the result of applying the given replacer function to the match result of this matcher corresponding to that subsequence. Exceptions thrown by the function are relayed to the caller. This method first resets this matcher. It then scans the input sequence looking for matches of the pattern. Characters that are not part of any match are appended directly to the result string; each match is replaced in the result by the applying the replacer function that returns a replacement string. Each replacement string may contain references to captured subsequences as in the appendReplacement method. Note that backslashes (\\) and dollar signs ($) in a replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. Given the regular expression dog, the input \"zzzdogzzzdogzzz\", and the function mr -\u003e mr.group().toUpperCase(), an invocation of this method on a matcher for that expression would yield the string \"zzzDOGzzzDOGzzz\". Invoking this method changes this matcher\u0027s state. If the matcher is to be used in further matching operations then it should first be reset. The replacer function should not modify this matcher\u0027s state during replacement. This method will, on a best-effort basis, throw a ConcurrentModificationException if such modification is detected. The state of each match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher\u0027s state.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ereplacer\u003c/code\u003e - The function to be applied to the match result of this matcher that returns a replacement string."
        ],
        "implNote": [
          "This implementation applies the replacer function to this matcher, which is an instance of \n\u003ccode\u003eMatchResult\u003c/code\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the replacer function is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/ConcurrentModificationException.html\" title\u003d\"class in java.util\"\u003eConcurrentModificationException\u003c/a\u003e\u003c/code\u003e - if it is detected, on a best-effort basis, that the replacer function modified this matcher\u0027s state"
        ],
        "return": [
          "The string constructed by replacing each matching subsequence with the result of applying the replacer function to that matched subsequence, substituting captured subsequences as needed."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "java.util.regex.MatchResult",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "results",
      "comment": "Returns a stream of match results for each subsequence of the input sequence that matches the pattern. The match results occur in the same order as the matching subsequences in the input sequence. Each match result is produced as if by toMatchResult(). This method does not reset this matcher. Matching starts on initiation of the terminal stream operation either at the beginning of this matcher\u0027s region, or, if the matcher has not since been reset, at the first character not matched by a previous match. If the matcher is to be used for further matching operations after the terminal stream operation completes then it should be first reset. This matcher\u0027s state should not be modified during execution of the returned stream\u0027s pipeline. The returned stream\u0027s source Spliterator is fail-fast and will, on a best-effort basis, throw a ConcurrentModificationException if such modification is detected.",
      "annotations": [],
      "tagMap": {
        "return": [
          "a sequential stream of match results."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "replaceFirst",
      "comment": "Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string. This method first resets this matcher. It then scans the input sequence looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method. Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. Given the regular expression dog, the input \"zzzdogzzzdogzzz\", and the replacement string \"cat\", an invocation of this method on a matcher for that expression would yield the string \"zzzcatzzzdogzzz\". Invoking this method changes this matcher\u0027s state. If the matcher is to be used in further matching operations then it should first be reset.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ereplacement\u003c/code\u003e - The replacement string"
        ],
        "return": [
          "The string constructed by replacing the first matching subsequence by the replacement string, substituting captured subsequences as needed"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "replaceFirst",
      "comment": "Replaces the first subsequence of the input sequence that matches the pattern with the result of applying the given replacer function to the match result of this matcher corresponding to that subsequence. Exceptions thrown by the replace function are relayed to the caller. This method first resets this matcher. It then scans the input sequence looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the applying the replacer function that returns a replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method. Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. Given the regular expression dog, the input \"zzzdogzzzdogzzz\", and the function mr -\u003e mr.group().toUpperCase(), an invocation of this method on a matcher for that expression would yield the string \"zzzDOGzzzdogzzz\". Invoking this method changes this matcher\u0027s state. If the matcher is to be used in further matching operations then it should first be reset. The replacer function should not modify this matcher\u0027s state during replacement. This method will, on a best-effort basis, throw a ConcurrentModificationException if such modification is detected. The state of the match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher\u0027s state.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ereplacer\u003c/code\u003e - The function to be applied to the match result of this matcher that returns a replacement string."
        ],
        "implNote": [
          "This implementation applies the replacer function to this matcher, which is an instance of \n\u003ccode\u003eMatchResult\u003c/code\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the replacer function is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/ConcurrentModificationException.html\" title\u003d\"class in java.util\"\u003eConcurrentModificationException\u003c/a\u003e\u003c/code\u003e - if it is detected, on a best-effort basis, that the replacer function modified this matcher\u0027s state"
        ],
        "return": [
          "The string constructed by replacing the first matching subsequence with the result of applying the replacer function to the matched subsequence, substituting captured subsequences as needed."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "region",
      "comment": "Sets the limits of this matcher\u0027s region. The region is the part of the input sequence that will be searched to find a match. Invoking this method resets the matcher, and then sets the region to start at the index specified by the start parameter and end at the index specified by the end parameter. Depending on the transparency and anchoring being used (see useTransparentBounds and useAnchoringBounds), certain constructs such as anchors may behave differently at or around the boundaries of the region.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003estart\u003c/code\u003e - The index to start searching at (inclusive)",
          "\u003ccode\u003eend\u003c/code\u003e - The index to end searching at (exclusive)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If start or end is less than zero, if start is greater than the length of the input sequence, if end is greater than the length of the input sequence, or if start is greater than end."
        ],
        "return": [
          "this matcher"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "regionStart",
      "comment": "Reports the start index of this matcher\u0027s region. The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).",
      "annotations": [],
      "tagMap": {
        "return": [
          "The starting point of this matcher\u0027s region"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "regionEnd",
      "comment": "Reports the end index (exclusive) of this matcher\u0027s region. The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).",
      "annotations": [],
      "tagMap": {
        "return": [
          "the ending point of this matcher\u0027s region"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasTransparentBounds",
      "comment": "Queries the transparency of region bounds for this matcher. This method returns true if this matcher uses transparent bounds, false if it uses opaque bounds. See useTransparentBounds for a description of transparent and opaque bounds. By default, a matcher uses opaque region boundaries.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/Matcher.html#useTransparentBounds(boolean)\"\u003e\u003ccode\u003euseTransparentBounds(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e iff this matcher is using transparent bounds, \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "useTransparentBounds",
      "comment": "Sets the transparency of region bounds for this matcher. Invoking this method with an argument of true will set this matcher to use transparent bounds. If the boolean argument is false, then opaque bounds will be used. Using transparent bounds, the boundaries of this matcher\u0027s region are transparent to lookahead, lookbehind, and boundary matching constructs. Those constructs can see beyond the boundaries of the region to see if a match is appropriate. Using opaque bounds, the boundaries of this matcher\u0027s region are opaque to lookahead, lookbehind, and boundary matching constructs that may try to see beyond them. Those constructs cannot look past the boundaries so they will fail to match anything outside of the region. By default, a matcher uses opaque bounds.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/Matcher.html#hasTransparentBounds()\"\u003e\u003ccode\u003ehasTransparentBounds()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eb\u003c/code\u003e - a boolean indicating whether to use opaque or transparent regions"
        ],
        "return": [
          "this matcher"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasAnchoringBounds",
      "comment": "Queries the anchoring of region bounds for this matcher. This method returns true if this matcher uses anchoring bounds, false otherwise. See useAnchoringBounds for a description of anchoring bounds. By default, a matcher uses anchoring region boundaries.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/Matcher.html#useAnchoringBounds(boolean)\"\u003e\u003ccode\u003euseAnchoringBounds(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e iff this matcher is using anchoring bounds, \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Matcher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "useAnchoringBounds",
      "comment": "Sets the anchoring of region bounds for this matcher. Invoking this method with an argument of true will set this matcher to use anchoring bounds. If the boolean argument is false, then non-anchoring bounds will be used. Using anchoring bounds, the boundaries of this matcher\u0027s region match anchors such as ^ and $. Without anchoring bounds, the boundaries of this matcher\u0027s region will not match anchors such as ^ and $. By default, a matcher uses anchoring region boundaries.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/Matcher.html#hasAnchoringBounds()\"\u003e\u003ccode\u003ehasAnchoringBounds()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eb\u003c/code\u003e - a boolean indicating whether or not to use anchoring bounds."
        ],
        "return": [
          "this matcher"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns the string representation of this matcher. The string representation of a Matcher contains information that may be useful for debugging. The exact format is unspecified.",
      "annotations": [],
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "The string representation of this matcher"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hitEnd",
      "comment": "Returns true if the end of input was hit by the search engine in the last match operation performed by this matcher. When this method returns true, then it is possible that more input would have changed the result of the last search.",
      "annotations": [],
      "tagMap": {
        "return": [
          "true iff the end of input was hit in the last match; false otherwise"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "requireEnd",
      "comment": "Returns true if more input could change a positive match into a negative one. If this method returns true, and a match was found, then more input could cause the match to be lost. If this method returns false and a match was found, then more input might change the match but the match won\u0027t be lost. If a match was not found, then requireEnd has no meaning.",
      "annotations": [],
      "tagMap": {
        "return": [
          "true iff more input could change a positive match into a negative one."
        ],
        "since": [
          "1.5"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.util.regex.Matcher",
  "comment": "An engine that performs match operations on a \n\u003ca href\u003d\"../../lang/CharSequence.html\" title\u003d\"interface in java.lang\"\u003echaracter sequence\u003c/a\u003e by interpreting a \n\u003ca href\u003d\"Pattern.html\" title\u003d\"class in java.util.regex\"\u003e\u003ccode\u003ePattern\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003e A matcher is created from a pattern by invoking the pattern\u0027s \u003ca href\u003d\"Pattern.html#matcher(java.lang.CharSequence)\"\u003e\u003ccode\u003ematcher\u003c/code\u003e\u003c/a\u003e method. Once created, a matcher can be used to perform three different kinds of match operations: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#matches()\"\u003e\u003ccode\u003ematches\u003c/code\u003e\u003c/a\u003e method attempts to match the entire input sequence against the pattern. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#lookingAt()\"\u003e\u003ccode\u003elookingAt\u003c/code\u003e\u003c/a\u003e method attempts to match the input sequence, starting at the beginning, against the pattern. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#find()\"\u003e\u003ccode\u003efind\u003c/code\u003e\u003c/a\u003e method scans the input sequence looking for the next subsequence that matches the pattern. \u003c/p\u003e\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Each of these methods returns a boolean indicating success or failure. More information about a successful match can be obtained by querying the state of the matcher. \u003c/p\u003e\n\u003cp\u003e A matcher finds matches in a subset of its input called the \u003ci\u003eregion\u003c/i\u003e. By default, the region contains all of the matcher\u0027s input. The region can be modified via the \u003ca href\u003d\"#region(int,int)\"\u003e\u003ccode\u003eregion\u003c/code\u003e\u003c/a\u003e method and queried via the \u003ca href\u003d\"#regionStart()\"\u003e\u003ccode\u003eregionStart\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#regionEnd()\"\u003e\u003ccode\u003eregionEnd\u003c/code\u003e\u003c/a\u003e methods. The way that the region boundaries interact with some pattern constructs can be changed. See \u003ca href\u003d\"#useAnchoringBounds(boolean)\"\u003e\u003ccode\u003euseAnchoringBounds\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#useTransparentBounds(boolean)\"\u003e\u003ccode\u003euseTransparentBounds\u003c/code\u003e\u003c/a\u003e for more details. \u003c/p\u003e\n\u003cp\u003e This class also defines methods for replacing matched subsequences with new strings whose contents can, if desired, be computed from the match result. The \u003ca href\u003d\"#appendReplacement(java.lang.StringBuffer,java.lang.String)\"\u003e\u003ccode\u003eappendReplacement\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#appendTail(java.lang.StringBuffer)\"\u003e\u003ccode\u003eappendTail\u003c/code\u003e\u003c/a\u003e methods can be used in tandem in order to collect the result into an existing string buffer or string builder. Alternatively, the more convenient \u003ca href\u003d\"#replaceAll(java.lang.String)\"\u003e\u003ccode\u003ereplaceAll\u003c/code\u003e\u003c/a\u003e method can be used to create a string in which every matching subsequence in the input sequence is replaced. \u003c/p\u003e\n\u003cp\u003e The explicit state of a matcher includes the start and end indices of the most recent successful match. It also includes the start and end indices of the input subsequence captured by each \u003ca href\u003d\"Pattern.html#cg\"\u003ecapturing group\u003c/a\u003e in the pattern as well as a total count of such subsequences. As a convenience, methods are also provided for returning these captured subsequences in string form. \u003c/p\u003e\n\u003cp\u003e The explicit state of a matcher is initially undefined; attempting to query any part of it before a successful match will cause an \u003ca href\u003d\"../../lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eIllegalStateException\u003c/code\u003e\u003c/a\u003e to be thrown. The explicit state of a matcher is recomputed by every match operation. \u003c/p\u003e\n\u003cp\u003e The implicit state of a matcher includes the input character sequence as well as the \u003ci\u003eappend position\u003c/i\u003e, which is initially zero and is updated by the \u003ca href\u003d\"#appendReplacement(java.lang.StringBuffer,java.lang.String)\"\u003e\u003ccode\u003eappendReplacement\u003c/code\u003e\u003c/a\u003e method. \u003c/p\u003e\n\u003cp\u003e A matcher may be reset explicitly by invoking its \u003ca href\u003d\"#reset()\"\u003e\u003ccode\u003ereset()\u003c/code\u003e\u003c/a\u003e method or, if a new input sequence is desired, its \u003ca href\u003d\"#reset(java.lang.CharSequence)\"\u003e\u003ccode\u003ereset(CharSequence)\u003c/code\u003e\u003c/a\u003e method. Resetting a matcher discards its explicit state information and sets the append position to zero. \u003c/p\u003e\n\u003cp\u003e Instances of this class are not safe for use by multiple concurrent threads. \u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.4"
    ]
  }
}