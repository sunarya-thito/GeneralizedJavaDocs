{
  "packageName": "java.util",
  "simpleName": "DoubleSummaryStatistics",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "value",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "accept",
      "comment": "Records another value into the summary information.",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/DoubleConsumer.html#accept(double)\"\u003eaccept\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/DoubleConsumer.html\" title\u003d\"interface in java.util.function\"\u003eDoubleConsumer\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - the input value"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.DoubleSummaryStatistics",
            "type": "Class"
          },
          "name": "other",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "combine",
      "comment": "Combines the state of another DoubleSummaryStatistics into this one.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eother\u003c/code\u003e - another \n\u003ccode\u003eDoubleSummaryStatistics\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eother\u003c/code\u003e is null"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getCount",
      "comment": "Return the count of values recorded.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the count of values"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getSum",
      "comment": "Returns the sum of values recorded, or zero if no values have been recorded. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of double values. Because of the unspecified order of operations and the possibility of using differing summation schemes, the output of this method may vary on the same input values. Various conditions can result in a non-finite sum being computed. This can occur even if the all the recorded values being summed are finite. If any recorded value is non-finite, the sum will be non-finite: If any recorded value is a NaN, then the final sum will be NaN. If the recorded values contain one or more infinities, the sum will be infinite or NaN. If the recorded values contain infinities of opposite sign, the sum will be NaN. If the recorded values contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN. It is possible for intermediate sums of finite values to overflow into opposite-signed infinities; if that occurs, the final sum will be NaN even if the recorded values are all finite. If all the recorded values are zero, the sign of zero is not guaranteed to be preserved in the final sum.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Values sorted by increasing absolute magnitude tend to yield more accurate results."
        ],
        "return": [
          "the sum of values, or zero if none"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getMin",
      "comment": "Returns the minimum recorded value, Double.NaN if any recorded value was NaN or Double.POSITIVE_INFINITY if no values were recorded. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the minimum recorded value, \n\u003ccode\u003eDouble.NaN\u003c/code\u003e if any recorded value was NaN or \n\u003ccode\u003eDouble.POSITIVE_INFINITY\u003c/code\u003e if no values were recorded"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getMax",
      "comment": "Returns the maximum recorded value, Double.NaN if any recorded value was NaN or Double.NEGATIVE_INFINITY if no values were recorded. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the maximum recorded value, \n\u003ccode\u003eDouble.NaN\u003c/code\u003e if any recorded value was NaN or \n\u003ccode\u003eDouble.NEGATIVE_INFINITY\u003c/code\u003e if no values were recorded"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAverage",
      "comment": "Returns the arithmetic mean of values recorded, or zero if no values have been recorded. The computed average can vary numerically and have the special case behavior as computing the sum; see getSum() for details.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Values sorted by increasing absolute magnitude tend to yield more accurate results."
        ],
        "return": [
          "the arithmetic mean of values, or zero if none"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a non-empty string representation of this object suitable for debugging. The exact presentation format is unspecified and may vary between implementations and versions.",
      "annotations": [],
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a string representation of the object."
        ]
      }
    },
    {
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs an empty instance with zero count, zero sum, Double.POSITIVE_INFINITY min, Double.NEGATIVE_INFINITY max and zero average.",
      "annotations": [],
      "tagMap": {}
    },
    {
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "count",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "min",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "max",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "sum",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a non-empty instance with the specified count, min, max, and sum. If count is zero then the remaining arguments are ignored and an empty instance is constructed. If the arguments are inconsistent then an IllegalArgumentException is thrown. The necessary consistent argument conditions are: count \u003e\u003d 0 (min \u003c\u003d max \u0026\u0026 !isNaN(sum)) || (isNaN(min) \u0026\u0026 isNaN(max) \u0026\u0026 isNaN(sum))",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "The enforcement of argument correctness means that the retrieved set of recorded values obtained from a \n\u003ccode\u003eDoubleSummaryStatistics\u003c/code\u003e source instance may not be a legal set of arguments for this constructor due to arithmetic overflow of the source\u0027s recorded count of values. The consistent argument conditions are not sufficient to prevent the creation of an internally inconsistent instance. An example of such a state would be an instance with: \n\u003ccode\u003ecount\u003c/code\u003e \u003d 2, \n\u003ccode\u003emin\u003c/code\u003e \u003d 1, \n\u003ccode\u003emax\u003c/code\u003e \u003d 2, and \n\u003ccode\u003esum\u003c/code\u003e \u003d 0."
        ],
        "param": [
          "\u003ccode\u003ecount\u003c/code\u003e - the count of values",
          "\u003ccode\u003emin\u003c/code\u003e - the minimum value",
          "\u003ccode\u003emax\u003c/code\u003e - the maximum value",
          "\u003ccode\u003esum\u003c/code\u003e - the sum of all values"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the arguments are inconsistent"
        ],
        "since": [
          "10"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.util.DoubleSummaryStatistics",
  "annotations": [],
  "tagMap": {
    "implNote": [
      "This implementation is not thread safe. However, it is safe to use \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#summarizingDouble(java.util.function.ToDoubleFunction)\"\u003e\u003ccode\u003eCollectors.summarizingDouble()\u003c/code\u003e\u003c/a\u003e on a parallel stream, because the parallel implementation of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)\"\u003e\u003ccode\u003eStream.collect()\u003c/code\u003e\u003c/a\u003e provides the necessary partitioning, isolation, and merging of results for safe and efficient parallel execution. \n\u003cp\u003eThis implementation does not check for overflow of the count.\u003c/p\u003e"
    ],
    "since": [
      "1.8"
    ]
  }
}