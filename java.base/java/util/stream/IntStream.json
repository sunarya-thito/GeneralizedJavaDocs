{
  "packageName": "java.util.stream",
  "simpleName": "IntStream",
  "moduleName": "java.base",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.util.stream.BaseStream",
    "parameters": [
      {
        "name": "java.lang.Integer",
        "type": "Class"
      },
      {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      }
    ],
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "filter",
      "comment": "Returns a stream consisting of the elements of this stream that match the given predicate. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to each element to determine if it should be included"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "map",
      "comment": "Returns a stream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "U",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "genericParameters": [
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapToObj",
      "comment": "Returns an object-valued Stream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eU\u003c/code\u003e - the element type of the new stream"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.LongStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapToLong",
      "comment": "Returns a LongStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.DoubleStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapToDouble",
      "comment": "Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "flatMap",
      "comment": "Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)\"\u003e\u003ccode\u003eStream.flatMap(Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element which produces an \n\u003ccode\u003eIntStream\u003c/code\u003e of new values"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapMulti",
      "comment": "Returns a stream consisting of the results of replacing each element of this stream with multiple elements, specifically zero or more elements. Replacement is performed by applying the provided mapping function to each element in conjunction with a consumer argument that accepts replacement elements. The mapping function calls the consumer zero or more times to provide the replacement elements. This is an intermediate operation. If the consumer argument is used outside the scope of its application to the mapping function, the results are undefined.",
      "annotations": [],
      "tagMap": {
        "implSpec": [
          "The default implementation invokes \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#flatMap(java.util.function.IntFunction)\"\u003e\u003ccode\u003eflatMap\u003c/code\u003e\u003c/a\u003e on this stream, passing a function that behaves as follows. First, it calls the mapper function with an \n\u003ccode\u003eIntConsumer\u003c/code\u003e that accumulates replacement elements into a newly created internal buffer. When the mapper function returns, it creates an \n\u003ccode\u003eIntStream\u003c/code\u003e from the internal buffer. Finally, it returns this stream to \n\u003ccode\u003eflatMap\u003c/code\u003e."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)\"\u003e\u003ccode\u003eStream.mapMulti\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that generates replacement elements"
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "distinct",
      "comment": "Returns a stream consisting of the distinct elements of this stream. This is a stateful intermediate operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "sorted",
      "comment": "Returns a stream consisting of the elements of this stream in sorted order. This is a stateful intermediate operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "peek",
      "comment": "Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation. For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline: \n\u003cpre\u003e\u003ccode\u003e\n     IntStream.of(1, 2, 3, 4)\n         .filter(e -\u0026gt; e \u0026gt; 2)\n         .peek(e -\u0026gt; System.out.println(\"Filtered value: \" + e))\n         .map(e -\u0026gt; e * e)\n         .peek(e -\u0026gt; System.out.println(\"Mapped value: \" + e))\n         .sum();\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eIn cases where the stream implementation is able to optimize away the production of some or all the elements (such as with short-circuiting operations like \u003ccode\u003efindFirst\u003c/code\u003e, or in the example described in \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#count()\"\u003e\u003ccode\u003ecount()\u003c/code\u003e\u003c/a\u003e), the action will not be invoked for those elements.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eaction\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003e non-interfering\u003c/a\u003e action to perform on the elements as they are consumed from the stream"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "limit",
      "comment": "Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length. This is a short-circuiting stateful intermediate operation.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "While \n\u003ccode\u003elimit()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of \n\u003ccode\u003emaxSize\u003c/code\u003e, since \n\u003ccode\u003elimit(n)\u003c/code\u003e is constrained to return not just any \n\u003cem\u003en\u003c/em\u003e elements, but the \n\u003cem\u003efirst n\u003c/em\u003e elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#generate(java.util.function.IntSupplier)\"\u003e\u003ccode\u003egenerate(IntSupplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003elimit()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003elimit()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003emaxSize\u003c/code\u003e - the number of elements the stream should be limited to"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emaxSize\u003c/code\u003e is negative"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "skip",
      "comment": "Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned. This is a stateful intermediate operation.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "While \n\u003ccode\u003eskip()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of \n\u003ccode\u003en\u003c/code\u003e, since \n\u003ccode\u003eskip(n)\u003c/code\u003e is constrained to skip not just any \n\u003cem\u003en\u003c/em\u003e elements, but the \n\u003cem\u003efirst n\u003c/em\u003e elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#generate(java.util.function.IntSupplier)\"\u003e\u003ccode\u003egenerate(IntSupplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003eskip()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003eskip()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003en\u003c/code\u003e - the number of leading elements to skip"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003en\u003c/code\u003e is negative"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "takeWhile",
      "comment": "Returns, if this stream is ordered, a stream consisting of the longest prefix of elements taken from this stream that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of a subset of elements taken from this stream that match the given predicate. If this stream is ordered then the longest prefix is a contiguous sequence of elements of this stream that match the given predicate. The first element of the sequence is the first element of this stream, and the element immediately following the last element of the sequence does not match the given predicate. If this stream is unordered, and some (but not all) elements of this stream match the given predicate, then the behavior of this operation is nondeterministic; it is free to take any subset of matching elements (which includes the empty set). Independent of whether this stream is ordered or unordered if all elements of this stream match the given predicate then this operation takes all elements (the result is the same as the input), or if no elements of the stream match the given predicate then no elements are taken (the result is an empty stream). This is a short-circuiting stateful intermediate operation.",
      "annotations": [],
      "tagMap": {
        "implSpec": [
          "The default implementation obtains the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#spliterator()\"\u003e\u003ccode\u003espliterator\u003c/code\u003e\u003c/a\u003e of this stream, wraps that spliterator so as to support the semantics of this operation on traversal, and returns a new stream associated with the wrapped spliterator. The returned stream preserves the execution characteristics of this stream (namely parallel or sequential execution as per \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#isParallel()\"\u003e\u003ccode\u003eBaseStream.isParallel()\u003c/code\u003e\u003c/a\u003e) but the wrapped spliterator may choose to not support splitting. When the returned stream is closed, the close handlers for both the returned and this stream are invoked."
        ],
        "apiNote": [
          "While \n\u003ccode\u003etakeWhile()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#generate(java.util.function.IntSupplier)\"\u003e\u003ccode\u003egenerate(IntSupplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003etakeWhile()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003etakeWhile()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements to determine the longest prefix of elements."
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "dropWhile",
      "comment": "Returns, if this stream is ordered, a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of the remaining elements of this stream after dropping a subset of elements that match the given predicate. If this stream is ordered then the longest prefix is a contiguous sequence of elements of this stream that match the given predicate. The first element of the sequence is the first element of this stream, and the element immediately following the last element of the sequence does not match the given predicate. If this stream is unordered, and some (but not all) elements of this stream match the given predicate, then the behavior of this operation is nondeterministic; it is free to drop any subset of matching elements (which includes the empty set). Independent of whether this stream is ordered or unordered if all elements of this stream match the given predicate then this operation drops all elements (the result is an empty stream), or if no elements of the stream match the given predicate then no elements are dropped (the result is the same as the input). This is a stateful intermediate operation.",
      "annotations": [],
      "tagMap": {
        "implSpec": [
          "The default implementation obtains the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#spliterator()\"\u003e\u003ccode\u003espliterator\u003c/code\u003e\u003c/a\u003e of this stream, wraps that spliterator so as to support the semantics of this operation on traversal, and returns a new stream associated with the wrapped spliterator. The returned stream preserves the execution characteristics of this stream (namely parallel or sequential execution as per \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#isParallel()\"\u003e\u003ccode\u003eBaseStream.isParallel()\u003c/code\u003e\u003c/a\u003e) but the wrapped spliterator may choose to not support splitting. When the returned stream is closed, the close handlers for both the returned and this stream are invoked."
        ],
        "apiNote": [
          "While \n\u003ccode\u003edropWhile()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#generate(java.util.function.IntSupplier)\"\u003e\u003ccode\u003egenerate(IntSupplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003edropWhile()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003edropWhile()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements to determine the longest prefix of elements."
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "forEach",
      "comment": "Performs an action for each element of this stream. This is a terminal operation. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eaction\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003e non-interfering\u003c/a\u003e action to perform on the elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "forEachOrdered",
      "comment": "Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order. This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#forEach(java.util.function.IntConsumer)\"\u003e\u003ccode\u003eforEach(IntConsumer)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eaction\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003e non-interfering\u003c/a\u003e action to perform on the elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toArray",
      "comment": "Returns an array containing the elements of this stream. This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "an array containing the elements of this stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "reduce",
      "comment": "Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to: \n     int result \u003d identity;\n     for (int element : this stream)\n         result \u003d accumulator.applyAsInt(result, element)\n     return result;\n but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all x, accumulator.apply(identity, x) is equal to x. The accumulator function must be an associative function. This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#sum()\"\u003e\u003ccode\u003esum()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#min()\"\u003e\u003ccode\u003emin()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#max()\"\u003e\u003ccode\u003emax()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#average()\"\u003e\u003ccode\u003eaverage()\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Sum, min and max are all special cases of reduction that can be expressed using this method. For example, summing a stream can be expressed as: \n\u003cpre\u003e\u003ccode\u003e\n     int sum \u003d integers.reduce(0, (a, b) -\u0026gt; a+b);\n \u003c/code\u003e\u003c/pre\u003e or more compactly: \n\u003cpre\u003e\u003ccode\u003e\n     int sum \u003d integers.reduce(0, Integer::sum);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eWhile this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eidentity\u003c/code\u003e - the identity value for the accumulating function",
          "\u003ccode\u003eop\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function for combining two values"
        ],
        "return": [
          "the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.OptionalInt",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "reduce",
      "comment": "Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an OptionalInt describing the reduced value, if any. This is equivalent to: \n     boolean foundAny \u003d false;\n     int result \u003d null;\n     for (int element : this stream) {\n         if (!foundAny) {\n             foundAny \u003d true;\n             result \u003d element;\n         }\n         else\n             result \u003d accumulator.applyAsInt(result, element);\n     }\n     return foundAny ? OptionalInt.of(result) : OptionalInt.empty();\n but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#reduce(int,java.util.function.IntBinaryOperator)\"\u003e\u003ccode\u003ereduce(int, IntBinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function for combining two values"
        ],
        "return": [
          "the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "R",
        "type": "Class"
      },
      "genericParameters": [
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "collect",
      "comment": "Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: \n     R result \u003d supplier.get();\n     for (int element : this stream)\n         accumulator.accept(result, element);\n     return result;\n Like reduce(int, IntBinaryOperator), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eR\u003c/code\u003e - the type of the mutable result container"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)\"\u003e\u003ccode\u003eStream.collect(Supplier, BiConsumer, BiConsumer)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esupplier\u003c/code\u003e - a function that creates a new mutable result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.",
          "\u003ccode\u003eaccumulator\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that must fold an element into a result container.",
          "\u003ccode\u003ecombiner\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that accepts two partial result containers and merges them, which must be compatible with the accumulator function. The combiner function must fold the elements from the second result container into the first result container."
        ],
        "return": [
          "the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "sum",
      "comment": "Returns the sum of elements in this stream. This is a special case of a reduction and is equivalent to: \n     return reduce(0, Integer::sum);\n This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the sum of elements in this stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.OptionalInt",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "min",
      "comment": "Returns an OptionalInt describing the minimum element of this stream, or an empty optional if this stream is empty. This is a special case of a reduction and is equivalent to: \n     return reduce(Integer::min);\n This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "an \n\u003ccode\u003eOptionalInt\u003c/code\u003e containing the minimum element of this stream, or an empty \n\u003ccode\u003eOptionalInt\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.OptionalInt",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "max",
      "comment": "Returns an OptionalInt describing the maximum element of this stream, or an empty optional if this stream is empty. This is a special case of a reduction and is equivalent to: \n     return reduce(Integer::max);\n This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "an \n\u003ccode\u003eOptionalInt\u003c/code\u003e containing the maximum element of this stream, or an empty \n\u003ccode\u003eOptionalInt\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "count",
      "comment": "Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to: \n     return mapToLong(e -\u003e 1L).sum();\n This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "An implementation may choose to not execute the stream pipeline (either sequentially or in parallel) if it is capable of computing the count directly from the stream source. In such cases no source elements will be traversed and no intermediate operations will be evaluated. Behavioral parameters with side-effects, which are strongly discouraged except for harmless cases such as debugging, may be affected. For example, consider the following stream: \n\u003cpre\u003e\u003ccode\u003e\n     IntStream s \u003d IntStream.of(1, 2, 3, 4);\n     long count \u003d s.peek(System.out::println).count();\n \u003c/code\u003e\u003c/pre\u003e The number of elements covered by the stream source is known and the intermediate operation, \n\u003ccode\u003epeek\u003c/code\u003e, does not inject into or remove elements from the stream (as may be the case for \n\u003ccode\u003eflatMap\u003c/code\u003e or \n\u003ccode\u003efilter\u003c/code\u003e operations). Thus the count is 4 and there is no need to execute the pipeline and, as a side-effect, print out the elements."
        ],
        "return": [
          "the count of elements in this stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.OptionalDouble",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "average",
      "comment": "Returns an OptionalDouble describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty. This is a special case of a reduction. This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "an \n\u003ccode\u003eOptionalDouble\u003c/code\u003e containing the average element of this stream, or an empty optional if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.IntSummaryStatistics",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "summaryStatistics",
      "comment": "Returns an IntSummaryStatistics describing various summary data about the elements of this stream. This is a special case of a reduction. This is a terminal operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "an \n\u003ccode\u003eIntSummaryStatistics\u003c/code\u003e describing various summary data about the elements of this stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "anyMatch",
      "comment": "Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "This method evaluates the \n\u003cem\u003eexistential quantification\u003c/em\u003e of the predicate over the elements of the stream (for some x P(x))."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements of this stream"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if any elements of the stream match the provided predicate, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "allMatch",
      "comment": "Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "This method evaluates the \n\u003cem\u003euniversal quantification\u003c/em\u003e of the predicate over the elements of the stream (for all x P(x)). If the stream is empty, the quantification is said to be \n\u003cem\u003evacuously satisfied\u003c/em\u003e and is always \n\u003ccode\u003etrue\u003c/code\u003e (regardless of P(x))."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements of this stream"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if either all elements of the stream match the provided predicate or the stream is empty, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "noneMatch",
      "comment": "Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "This method evaluates the \n\u003cem\u003euniversal quantification\u003c/em\u003e of the negated predicate over the elements of the stream (for all x ~P(x)). If the stream is empty, the quantification is said to be vacuously satisfied and is always \n\u003ccode\u003etrue\u003c/code\u003e, regardless of P(x)."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements of this stream"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if either no elements of the stream match the provided predicate or the stream is empty, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.OptionalInt",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "findFirst",
      "comment": "Returns an OptionalInt describing the first element of this stream, or an empty OptionalInt if the stream is empty. If the stream has no encounter order, then any element may be returned. This is a short-circuiting terminal operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "an \n\u003ccode\u003eOptionalInt\u003c/code\u003e describing the first element of this stream, or an empty \n\u003ccode\u003eOptionalInt\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.OptionalInt",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "findAny",
      "comment": "Returns an OptionalInt describing some element of the stream, or an empty OptionalInt if the stream is empty. This is a short-circuiting terminal operation. The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use findFirst() instead.)",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html#findFirst()\"\u003e\u003ccode\u003efindFirst()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an \n\u003ccode\u003eOptionalInt\u003c/code\u003e describing some element of this stream, or an empty \n\u003ccode\u003eOptionalInt\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.LongStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "asLongStream",
      "comment": "Returns a LongStream consisting of the elements of this stream, converted to long. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eLongStream\u003c/code\u003e consisting of the elements of this stream, converted to \n\u003ccode\u003elong\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.DoubleStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "asDoubleStream",
      "comment": "Returns a DoubleStream consisting of the elements of this stream, converted to double. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eDoubleStream\u003c/code\u003e consisting of the elements of this stream, converted to \n\u003ccode\u003edouble\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "java.lang.Integer",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "boxed",
      "comment": "Returns a Stream consisting of the elements of this stream, each boxed to an Integer. This is an intermediate operation.",
      "annotations": [],
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eStream\u003c/code\u003e consistent of the elements of this stream, each boxed to an \n\u003ccode\u003eInteger\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream$Builder",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "builder",
      "comment": "Returns a builder for an IntStream.",
      "annotations": [],
      "tagMap": {
        "return": [
          "a stream builder"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "empty",
      "comment": "Returns an empty sequential IntStream.",
      "annotations": [],
      "tagMap": {
        "return": [
          "an empty sequential stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "of",
      "comment": "Returns a sequential IntStream containing a single element.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003et\u003c/code\u003e - the single element"
        ],
        "return": [
          "a singleton sequential stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "of",
      "comment": "Returns a sequential ordered stream whose elements are the specified values.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003evalues\u003c/code\u003e - the elements of the new stream"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "iterate",
      "comment": "Returns an infinite sequential ordered IntStream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the IntStream will be the provided seed. For n \u003e 0, the element at position n, will be the result of applying the function f to the element at position n - 1. The action of applying f for one element happens-before the action of applying f for subsequent elements. For any given element the action may be performed in whatever thread the library chooses.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eseed\u003c/code\u003e - the initial element",
          "\u003ccode\u003ef\u003c/code\u003e - a function to be applied to the previous element to produce a new element"
        ],
        "return": [
          "a new sequential \n\u003ccode\u003eIntStream\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "iterate",
      "comment": "Returns a sequential ordered IntStream produced by iterative application of the given next function to an initial element, conditioned on satisfying the given hasNext predicate. The stream terminates as soon as the hasNext predicate returns false. IntStream.iterate should produce the same sequence of elements as produced by the corresponding for-loop: \n     for (int index\u003dseed; hasNext.test(index); index \u003d next.applyAsInt(index)) {\n         ...\n     }\n The resulting sequence may be empty if the hasNext predicate does not hold on the seed value. Otherwise the first element will be the supplied seed value, the next element (if present) will be the result of applying the next function to the seed value, and so on iteratively until the hasNext predicate indicates that the stream should terminate. The action of applying the hasNext predicate to an element happens-before the action of applying the next function to that element. The action of applying the next function for one element happens-before the action of applying the hasNext predicate for subsequent elements. For any given element an action may be performed in whatever thread the library chooses.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eseed\u003c/code\u003e - the initial element",
          "\u003ccode\u003ehasNext\u003c/code\u003e - a predicate to apply to elements to determine when the stream must terminate.",
          "\u003ccode\u003enext\u003c/code\u003e - a function to be applied to the previous element to produce a new element"
        ],
        "return": [
          "a new sequential \n\u003ccode\u003eIntStream\u003c/code\u003e"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "generate",
      "comment": "Returns an infinite sequential unordered stream where each element is generated by the provided IntSupplier. This is suitable for generating constant streams, streams of random elements, etc.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - the \n\u003ccode\u003eIntSupplier\u003c/code\u003e for generated elements"
        ],
        "return": [
          "a new infinite sequential unordered \n\u003ccode\u003eIntStream\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "range",
      "comment": "Returns a sequential ordered IntStream from startInclusive (inclusive) to endExclusive (exclusive) by an incremental step of 1.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eAn equivalent sequence of increasing values can be produced sequentially using a \u003ccode\u003efor\u003c/code\u003e loop as follows: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     for (int i \u003d startInclusive; i \u0026lt; endExclusive ; i++) { ... }\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the (inclusive) initial value",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - the exclusive upper bound"
        ],
        "return": [
          "a sequential \n\u003ccode\u003eIntStream\u003c/code\u003e for the range of \n\u003ccode\u003eint\u003c/code\u003e elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "rangeClosed",
      "comment": "Returns a sequential ordered IntStream from startInclusive (inclusive) to endInclusive (inclusive) by an incremental step of 1.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eAn equivalent sequence of increasing values can be produced sequentially using a \u003ccode\u003efor\u003c/code\u003e loop as follows: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     for (int i \u003d startInclusive; i \u0026lt;\u003d endInclusive ; i++) { ... }\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the (inclusive) initial value",
          "\u003ccode\u003eendInclusive\u003c/code\u003e - the inclusive upper bound"
        ],
        "return": [
          "a sequential \n\u003ccode\u003eIntStream\u003c/code\u003e for the range of \n\u003ccode\u003eint\u003c/code\u003e elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "concat",
      "comment": "Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream. The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel. When the resulting stream is closed, the close handlers for both input streams are invoked. This method operates on the two input streams and binds each stream to its source. As a result subsequent modifications to an input stream source may not be reflected in the concatenated stream result.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "To preserve optimization opportunities this method binds each stream to its source and accepts only two streams as parameters. For example, the exact size of the concatenated stream source can be computed if the exact size of each input stream source is known. To concatenate more streams without binding, or without nested calls to this method, try creating a stream of streams and flat-mapping with the identity function, for example: \n\u003cpre\u003e\u003ccode\u003e\n     IntStream concat \u003d Stream.of(s1, s2, s3, s4).flatMapToInt(s -\u0026gt; s);\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first stream",
          "\u003ccode\u003eb\u003c/code\u003e - the second stream"
        ],
        "implNote": [
          "Use caution when constructing streams from repeated concatenation. Accessing an element of a deeply concatenated stream can result in deep call chains, or even \n\u003ccode\u003eStackOverflowError\u003c/code\u003e."
        ],
        "return": [
          "the concatenation of the two input streams"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.util.stream.IntStream$IntMapMultiConsumer",
    "java.util.stream.IntStream$Builder"
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "java.util.stream.IntStream",
  "comment": "A sequence of primitive int-valued elements supporting sequential and parallel aggregate operations. This is the \n\u003ccode\u003eint\u003c/code\u003e primitive specialization of \n\u003ca href\u003d\"Stream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eStream\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003eThe following example illustrates an aggregate operation using \u003ca href\u003d\"Stream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eStream\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"IntStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eIntStream\u003c/code\u003e\u003c/a\u003e, computing the sum of the weights of the red widgets: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int sum \u003d widgets.stream()\n                      .filter(w -\u0026gt; w.getColor() \u003d\u003d RED)\n                      .mapToInt(w -\u0026gt; w.getWeight())\n                      .sum();\n \u003c/code\u003e\u003c/pre\u003e See the class documentation for \n\u003ca href\u003d\"Stream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eStream\u003c/code\u003e\u003c/a\u003e and the package documentation for \n\u003ca href\u003d\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e for additional specification of streams, stream operations, stream pipelines, and parallelism.\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eStream\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html\"\u003ejava.util.stream\u003c/a\u003e"
    ],
    "since": [
      "1.8"
    ]
  }
}