{
  "packageName": "java.util.stream",
  "simpleName": "Stream",
  "moduleName": "java.base",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.util.stream.BaseStream",
    "parameters": [
      {
        "name": "T",
        "type": "Class"
      },
      {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      }
    ],
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "predicate"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "filter",
      "comment": "Returns a stream consisting of the elements of this stream that match the given predicate. This is an intermediate operation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to each element to determine if it should be included"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "R",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "R",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "map",
      "comment": "Returns a stream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eR\u003c/code\u003e - The element type of the new stream"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.ToIntFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapToInt",
      "comment": "Returns an IntStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.LongStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.ToLongFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapToLong",
      "comment": "Returns a LongStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.DoubleStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.ToDoubleFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapToDouble",
      "comment": "Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "R",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "java.util.stream.Stream",
                    "parameters": [
                      {
                        "upperBounds": [
                          {
                            "name": "R",
                            "type": "Class"
                          }
                        ],
                        "type": "Wildcard"
                      }
                    ],
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "flatMap",
      "comment": "Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eR\u003c/code\u003e - The element type of the new stream"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)\"\u003e\u003ccode\u003emapMulti(java.util.function.BiConsumer\u0026lt;? super T, ? super java.util.function.Consumer\u0026lt;R\u0026gt;\u0026gt;)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003eflatMap()\u003c/code\u003e operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream. \n\u003cp\u003e\u003cb\u003eExamples.\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eIf \u003ccode\u003eorders\u003c/code\u003e is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a stream containing all the line items in all the orders: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     orders.flatMap(order -\u0026gt; order.getLineItems().stream())...\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eIf \u003ccode\u003epath\u003c/code\u003e is the path to a file, then the following produces a stream of the \u003ccode\u003ewords\u003c/code\u003e contained in that file: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     Stream\u0026lt;String\u0026gt; lines \u003d Files.lines(path, StandardCharsets.UTF_8);\n     Stream\u0026lt;String\u0026gt; words \u003d lines.flatMap(line -\u0026gt; Stream.of(line.split(\" +\")));\n \u003c/code\u003e\u003c/pre\u003e The \n\u003ccode\u003emapper\u003c/code\u003e function passed to \n\u003ccode\u003eflatMap\u003c/code\u003e splits a line, using a simple regular expression, into an array of words, and then creates a stream of words from that array.\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element which produces a stream of new values"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "java.util.stream.IntStream",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "flatMapToInt",
      "comment": "Returns an IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)\"\u003e\u003ccode\u003eflatMap(Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element which produces a stream of new values"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.LongStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "java.util.stream.LongStream",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "flatMapToLong",
      "comment": "Returns an LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)\"\u003e\u003ccode\u003eflatMap(Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element which produces a stream of new values"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.DoubleStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "java.util.stream.DoubleStream",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "flatMapToDouble",
      "comment": "Returns an DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have placed been into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)\"\u003e\u003ccode\u003eflatMap(Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function to apply to each element which produces a stream of new values"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "R",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.BiConsumer",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "lowerBounds": [
                  {
                    "name": "java.util.function.Consumer",
                    "parameters": [
                      {
                        "name": "R",
                        "type": "Class"
                      }
                    ],
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapMulti",
      "comment": "Returns a stream consisting of the results of replacing each element of this stream with multiple elements, specifically zero or more elements. Replacement is performed by applying the provided mapping function to each element in conjunction with a consumer argument that accepts replacement elements. The mapping function calls the consumer zero or more times to provide the replacement elements. This is an intermediate operation. If the consumer argument is used outside the scope of its application to the mapping function, the results are undefined.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eR\u003c/code\u003e - The element type of the new stream"
        ],
        "implSpec": [
          "The default implementation invokes \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)\"\u003e\u003ccode\u003eflatMap\u003c/code\u003e\u003c/a\u003e on this stream, passing a function that behaves as follows. First, it calls the mapper function with a \n\u003ccode\u003eConsumer\u003c/code\u003e that accumulates replacement elements into a newly created internal buffer. When the mapper function returns, it creates a stream from the internal buffer. Finally, it returns this stream to \n\u003ccode\u003eflatMap\u003c/code\u003e."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)\"\u003e\u003ccode\u003eflatMap\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method is similar to \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)\"\u003e\u003ccode\u003eflatMap\u003c/code\u003e\u003c/a\u003e in that it applies a one-to-many transformation to the elements of the stream and flattens the result elements into a new stream. This method is preferable to \n\u003ccode\u003eflatMap\u003c/code\u003e in the following circumstances: \n\u003cul\u003e \n \u003cli\u003eWhen replacing each stream element with a small (possibly zero) number of elements. Using this method avoids the overhead of creating a new Stream instance for every group of result elements, as required by \u003ccode\u003eflatMap\u003c/code\u003e.\u003c/li\u003e \n \u003cli\u003eWhen it is easier to use an imperative approach for generating result elements than it is to return them in the form of a Stream.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003eIf a lambda expression is provided as the mapper function argument, additional type information may be necessary for proper inference of the element type \u003ccode\u003e\u0026lt;R\u0026gt;\u003c/code\u003e of the returned stream. This can be provided in the form of explicit type declarations for the lambda parameters or as an explicit type argument to the \u003ccode\u003emapMulti\u003c/code\u003e call. \u003c/p\u003e\n\u003cp\u003e\u003cb\u003eExamples\u003c/b\u003e \u003c/p\u003e\n\u003cp\u003eGiven a stream of \u003ccode\u003eNumber\u003c/code\u003e objects, the following produces a list containing only the \u003ccode\u003eInteger\u003c/code\u003e objects: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     Stream\u0026lt;Number\u0026gt; numbers \u003d ... ;\n     List\u0026lt;Integer\u0026gt; integers \u003d numbers.\u0026lt;Integer\u0026gt;mapMulti((number, consumer) -\u0026gt; {\n             if (number instanceof Integer)\n                 consumer.accept((Integer) number);\n         })\n         .collect(Collectors.toList());\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eIf we have an \u003ccode\u003eIterable\u0026lt;Object\u0026gt;\u003c/code\u003e and need to recursively expand its elements that are themselves of type \u003ccode\u003eIterable\u003c/code\u003e, we can use \u003ccode\u003emapMulti\u003c/code\u003e as follows: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n class C {\n     static void expandIterable(Object e, Consumer\u0026lt;Object\u0026gt; c) {\n         if (e instanceof Iterable) {\n             for (Object ie: (Iterable\u0026lt;?\u0026gt;) e) {\n                 expandIterable(ie, c);\n             }\n         } else if (e !\u003d null) {\n             c.accept(e);\n         }\n     }\n\n     public static void main(String[] args) {\n         Stream\u0026lt;Object\u0026gt; stream \u003d ...;\n         Stream\u0026lt;Object\u0026gt; expandedStream \u003d stream.mapMulti(C::expandIterable);\n     }\n }\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that generates replacement elements"
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.BiConsumer",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "lowerBounds": [
                  {
                    "name": "java.util.function.IntConsumer",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapMultiToInt",
      "comment": "Returns an IntStream consisting of the results of replacing each element of this stream with multiple elements, specifically zero or more elements. Replacement is performed by applying the provided mapping function to each element in conjunction with a consumer argument that accepts replacement elements. The mapping function calls the consumer zero or more times to provide the replacement elements. This is an intermediate operation. If the consumer argument is used outside the scope of its application to the mapping function, the results are undefined.",
      "tagMap": {
        "implSpec": [
          "The default implementation invokes \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMapToInt(java.util.function.Function)\"\u003e\u003ccode\u003eflatMapToInt\u003c/code\u003e\u003c/a\u003e on this stream, passing a function that behaves as follows. First, it calls the mapper function with an \n\u003ccode\u003eIntConsumer\u003c/code\u003e that accumulates replacement elements into a newly created internal buffer. When the mapper function returns, it creates an \n\u003ccode\u003eIntStream\u003c/code\u003e from the internal buffer. Finally, it returns this stream to \n\u003ccode\u003eflatMapToInt\u003c/code\u003e."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)\"\u003e\u003ccode\u003emapMulti\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that generates replacement elements"
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.LongStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.BiConsumer",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "lowerBounds": [
                  {
                    "name": "java.util.function.LongConsumer",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapMultiToLong",
      "comment": "Returns a LongStream consisting of the results of replacing each element of this stream with multiple elements, specifically zero or more elements. Replacement is performed by applying the provided mapping function to each element in conjunction with a consumer argument that accepts replacement elements. The mapping function calls the consumer zero or more times to provide the replacement elements. This is an intermediate operation. If the consumer argument is used outside the scope of its application to the mapping function, the results are undefined.",
      "tagMap": {
        "implSpec": [
          "The default implementation invokes \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMapToLong(java.util.function.Function)\"\u003e\u003ccode\u003eflatMapToLong\u003c/code\u003e\u003c/a\u003e on this stream, passing a function that behaves as follows. First, it calls the mapper function with a \n\u003ccode\u003eLongConsumer\u003c/code\u003e that accumulates replacement elements into a newly created internal buffer. When the mapper function returns, it creates a \n\u003ccode\u003eLongStream\u003c/code\u003e from the internal buffer. Finally, it returns this stream to \n\u003ccode\u003eflatMapToLong\u003c/code\u003e."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)\"\u003e\u003ccode\u003emapMulti\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that generates replacement elements"
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.DoubleStream",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.BiConsumer",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "lowerBounds": [
                  {
                    "name": "java.util.function.DoubleConsumer",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "mapper"
          }
        }
      ],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "mapMultiToDouble",
      "comment": "Returns a DoubleStream consisting of the results of replacing each element of this stream with multiple elements, specifically zero or more elements. Replacement is performed by applying the provided mapping function to each element in conjunction with a consumer argument that accepts replacement elements. The mapping function calls the consumer zero or more times to provide the replacement elements. This is an intermediate operation. If the consumer argument is used outside the scope of its application to the mapping function, the results are undefined.",
      "tagMap": {
        "implSpec": [
          "The default implementation invokes \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMapToDouble(java.util.function.Function)\"\u003e\u003ccode\u003eflatMapToDouble\u003c/code\u003e\u003c/a\u003e on this stream, passing a function that behaves as follows. First, it calls the mapper function with an \n\u003ccode\u003eDoubleConsumer\u003c/code\u003e that accumulates replacement elements into a newly created internal buffer. When the mapper function returns, it creates a \n\u003ccode\u003eDoubleStream\u003c/code\u003e from the internal buffer. Finally, it returns this stream to \n\u003ccode\u003eflatMapToDouble\u003c/code\u003e."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)\"\u003e\u003ccode\u003emapMulti\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that generates replacement elements"
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "distinct",
      "comment": "Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream. For ordered streams, the selection of distinct elements is stable (for duplicated elements, the element appearing first in the encounter order is preserved.) For unordered streams, no stability guarantees are made. This is a stateful intermediate operation.",
      "tagMap": {
        "apiNote": [
          "Preserving stability for \n\u003ccode\u003edistinct()\u003c/code\u003e in parallel pipelines is relatively expensive (requires that the operation act as a full barrier, with substantial buffering overhead), and stability is often not needed. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#generate(java.util.function.Supplier)\"\u003e\u003ccode\u003egenerate(Supplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significantly more efficient execution for \n\u003ccode\u003edistinct()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003edistinct()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "sorted",
      "comment": "Returns a stream consisting of the elements of this stream, sorted according to natural order. If the elements of this stream are not Comparable, a java.lang.ClassCastException may be thrown when the terminal operation is executed. For ordered streams, the sort is stable. For unordered streams, no stability guarantees are made. This is a stateful intermediate operation.",
      "tagMap": {
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "comparator"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "sorted",
      "comment": "Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator. For ordered streams, the sort is stable. For unordered streams, no stability guarantees are made. This is a stateful intermediate operation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ecomparator\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e \n\u003ccode\u003eComparator\u003c/code\u003e to be used to compare stream elements"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Consumer",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "action"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "peek",
      "comment": "Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation. For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization.",
      "tagMap": {
        "apiNote": [
          "This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline: \n\u003cpre\u003e\u003ccode\u003e\n     Stream.of(\"one\", \"two\", \"three\", \"four\")\n         .filter(e -\u0026gt; e.length() \u0026gt; 3)\n         .peek(e -\u0026gt; System.out.println(\"Filtered value: \" + e))\n         .map(String::toUpperCase)\n         .peek(e -\u0026gt; System.out.println(\"Mapped value: \" + e))\n         .collect(Collectors.toList());\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eIn cases where the stream implementation is able to optimize away the production of some or all the elements (such as with short-circuiting operations like \u003ccode\u003efindFirst\u003c/code\u003e, or in the example described in \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#count()\"\u003e\u003ccode\u003ecount()\u003c/code\u003e\u003c/a\u003e), the action will not be invoked for those elements.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eaction\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003e non-interfering\u003c/a\u003e action to perform on the elements as they are consumed from the stream"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "maxSize"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "limit",
      "comment": "Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length. This is a short-circuiting stateful intermediate operation.",
      "tagMap": {
        "apiNote": [
          "While \n\u003ccode\u003elimit()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of \n\u003ccode\u003emaxSize\u003c/code\u003e, since \n\u003ccode\u003elimit(n)\u003c/code\u003e is constrained to return not just any \n\u003cem\u003en\u003c/em\u003e elements, but the \n\u003cem\u003efirst n\u003c/em\u003e elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#generate(java.util.function.Supplier)\"\u003e\u003ccode\u003egenerate(Supplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003elimit()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003elimit()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003emaxSize\u003c/code\u003e - the number of elements the stream should be limited to"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emaxSize\u003c/code\u003e is negative"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "long",
            "type": "Class"
          },
          "field": {
            "name": "n"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "skip",
      "comment": "Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned. This is a stateful intermediate operation.",
      "tagMap": {
        "apiNote": [
          "While \n\u003ccode\u003eskip()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of \n\u003ccode\u003en\u003c/code\u003e, since \n\u003ccode\u003eskip(n)\u003c/code\u003e is constrained to skip not just any \n\u003cem\u003en\u003c/em\u003e elements, but the \n\u003cem\u003efirst n\u003c/em\u003e elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#generate(java.util.function.Supplier)\"\u003e\u003ccode\u003egenerate(Supplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003eskip()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003eskip()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003en\u003c/code\u003e - the number of leading elements to skip"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003en\u003c/code\u003e is negative"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "predicate"
          }
        }
      ],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "takeWhile",
      "comment": "Returns, if this stream is ordered, a stream consisting of the longest prefix of elements taken from this stream that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of a subset of elements taken from this stream that match the given predicate. If this stream is ordered then the longest prefix is a contiguous sequence of elements of this stream that match the given predicate. The first element of the sequence is the first element of this stream, and the element immediately following the last element of the sequence does not match the given predicate. If this stream is unordered, and some (but not all) elements of this stream match the given predicate, then the behavior of this operation is nondeterministic; it is free to take any subset of matching elements (which includes the empty set). Independent of whether this stream is ordered or unordered if all elements of this stream match the given predicate then this operation takes all elements (the result is the same as the input), or if no elements of the stream match the given predicate then no elements are taken (the result is an empty stream). This is a short-circuiting stateful intermediate operation.",
      "tagMap": {
        "implSpec": [
          "The default implementation obtains the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#spliterator()\"\u003e\u003ccode\u003espliterator\u003c/code\u003e\u003c/a\u003e of this stream, wraps that spliterator so as to support the semantics of this operation on traversal, and returns a new stream associated with the wrapped spliterator. The returned stream preserves the execution characteristics of this stream (namely parallel or sequential execution as per \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#isParallel()\"\u003e\u003ccode\u003eBaseStream.isParallel()\u003c/code\u003e\u003c/a\u003e) but the wrapped spliterator may choose to not support splitting. When the returned stream is closed, the close handlers for both the returned and this stream are invoked."
        ],
        "apiNote": [
          "While \n\u003ccode\u003etakeWhile()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#generate(java.util.function.Supplier)\"\u003e\u003ccode\u003egenerate(Supplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003etakeWhile()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003etakeWhile()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements to determine the longest prefix of elements."
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "predicate"
          }
        }
      ],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "dropWhile",
      "comment": "Returns, if this stream is ordered, a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of the remaining elements of this stream after dropping a subset of elements that match the given predicate. If this stream is ordered then the longest prefix is a contiguous sequence of elements of this stream that match the given predicate. The first element of the sequence is the first element of this stream, and the element immediately following the last element of the sequence does not match the given predicate. If this stream is unordered, and some (but not all) elements of this stream match the given predicate, then the behavior of this operation is nondeterministic; it is free to drop any subset of matching elements (which includes the empty set). Independent of whether this stream is ordered or unordered if all elements of this stream match the given predicate then this operation drops all elements (the result is an empty stream), or if no elements of the stream match the given predicate then no elements are dropped (the result is the same as the input). This is a stateful intermediate operation.",
      "tagMap": {
        "implSpec": [
          "The default implementation obtains the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#spliterator()\"\u003e\u003ccode\u003espliterator\u003c/code\u003e\u003c/a\u003e of this stream, wraps that spliterator so as to support the semantics of this operation on traversal, and returns a new stream associated with the wrapped spliterator. The returned stream preserves the execution characteristics of this stream (namely parallel or sequential execution as per \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#isParallel()\"\u003e\u003ccode\u003eBaseStream.isParallel()\u003c/code\u003e\u003c/a\u003e) but the wrapped spliterator may choose to not support splitting. When the returned stream is closed, the close handlers for both the returned and this stream are invoked."
        ],
        "apiNote": [
          "While \n\u003ccode\u003edropWhile()\u003c/code\u003e is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#generate(java.util.function.Supplier)\"\u003e\u003ccode\u003egenerate(Supplier)\u003c/code\u003e\u003c/a\u003e) or removing the ordering constraint with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#unordered()\"\u003e\u003ccode\u003eBaseStream.unordered()\u003c/code\u003e\u003c/a\u003e may result in significant speedups of \n\u003ccode\u003edropWhile()\u003c/code\u003e in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with \n\u003ccode\u003edropWhile()\u003c/code\u003e in parallel pipelines, switching to sequential execution with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e may improve performance."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements to determine the longest prefix of elements."
        ],
        "return": [
          "the new stream"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Consumer",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "action"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "forEach",
      "comment": "Performs an action for each element of this stream. This is a terminal operation. The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eaction\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003e non-interfering\u003c/a\u003e action to perform on the elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Consumer",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "action"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "forEachOrdered",
      "comment": "Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order. This is a terminal operation. This operation processes the elements one at a time, in encounter order if one exists. Performing the action for one element happens-before performing the action for subsequent elements, but for any given element, the action may be performed in whatever thread the library chooses.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#forEach(java.util.function.Consumer)\"\u003e\u003ccode\u003eforEach(Consumer)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eaction\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003e non-interfering\u003c/a\u003e action to perform on the elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toArray",
      "comment": "Returns an array containing the elements of this stream. This is a terminal operation.",
      "tagMap": {
        "return": [
          "an array, whose \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#getComponentType()\"\u003eruntime component type\u003c/a\u003e is \n\u003ccode\u003eObject\u003c/code\u003e, containing the elements of this stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "A",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.IntFunction",
            "parameters": [
              {
                "name": "A",
                "type": "Class",
                "arrayDimensions": [
                  {}
                ]
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "generator"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toArray",
      "comment": "Returns an array containing the elements of this stream, using the provided generator function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing. This is a terminal operation.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - the component type of the resulting array"
        ],
        "apiNote": [
          "The generator function takes an integer, which is the size of the desired array, and produces an array of the desired size. This can be concisely expressed with an array constructor reference: \n\u003cpre\u003e\u003ccode\u003e\n     Person[] men \u003d people.stream()\n                          .filter(p -\u0026gt; p.getGender() \u003d\u003d MALE)\n                          .toArray(Person[]::new);\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003egenerator\u003c/code\u003e - a function which produces a new array of the desired type and the provided length"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayStoreException.html\" title\u003d\"class in java.lang\"\u003eArrayStoreException\u003c/a\u003e\u003c/code\u003e - if the runtime type of any element of this stream is not assignable to the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#getComponentType()\"\u003eruntime component type\u003c/a\u003e of the generated array"
        ],
        "return": [
          "an array containing the elements in this stream"
        ]
      }
    },
    {
      "returnType": {
        "owner": "java.util.stream.Stream",
        "name": "T",
        "type": "Variable"
      },
      "parameters": [
        {
          "type": {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          },
          "field": {
            "name": "identity"
          }
        },
        {
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "owner": "java.util.stream.Stream",
                "name": "T",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "accumulator"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "reduce",
      "comment": "Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to: \n     T result \u003d identity;\n     for (T element : this stream)\n         result \u003d accumulator.apply(result, element)\n     return result;\n but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all t, accumulator.apply(identity, t) is equal to t. The accumulator function must be an associative function. This is a terminal operation.",
      "tagMap": {
        "apiNote": [
          "Sum, min, max, average, and string concatenation are all special cases of reduction. Summing a stream of numbers can be expressed as: \n\u003cpre\u003e\u003ccode\u003e\n     Integer sum \u003d integers.reduce(0, (a, b) -\u0026gt; a+b);\n \u003c/code\u003e\u003c/pre\u003e or: \n\u003cpre\u003e\u003ccode\u003e\n     Integer sum \u003d integers.reduce(0, Integer::sum);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eWhile this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eidentity\u003c/code\u003e - the identity value for the accumulating function",
          "\u003ccode\u003eaccumulator\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function for combining two values"
        ],
        "return": [
          "the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "owner": "java.util.stream.Stream",
                "name": "T",
                "type": "Variable"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "accumulator"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "reduce",
      "comment": "Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any. This is equivalent to: \n     boolean foundAny \u003d false;\n     T result \u003d null;\n     for (T element : this stream) {\n         if (!foundAny) {\n             foundAny \u003d true;\n             result \u003d element;\n         }\n         else\n             result \u003d accumulator.apply(result, element);\n     }\n     return foundAny ? Optional.of(result) : Optional.empty();\n but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#reduce(T,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereduce(Object, BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#min(java.util.Comparator)\"\u003e\u003ccode\u003emin(Comparator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#max(java.util.Comparator)\"\u003e\u003ccode\u003emax(Comparator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eaccumulator\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function for combining two values"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the result of the reduction is null"
        ],
        "return": [
          "an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Optional.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eOptional\u003c/code\u003e\u003c/a\u003e describing the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "U",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "U",
            "type": "Class"
          },
          "field": {
            "name": "identity"
          }
        },
        {
          "type": {
            "name": "java.util.function.BiFunction",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "accumulator"
          }
        },
        {
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "combiner"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "reduce",
      "comment": "Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions. This is equivalent to: \n     U result \u003d identity;\n     for (T element : this stream)\n         result \u003d accumulator.apply(result, element)\n     return result;\n but is not constrained to execute sequentially. The identity value must be an identity for the combiner function. This means that for all u, combiner(identity, u) is equal to u. Additionally, the combiner function must be compatible with the accumulator function; for all u and t, the following must hold: \n     combiner.apply(u, accumulator.apply(identity, t)) \u003d\u003d accumulator.apply(u, t)\n This is a terminal operation.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eU\u003c/code\u003e - The type of the result"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereduce(BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#reduce(T,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereduce(Object, BinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Many reductions using this form can be represented more simply by an explicit combination of \n\u003ccode\u003emap\u003c/code\u003e and \n\u003ccode\u003ereduce\u003c/code\u003e operations. The \n\u003ccode\u003eaccumulator\u003c/code\u003e function acts as a fused mapper and accumulator, which can sometimes be more efficient than separate mapping and reduction, such as when knowing the previously reduced value allows you to avoid some computation."
        ],
        "param": [
          "\u003ccode\u003eidentity\u003c/code\u003e - the identity value for the combiner function",
          "\u003ccode\u003eaccumulator\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function for incorporating an additional element into a result",
          "\u003ccode\u003ecombiner\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function for combining two values, which must be compatible with the accumulator function"
        ],
        "return": [
          "the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "R",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Supplier",
            "parameters": [
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "supplier"
          }
        },
        {
          "type": {
            "name": "java.util.function.BiConsumer",
            "parameters": [
              {
                "name": "R",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "accumulator"
          }
        },
        {
          "type": {
            "name": "java.util.function.BiConsumer",
            "parameters": [
              {
                "name": "R",
                "type": "Class"
              },
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "combiner"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "collect",
      "comment": "Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: \n     R result \u003d supplier.get();\n     for (T element : this stream)\n         accumulator.accept(result, element);\n     return result;\n Like reduce(Object, BinaryOperator), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eR\u003c/code\u003e - the type of the mutable result container"
        ],
        "apiNote": [
          "There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to \n\u003ccode\u003ecollect()\u003c/code\u003e. For example, the following will accumulate strings into an \n\u003ccode\u003eArrayList\u003c/code\u003e: \n\u003cpre\u003e\u003ccode\u003e\n     List\u0026lt;String\u0026gt; asList \u003d stringStream.collect(ArrayList::new, ArrayList::add,\n                                                ArrayList::addAll);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eThe following will take a stream of strings and concatenates them into a single string: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     String concat \u003d stringStream.collect(StringBuilder::new, StringBuilder::append,\n                                          StringBuilder::append)\n                                 .toString();\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003esupplier\u003c/code\u003e - a function that creates a new mutable result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.",
          "\u003ccode\u003eaccumulator\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that must fold an element into a result container.",
          "\u003ccode\u003ecombiner\u003c/code\u003e - an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e function that accepts two partial result containers and merges them, which must be compatible with the accumulator function. The combiner function must fold the elements from the second result container into the first result container."
        ],
        "return": [
          "the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "R",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "collector"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "R",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "collect",
      "comment": "Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning. If the stream is parallel, and the Collector is concurrent, and either the stream is unordered or the collector is unordered, then a concurrent reduction will be performed (see Collector for details on concurrent reduction.) This is a terminal operation. When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures (such as ArrayList), no additional synchronization is needed for a parallel reduction.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eR\u003c/code\u003e - the type of the result",
          "\u003ccode\u003eA\u003c/code\u003e - the intermediate accumulation type of the \n\u003ccode\u003eCollector\u003c/code\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)\"\u003e\u003ccode\u003ecollect(Supplier, BiConsumer, BiConsumer)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html\" title\u003d\"class in java.util.stream\"\u003e\u003ccode\u003eCollectors\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The following will accumulate strings into a List: \n\u003cpre\u003e\u003ccode\u003e\n     List\u0026lt;String\u0026gt; asList \u003d stringStream.collect(Collectors.toList());\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eThe following will classify \u003ccode\u003ePerson\u003c/code\u003e objects by city: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     Map\u0026lt;String, List\u0026lt;Person\u0026gt;\u0026gt; peopleByCity\n         \u003d personStream.collect(Collectors.groupingBy(Person::getCity));\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe following will classify \u003ccode\u003ePerson\u003c/code\u003e objects by state and city, cascading two \u003ccode\u003eCollector\u003c/code\u003es together: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     Map\u0026lt;String, Map\u0026lt;String, List\u0026lt;Person\u0026gt;\u0026gt;\u0026gt; peopleByStateAndCity\n         \u003d personStream.collect(Collectors.groupingBy(Person::getState,\n                                                      Collectors.groupingBy(Person::getCity)));\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ecollector\u003c/code\u003e - the \n\u003ccode\u003eCollector\u003c/code\u003e describing the reduction"
        ],
        "return": [
          "the result of the reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "toList",
      "comment": "Accumulates the elements of this stream into a List. The elements in the list will be in this stream\u0027s encounter order, if one exists. The returned List is unmodifiable; calls to any mutator method will always cause UnsupportedOperationException to be thrown. There are no guarantees on the implementation type or serializability of the returned List. The returned instance may be value-based. Callers should make no assumptions about the identity of the returned instances. Identity-sensitive operations on these instances (reference equality (\u003d\u003d), identity hash code, and synchronization) are unreliable and should be avoided. This is a terminal operation.",
      "tagMap": {
        "implSpec": [
          "The implementation in this interface returns a List produced as if by the following: \n\u003cpre\u003e\u003ccode\u003e\n Collections.unmodifiableList(new ArrayList\u0026lt;\u0026gt;(Arrays.asList(this.toArray())))\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "apiNote": [
          "If more control over the returned object is required, use \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toCollection(java.util.function.Supplier)\"\u003e\u003ccode\u003eCollectors.toCollection(Supplier)\u003c/code\u003e\u003c/a\u003e."
        ],
        "implNote": [
          "Most instances of Stream will override this method and provide an implementation that is highly optimized compared to the implementation in this interface."
        ],
        "return": [
          "a List containing the stream elements"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "comparator"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "min",
      "comment": "Returns the minimum element of this stream according to the provided Comparator. This is a special case of a reduction. This is a terminal operation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ecomparator\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e \n\u003ccode\u003eComparator\u003c/code\u003e to compare elements of this stream"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the minimum element is null"
        ],
        "return": [
          "an \n\u003ccode\u003eOptional\u003c/code\u003e describing the minimum element of this stream, or an empty \n\u003ccode\u003eOptional\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "comparator"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "max",
      "comment": "Returns the maximum element of this stream according to the provided Comparator. This is a special case of a reduction. This is a terminal operation.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ecomparator\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e \n\u003ccode\u003eComparator\u003c/code\u003e to compare elements of this stream"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the maximum element is null"
        ],
        "return": [
          "an \n\u003ccode\u003eOptional\u003c/code\u003e describing the maximum element of this stream, or an empty \n\u003ccode\u003eOptional\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "count",
      "comment": "Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to: \n     return mapToLong(e -\u003e 1L).sum();\n This is a terminal operation.",
      "tagMap": {
        "apiNote": [
          "An implementation may choose to not execute the stream pipeline (either sequentially or in parallel) if it is capable of computing the count directly from the stream source. In such cases no source elements will be traversed and no intermediate operations will be evaluated. Behavioral parameters with side-effects, which are strongly discouraged except for harmless cases such as debugging, may be affected. For example, consider the following stream: \n\u003cpre\u003e\u003ccode\u003e\n     List\u0026lt;String\u0026gt; l \u003d Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n     long count \u003d l.stream().peek(System.out::println).count();\n \u003c/code\u003e\u003c/pre\u003e The number of elements covered by the stream source, a \n\u003ccode\u003eList\u003c/code\u003e, is known and the intermediate operation, \n\u003ccode\u003epeek\u003c/code\u003e, does not inject into or remove elements from the stream (as may be the case for \n\u003ccode\u003eflatMap\u003c/code\u003e or \n\u003ccode\u003efilter\u003c/code\u003e operations). Thus the count is the size of the \n\u003ccode\u003eList\u003c/code\u003e and there is no need to execute the pipeline and, as a side-effect, print out the list elements."
        ],
        "return": [
          "the count of elements in this stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "predicate"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "anyMatch",
      "comment": "Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.",
      "tagMap": {
        "apiNote": [
          "This method evaluates the \n\u003cem\u003eexistential quantification\u003c/em\u003e of the predicate over the elements of the stream (for some x P(x))."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements of this stream"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if any elements of the stream match the provided predicate, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "predicate"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "allMatch",
      "comment": "Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.",
      "tagMap": {
        "apiNote": [
          "This method evaluates the \n\u003cem\u003euniversal quantification\u003c/em\u003e of the predicate over the elements of the stream (for all x P(x)). If the stream is empty, the quantification is said to be \n\u003cem\u003evacuously satisfied\u003c/em\u003e and is always \n\u003ccode\u003etrue\u003c/code\u003e (regardless of P(x))."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements of this stream"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if either all elements of the stream match the provided predicate or the stream is empty, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "owner": "java.util.stream.Stream",
                    "name": "T",
                    "type": "Variable"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "predicate"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "noneMatch",
      "comment": "Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.",
      "tagMap": {
        "apiNote": [
          "This method evaluates the \n\u003cem\u003euniversal quantification\u003c/em\u003e of the negated predicate over the elements of the stream (for all x ~P(x)). If the stream is empty, the quantification is said to be vacuously satisfied and is always \n\u003ccode\u003etrue\u003c/code\u003e, regardless of P(x)."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e predicate to apply to elements of this stream"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if either no elements of the stream match the provided predicate or the stream is empty, otherwise \n\u003ccode\u003efalse\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "findFirst",
      "comment": "Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned. This is a short-circuiting terminal operation.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the element selected is null"
        ],
        "return": [
          "an \n\u003ccode\u003eOptional\u003c/code\u003e describing the first element of this stream, or an empty \n\u003ccode\u003eOptional\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "owner": "java.util.stream.Stream",
            "name": "T",
            "type": "Variable"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "findAny",
      "comment": "Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty. This is a short-circuiting terminal operation. The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use findFirst() instead.)",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#findFirst()\"\u003e\u003ccode\u003efindFirst()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the element selected is null"
        ],
        "return": [
          "an \n\u003ccode\u003eOptional\u003c/code\u003e describing some element of this stream, or an empty \n\u003ccode\u003eOptional\u003c/code\u003e if the stream is empty"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream$Builder",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "builder",
      "comment": "Returns a builder for a Stream.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - type of elements"
        ],
        "return": [
          "a stream builder"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "empty",
      "comment": "Returns an empty sequential Stream.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of stream elements"
        ],
        "return": [
          "an empty sequential stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "T",
            "type": "Class"
          },
          "field": {
            "name": "t"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "of",
      "comment": "Returns a sequential Stream containing a single element.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of stream elements"
        ],
        "param": [
          "\u003ccode\u003et\u003c/code\u003e - the single element"
        ],
        "return": [
          "a singleton sequential stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "T",
            "type": "Class"
          },
          "field": {
            "name": "t"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "ofNullable",
      "comment": "Returns a sequential Stream containing a single element, if non-null, otherwise returns an empty Stream.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of stream elements"
        ],
        "param": [
          "\u003ccode\u003et\u003c/code\u003e - the single element"
        ],
        "return": [
          "a stream with a single element if the specified element is non-null, otherwise an empty stream"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "T",
            "type": "Class"
          },
          "field": {
            "name": "values"
          },
          "varArgs": {}
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "of",
      "comment": "Returns a sequential ordered stream whose elements are the specified values.",
      "annotations": [
        {
          "type": "SafeVarargs"
        }
      ],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of stream elements"
        ],
        "param": [
          "\u003ccode\u003evalues\u003c/code\u003e - the elements of the new stream"
        ],
        "return": [
          "the new stream"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "T",
            "type": "Class"
          },
          "field": {
            "name": "seed"
          }
        },
        {
          "type": {
            "name": "java.util.function.UnaryOperator",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "f"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "iterate",
      "comment": "Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the Stream will be the provided seed. For n \u003e 0, the element at position n, will be the result of applying the function f to the element at position n - 1. The action of applying f for one element happens-before the action of applying f for subsequent elements. For any given element the action may be performed in whatever thread the library chooses.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of stream elements"
        ],
        "param": [
          "\u003ccode\u003eseed\u003c/code\u003e - the initial element",
          "\u003ccode\u003ef\u003c/code\u003e - a function to be applied to the previous element to produce a new element"
        ],
        "return": [
          "a new sequential \n\u003ccode\u003eStream\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "T",
            "type": "Class"
          },
          "field": {
            "name": "seed"
          }
        },
        {
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "hasNext"
          }
        },
        {
          "type": {
            "name": "java.util.function.UnaryOperator",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "next"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "iterate",
      "comment": "Returns a sequential ordered Stream produced by iterative application of the given next function to an initial element, conditioned on satisfying the given hasNext predicate. The stream terminates as soon as the hasNext predicate returns false. Stream.iterate should produce the same sequence of elements as produced by the corresponding for-loop: \n     for (T index\u003dseed; hasNext.test(index); index \u003d next.apply(index)) {\n         ...\n     }\n The resulting sequence may be empty if the hasNext predicate does not hold on the seed value. Otherwise the first element will be the supplied seed value, the next element (if present) will be the result of applying the next function to the seed value, and so on iteratively until the hasNext predicate indicates that the stream should terminate. The action of applying the hasNext predicate to an element happens-before the action of applying the next function to that element. The action of applying the next function for one element happens-before the action of applying the hasNext predicate for subsequent elements. For any given element an action may be performed in whatever thread the library chooses.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of stream elements"
        ],
        "param": [
          "\u003ccode\u003eseed\u003c/code\u003e - the initial element",
          "\u003ccode\u003ehasNext\u003c/code\u003e - a predicate to apply to elements to determine when the stream must terminate.",
          "\u003ccode\u003enext\u003c/code\u003e - a function to be applied to the previous element to produce a new element"
        ],
        "return": [
          "a new sequential \n\u003ccode\u003eStream\u003c/code\u003e"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.Supplier",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "s"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "generate",
      "comment": "Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of stream elements"
        ],
        "param": [
          "\u003ccode\u003es\u003c/code\u003e - the \n\u003ccode\u003eSupplier\u003c/code\u003e of generated elements"
        ],
        "return": [
          "a new infinite sequential unordered \n\u003ccode\u003eStream\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.stream.Stream",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "a"
          }
        },
        {
          "type": {
            "name": "java.util.stream.Stream",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "b"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "concat",
      "comment": "Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream. The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel. When the resulting stream is closed, the close handlers for both input streams are invoked. This method operates on the two input streams and binds each stream to its source. As a result subsequent modifications to an input stream source may not be reflected in the concatenated stream result.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - The type of stream elements"
        ],
        "apiNote": [
          "To preserve optimization opportunities this method binds each stream to its source and accepts only two streams as parameters. For example, the exact size of the concatenated stream source can be computed if the exact size of each input stream source is known. To concatenate more streams without binding, or without nested calls to this method, try creating a stream of streams and flat-mapping with the identity function, for example: \n\u003cpre\u003e\u003ccode\u003e\n     Stream\u0026lt;T\u0026gt; concat \u003d Stream.of(s1, s2, s3, s4).flatMap(s -\u0026gt; s);\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first stream",
          "\u003ccode\u003eb\u003c/code\u003e - the second stream"
        ],
        "implNote": [
          "Use caution when constructing streams from repeated concatenation. Accessing an element of a deeply concatenated stream can result in deep call chains, or even \n\u003ccode\u003eStackOverflowError\u003c/code\u003e. \n\u003cp\u003eSubsequent changes to the sequential/parallel execution mode of the returned stream are not guaranteed to be propagated to the input streams.\u003c/p\u003e"
        ],
        "return": [
          "the concatenation of the two input streams"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.util.stream.Stream$Builder"
  ],
  "genericParameters": [
    {
      "name": "T",
      "type": "Variable"
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "java.util.stream.Stream",
  "comment": "A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using \n\u003ca href\u003d\"Stream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eStream\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"IntStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eIntStream\u003c/code\u003e\u003c/a\u003e: \n\u003cpre\u003e\u003ccode\u003e\n     int sum \u003d widgets.stream()\n                      .filter(w -\u0026gt; w.getColor() \u003d\u003d RED)\n                      .mapToInt(w -\u0026gt; w.getWeight())\n                      .sum();\n \u003c/code\u003e\u003c/pre\u003e In this example, \n\u003ccode\u003ewidgets\u003c/code\u003e is a \n\u003ccode\u003eCollection\u0026lt;Widget\u0026gt;\u003c/code\u003e. We create a stream of \n\u003ccode\u003eWidget\u003c/code\u003e objects via \n\u003ca href\u003d\"../Collection.html#stream()\"\u003e\u003ccode\u003eCollection.stream()\u003c/code\u003e\u003c/a\u003e, filter it to produce a stream containing only the red widgets, and then transform it into a stream of \n\u003ccode\u003eint\u003c/code\u003e values representing the weight of each red widget. Then this stream is summed to produce a total weight. \n\u003cp\u003eIn addition to \u003ccode\u003eStream\u003c/code\u003e, which is a stream of object references, there are primitive specializations for \u003ca href\u003d\"IntStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eIntStream\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"LongStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eLongStream\u003c/code\u003e\u003c/a\u003e, and \u003ca href\u003d\"DoubleStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eDoubleStream\u003c/code\u003e\u003c/a\u003e, all of which are referred to as \"streams\" and conform to the characteristics and restrictions described here. \u003c/p\u003e\n\u003cp\u003eTo perform a computation, stream \u003ca href\u003d\"package-summary.html#StreamOps\"\u003eoperations\u003c/a\u003e are composed into a \u003cem\u003estream pipeline\u003c/em\u003e. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more \u003cem\u003eintermediate operations\u003c/em\u003e (which transform a stream into another stream, such as \u003ca href\u003d\"#filter(java.util.function.Predicate)\"\u003e\u003ccode\u003efilter(Predicate)\u003c/code\u003e\u003c/a\u003e), and a \u003cem\u003eterminal operation\u003c/em\u003e (which produces a result or side-effect, such as \u003ca href\u003d\"#count()\"\u003e\u003ccode\u003ecount()\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"#forEach(java.util.function.Consumer)\"\u003e\u003ccode\u003eforEach(Consumer)\u003c/code\u003e\u003c/a\u003e). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. \u003c/p\u003e\n\u003cp\u003eA stream implementation is permitted significant latitude in optimizing the computation of the result. For example, a stream implementation is free to elide operations (or entire stages) from a stream pipeline -- and therefore elide invocation of behavioral parameters -- if it can prove that it would not affect the result of the computation. This means that side-effects of behavioral parameters may not always be executed and should not be relied upon, unless otherwise specified (such as by the terminal operations \u003ccode\u003eforEach\u003c/code\u003e and \u003ccode\u003eforEachOrdered\u003c/code\u003e). (For a specific example of such an optimization, see the API note documented on the \u003ca href\u003d\"#count()\"\u003e\u003ccode\u003ecount()\u003c/code\u003e\u003c/a\u003e operation. For more detail, see the \u003ca href\u003d\"package-summary.html#SideEffects\"\u003eside-effects\u003c/a\u003e section of the stream package documentation.) \u003c/p\u003e\n\u003cp\u003eCollections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the \u003ca href\u003d\"BaseStream.html#iterator()\"\u003e\u003ccode\u003eBaseStream.iterator()\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"BaseStream.html#spliterator()\"\u003e\u003ccode\u003eBaseStream.spliterator()\u003c/code\u003e\u003c/a\u003e operations can be used to perform a controlled traversal. \u003c/p\u003e\n\u003cp\u003eA stream pipeline, like the \"widgets\" example above, can be viewed as a \u003cem\u003equery\u003c/em\u003e on the stream source. Unless the source was explicitly designed for concurrent modification (such as a \u003ca href\u003d\"../concurrent/ConcurrentHashMap.html\" title\u003d\"class in java.util.concurrent\"\u003e\u003ccode\u003eConcurrentHashMap\u003c/code\u003e\u003c/a\u003e), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried. \u003c/p\u003e\n\u003cp\u003eMost stream operations accept parameters that describe user-specified behavior, such as the lambda expression \u003ccode\u003ew -\u0026gt; w.getWeight()\u003c/code\u003e passed to \u003ccode\u003emapToInt\u003c/code\u003e in the example above. To preserve correct behavior, these \u003cem\u003ebehavioral parameters\u003c/em\u003e: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003emust be \u003ca href\u003d\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e (they do not modify the stream source); and\u003c/li\u003e \n \u003cli\u003ein most cases must be \u003ca href\u003d\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e (their result should not depend on any state that might change during execution of the stream pipeline).\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eSuch parameters are always instances of a \u003ca href\u003d\"../function/package-summary.html\"\u003efunctional interface\u003c/a\u003e such as \u003ca href\u003d\"../function/Function.html\" title\u003d\"interface in java.util.function\"\u003e\u003ccode\u003eFunction\u003c/code\u003e\u003c/a\u003e, and are often lambda expressions or method references. Unless otherwise specified these parameters must be \u003cem\u003enon-null\u003c/em\u003e. \u003c/p\u003e\n\u003cp\u003eA stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, \"forked\" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw \u003ca href\u003d\"../../lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eIllegalStateException\u003c/code\u003e\u003c/a\u003e if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases. \u003c/p\u003e\n\u003cp\u003eStreams have a \u003ca href\u003d\"BaseStream.html#close()\"\u003e\u003ccode\u003eBaseStream.close()\u003c/code\u003e\u003c/a\u003e method and implement \u003ca href\u003d\"../../lang/AutoCloseable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eAutoCloseable\u003c/code\u003e\u003c/a\u003e. Operating on a stream after it has been closed will throw \u003ca href\u003d\"../../lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eIllegalStateException\u003c/code\u003e\u003c/a\u003e. Most stream instances do not actually need to be closed after use, as they are backed by collections, arrays, or generating functions, which require no special resource management. Generally, only streams whose source is an IO channel, such as those returned by \u003ca href\u003d\"../../nio/file/Files.html#lines(java.nio.file.Path)\"\u003e\u003ccode\u003eFiles.lines(Path)\u003c/code\u003e\u003c/a\u003e, will require closing. If a stream does require closing, it must be opened as a resource within a try-with-resources statement or similar control structure to ensure that it is closed promptly after its operations have completed. \u003c/p\u003e\n\u003cp\u003eStream pipelines may execute either sequentially or in \u003ca href\u003d\"package-summary.html#Parallelism\"\u003eparallel\u003c/a\u003e. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, \u003ca href\u003d\"../Collection.html#stream()\"\u003e\u003ccode\u003eCollection.stream()\u003c/code\u003e\u003c/a\u003e creates a sequential stream, and \u003ca href\u003d\"../Collection.html#parallelStream()\"\u003e\u003ccode\u003eCollection.parallelStream()\u003c/code\u003e\u003c/a\u003e creates a parallel one.) This choice of execution mode may be modified by the \u003ca href\u003d\"BaseStream.html#sequential()\"\u003e\u003ccode\u003eBaseStream.sequential()\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"BaseStream.html#parallel()\"\u003e\u003ccode\u003eBaseStream.parallel()\u003c/code\u003e\u003c/a\u003e methods, and may be queried with the \u003ca href\u003d\"BaseStream.html#isParallel()\"\u003e\u003ccode\u003eBaseStream.isParallel()\u003c/code\u003e\u003c/a\u003e method.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/IntStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eIntStream\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/LongStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eLongStream\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/DoubleStream.html\" title\u003d\"interface in java.util.stream\"\u003e\u003ccode\u003eDoubleStream\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/package-summary.html\"\u003ejava.util.stream\u003c/a\u003e"
    ],
    "since": [
      "1.8"
    ]
  }
}