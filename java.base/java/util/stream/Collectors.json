{
  "packageName": "java.util.stream",
  "simpleName": "Collectors",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "C",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Supplier",
            "parameters": [
              {
                "name": "C",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "collectionFactory",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "C",
          "upperBounds": [
            {
              "name": "java.util.Collection",
              "parameters": [
                {
                  "name": "T",
                  "type": "Class"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toCollection",
      "comment": "Returns a Collector that accumulates the input elements into a new Collection, in encounter order. The Collection is created by the provided factory.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eC\u003c/code\u003e - the type of the resulting \n\u003ccode\u003eCollection\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ecollectionFactory\u003c/code\u003e - a supplier providing a new empty \n\u003ccode\u003eCollection\u003c/code\u003e into which the results will be inserted"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which collects all the input elements into a \n\u003ccode\u003eCollection\u003c/code\u003e, in encounter order"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toList",
      "comment": "Returns a Collector that accumulates the input elements into a new List. There are no guarantees on the type, mutability, serializability, or thread-safety of the List returned; if more control over the returned List is required, use toCollection(Supplier).",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which collects all the input elements into a \n\u003ccode\u003eList\u003c/code\u003e, in encounter order"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toUnmodifiableList",
      "comment": "Returns a Collector that accumulates the input elements into an unmodifiable List in encounter order. The returned Collector disallows null values and will throw NullPointerException if it is presented with a null value.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that accumulates the input elements into an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/List.html#unmodifiable\"\u003eunmodifiable List\u003c/a\u003e in encounter order"
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Set",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toSet",
      "comment": "Returns a Collector that accumulates the input elements into a new Set. There are no guarantees on the type, mutability, serializability, or thread-safety of the Set returned; if more control over the returned Set is required, use toCollection(Supplier). This is an unordered Collector.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which collects all the input elements into a \n\u003ccode\u003eSet\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Set",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toUnmodifiableSet",
      "comment": "Returns a Collector that accumulates the input elements into an unmodifiable Set. The returned Collector disallows null values and will throw NullPointerException if it is presented with a null value. If the input contains duplicate elements, an arbitrary element of the duplicates is preserved. This is an unordered Collector.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that accumulates the input elements into an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Set.html#unmodifiable\"\u003eunmodifiable Set\u003c/a\u003e"
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "joining",
      "comment": "Returns a Collector that concatenates the input elements into a String, in encounter order.",
      "annotations": [],
      "tagMap": {
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that concatenates the input elements into a \n\u003ccode\u003eString\u003c/code\u003e, in encounter order"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "delimiter",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "joining",
      "comment": "Returns a Collector that concatenates the input elements, separated by the specified delimiter, in encounter order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003edelimiter\u003c/code\u003e - the delimiter to be used between each element"
        ],
        "return": [
          "A \n\u003ccode\u003eCollector\u003c/code\u003e which concatenates CharSequence elements, separated by the specified delimiter, in encounter order"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "delimiter",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "prefix",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "name": "suffix",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "joining",
      "comment": "Returns a Collector that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003edelimiter\u003c/code\u003e - the delimiter to be used between each element",
          "\u003ccode\u003eprefix\u003c/code\u003e - the sequence of characters to be used at the beginning of the joined result",
          "\u003ccode\u003esuffix\u003c/code\u003e - the sequence of characters to be used at the end of the joined result"
        ],
        "return": [
          "A \n\u003ccode\u003eCollector\u003c/code\u003e which concatenates CharSequence elements, separated by the specified delimiter, in encounter order"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "R",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mapping",
      "comment": "Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eU\u003c/code\u003e - type of elements accepted by downstream collector",
          "\u003ccode\u003eA\u003c/code\u003e - intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eR\u003c/code\u003e - result type of collector"
        ],
        "apiNote": [
          "The \n\u003ccode\u003emapping()\u003c/code\u003e collectors are most useful when used in a multi-level reduction, such as downstream of a \n\u003ccode\u003egroupingBy\u003c/code\u003e or \n\u003ccode\u003epartitioningBy\u003c/code\u003e. For example, given a stream of \n\u003ccode\u003ePerson\u003c/code\u003e, to accumulate the set of last names in each city: \n\u003cpre\u003e\u003ccode\u003e\n Map\u0026lt;City, Set\u0026lt;String\u0026gt;\u0026gt; lastNamesByCity\n   \u003d people.stream().collect(\n     groupingBy(Person::getCity,\n                mapping(Person::getLastName,\n                        toSet())));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function to be applied to the input elements",
          "\u003ccode\u003edownstream\u003c/code\u003e - a collector which will accept mapped values"
        ],
        "return": [
          "a collector which applies the mapping function to the input elements and provides the mapped results to the downstream collector"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "R",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "java.util.stream.Stream",
                    "parameters": [
                      {
                        "upperBounds": [
                          {
                            "name": "U",
                            "type": "Class"
                          }
                        ],
                        "type": "Wildcard"
                      }
                    ],
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "flatMapping",
      "comment": "Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a flat mapping function to each input element before accumulation. The flat mapping function maps an input element to a stream covering zero or more output elements that are then accumulated downstream. Each mapped stream is closed after its contents have been placed downstream. (If a mapped stream is null an empty stream is used, instead.)",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eU\u003c/code\u003e - type of elements accepted by downstream collector",
          "\u003ccode\u003eA\u003c/code\u003e - intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eR\u003c/code\u003e - result type of collector"
        ],
        "apiNote": [
          "The \n\u003ccode\u003eflatMapping()\u003c/code\u003e collectors are most useful when used in a multi-level reduction, such as downstream of a \n\u003ccode\u003egroupingBy\u003c/code\u003e or \n\u003ccode\u003epartitioningBy\u003c/code\u003e. For example, given a stream of \n\u003ccode\u003eOrder\u003c/code\u003e, to accumulate the set of line items for each customer: \n\u003cpre\u003e\u003ccode\u003e\n Map\u0026lt;String, Set\u0026lt;LineItem\u0026gt;\u0026gt; itemsByCustomerName\n   \u003d orders.stream().collect(\n     groupingBy(Order::getCustomerName,\n                flatMapping(order -\u0026gt; order.getLineItems().stream(),\n                            toSet())));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function to be applied to the input elements, which returns a stream of results",
          "\u003ccode\u003edownstream\u003c/code\u003e - a collector which will receive the elements of the stream returned by mapper"
        ],
        "return": [
          "a collector which applies the mapping function to the input elements and provides the flat mapped results to the downstream collector"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "R",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "predicate",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "filtering",
      "comment": "Adapts a Collector to one accepting elements of the same type T by applying the predicate to each input element and only accumulating if the predicate returns true.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eA\u003c/code\u003e - intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eR\u003c/code\u003e - result type of collector"
        ],
        "apiNote": [
          "The \n\u003ccode\u003efiltering()\u003c/code\u003e collectors are most useful when used in a multi-level reduction, such as downstream of a \n\u003ccode\u003egroupingBy\u003c/code\u003e or \n\u003ccode\u003epartitioningBy\u003c/code\u003e. For example, given a stream of \n\u003ccode\u003eEmployee\u003c/code\u003e, to accumulate the employees in each department that have a salary above a certain threshold: \n\u003cpre\u003e\u003ccode\u003e\n Map\u0026lt;Department, Set\u0026lt;Employee\u0026gt;\u0026gt; wellPaidEmployeesByDepartment\n   \u003d employees.stream().collect(\n     groupingBy(Employee::getDepartment,\n                filtering(e -\u0026gt; e.getSalary() \u0026gt; 2000,\n                          toSet())));\n \u003c/code\u003e\u003c/pre\u003e A filtering collector differs from a stream\u0027s \n\u003ccode\u003efilter()\u003c/code\u003e operation. In this example, suppose there are no employees whose salary is above the threshold in some department. Using a filtering collector as shown above would result in a mapping from that department to an empty \n\u003ccode\u003eSet\u003c/code\u003e. If a stream \n\u003ccode\u003efilter()\u003c/code\u003e operation were done instead, there would be no mapping for that department at all."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a predicate to be applied to the input elements",
          "\u003ccode\u003edownstream\u003c/code\u003e - a collector which will accept values that match the predicate"
        ],
        "return": [
          "a collector which applies the predicate to the input elements and provides matching elements to the downstream collector"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "name": "A",
            "type": "Class"
          },
          {
            "name": "RR",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "name": "R",
                "type": "Class"
              },
              {
                "name": "RR",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "finisher",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "R",
          "type": "Variable"
        },
        {
          "name": "RR",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "collectingAndThen",
      "comment": "Adapts a Collector to perform an additional finishing transformation. For example, one could adapt the toList() collector to always produce an immutable list with: \n List\u003cString\u003e list \u003d people.stream().collect(\n   collectingAndThen(toList(),\n                     Collections::unmodifiableList));",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eA\u003c/code\u003e - intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eR\u003c/code\u003e - result type of the downstream collector",
          "\u003ccode\u003eRR\u003c/code\u003e - result type of the resulting collector"
        ],
        "param": [
          "\u003ccode\u003edownstream\u003c/code\u003e - a collector",
          "\u003ccode\u003efinisher\u003c/code\u003e - a function to be applied to the final result of the downstream collector"
        ],
        "return": [
          "a collector which performs the action of the downstream collector, followed by an additional finishing step"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.Long",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "counting",
      "comment": "Returns a Collector accepting elements of type T that counts the number of input elements. If no elements are present, the result is 0.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "implSpec": [
          "This produces a result equivalent to: \n\u003cpre\u003e\u003ccode\u003e\n     reducing(0L, e -\u0026gt; 1L, Long::sum)\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that counts the input elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Optional",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "comparator",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "minBy",
      "comment": "Returns a Collector that produces the minimal element according to a given Comparator, described as an Optional\u003cT\u003e.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "implSpec": [
          "This produces a result equivalent to: \n\u003cpre\u003e\u003ccode\u003e\n     reducing(BinaryOperator.minBy(comparator))\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003ecomparator\u003c/code\u003e - a \n\u003ccode\u003eComparator\u003c/code\u003e for comparing elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the minimal value"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Optional",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "comparator",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "maxBy",
      "comment": "Returns a Collector that produces the maximal element according to a given Comparator, described as an Optional\u003cT\u003e.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "implSpec": [
          "This produces a result equivalent to: \n\u003cpre\u003e\u003ccode\u003e\n     reducing(BinaryOperator.maxBy(comparator))\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003ecomparator\u003c/code\u003e - a \n\u003ccode\u003eComparator\u003c/code\u003e for comparing elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the maximal value"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.Integer",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToIntFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "summingInt",
      "comment": "Returns a Collector that produces the sum of a integer-valued function applied to the input elements. If no elements are present, the result is 0.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function extracting the property to be summed"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the sum of a derived property"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.Long",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToLongFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "summingLong",
      "comment": "Returns a Collector that produces the sum of a long-valued function applied to the input elements. If no elements are present, the result is 0.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function extracting the property to be summed"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the sum of a derived property"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.Double",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToDoubleFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "summingDouble",
      "comment": "Returns a Collector that produces the sum of a double-valued function applied to the input elements. If no elements are present, the result is 0. The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a NaN or the sum is at any point a NaN then the sum will be NaN.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function extracting the property to be summed"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the sum of a derived property"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.Double",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToIntFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "averagingInt",
      "comment": "Returns a Collector that produces the arithmetic mean of an integer-valued function applied to the input elements. If no elements are present, the result is 0.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function extracting the property to be averaged"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the arithmetic mean of a derived property"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.Double",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToLongFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "averagingLong",
      "comment": "Returns a Collector that produces the arithmetic mean of a long-valued function applied to the input elements. If no elements are present, the result is 0.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function extracting the property to be averaged"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the arithmetic mean of a derived property"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.lang.Double",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToDoubleFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "averagingDouble",
      "comment": "Returns a Collector that produces the arithmetic mean of a double-valued function applied to the input elements. If no elements are present, the result is 0. The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a NaN or the sum is at any point a NaN then the average will be NaN.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a function extracting the property to be averaged"
        ],
        "implNote": [
          "The \n\u003ccode\u003edouble\u003c/code\u003e format can represent all consecutive integers in the range -2\n\u003csup\u003e53\u003c/sup\u003e to 2\n\u003csup\u003e53\u003c/sup\u003e. If the pipeline has more than 2\n\u003csup\u003e53\u003c/sup\u003e values, the divisor in the average computation will saturate at 2\n\u003csup\u003e53\u003c/sup\u003e, leading to additional numerical errors."
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that produces the arithmetic mean of a derived property"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class"
          },
          "name": "identity",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "reducing",
      "comment": "Returns a Collector which performs a reduction of its input elements under a specified BinaryOperator using the provided identity.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - element type for the input and output of the reduction"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#reducing(java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereducing(BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereducing(Object, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003ereducing()\u003c/code\u003e collectors are most useful when used in a multi-level reduction, downstream of \n\u003ccode\u003egroupingBy\u003c/code\u003e or \n\u003ccode\u003epartitioningBy\u003c/code\u003e. To perform a simple reduction on a stream, use \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#reduce(T,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003eStream.reduce(Object, BinaryOperator)\u003c/code\u003e\u003c/a\u003e} instead."
        ],
        "param": [
          "\u003ccode\u003eidentity\u003c/code\u003e - the identity value for the reduction (also, the value that is returned when there are no input elements)",
          "\u003ccode\u003eop\u003c/code\u003e - a \n\u003ccode\u003eBinaryOperator\u0026lt;T\u0026gt;\u003c/code\u003e used to reduce the input elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which implements the reduction operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Optional",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "reducing",
      "comment": "Returns a Collector which performs a reduction of its input elements under a specified BinaryOperator. The result is described as an Optional\u003cT\u003e.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - element type for the input and output of the reduction"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#reducing(T,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereducing(Object, BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereducing(Object, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003ereducing()\u003c/code\u003e collectors are most useful when used in a multi-level reduction, downstream of \n\u003ccode\u003egroupingBy\u003c/code\u003e or \n\u003ccode\u003epartitioningBy\u003c/code\u003e. To perform a simple reduction on a stream, use \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)\"\u003e\u003ccode\u003eStream.reduce(BinaryOperator)\u003c/code\u003e\u003c/a\u003e instead. \n\u003cp\u003eFor example, given a stream of \u003ccode\u003ePerson\u003c/code\u003e, to calculate tallest person in each city: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n Comparator\u0026lt;Person\u0026gt; byHeight \u003d Comparator.comparing(Person::getHeight);\n Map\u0026lt;City, Optional\u0026lt;Person\u0026gt;\u0026gt; tallestByCity\n   \u003d people.stream().collect(\n     groupingBy(Person::getCity,\n                reducing(BinaryOperator.maxBy(byHeight))));\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eop\u003c/code\u003e - a \n\u003ccode\u003eBinaryOperator\u0026lt;T\u0026gt;\u003c/code\u003e used to reduce the input elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which implements the reduction operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "U",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "U",
            "type": "Class"
          },
          "name": "identity",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "reducing",
      "comment": "Returns a Collector which performs a reduction of its input elements under a specified mapping function and BinaryOperator. This is a generalization of reducing(Object, BinaryOperator) which allows a transformation of the elements before reduction.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eU\u003c/code\u003e - the type of the mapped values"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#reducing(T,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereducing(Object, BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#reducing(java.util.function.BinaryOperator)\"\u003e\u003ccode\u003ereducing(BinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The \n\u003ccode\u003ereducing()\u003c/code\u003e collectors are most useful when used in a multi-level reduction, downstream of \n\u003ccode\u003egroupingBy\u003c/code\u003e or \n\u003ccode\u003epartitioningBy\u003c/code\u003e. To perform a simple map-reduce on a stream, use \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)\"\u003e\u003ccode\u003eStream.map(Function)\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#reduce(T,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003eStream.reduce(Object, BinaryOperator)\u003c/code\u003e\u003c/a\u003e instead. \n\u003cp\u003eFor example, given a stream of \u003ccode\u003ePerson\u003c/code\u003e, to calculate the longest last name of residents in each city: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n Comparator\u0026lt;String\u0026gt; byLength \u003d Comparator.comparing(String::length);\n Map\u0026lt;City, String\u0026gt; longestLastNameByCity\n   \u003d people.stream().collect(\n     groupingBy(Person::getCity,\n                reducing(\"\",\n                         Person::getLastName,\n                         BinaryOperator.maxBy(byLength))));\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003eidentity\u003c/code\u003e - the identity value for the reduction (also, the value that is returned when there are no input elements)",
          "\u003ccode\u003emapper\u003c/code\u003e - a mapping function to apply to each input value",
          "\u003ccode\u003eop\u003c/code\u003e - a \n\u003ccode\u003eBinaryOperator\u0026lt;U\u0026gt;\u003c/code\u003e used to reduce the mapped values"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the map-reduce operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "java.util.List",
                "parameters": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "classifier",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "groupingBy",
      "comment": "Returns a Collector implementing a \"group by\" operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map. The classification function maps elements to some key type K. The collector produces a Map\u003cK, List\u003cT\u003e\u003e whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are Lists containing the input elements which map to the associated key under the classification function. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map or List objects returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the type of the keys"
        ],
        "implSpec": [
          "This produces a result similar to: \n\u003cpre\u003e\u003ccode\u003e\n     groupingBy(classifier, toList());\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingBy(Function, Collector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingBy(Function, Supplier, Collector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function)\"\u003e\u003ccode\u003egroupingByConcurrent(Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eclassifier\u003c/code\u003e - the classifier function mapping input elements to keys"
        ],
        "implNote": [
          "The returned \n\u003ccode\u003eCollector\u003c/code\u003e is not concurrent. For parallel stream pipelines, the \n\u003ccode\u003ecombiner\u003c/code\u003e function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting \n\u003ccode\u003eMap\u003c/code\u003e collector is not required, using \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function)\"\u003e\u003ccode\u003egroupingByConcurrent(Function)\u003c/code\u003e\u003c/a\u003e may offer better parallel performance."
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the group-by operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "classifier",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "D",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "groupingBy",
      "comment": "Returns a Collector implementing a cascaded \"group by\" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map\u003cK, D\u003e. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map returned. For example, to compute the set of last names of people in each city: \n Map\u003cCity, Set\u003cString\u003e\u003e namesByCity\n   \u003d people.stream().collect(\n     groupingBy(Person::getCity,\n                mapping(Person::getLastName,\n                        toSet())));",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the type of the keys",
          "\u003ccode\u003eA\u003c/code\u003e - the intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eD\u003c/code\u003e - the result type of the downstream reduction"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function)\"\u003e\u003ccode\u003egroupingBy(Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingBy(Function, Supplier, Collector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Collector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eclassifier\u003c/code\u003e - a classifier function mapping input elements to keys",
          "\u003ccode\u003edownstream\u003c/code\u003e - a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the downstream reduction"
        ],
        "implNote": [
          "The returned \n\u003ccode\u003eCollector\u003c/code\u003e is not concurrent. For parallel stream pipelines, the \n\u003ccode\u003ecombiner\u003c/code\u003e function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Collector)\u003c/code\u003e\u003c/a\u003e may offer better parallel performance."
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the cascaded group-by operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "M",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "classifier",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Supplier",
            "parameters": [
              {
                "name": "M",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mapFactory",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "D",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "M",
          "upperBounds": [
            {
              "name": "java.util.Map",
              "parameters": [
                {
                  "name": "K",
                  "type": "Class"
                },
                {
                  "name": "D",
                  "type": "Class"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "groupingBy",
      "comment": "Returns a Collector implementing a cascaded \"group by\" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The Map produced by the Collector is created with the supplied factory function. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map\u003cK, D\u003e. For example, to compute the set of last names of people in each city, where the city names are sorted: \n Map\u003cCity, Set\u003cString\u003e\u003e namesByCity\n   \u003d people.stream().collect(\n     groupingBy(Person::getCity,\n                TreeMap::new,\n                mapping(Person::getLastName,\n                        toSet())));",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the type of the keys",
          "\u003ccode\u003eA\u003c/code\u003e - the intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eD\u003c/code\u003e - the result type of the downstream reduction",
          "\u003ccode\u003eM\u003c/code\u003e - the type of the resulting \n\u003ccode\u003eMap\u003c/code\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingBy(Function, Collector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function)\"\u003e\u003ccode\u003egroupingBy(Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Supplier, Collector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eclassifier\u003c/code\u003e - a classifier function mapping input elements to keys",
          "\u003ccode\u003edownstream\u003c/code\u003e - a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the downstream reduction",
          "\u003ccode\u003emapFactory\u003c/code\u003e - a supplier providing a new empty \n\u003ccode\u003eMap\u003c/code\u003e into which the results will be inserted"
        ],
        "implNote": [
          "The returned \n\u003ccode\u003eCollector\u003c/code\u003e is not concurrent. For parallel stream pipelines, the \n\u003ccode\u003ecombiner\u003c/code\u003e function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Supplier, Collector)\u003c/code\u003e\u003c/a\u003e may offer better parallel performance."
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the cascaded group-by operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.concurrent.ConcurrentMap",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "java.util.List",
                "parameters": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "classifier",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "groupingByConcurrent",
      "comment": "Returns a concurrent Collector implementing a \"group by\" operation on input elements of type T, grouping elements according to a classification function. This is a concurrent and unordered Collector. The classification function maps elements to some key type K. The collector produces a ConcurrentMap\u003cK, List\u003cT\u003e\u003e whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are Lists containing the input elements which map to the associated key under the classification function. There are no guarantees on the type, mutability, or serializability of the ConcurrentMap or List objects returned, or of the thread-safety of the List objects returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the type of the keys"
        ],
        "implSpec": [
          "This produces a result similar to: \n\u003cpre\u003e\u003ccode\u003e\n     groupingByConcurrent(classifier, toList());\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function)\"\u003e\u003ccode\u003egroupingBy(Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Collector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Supplier, Collector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eclassifier\u003c/code\u003e - a classifier function mapping input elements to keys"
        ],
        "return": [
          "a concurrent, unordered \n\u003ccode\u003eCollector\u003c/code\u003e implementing the group-by operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.concurrent.ConcurrentMap",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "classifier",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "D",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "groupingByConcurrent",
      "comment": "Returns a concurrent Collector implementing a cascaded \"group by\" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. This is a concurrent and unordered Collector. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a ConcurrentMap\u003cK, D\u003e. There are no guarantees on the type, mutability, or serializability of the ConcurrentMap returned. For example, to compute the set of last names of people in each city, where the city names are sorted: \n ConcurrentMap\u003cCity, Set\u003cString\u003e\u003e namesByCity\n   \u003d people.stream().collect(\n     groupingByConcurrent(Person::getCity,\n                          mapping(Person::getLastName,\n                                  toSet())));",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the type of the keys",
          "\u003ccode\u003eA\u003c/code\u003e - the intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eD\u003c/code\u003e - the result type of the downstream reduction"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingBy(Function, Collector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function)\"\u003e\u003ccode\u003egroupingByConcurrent(Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Supplier, Collector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eclassifier\u003c/code\u003e - a classifier function mapping input elements to keys",
          "\u003ccode\u003edownstream\u003c/code\u003e - a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the downstream reduction"
        ],
        "return": [
          "a concurrent, unordered \n\u003ccode\u003eCollector\u003c/code\u003e implementing the cascaded group-by operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "M",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "classifier",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Supplier",
            "parameters": [
              {
                "name": "M",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mapFactory",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        },
        {
          "name": "D",
          "type": "Variable"
        },
        {
          "name": "M",
          "upperBounds": [
            {
              "name": "java.util.concurrent.ConcurrentMap",
              "parameters": [
                {
                  "name": "K",
                  "type": "Class"
                },
                {
                  "name": "D",
                  "type": "Class"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "groupingByConcurrent",
      "comment": "Returns a concurrent Collector implementing a cascaded \"group by\" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The ConcurrentMap produced by the Collector is created with the supplied factory function. This is a concurrent and unordered Collector. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a ConcurrentMap\u003cK, D\u003e. For example, to compute the set of last names of people in each city, where the city names are sorted: \n ConcurrentMap\u003cCity, Set\u003cString\u003e\u003e namesByCity\n   \u003d people.stream().collect(\n     groupingByConcurrent(Person::getCity,\n                          ConcurrentSkipListMap::new,\n                          mapping(Person::getLastName,\n                                  toSet())));",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the type of the keys",
          "\u003ccode\u003eA\u003c/code\u003e - the intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eD\u003c/code\u003e - the result type of the downstream reduction",
          "\u003ccode\u003eM\u003c/code\u003e - the type of the resulting \n\u003ccode\u003eConcurrentMap\u003c/code\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function)\"\u003e\u003ccode\u003egroupingByConcurrent(Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingByConcurrent(Function, Collector)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)\"\u003e\u003ccode\u003egroupingBy(Function, Supplier, Collector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eclassifier\u003c/code\u003e - a classifier function mapping input elements to keys",
          "\u003ccode\u003edownstream\u003c/code\u003e - a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the downstream reduction",
          "\u003ccode\u003emapFactory\u003c/code\u003e - a supplier providing a new empty \n\u003ccode\u003eConcurrentMap\u003c/code\u003e into which the results will be inserted"
        ],
        "return": [
          "a concurrent, unordered \n\u003ccode\u003eCollector\u003c/code\u003e implementing the cascaded group-by operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "java.lang.Boolean",
                "type": "Class"
              },
              {
                "name": "java.util.List",
                "parameters": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "predicate",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "partitioningBy",
      "comment": "Returns a Collector which partitions the input elements according to a Predicate, and organizes them into a Map\u003cBoolean, List\u003cT\u003e\u003e. The returned Map always contains mappings for both false and true keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map or List returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#partitioningBy(java.util.function.Predicate,java.util.stream.Collector)\"\u003e\u003ccode\u003epartitioningBy(Predicate, Collector)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "If a partition has no elements, its value in the result Map will be an empty List."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a predicate used for classifying input elements"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the partitioning operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "java.lang.Boolean",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Predicate",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "predicate",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "A",
                "type": "Class"
              },
              {
                "name": "D",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "D",
          "type": "Variable"
        },
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "partitioningBy",
      "comment": "Returns a Collector which partitions the input elements according to a Predicate, reduces the values in each partition according to another Collector, and organizes them into a Map\u003cBoolean, D\u003e whose values are the result of the downstream reduction. The returned Map always contains mappings for both false and true keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eA\u003c/code\u003e - the intermediate accumulation type of the downstream collector",
          "\u003ccode\u003eD\u003c/code\u003e - the result type of the downstream reduction"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#partitioningBy(java.util.function.Predicate)\"\u003e\u003ccode\u003epartitioningBy(Predicate)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "If a partition has no elements, its value in the result Map will be obtained by calling the downstream collector\u0027s supplier function and then applying the finisher function."
        ],
        "param": [
          "\u003ccode\u003epredicate\u003c/code\u003e - a predicate used for classifying input elements",
          "\u003ccode\u003edownstream\u003c/code\u003e - a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the downstream reduction"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the cascaded partitioning operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toMap",
      "comment": "Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), an IllegalStateException is thrown when the collection operation is performed. If the mapped keys might have duplicates, use toMap(Function, Function, BinaryOperator) instead. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)\"\u003e\u003ccode\u003etoMap(Function, Function, BinaryOperator, Supplier)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "It is common for either the key or the value to be the input elements. In this case, the utility method \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Function.html#identity()\"\u003e\u003ccode\u003eFunction.identity()\u003c/code\u003e\u003c/a\u003e may be helpful. For example, the following produces a \n\u003ccode\u003eMap\u003c/code\u003e mapping students to their grade point average: \n\u003cpre\u003e\u003ccode\u003e\n Map\u0026lt;Student, Double\u0026gt; studentToGPA\n   \u003d students.stream().collect(\n     toMap(Function.identity(),\n           student -\u0026gt; computeGPA(student)));\n \u003c/code\u003e\u003c/pre\u003e And the following produces a \n\u003ccode\u003eMap\u003c/code\u003e mapping a unique identifier to students: \n\u003cpre\u003e\u003ccode\u003e\n Map\u0026lt;String, Student\u0026gt; studentIdToStudent\n   \u003d students.stream().collect(\n     toMap(Student::getId,\n           Function.identity()));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - a mapping function to produce keys",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - a mapping function to produce values"
        ],
        "implNote": [
          "The returned \n\u003ccode\u003eCollector\u003c/code\u003e is not concurrent. For parallel stream pipelines, the \n\u003ccode\u003ecombiner\u003c/code\u003e function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the \n\u003ccode\u003eMap\u003c/code\u003e in encounter order, using \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function)\u003c/code\u003e\u003c/a\u003e may offer better parallel performance."
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which collects elements into a \n\u003ccode\u003eMap\u003c/code\u003e whose keys and values are the result of applying mapping functions to the input elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toUnmodifiableMap",
      "comment": "Returns a Collector that accumulates the input elements into an unmodifiable Map, whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), an IllegalStateException is thrown when the collection operation is performed. If the mapped keys might have duplicates, use toUnmodifiableMap(Function, Function, BinaryOperator) to handle merging of the values. The returned Collector disallows null keys and values. If either mapping function returns null, NullPointerException will be thrown.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoUnmodifiableMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - a mapping function to produce keys, must be non-null",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - a mapping function to produce values, must be non-null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either keyMapper or valueMapper is null"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that accumulates the input elements into an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Map.html#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e, whose keys and values are the result of applying the provided mapping functions to the input elements"
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mergeFunction",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toMap",
      "comment": "Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoMap(Function, Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)\"\u003e\u003ccode\u003etoMap(Function, Function, BinaryOperator, Supplier)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of \n\u003ccode\u003etoMap\u003c/code\u003e simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of \n\u003ccode\u003ePerson\u003c/code\u003e, and you want to produce a \"phone book\" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a \n\u003ccode\u003eMap\u003c/code\u003e mapping names to a concatenated list of addresses: \n\u003cpre\u003e\u003ccode\u003e\n Map\u0026lt;String, String\u0026gt; phoneBook\n   \u003d people.stream().collect(\n     toMap(Person::getName,\n           Person::getAddress,\n           (s, a) -\u0026gt; s + \", \" + a));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - a mapping function to produce keys",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - a mapping function to produce values",
          "\u003ccode\u003emergeFunction\u003c/code\u003e - a merge function, used to resolve collisions between values associated with the same key, as supplied to \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)\"\u003e\u003ccode\u003eMap.merge(Object, Object, BiFunction)\u003c/code\u003e\u003c/a\u003e"
        ],
        "implNote": [
          "The returned \n\u003ccode\u003eCollector\u003c/code\u003e is not concurrent. For parallel stream pipelines, the \n\u003ccode\u003ecombiner\u003c/code\u003e function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the \n\u003ccode\u003eMap\u003c/code\u003e in encounter order, using \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e may offer better parallel performance."
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which collects elements into a \n\u003ccode\u003eMap\u003c/code\u003e whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.Map",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mergeFunction",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toUnmodifiableMap",
      "comment": "Returns a Collector that accumulates the input elements into an unmodifiable Map, whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The returned Collector disallows null keys and values. If either mapping function returns null, NullPointerException will be thrown.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoUnmodifiableMap(Function, Function)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - a mapping function to produce keys, must be non-null",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - a mapping function to produce values, must be non-null",
          "\u003ccode\u003emergeFunction\u003c/code\u003e - a merge function, used to resolve collisions between values associated with the same key, as supplied to \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)\"\u003e\u003ccode\u003eMap.merge(Object, Object, BiFunction)\u003c/code\u003e\u003c/a\u003e, must be non-null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the keyMapper, valueMapper, or mergeFunction is null"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e that accumulates the input elements into an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Map.html#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e, whose keys and values are the result of applying the provided mapping functions to the input elements"
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "M",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mergeFunction",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Supplier",
            "parameters": [
              {
                "name": "M",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mapFactory",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        },
        {
          "name": "M",
          "upperBounds": [
            {
              "name": "java.util.Map",
              "parameters": [
                {
                  "name": "K",
                  "type": "Class"
                },
                {
                  "name": "U",
                  "type": "Class"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toMap",
      "comment": "Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The Map is created by a provided supplier function.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function",
          "\u003ccode\u003eM\u003c/code\u003e - the type of the resulting \n\u003ccode\u003eMap\u003c/code\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoMap(Function, Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator, Supplier)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - a mapping function to produce keys",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - a mapping function to produce values",
          "\u003ccode\u003emergeFunction\u003c/code\u003e - a merge function, used to resolve collisions between values associated with the same key, as supplied to \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)\"\u003e\u003ccode\u003eMap.merge(Object, Object, BiFunction)\u003c/code\u003e\u003c/a\u003e",
          "\u003ccode\u003emapFactory\u003c/code\u003e - a supplier providing a new empty \n\u003ccode\u003eMap\u003c/code\u003e into which the results will be inserted"
        ],
        "implNote": [
          "The returned \n\u003ccode\u003eCollector\u003c/code\u003e is not concurrent. For parallel stream pipelines, the \n\u003ccode\u003ecombiner\u003c/code\u003e function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the \n\u003ccode\u003eMap\u003c/code\u003e in encounter order, using \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator, Supplier)\u003c/code\u003e\u003c/a\u003e may offer better parallel performance."
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which collects elements into a \n\u003ccode\u003eMap\u003c/code\u003e whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.concurrent.ConcurrentMap",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toConcurrentMap",
      "comment": "Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), an IllegalStateException is thrown when the collection operation is performed. If the mapped keys may have duplicates, use toConcurrentMap(Function, Function, BinaryOperator) instead. There are no guarantees on the type, mutability, or serializability of the ConcurrentMap returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoMap(Function, Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator, Supplier)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "It is common for either the key or the value to be the input elements. In this case, the utility method \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Function.html#identity()\"\u003e\u003ccode\u003eFunction.identity()\u003c/code\u003e\u003c/a\u003e may be helpful. For example, the following produces a \n\u003ccode\u003eConcurrentMap\u003c/code\u003e mapping students to their grade point average: \n\u003cpre\u003e\u003ccode\u003e\n ConcurrentMap\u0026lt;Student, Double\u0026gt; studentToGPA\n   \u003d students.stream().collect(\n     toConcurrentMap(Function.identity(),\n                     student -\u0026gt; computeGPA(student)));\n \u003c/code\u003e\u003c/pre\u003e And the following produces a \n\u003ccode\u003eConcurrentMap\u003c/code\u003e mapping a unique identifier to students: \n\u003cpre\u003e\u003ccode\u003e\n ConcurrentMap\u0026lt;String, Student\u0026gt; studentIdToStudent\n   \u003d students.stream().collect(\n     toConcurrentMap(Student::getId,\n                     Function.identity()));\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eThis is a \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collector.Characteristics.html#CONCURRENT\"\u003e\u003ccode\u003econcurrent\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collector.Characteristics.html#UNORDERED\"\u003e\u003ccode\u003eunordered\u003c/code\u003e\u003c/a\u003e Collector.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - the mapping function to produce keys",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - the mapping function to produce values"
        ],
        "return": [
          "a concurrent, unordered \n\u003ccode\u003eCollector\u003c/code\u003e which collects elements into a \n\u003ccode\u003eConcurrentMap\u003c/code\u003e whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to the input elements"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.concurrent.ConcurrentMap",
            "parameters": [
              {
                "name": "K",
                "type": "Class"
              },
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mergeFunction",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toConcurrentMap",
      "comment": "Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. There are no guarantees on the type, mutability, or serializability of the ConcurrentMap returned.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator, Supplier)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of \n\u003ccode\u003etoConcurrentMap\u003c/code\u003e simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of \n\u003ccode\u003ePerson\u003c/code\u003e, and you want to produce a \"phone book\" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a \n\u003ccode\u003eConcurrentMap\u003c/code\u003e mapping names to a concatenated list of addresses: \n\u003cpre\u003e\u003ccode\u003e\n ConcurrentMap\u0026lt;String, String\u0026gt; phoneBook\n   \u003d people.stream().collect(\n     toConcurrentMap(Person::getName,\n                     Person::getAddress,\n                     (s, a) -\u0026gt; s + \", \" + a));\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eThis is a \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collector.Characteristics.html#CONCURRENT\"\u003e\u003ccode\u003econcurrent\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collector.Characteristics.html#UNORDERED\"\u003e\u003ccode\u003eunordered\u003c/code\u003e\u003c/a\u003e Collector.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - a mapping function to produce keys",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - a mapping function to produce values",
          "\u003ccode\u003emergeFunction\u003c/code\u003e - a merge function, used to resolve collisions between values associated with the same key, as supplied to \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)\"\u003e\u003ccode\u003eMap.merge(Object, Object, BiFunction)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a concurrent, unordered \n\u003ccode\u003eCollector\u003c/code\u003e which collects elements into a \n\u003ccode\u003eConcurrentMap\u003c/code\u003e whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "M",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "K",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "keyMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "upperBounds": [
                  {
                    "name": "U",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "valueMapper",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "U",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mergeFunction",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.Supplier",
            "parameters": [
              {
                "name": "M",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "mapFactory",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "K",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        },
        {
          "name": "M",
          "upperBounds": [
            {
              "name": "java.util.concurrent.ConcurrentMap",
              "parameters": [
                {
                  "name": "K",
                  "type": "Class"
                },
                {
                  "name": "U",
                  "type": "Class"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toConcurrentMap",
      "comment": "Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The ConcurrentMap is created by a provided supplier function. This is a concurrent and unordered Collector.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eK\u003c/code\u003e - the output type of the key mapping function",
          "\u003ccode\u003eU\u003c/code\u003e - the output type of the value mapping function",
          "\u003ccode\u003eM\u003c/code\u003e - the type of the resulting \n\u003ccode\u003eConcurrentMap\u003c/code\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\"\u003e\u003ccode\u003etoConcurrentMap(Function, Function, BinaryOperator)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)\"\u003e\u003ccode\u003etoMap(Function, Function, BinaryOperator, Supplier)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ekeyMapper\u003c/code\u003e - a mapping function to produce keys",
          "\u003ccode\u003evalueMapper\u003c/code\u003e - a mapping function to produce values",
          "\u003ccode\u003emergeFunction\u003c/code\u003e - a merge function, used to resolve collisions between values associated with the same key, as supplied to \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)\"\u003e\u003ccode\u003eMap.merge(Object, Object, BiFunction)\u003c/code\u003e\u003c/a\u003e",
          "\u003ccode\u003emapFactory\u003c/code\u003e - a supplier providing a new empty \n\u003ccode\u003eConcurrentMap\u003c/code\u003e into which the results will be inserted"
        ],
        "return": [
          "a concurrent, unordered \n\u003ccode\u003eCollector\u003c/code\u003e which collects elements into a \n\u003ccode\u003eConcurrentMap\u003c/code\u003e whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.IntSummaryStatistics",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToIntFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "summarizingInt",
      "comment": "Returns a Collector which applies an int-producing mapping function to each input element, and returns summary statistics for the resulting values.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#summarizingDouble(java.util.function.ToDoubleFunction)\"\u003e\u003ccode\u003esummarizingDouble(ToDoubleFunction)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#summarizingLong(java.util.function.ToLongFunction)\"\u003e\u003ccode\u003esummarizingLong(ToLongFunction)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a mapping function to apply to each element"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the summary-statistics reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.LongSummaryStatistics",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToLongFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "summarizingLong",
      "comment": "Returns a Collector which applies an long-producing mapping function to each input element, and returns summary statistics for the resulting values.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#summarizingDouble(java.util.function.ToDoubleFunction)\"\u003e\u003ccode\u003esummarizingDouble(ToDoubleFunction)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#summarizingInt(java.util.function.ToIntFunction)\"\u003e\u003ccode\u003esummarizingInt(ToIntFunction)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - the mapping function to apply to each element"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the summary-statistics reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "java.util.DoubleSummaryStatistics",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.ToDoubleFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "mapper",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "summarizingDouble",
      "comment": "Returns a Collector which applies an double-producing mapping function to each input element, and returns summary statistics for the resulting values.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#summarizingLong(java.util.function.ToLongFunction)\"\u003e\u003ccode\u003esummarizingLong(ToLongFunction)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#summarizingInt(java.util.function.ToIntFunction)\"\u003e\u003ccode\u003esummarizingInt(ToIntFunction)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emapper\u003c/code\u003e - a mapping function to apply to each element"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e implementing the summary-statistics reduction"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Collector",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          },
          {
            "type": "Wildcard"
          },
          {
            "name": "R",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "type": "Wildcard"
              },
              {
                "name": "R1",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream1",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.stream.Collector",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "type": "Wildcard"
              },
              {
                "name": "R2",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "downstream2",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BiFunction",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "R1",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "lowerBounds": [
                  {
                    "name": "R2",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              },
              {
                "name": "R",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "merger",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "R1",
          "type": "Variable"
        },
        {
          "name": "R2",
          "type": "Variable"
        },
        {
          "name": "R",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "teeing",
      "comment": "Returns a Collector that is a composite of two downstream collectors. Every element passed to the resulting collector is processed by both downstream collectors, then their results are merged using the specified merge function into the final result. The resulting collector functions do the following: supplier: creates a result container that contains result containers obtained by calling each collector\u0027s supplier accumulator: calls each collector\u0027s accumulator with its result container and the input element combiner: calls each collector\u0027s combiner with two result containers finisher: calls each collector\u0027s finisher with its result container, then calls the supplied merger and returns its result. The resulting collector is Collector.Characteristics.UNORDERED if both downstream collectors are unordered and Collector.Characteristics.CONCURRENT if both downstream collectors are concurrent.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the input elements",
          "\u003ccode\u003eR1\u003c/code\u003e - the result type of the first collector",
          "\u003ccode\u003eR2\u003c/code\u003e - the result type of the second collector",
          "\u003ccode\u003eR\u003c/code\u003e - the final result type"
        ],
        "param": [
          "\u003ccode\u003edownstream1\u003c/code\u003e - the first downstream collector",
          "\u003ccode\u003edownstream2\u003c/code\u003e - the second downstream collector",
          "\u003ccode\u003emerger\u003c/code\u003e - the function which merges two results into the single one"
        ],
        "return": [
          "a \n\u003ccode\u003eCollector\u003c/code\u003e which aggregates the results of two supplied collectors."
        ],
        "since": [
          "12"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.util.stream.Collectors",
  "annotations": [],
  "tagMap": {
    "since": [
      "1.8"
    ]
  }
}