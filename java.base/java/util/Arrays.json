{
  "packageName": "java.util",
  "simpleName": "Arrays",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array into ascending numerical order. The \u003c relation does not provide a total order on all float values: -0.0f \u003d\u003d 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty. The \u003c relation does not provide a total order on all float values: -0.0f \u003d\u003d 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array into ascending numerical order. The \u003c relation does not provide a total order on all double values: -0.0d \u003d\u003d 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Double.compareTo(java.lang.Double): -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty. The \u003c relation does not provide a total order on all double values: -0.0d \u003d\u003d 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Double.compareTo(java.lang.Double): -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array into ascending numerical order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array into ascending numerical order. The \u003c relation does not provide a total order on all float values: -0.0f \u003d\u003d 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty. The \u003c relation does not provide a total order on all float values: -0.0f \u003d\u003d 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array into ascending numerical order. The \u003c relation does not provide a total order on all double values: -0.0d \u003d\u003d 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Double.compareTo(java.lang.Double): -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex \u003d\u003d toIndex, the range to be sorted is empty. The \u003c relation does not provide a total order on all double values: -0.0d \u003d\u003d 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Double.compareTo(java.lang.Double): -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive, to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive, to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "upperBounds": [
            {
              "name": "java.lang.Comparable",
              "parameters": [
                {
                  "lowerBounds": [
                    {
                      "name": "T",
                      "type": "Class"
                    }
                  ],
                  "type": "Wildcard"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects to be sorted"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. The algorithm requires a working space no greater than the size of the original array. The \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#commonPool()\"\u003e\u003ccode\u003eForkJoin common pool\u003c/code\u003e\u003c/a\u003e is used to execute any parallel tasks."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and integers)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - (optional) if the natural ordering of the array elements is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eComparable\u003c/code\u003e\u003c/a\u003e contract"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "upperBounds": [
            {
              "name": "java.lang.Comparable",
              "parameters": [
                {
                  "lowerBounds": [
                    {
                      "name": "T",
                      "type": "Class"
                    }
                  ],
                  "type": "Wildcard"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects to be sorted"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be sorted"
        ],
        "implNote": [
          "The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. The algorithm requires a working space no greater than the size of the specified range of the original array. The \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#commonPool()\"\u003e\u003ccode\u003eForkJoin common pool\u003c/code\u003e\u003c/a\u003e is used to execute any parallel tasks."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e or (optional) if the natural ordering of the array elements is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eComparable\u003c/code\u003e\u003c/a\u003e contract",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and integers)."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects to be sorted"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to determine the order of the array. A \n\u003ccode\u003enull\u003c/code\u003e value indicates that the elements\u0027 \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003enatural ordering\u003c/a\u003e should be used."
        ],
        "implNote": [
          "The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. The algorithm requires a working space no greater than the size of the original array. The \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#commonPool()\"\u003e\u003ccode\u003eForkJoin common pool\u003c/code\u003e\u003c/a\u003e is used to execute any parallel tasks."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - (optional) if the comparator is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Comparator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eComparator\u003c/code\u003e\u003c/a\u003e contract"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSort",
      "comment": "Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects to be sorted"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be sorted",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to determine the order of the array. A \n\u003ccode\u003enull\u003c/code\u003e value indicates that the elements\u0027 \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003enatural ordering\u003c/a\u003e should be used."
        ],
        "implNote": [
          "The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e method. The algorithm requires a working space no greater than the size of the specified range of the original array. The \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#commonPool()\"\u003e\u003ccode\u003eForkJoin common pool\u003c/code\u003e\u003c/a\u003e is used to execute any parallel tasks."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e or (optional) if the natural ordering of the array elements is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eComparable\u003c/code\u003e\u003c/a\u003e contract",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and integers)."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters\u0027s list sort for Python ( TimSort). It uses techniques from Peter McIlroy\u0027s \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and integers)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - (optional) if the natural ordering of the array elements is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eComparable\u003c/code\u003e\u003c/a\u003e contract"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters\u0027s list sort for Python ( TimSort). It uses techniques from Peter McIlroy\u0027s \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be sorted"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e or (optional) if the natural ordering of the array elements is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eComparable\u003c/code\u003e\u003c/a\u003e contract",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and integers)."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "c",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters\u0027s list sort for Python ( TimSort). It uses techniques from Peter McIlroy\u0027s \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects to be sorted"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003ec\u003c/code\u003e - the comparator to determine the order of the array. A \n\u003ccode\u003enull\u003c/code\u003e value indicates that the elements\u0027 \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003enatural ordering\u003c/a\u003e should be used."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - (optional) if the comparator is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Comparator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eComparator\u003c/code\u003e\u003c/a\u003e contract"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "c",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "sort",
      "comment": "Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters\u0027s list sort for Python ( TimSort). It uses techniques from Peter McIlroy\u0027s \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects to be sorted"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be sorted",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be sorted",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be sorted",
          "\u003ccode\u003ec\u003c/code\u003e - the comparator to determine the order of the array. A \n\u003ccode\u003enull\u003c/code\u003e value indicates that the elements\u0027 \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003enatural ordering\u003c/a\u003e should be used."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e or (optional) if the comparator is found to violate the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Comparator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eComparator\u003c/code\u003e\u003c/a\u003e contract",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the array"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, which is modified in-place by this method",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free, associative function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.BinaryOperator",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Performs parallelPrefix(Object[], BinaryOperator) for the given subrange of the array.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the array"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free, associative function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; array.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.LongBinaryOperator",
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, which is modified in-place by this method",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free, associative function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.LongBinaryOperator",
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Performs parallelPrefix(long[], LongBinaryOperator) for the given subrange of the array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free, associative function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; array.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.DoubleBinaryOperator",
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2.0, 1.0, 0.0, 3.0] and the operation performs addition, then upon return the array holds [2.0, 3.0, 3.0, 6.0]. Parallel prefix computation is usually more efficient than sequential loops for large arrays. Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, which is modified in-place by this method",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.DoubleBinaryOperator",
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Performs parallelPrefix(double[], DoubleBinaryOperator) for the given subrange of the array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free, associative function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; array.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntBinaryOperator",
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, which is modified in-place by this method",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free, associative function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntBinaryOperator",
            "type": "Class"
          },
          "name": "op",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelPrefix",
      "comment": "Performs parallelPrefix(int[], IntBinaryOperator) for the given subrange of the array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element, inclusive",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element, exclusive",
          "\u003ccode\u003eop\u003c/code\u003e - a side-effect-free, associative function to perform the cumulation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; array.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array or function is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(long[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the sort(long[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the sort(int[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the sort(short[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the sort(char[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the sort(double[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the sort(float[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the natural ordering of its elements (as by the sort(Object[]) method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the search key is not comparable to the elements of the array."
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the natural ordering of its elements (as by the sort(Object[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the search key is not comparable to the elements of the array within the specified range.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "c",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the sort(T[], Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the array"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for",
          "\u003ccode\u003ec\u003c/code\u003e - the comparator by which the array is ordered. A \n\u003ccode\u003enull\u003c/code\u003e value indicates that the elements\u0027 \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003enatural ordering\u003c/a\u003e should be used."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the array contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator, or the search key is not comparable to the elements of the array using this comparator."
        ],
        "return": [
          "index of the search key, if it is contained in the array; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or \n\u003ccode\u003ea.length\u003c/code\u003e if all elements in the array are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "c",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "binarySearch",
      "comment": "Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the sort(T[], int, int, Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the array"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be searched",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be searched",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be searched",
          "\u003ccode\u003ekey\u003c/code\u003e - the value to be searched for",
          "\u003ccode\u003ec\u003c/code\u003e - the comparator by which the array is ordered. A \n\u003ccode\u003enull\u003c/code\u003e value indicates that the elements\u0027 \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003enatural ordering\u003c/a\u003e should be used."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the range contains elements that are not \n\u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0 or toIndex \u0026gt; a.length\u003c/code\u003e"
        ],
        "return": [
          "index of the search key, if it is contained in the array within the specified range; otherwise, \n\u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The \n\u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or \n\u003ccode\u003etoIndex\u003c/code\u003e if all elements in the range are less than the specified key. Note that this guarantees that the return value will be \u0026gt;\u003d 0 if and only if the key is found."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of longs, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of ints, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of shorts, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of chars, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of bytes, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of booleans, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two doubles d1 and d2 are considered equal if:     new Double(d1).equals(new Double(d2)) (Unlike the \u003d\u003d operator, this method considers NaN equal to itself, and 0.0d unequal to -0.0d.)",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eDouble.equals(Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of doubles, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two doubles d1 and d2 are considered equal if:     new Double(d1).equals(new Double(d2)) (Unlike the \u003d\u003d operator, this method considers NaN equal to itself, and 0.0d unequal to -0.0d.)",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eDouble.equals(Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two floats f1 and f2 are considered equal if:     new Float(f1).equals(new Float(f2)) (Unlike the \u003d\u003d operator, this method considers NaN equal to itself, and 0.0f unequal to -0.0f.)",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eFloat.equals(Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of floats, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two floats f1 and f2 are considered equal if:     new Float(f1).equals(new Float(f2)) (Unlike the \u003d\u003d operator, this method considers NaN equal to itself, and 0.0f unequal to -0.0f.)",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eFloat.equals(Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects e1 and e2 are considered equal if Objects.equals(e1, e2). In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of Objects, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two objects e1 and e2 are considered equal if Objects.equals(e1, e2).",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of Objects are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two objects e1 and e2 are considered equal if, given the specified comparator, cmp.compare(e1, e2) \u003d\u003d 0.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of array elements"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to compare array elements"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the comparator is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "equals",
      "comment": "Returns true if the two specified arrays of Objects, over the specified ranges, are equal to one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two objects e1 and e2 are considered equal if, given the specified comparator, cmp.compare(e1, e2) \u003d\u003d 0.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of array elements"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for equality",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for equality",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to compare array elements"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array or the comparator is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays, over the specified ranges, are equal"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified long value to each element of the specified array of longs.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified int value to each element of the specified array of ints.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified short value to each element of the specified array of shorts.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified char value to each element of the specified array of chars.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified byte value to each element of the specified array of bytes.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified boolean value to each element of the specified array of booleans.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified double value to each element of the specified array of doubles.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified float value to each element of the specified array of floats.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified Object reference to each element of the specified array of Objects.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayStoreException.html\" title\u003d\"class in java.lang\"\u003eArrayStoreException\u003c/a\u003e\u003c/code\u003e - if the specified value is not of a runtime type that can be stored in the specified array"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "fromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "toIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "val",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fill",
      "comment": "Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex\u003d\u003dtoIndex, the range to be filled is empty.)",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array to be filled",
          "\u003ccode\u003efromIndex\u003c/code\u003e - the index of the first element (inclusive) to be filled with the specified value",
          "\u003ccode\u003etoIndex\u003c/code\u003e - the index of the last element (exclusive) to be filled with the specified value",
          "\u003ccode\u003eval\u003c/code\u003e - the value to be stored in all elements of the array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026gt; toIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efromIndex \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003etoIndex \u0026gt; a.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayStoreException.html\" title\u003d\"class in java.lang\"\u003eArrayStoreException\u003c/a\u003e\u003c/code\u003e - if the specified value is not of a runtime type that can be stored in the specified array"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the array"
        ],
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with nulls to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "U",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "T",
                    "type": "Class",
                    "arrayDimensions": 1
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "newType",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class newType.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eU\u003c/code\u003e - the class of the objects in the original array",
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the returned array"
        ],
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned",
          "\u003ccode\u003enewType\u003c/code\u003e - the class of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayStoreException.html\" title\u003d\"class in java.lang\"\u003eArrayStoreException\u003c/a\u003e\u003c/code\u003e - if an element copied from \n\u003ccode\u003eoriginal\u003c/code\u003e is not of a runtime type that can be stored in an array of class \n\u003ccode\u003enewType\u003c/code\u003e"
        ],
        "return": [
          "a copy of the original array, truncated or padded with nulls to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (byte)0. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with zeros to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "short",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (short)0. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with zeros to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with zeros to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0L. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with zeros to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "char",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain \u0027\\u0000\u0027. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with null characters to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0f. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with zeros to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0d. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with zeros to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "newLength",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOf",
      "comment": "Copies the specified array, truncating or padding with false (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain false. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array to be copied",
          "\u003ccode\u003enewLength\u003c/code\u003e - the length of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NegativeArraySizeException.html\" title\u003d\"class in java.lang\"\u003eNegativeArraySizeException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewLength\u003c/code\u003e is negative",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a copy of the original array, truncated or padded with false elements to obtain the specified length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from. The resulting array is of exactly the same class as the original array.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the array"
        ],
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "U",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "T",
                    "type": "Class",
                    "arrayDimensions": 1
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "newType",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        },
        {
          "name": "U",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from. The resulting array is of the class newType.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eU\u003c/code\u003e - the class of the objects in the original array",
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the returned array"
        ],
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)",
          "\u003ccode\u003enewType\u003c/code\u003e - the class of the copy to be returned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayStoreException.html\" title\u003d\"class in java.lang\"\u003eArrayStoreException\u003c/a\u003e\u003c/code\u003e - if an element copied from \n\u003ccode\u003eoriginal\u003c/code\u003e is not of a runtime type that can be stored in an array of class \n\u003ccode\u003enewType\u003c/code\u003e."
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (byte)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "short",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (short)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0L is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "char",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case \u0027\\u0000\u0027 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with null characters to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0f is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0d is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "original",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "from",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "to",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "copyOfRange",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from \u003d\u003d original.length or from \u003d\u003d to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case false is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoriginal\u003c/code\u003e - the array from which a range is to be copied",
          "\u003ccode\u003efrom\u003c/code\u003e - the initial index of the range to be copied, inclusive",
          "\u003ccode\u003eto\u003c/code\u003e - the final index of the range to be copied, exclusive. (This index may lie outside the array.)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026lt; 0\u003c/code\u003e or \n\u003ccode\u003efrom \u0026gt; original.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003efrom \u0026gt; to\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoriginal\u003c/code\u003e is null"
        ],
        "return": [
          "a new array containing the specified range from the original array, truncated or padded with false elements to obtain the required length"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class"
          },
          "name": "a",
          "varargs": true
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "asList",
      "comment": "Returns a fixed-size list backed by the specified array. Changes made to the array will be visible in the returned list, and changes made to the list will be visible in the array. The returned list is Serializable and implements RandomAccess. The returned list implements the optional Collection methods, except those that would change the size of the returned list. Those methods leave the list unchanged and throw UnsupportedOperationException.",
      "annotations": [
        {
          "type": {
            "name": "SafeVarargs",
            "type": "Class"
          }
        }
      ],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the class of the objects in the array"
        ],
        "apiNote": [
          "This method acts as bridge between array-based and collection-based APIs, in combination with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Collection.html#toArray()\"\u003e\u003ccode\u003eCollection.toArray()\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003eThis method provides a way to wrap an existing array: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     Integer[] numbers \u003d ...\n     ...\n     List\u0026lt;Integer\u0026gt; values \u003d Arrays.asList(numbers);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThis method also provides a convenient way to create a fixed-size list initialized to contain several elements: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     List\u0026lt;String\u0026gt; stooges \u003d Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThe list returned by this method is modifiable.\u003c/em\u003e To create an unmodifiable list, use \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Collections.html#unmodifiableList(java.util.List)\"\u003e\u003ccode\u003eCollections.unmodifiableList\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/List.html#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array by which the list will be backed"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "a list view of the specified array"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two long arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Long instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two non-null int arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Integer instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two short arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Short instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two char arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Character instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two byte arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Byte instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two boolean arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Boolean instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two float arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Float instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. For any two double arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Double instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose hash value to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "hashCode",
      "comment": "Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) \u003d\u003d Arrays.hashCode(b). The value returned by this method is equal to the value that would be returned by Arrays.asList(a).hashCode(), unless a is null, in which case 0 is returned.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#deepHashCode(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003edeepHashCode(Object[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose content-based hash code to compute"
        ],
        "return": [
          "a content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "deepHashCode",
      "comment": "Returns a hash code based on the \"deep contents\" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays a and b such that Arrays.deepEquals(a, b), it is also the case that Arrays.deepHashCode(a) \u003d\u003d Arrays.deepHashCode(b). The computation of the value returned by this method is similar to that of the value returned by List.hashCode() on a list containing the same elements as a in the same order, with one difference: If an element e of a is itself an array, its hash code is computed not by calling e.hashCode(), but as by calling the appropriate overloading of Arrays.hashCode(e) if e is an array of a primitive type, or as by calling Arrays.deepHashCode(e) recursively if e is an array of a reference type. If a is null, this method returns 0.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#hashCode(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003ehashCode(Object[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose deep-content-based hash code to compute"
        ],
        "return": [
          "a deep-content-based hash code for \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a1",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a2",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "deepEquals",
      "comment": "Returns true if the two specified arrays are deeply equal to one another. Unlike the equals(Object[],Object[]) method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are null, or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly null elements e1 and e2 are deeply equal if any of the following conditions hold: e1 and e2 are both arrays of object reference types, and Arrays.deepEquals(e1, e2) would return true e1 and e2 are arrays of the same primitive type, and the appropriate overloading of Arrays.equals(e1, e2) would return true. e1 \u003d\u003d e2 e1.equals(e2) would return true. Note that this definition permits null elements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#equals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eequals(Object[],Object[])\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#deepEquals(java.lang.Object,java.lang.Object)\"\u003e\u003ccode\u003eObjects.deepEquals(Object, Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea1\u003c/code\u003e - one array to be tested for equality",
          "\u003ccode\u003ea2\u003c/code\u003e - the other array to be tested for equality"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the two arrays are equal"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(long). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(int). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(short). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(char). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(byte). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(boolean). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(float). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(double). Returns \"null\" if a is null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "toString",
      "comment": "Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the Object.toString() method inherited from Object, which describes their identities rather than their contents. The value returned by this method is equal to the value that would be returned by Arrays.asList(a).toString(), unless a is null, in which case \"null\" is returned.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003edeepToString(Object[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "deepToString",
      "comment": "Returns a string representation of the \"deep contents\" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array\u0027s elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by String.valueOf(Object), unless they are themselves arrays. If an element e is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of Arrays.toString(e). If an element e is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string \"[...]\". For example, an array containing only a reference to itself would be rendered as \"[[...]]\". This method returns \"null\" if the specified array is null.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003etoString(Object[])\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the array whose string representation to return"
        ],
        "return": [
          "a string representation of \n\u003ccode\u003ea\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntFunction",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "setAll",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - type of elements of the array"
        ],
        "apiNote": [
          "Setting a subrange of an array, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .forEach(i -\u0026gt; array[i] \u003d generator.apply(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntFunction",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSetAll",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - type of elements of the array"
        ],
        "apiNote": [
          "Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .parallel()\n          .forEach(i -\u0026gt; array[i] \u003d generator.apply(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntUnaryOperator",
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "setAll",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Setting a subrange of an array, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .forEach(i -\u0026gt; array[i] \u003d generator.applyAsInt(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntUnaryOperator",
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSetAll",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .parallel()\n          .forEach(i -\u0026gt; array[i] \u003d generator.applyAsInt(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntToLongFunction",
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "setAll",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Setting a subrange of an array, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .forEach(i -\u0026gt; array[i] \u003d generator.applyAsLong(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntToLongFunction",
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSetAll",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .parallel()\n          .forEach(i -\u0026gt; array[i] \u003d generator.applyAsLong(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntToDoubleFunction",
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "setAll",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Setting a subrange of an array, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .forEach(i -\u0026gt; array[i] \u003d generator.applyAsDouble(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.function.IntToDoubleFunction",
            "type": "Class"
          },
          "name": "generator",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "parallelSetAll",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: \n\u003cpre\u003e\u003ccode\u003e\n IntStream.range(startInclusive, endExclusive)\n          .parallel()\n          .forEach(i -\u0026gt; array[i] \u003d generator.applyAsDouble(i));\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - array to be initialized",
          "\u003ccode\u003egenerator\u003c/code\u003e - a function accepting an index and producing the desired value for that position"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the generator is null"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator covering all of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - type of elements"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use"
        ],
        "return": [
          "a spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator covering the specified range of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - type of elements"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "a spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator$OfInt",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator.OfInt covering all of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use"
        ],
        "return": [
          "a spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator$OfInt",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator.OfInt covering the specified range of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "a spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator$OfLong",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator.OfLong covering all of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use"
        ],
        "return": [
          "the spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator$OfLong",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator.OfLong covering the specified range of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "a spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator$OfDouble",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator.OfDouble covering all of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use"
        ],
        "return": [
          "a spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Spliterator$OfDouble",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spliterator",
      "comment": "Returns a Spliterator.OfDouble covering the specified range of the specified array. The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, Spliterator.ORDERED, and Spliterator.IMMUTABLE.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "a spliterator for the array elements"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential Stream with the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - The type of the array elements"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - The array, assumed to be unmodified during use"
        ],
        "return": [
          "a \n\u003ccode\u003eStream\u003c/code\u003e for the array"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "T",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential Stream with the specified range of the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the array elements"
        ],
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "a \n\u003ccode\u003eStream\u003c/code\u003e for the array range"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential IntStream with the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use"
        ],
        "return": [
          "an \n\u003ccode\u003eIntStream\u003c/code\u003e for the array"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.IntStream",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential IntStream with the specified range of the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "an \n\u003ccode\u003eIntStream\u003c/code\u003e for the array range"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.LongStream",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential LongStream with the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use"
        ],
        "return": [
          "a \n\u003ccode\u003eLongStream\u003c/code\u003e for the array"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.LongStream",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential LongStream with the specified range of the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "a \n\u003ccode\u003eLongStream\u003c/code\u003e for the array range"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.DoubleStream",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential DoubleStream with the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use"
        ],
        "return": [
          "a \n\u003ccode\u003eDoubleStream\u003c/code\u003e for the array"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.DoubleStream",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "array",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "startInclusive",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "endExclusive",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "stream",
      "comment": "Returns a sequential DoubleStream with the specified range of the specified array as its source.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003earray\u003c/code\u003e - the array, assumed to be unmodified during use",
          "\u003ccode\u003estartInclusive\u003c/code\u003e - the first index to cover, inclusive",
          "\u003ccode\u003eendExclusive\u003c/code\u003e - index immediately past the last index to cover"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003estartInclusive\u003c/code\u003e is negative, \n\u003ccode\u003eendExclusive\u003c/code\u003e is less than \n\u003ccode\u003estartInclusive\u003c/code\u003e, or \n\u003ccode\u003eendExclusive\u003c/code\u003e is greater than the array size"
        ],
        "return": [
          "a \n\u003ccode\u003eDoubleStream\u003c/code\u003e for the array range"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two boolean arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Boolean.compare(boolean, boolean), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(boolean[], boolean[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Boolean.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two boolean arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Boolean.compare(boolean, boolean), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(boolean[], int, int, boolean[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two byte arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Byte.compare(byte, byte), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(byte[], byte[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Byte.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two byte arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Byte.compare(byte, byte), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(byte[], int, int, byte[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two byte arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Byte.compareUnsigned(byte, byte), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(byte[], byte[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Byte.compareUnsigned(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two byte arrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Byte.compareUnsigned(byte, byte), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(byte[], int, int, byte[], int, int) for the definition of a common and proper prefix.)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is null"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two short arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Short.compare(short, short), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(short[], short[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Short.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two short arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Short.compare(short, short), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(short[], int, int, short[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two short arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Short.compareUnsigned(short, short), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(short[], short[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Short.compareUnsigned(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two short arrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Short.compareUnsigned(short, short), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(short[], int, int, short[], int, int) for the definition of a common and proper prefix.)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is null"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two char arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Character.compare(char, char), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(char[], char[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Character.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two char arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Character.compare(char, char), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(char[], int, int, char[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two int arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Integer.compare(int, int), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(int[], int[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Integer.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two int arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Integer.compare(int, int), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(int[], int, int, int[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two int arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Integer.compareUnsigned(int, int), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(int[], int[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Integer.compareUnsigned(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two int arrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Integer.compareUnsigned(int, int), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(int[], int, int, int[], int, int) for the definition of a common and proper prefix.)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is null"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two long arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Long.compare(long, long), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(long[], long[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Long.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two long arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Long.compare(long, long), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(long[], int, int, long[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two long arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Long.compareUnsigned(long, long), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(long[], long[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal.",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Long.compareUnsigned(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compareUnsigned",
      "comment": "Compares two long arrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Long.compareUnsigned(long, long), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(long[], int, int, long[], int, int) for the definition of a common and proper prefix.)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is null"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two float arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Float.compare(float, float), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(float[], float[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Float.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two float arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Float.compare(float, float), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(float[], int, int, float[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two double arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Double.compare(double, double), at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(double[], double[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return Double.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two double arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by Double.compare(double, double), at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(double[], int, int, double[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "apiNote": [
          "\u003cp\u003eThis method behaves as if: \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "upperBounds": [
            {
              "name": "java.lang.Comparable",
              "parameters": [
                {
                  "lowerBounds": [
                    {
                      "name": "T",
                      "type": "Class"
                    }
                  ],
                  "type": "Wildcard"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two Object arrays, within comparable elements, lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements of type T at an index i within the respective arrays that is the prefix length, as if by: \n     Comparator.nullsFirst(Comparator.\u003cT\u003enaturalOrder()).\n         compare(a[i], b[i])\n Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(Object[], Object[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal. A null array element is considered lexicographically less than a non-null array element. Two null array elements are considered equal. The comparison is consistent with equals, more specifically the following holds for arrays a and b: \n     Arrays.equals(a, b) \u003d\u003d (Arrays.compare(a, b) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of comparable array elements"
        ],
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references and elements): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return a[i].compareTo(b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "upperBounds": [
            {
              "name": "java.lang.Comparable",
              "parameters": [
                {
                  "lowerBounds": [
                    {
                      "name": "T",
                      "type": "Class"
                    }
                  ],
                  "type": "Wildcard"
                }
              ],
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two Object arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements of type T at a relative index i within the respective arrays that is the prefix length, as if by: \n     Comparator.nullsFirst(Comparator.\u003cT\u003enaturalOrder()).\n         compare(a[aFromIndex + i, b[bFromIndex + i])\n Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(Object[], int, int, Object[], int, int) for the definition of a common and proper prefix.) The comparison is consistent with equals, more specifically the following holds for arrays a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively: \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) \u003d\u003d 0)",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of comparable array elements"
        ],
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array elements): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return a[aFromIndex + i].compareTo(b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two Object arrays lexicographically using a specified comparator. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See mismatch(Object[], Object[]) for the definition of a common and proper prefix.) A null array reference is considered lexicographically less than a non-null array reference. Two null array references are considered equal.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of array elements"
        ],
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array references): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, b, cmp);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(a.length, b.length))\n         return cmp.compare(a[i], b[i]);\n     return a.length - b.length;\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to compare array elements"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the comparator is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "compare",
      "comment": "Compares two Object arrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at a relative index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See mismatch(Object[], int, int, Object[], int, int) for the definition of a common and proper prefix.)",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of array elements"
        ],
        "apiNote": [
          "\u003cp\u003eThis method behaves as if (for non-\u003ccode\u003enull\u003c/code\u003e array elements): \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n     int i \u003d Arrays.mismatch(a, aFromIndex, aToIndex,\n                             b, bFromIndex, bToIndex, cmp);\n     if (i \u0026gt;\u003d 0 \u0026amp;\u0026amp; i \u0026lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n         return cmp.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to compare",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be compared",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be compared",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to compare",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be compared",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be compared",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to compare array elements"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array or the comparator is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the value \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than \n\u003ccode\u003e0\u003c/code\u003e if, over the specified ranges, the first array is lexicographically greater than the second array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two boolean arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     a[pl] !\u003d b[pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "boolean",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two boolean arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     a[aFromIndex + pl] !\u003d b[bFromIndex + pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two byte arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     a[pl] !\u003d b[pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two byte arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     a[aFromIndex + pl] !\u003d b[bFromIndex + pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two char arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     a[pl] !\u003d b[pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "char",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two char arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     a[aFromIndex + pl] !\u003d b[bFromIndex + pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two short arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     a[pl] !\u003d b[pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "short",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two short arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     a[aFromIndex + pl] !\u003d b[bFromIndex + pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two int arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     a[pl] !\u003d b[pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two int arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     a[aFromIndex + pl] !\u003d b[bFromIndex + pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two long arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     a[pl] !\u003d b[pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two long arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     a[aFromIndex + pl] !\u003d b[bFromIndex + pl]\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two float arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     Float.compare(a[pl], b[pl]) !\u003d 0\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "float",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two float arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) !\u003d 0\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two double arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     Double.compare(a[pl], b[pl]) !\u003d 0\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "double",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two double arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) !\u003d 0\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two Object arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\n     !Objects.equals(a[pl], b[pl])\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two Object arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\n     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the index of the first mismatch between two Object arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. The specified comparator is used to determine if two array elements from the each array are not equal. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non-null arrays, a and b, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(a.length, b.length) \u0026\u0026\n     Arrays.equals(a, 0, pl, b, 0, pl, cmp)\n     cmp.compare(a[pl], b[pl]) !\u003d 0\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b, share a proper prefix if the following expression is true: \n     a.length !\u003d b.length \u0026\u0026\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length),\n                   cmp)",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of array elements"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to compare array elements"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array or the comparator is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the index of the first mismatch between the two arrays, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "a",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "aToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "b",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bFromIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "bToIndex",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.Comparator",
            "parameters": [
              {
                "lowerBounds": [
                  {
                    "name": "T",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "cmp",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "mismatch",
      "comment": "Finds and returns the relative index of the first mismatch between two Object arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a common prefix of length pl if the following expression is true: \n     pl \u003e\u003d 0 \u0026\u0026\n     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) \u0026\u0026\n     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) !\u003d 0\n Note that a common prefix length of 0 indicates that the first elements from each array mismatch. Two non-null arrays, a and b with specified ranges [aFromIndex, atoIndex) and [bFromIndex, btoIndex) respectively, share a proper prefix if the following expression is true: \n     (aToIndex - aFromIndex) !\u003d (bToIndex - bFromIndex) \u0026\u0026\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   cmp)",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of array elements"
        ],
        "param": [
          "\u003ccode\u003ea\u003c/code\u003e - the first array to be tested for a mismatch",
          "\u003ccode\u003eaFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the first array to be tested",
          "\u003ccode\u003eaToIndex\u003c/code\u003e - the index (exclusive) of the last element in the first array to be tested",
          "\u003ccode\u003eb\u003c/code\u003e - the second array to be tested for a mismatch",
          "\u003ccode\u003ebFromIndex\u003c/code\u003e - the index (inclusive) of the first element in the second array to be tested",
          "\u003ccode\u003ebToIndex\u003c/code\u003e - the index (exclusive) of the last element in the second array to be tested",
          "\u003ccode\u003ecmp\u003c/code\u003e - the comparator to compare array elements"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026gt; aToIndex\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026gt; bToIndex\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eArrayIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaFromIndex \u0026lt; 0 or aToIndex \u0026gt; a.length\u003c/code\u003e or if \n\u003ccode\u003ebFromIndex \u0026lt; 0 or bToIndex \u0026gt; b.length\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either array or the comparator is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the relative index of the first mismatch between the two arrays over the specified ranges, otherwise \n\u003ccode\u003e-1\u003c/code\u003e."
        ],
        "since": [
          "9"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.util.Arrays",
  "comment": "This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists. \n\u003cp\u003eThe methods in this class all throw a \u003ccode\u003eNullPointerException\u003c/code\u003e, if the specified array reference is null, except where noted. \u003c/p\u003e\n\u003cp\u003eThe documentation for the methods contained in this class includes brief descriptions of the \u003ci\u003eimplementations\u003c/i\u003e. Such descriptions should be regarded as \u003ci\u003eimplementation notes\u003c/i\u003e, rather than parts of the \u003ci\u003especification\u003c/i\u003e. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by \u003ccode\u003esort(Object[])\u003c/code\u003e does not have to be a MergeSort, but it does have to be \u003ci\u003estable\u003c/i\u003e.) \u003c/p\u003e\n\u003cp\u003eThis class is a member of the \u003ca href\u003d\"../../../java.base/java/util/package-summary.html#CollectionsFramework\"\u003e Java Collections Framework\u003c/a\u003e.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.2"
    ]
  }
}