{
  "packageName": "java.util.spi",
  "simpleName": "LocaleServiceProvider",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.util.Locale",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getAvailableLocales",
      "comment": "Returns an array of all locales for which this locale service provider can provide localized objects or names. This information is used to compose getAvailableLocales() values of the locale-dependent services, such as DateFormat.getAvailableLocales(). The array returned by this method should not include two or more Locale objects only differing in their extensions.",
      "tagMap": {
        "return": [
          "An array of all locales for which this locale service provider can provide localized objects or names."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Locale",
            "type": "Class"
          },
          "field": {
            "name": "locale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isSupportedLocale",
      "comment": "Returns true if the given locale is supported by this locale service provider. The given locale may contain extensions that should be taken into account for the support determination. The default implementation returns true if the given locale is equal to any of the available Locales returned by getAvailableLocales() with ignoring any extensions in both the given locale and the available locales. Concrete locale service provider implementations should override this method if those implementations are Locale extensions-aware. For example, DecimalFormatSymbolsProvider implementations will need to check extensions in the given locale to see if any numbering system is specified and can be supported. However, CollatorProvider implementations may not be affected by any particular numbering systems, and in that case, extensions for numbering systems should be ignored.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Locale.html#hasExtensions()\"\u003e\u003ccode\u003eLocale.hasExtensions()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Locale.html#stripExtensions()\"\u003e\u003ccode\u003eLocale.stripExtensions()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elocale\u003c/code\u003e - a \n\u003ccode\u003eLocale\u003c/code\u003e to be tested"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the given \n\u003ccode\u003elocale\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the given \n\u003ccode\u003elocale\u003c/code\u003e is supported by this provider; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Initializes a new locale service provider.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If a security manager has been installed and it denies \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/RuntimePermission.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eRuntimePermission(\"localeServiceProvider\")\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.util.spi.LocaleServiceProvider",
  "comment": "\u003cp\u003e This is the super class of all the locale sensitive service provider interfaces (SPIs). \u003c/p\u003e\n\u003cp\u003e Locale sensitive service provider interfaces are interfaces that correspond to locale sensitive classes in the \u003ccode\u003ejava.text\u003c/code\u003e and \u003ccode\u003ejava.util\u003c/code\u003e packages. The interfaces enable the construction of locale sensitive objects and the retrieval of localized names for these packages. Locale sensitive factory methods and methods for name retrieval in the \u003ccode\u003ejava.text\u003c/code\u003e and \u003ccode\u003ejava.util\u003c/code\u003e packages use implementations of the provider interfaces to offer support for locales beyond the set of locales supported by the Java runtime environment itself. \u003c/p\u003e\n\u003ch2\u003ePackaging of Locale Sensitive Service Provider Implementations\u003c/h2\u003e Implementations of these locale sensitive services can be made available by adding them to the application\u0027s class path. A provider identifies itself with a provider-configuration file in the resource directory META-INF/services, using the fully qualified provider interface class name as the file name. The file should contain a list of fully-qualified concrete provider class names, one per line. A line is terminated by any one of a line feed (\u0027\\n\u0027), a carriage return (\u0027\\r\u0027), or a carriage return followed immediately by a line feed. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is \u0027#\u0027 (\u0027#\u0027); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8. \n\u003cp\u003e If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file. \u003c/p\u003e\n\u003cp\u003e For example, an implementation of the \u003ca href\u003d\"../../text/spi/DateFormatProvider.html\" title\u003d\"class in java.text.spi\"\u003e\u003ccode\u003eDateFormatProvider\u003c/code\u003e\u003c/a\u003e class should take the form of a jar file which contains the file: \u003c/p\u003e\n\u003cpre\u003e META-INF/services/java.text.spi.DateFormatProvider\n \u003c/pre\u003e And the file \n\u003ccode\u003ejava.text.spi.DateFormatProvider\u003c/code\u003e should have a line such as: \n\u003cpre\u003e \u003ccode\u003ecom.foo.DateFormatProviderImpl\u003c/code\u003e\n \u003c/pre\u003e which is the fully qualified class name of the class implementing \n\u003ccode\u003eDateFormatProvider\u003c/code\u003e. \n\u003cp\u003e\u003c/p\u003e\n\u003ch3\u003eInvocation of Locale Sensitive Services\u003c/h3\u003e \n\u003cp\u003e Locale sensitive factory methods and methods for name retrieval in the \u003ccode\u003ejava.text\u003c/code\u003e and \u003ccode\u003ejava.util\u003c/code\u003e packages invoke service provider methods when needed to support the requested locale. The methods first check whether the Java runtime environment itself supports the requested locale, and use its support if available. Otherwise, they call the \u003ca href\u003d\"#isSupportedLocale(java.util.Locale)\"\u003e\u003ccode\u003eisSupportedLocale\u003c/code\u003e\u003c/a\u003e methods of installed providers for the appropriate interface to find one that supports the requested locale. If such a provider is found, its other methods are called to obtain the requested object or name. When checking whether a locale is supported, the \u003ca href\u003d\"../Locale.html#def_extensions\"\u003e locale\u0027s extensions\u003c/a\u003e are ignored by default. (If locale\u0027s extensions should also be checked, the \u003ccode\u003eisSupportedLocale\u003c/code\u003e method must be overridden.) If neither the Java runtime environment itself nor an installed provider supports the requested locale, the methods go through a list of candidate locales and repeat the availability check for each until a match is found. The algorithm used for creating a list of candidate locales is same as the one used by \u003ccode\u003eResourceBundle\u003c/code\u003e by default (see \u003ca href\u003d\"../ResourceBundle.Control.html#getCandidateLocales(java.lang.String,java.util.Locale)\"\u003e\u003ccode\u003egetCandidateLocales\u003c/code\u003e\u003c/a\u003e for the details). Even if a locale is resolved from the candidate list, methods that return requested objects or names are invoked with the original requested locale including \u003ccode\u003eLocale\u003c/code\u003e extensions. The Java runtime environment must support the root locale for all locale sensitive services in order to guarantee that this process terminates. \u003c/p\u003e\n\u003cp\u003e Providers of names (but not providers of other objects) are allowed to return null for some name requests even for locales that they claim to support by including them in their return value for \u003ccode\u003egetAvailableLocales\u003c/code\u003e. Similarly, the Java runtime environment itself may not have all names for all locales that it supports. This is because the sets of objects for which names are requested can be large and vary over time, so that it\u0027s not always feasible to cover them completely. If the Java runtime environment or a provider returns null instead of a name, the lookup will proceed as described above as if the locale was not supported. \u003c/p\u003e\n\u003cp\u003e The search order of locale sensitive services can be configured by using the \u003ccode\u003e\u003cspan id\u003d\"java.locale.providers\" class\u003d\"search-tag-result\"\u003ejava.locale.providers\u003c/span\u003e\u003c/code\u003e system property. This system property declares the user\u0027s preferred order for looking up the locale sensitive services separated by a comma. It is only read at the Java runtime startup, so the later call to System.setProperty() won\u0027t affect the order. \u003c/p\u003e\n\u003cp\u003e Java Runtime Environment provides the following four locale providers: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \"CLDR\": A provider based on Unicode Consortium\u0027s \u003ca href\u003d\"http://cldr.unicode.org/\"\u003eCLDR Project\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003e \"COMPAT\": represents the locale sensitive services that is compatible with the prior JDK releases up to JDK8 (same as JDK8\u0027s \"JRE\"). \u003c/li\u003e\n \u003cli\u003e \"SPI\": represents the locale sensitive services implementing the subclasses of this \u003ccode\u003eLocaleServiceProvider\u003c/code\u003e class. \u003c/li\u003e\n \u003cli\u003e \"HOST\": A provider that reflects the user\u0027s custom settings in the underlying operating system. This provider may not be available, depending on the Java Runtime Environment implementation. \u003c/li\u003e\n \u003cli\u003e \"JRE\": represents a synonym to \"COMPAT\". This name is deprecated and will be removed in the future release of JDK. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e For example, if the following is specified in the property: \u003c/p\u003e\n\u003cpre\u003e java.locale.providers\u003dSPI,CLDR,COMPAT\n \u003c/pre\u003e the locale sensitive services in the SPI providers are looked up first. If the desired locale sensitive service is not available, then the runtime looks for CLDR, COMPAT in that order. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The default order for looking up the preferred locale providers is \"CLDR,COMPAT\", so specifying \"CLDR,COMPAT\" is identical to the default behavior. Applications which require implementations of the locale sensitive services must explicitly specify \"SPI\" in order for the Java runtime to load them from the classpath.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.6"
    ]
  }
}