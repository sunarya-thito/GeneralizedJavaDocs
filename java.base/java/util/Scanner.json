{
  "packageName": "java.util",
  "simpleName": "Scanner",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "close",
      "comment": "Closes this scanner. If this scanner has not yet been closed then if its underlying readable also implements the Closeable interface then the readable\u0027s close method will be invoked. If this scanner is already closed then invoking this method will have no effect. Attempting to perform search operations after a scanner has been closed will result in an IllegalStateException.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/AutoCloseable.html#close()\"\u003eclose\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/AutoCloseable.html\" title\u003d\"interface in java.lang\"\u003eAutoCloseable\u003c/a\u003e\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/Closeable.html#close()\"\u003eclose\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/Closeable.html\" title\u003d\"interface in java.io\"\u003eCloseable\u003c/a\u003e\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.io.IOException",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "ioException",
      "comment": "Returns the IOException last thrown by this Scanner\u0027s underlying Readable. This method returns null if no such exception exists.",
      "tagMap": {
        "return": [
          "the last exception thrown by this scanner\u0027s readable"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.Pattern",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "delimiter",
      "comment": "Returns the Pattern this Scanner is currently using to match delimiters.",
      "tagMap": {
        "return": [
          "this scanner\u0027s delimiting pattern."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Scanner",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.regex.Pattern",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "useDelimiter",
      "comment": "Sets this scanner\u0027s delimiting pattern to the specified pattern.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - A delimiting pattern"
        ],
        "return": [
          "this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Scanner",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "useDelimiter",
      "comment": "Sets this scanner\u0027s delimiting pattern to a pattern constructed from the specified String. An invocation of this method of the form useDelimiter(pattern) behaves in exactly the same way as the invocation useDelimiter(Pattern.compile(pattern)). Invoking the reset() method will set the scanner\u0027s delimiter to the default.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - A string specifying a delimiting pattern"
        ],
        "return": [
          "this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Locale",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "locale",
      "comment": "Returns this scanner\u0027s locale. A scanner\u0027s locale affects many elements of its default primitive matching regular expressions; see localized numbers above.",
      "tagMap": {
        "return": [
          "this scanner\u0027s locale"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Scanner",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Locale",
            "type": "Class"
          },
          "field": {
            "name": "locale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "useLocale",
      "comment": "Sets this scanner\u0027s locale to the specified locale. A scanner\u0027s locale affects many elements of its default primitive matching regular expressions; see localized numbers above. Invoking the reset() method will set the scanner\u0027s locale to the initial locale.",
      "tagMap": {
        "param": [
          "\u003ccode\u003elocale\u003c/code\u003e - A string specifying the locale to use"
        ],
        "return": [
          "this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "radix",
      "comment": "Returns this scanner\u0027s default radix. A scanner\u0027s radix affects elements of its default number matching regular expressions; see localized numbers above.",
      "tagMap": {
        "return": [
          "the default radix of this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Scanner",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "useRadix",
      "comment": "Sets this scanner\u0027s default radix to the specified radix. A scanner\u0027s radix affects elements of its default number matching regular expressions; see localized numbers above. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown. Invoking the reset() method will set the scanner\u0027s radix to 10.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - The radix to use when scanning numbers"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if radix is out of range"
        ],
        "return": [
          "this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.regex.MatchResult",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "match",
      "comment": "Returns the match result of the last scanning operation performed by this scanner. This method throws IllegalStateException if no match has been performed, or if the last match was not successful. The various next methods of Scanner make a match result available if they complete without throwing an exception. For instance, after an invocation of the nextInt() method that returned an int, this method returns a MatchResult for the search of the Integer regular expression defined above. Similarly the findInLine(), findWithinHorizon(), and skip() methods will make a match available if they succeed.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - If no match result is available"
        ],
        "return": [
          "a match result for the last match operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns the string representation of this Scanner. The string representation of a Scanner contains information that may be useful for debugging. The exact format is unspecified.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "The string representation of this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNext",
      "comment": "Returns true if this scanner has another token in its input. This method may block while waiting for input to scan. The scanner does not advance past any input.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eIterator\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html#hasNext()\"\u003ehasNext\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html\" title\u003d\"interface in java.util\"\u003eIterator\u003c/a\u003e\u0026lt;\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/String.html\" title\u003d\"class in java.lang\"\u003eString\u003c/a\u003e\u0026gt;\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner has another token"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "next",
      "comment": "Finds and returns the next complete token from this scanner. A complete token is preceded and followed by input that matches the delimiter pattern. This method may block while waiting for input to scan, even if a previous invocation of hasNext() returned true.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eIterator\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html#next()\"\u003enext\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html\" title\u003d\"interface in java.util\"\u003eIterator\u003c/a\u003e\u0026lt;\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/String.html\" title\u003d\"class in java.lang\"\u003eString\u003c/a\u003e\u0026gt;\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if no more tokens are available",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the next token"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "remove",
      "comment": "The remove operation is not supported by this implementation of Iterator.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eIterator\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html#remove()\"\u003eremove\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html\" title\u003d\"interface in java.util\"\u003eIterator\u003c/a\u003e\u0026lt;\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/String.html\" title\u003d\"class in java.lang\"\u003eString\u003c/a\u003e\u0026gt;\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this method is invoked."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNext",
      "comment": "Returns true if the next token matches the pattern constructed from the specified string. The scanner does not advance past any input. An invocation of this method of the form hasNext(pattern) behaves in exactly the same way as the invocation hasNext(Pattern.compile(pattern)).",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - a string specifying the pattern to scan"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner has another token matching the specified pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "next",
      "comment": "Returns the next token if it matches the pattern constructed from the specified string. If the match is successful, the scanner advances past the input that matched the pattern. An invocation of this method of the form next(pattern) behaves in exactly the same way as the invocation next(Pattern.compile(pattern)).",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - a string specifying the pattern to scan"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if no such tokens are available",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the next token"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.regex.Pattern",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNext",
      "comment": "Returns true if the next complete token matches the specified pattern. A complete token is prefixed and postfixed by input that matches the delimiter pattern. This method may block while waiting for input. The scanner does not advance past any input.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern to scan for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner has another token matching the specified pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.regex.Pattern",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "next",
      "comment": "Returns the next token if it matches the specified pattern. This method may block while waiting for input to scan, even if a previous invocation of hasNext(Pattern) returned true. If the match is successful, the scanner advances past the input that matched the pattern.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern to scan for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if no more tokens are available",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the next token"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextLine",
      "comment": "Returns true if there is another line in the input of this scanner. This method may block while waiting for input. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner has another line of input"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextLine",
      "comment": "Advances this scanner past the current line and returns the input that was skipped. This method returns the rest of the current line, excluding any line separator at the end. The position is set to the beginning of the next line. Since this method continues to search through the input looking for a line separator, it may buffer all of the input searching for the line to skip if no line separators are present.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if no line was found",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the line that was skipped"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findInLine",
      "comment": "Attempts to find the next occurrence of a pattern constructed from the specified string, ignoring delimiters. An invocation of this method of the form findInLine(pattern) behaves in exactly the same way as the invocation findInLine(Pattern.compile(pattern)).",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - a string specifying the pattern to search for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the text that matched the specified pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.regex.Pattern",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findInLine",
      "comment": "Attempts to find the next occurrence of the specified pattern ignoring delimiters. If the pattern is found before the next line separator, the scanner advances past the input that matched and returns the string that matched the pattern. If no such pattern is detected in the input up to the next line separator, then null is returned and the scanner\u0027s position is unchanged. This method may block waiting for input that matches the pattern. Since this method continues to search through the input looking for the specified pattern, it may buffer all of the input searching for the desired token if no line separators are present.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern to scan for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the text that matched the specified pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "horizon"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findWithinHorizon",
      "comment": "Attempts to find the next occurrence of a pattern constructed from the specified string, ignoring delimiters. An invocation of this method of the form findWithinHorizon(pattern) behaves in exactly the same way as the invocation findWithinHorizon(Pattern.compile(pattern), horizon).",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - a string specifying the pattern to search for",
          "\u003ccode\u003ehorizon\u003c/code\u003e - the search horizon"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if horizon is negative"
        ],
        "return": [
          "the text that matched the specified pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.regex.Pattern",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "horizon"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findWithinHorizon",
      "comment": "Attempts to find the next occurrence of the specified pattern. This method searches through the input up to the specified search horizon, ignoring delimiters. If the pattern is found the scanner advances past the input that matched and returns the string that matched the pattern. If no such pattern is detected then the null is returned and the scanner\u0027s position remains unchanged. This method may block waiting for input that matches the pattern. A scanner will never search more than horizon code points beyond its current position. Note that a match may be clipped by the horizon; that is, an arbitrary match result may have been different if the horizon had been larger. The scanner treats the horizon as a transparent, non-anchoring bound (see Matcher.useTransparentBounds(boolean) and Matcher.useAnchoringBounds(boolean)). If horizon is 0, then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern. If horizon is negative, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern to scan for",
          "\u003ccode\u003ehorizon\u003c/code\u003e - the search horizon"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if horizon is negative"
        ],
        "return": [
          "the text that matched the specified pattern"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Scanner",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.regex.Pattern",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "skip",
      "comment": "Skips input that matches the specified pattern, ignoring delimiters. This method will skip input if an anchored match of the specified pattern succeeds. If a match to the specified pattern is not found at the current position, then no input is skipped and a NoSuchElementException is thrown. Since this method seeks to match the specified pattern starting at the scanner\u0027s current position, patterns that can match a lot of input (\".*\", for example) may cause the scanner to buffer a large amount of input. Note that it is possible to skip something without risking a NoSuchElementException by using a pattern that can match nothing, e.g., sc.skip(\"[ \\t]*\").",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - a string specifying the pattern to skip over"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if the specified pattern is not found",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Scanner",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "skip",
      "comment": "Skips input that matches a pattern constructed from the specified string. An invocation of this method of the form skip(pattern) behaves in exactly the same way as the invocation skip(Pattern.compile(pattern)).",
      "tagMap": {
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - a string specifying the pattern to skip over"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "this scanner"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextBoolean",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a boolean value using a case insensitive pattern created from the string \"true|false\". The scanner does not advance past the input that matched.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid boolean value"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextBoolean",
      "comment": "Scans the next token of the input into a boolean value and returns that value. This method will throw InputMismatchException if the next token cannot be translated into a valid boolean value. If the match is successful, the scanner advances past the input that matched.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token is not a valid boolean",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the boolean scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextByte",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a byte value in the default radix using the nextByte() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid byte value"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextByte",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a byte value in the specified radix using the nextByte() method. The scanner does not advance past any input. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as a byte value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid byte value"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextByte",
      "comment": "Scans the next token of the input as a byte. An invocation of this method of the form nextByte() behaves in exactly the same way as the invocation nextByte(radix), where radix is the default radix of this scanner.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003ebyte\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextByte",
      "comment": "Scans the next token of the input as a byte. This method will throw InputMismatchException if the next token cannot be translated into a valid byte value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into a byte value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Byte.parseByte with the specified radix. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as a byte value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "the \n\u003ccode\u003ebyte\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextShort",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a short value in the default radix using the nextShort() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid short value in the default radix"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextShort",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a short value in the specified radix using the nextShort() method. The scanner does not advance past any input. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as a short value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid short value in the specified radix"
        ]
      }
    },
    {
      "returnType": {
        "name": "short",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextShort",
      "comment": "Scans the next token of the input as a short. An invocation of this method of the form nextShort() behaves in exactly the same way as the invocation nextShort(radix), where radix is the default radix of this scanner.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003eshort\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "short",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextShort",
      "comment": "Scans the next token of the input as a short. This method will throw InputMismatchException if the next token cannot be translated into a valid short value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into a short value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Short.parseShort with the specified radix. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as a short value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "the \n\u003ccode\u003eshort\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextInt",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as an int value in the default radix using the nextInt() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid int value"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextInt",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as an int value in the specified radix using the nextInt() method. The scanner does not advance past any input. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as an int value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid int value"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextInt",
      "comment": "Scans the next token of the input as an int. An invocation of this method of the form nextInt() behaves in exactly the same way as the invocation nextInt(radix), where radix is the default radix of this scanner.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003eint\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextInt",
      "comment": "Scans the next token of the input as an int. This method will throw InputMismatchException if the next token cannot be translated into a valid int value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into an int value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Integer.parseInt with the specified radix. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as an int value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "the \n\u003ccode\u003eint\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextLong",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a long value in the default radix using the nextLong() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid long value"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextLong",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a long value in the specified radix using the nextLong() method. The scanner does not advance past any input. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as a long value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid long value"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextLong",
      "comment": "Scans the next token of the input as a long. An invocation of this method of the form nextLong() behaves in exactly the same way as the invocation nextLong(radix), where radix is the default radix of this scanner.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003elong\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextLong",
      "comment": "Scans the next token of the input as a long. This method will throw InputMismatchException if the next token cannot be translated into a valid long value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into a long value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Long.parseLong with the specified radix. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as an int value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "the \n\u003ccode\u003elong\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextFloat",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a float value using the nextFloat() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid float value"
        ]
      }
    },
    {
      "returnType": {
        "name": "float",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextFloat",
      "comment": "Scans the next token of the input as a float. This method will throw InputMismatchException if the next token cannot be translated into a valid float value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Float regular expression defined above then the token is converted into a float value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Float.parseFloat. If the token matches the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\" is passed to Float.parseFloat as appropriate.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eFloat\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003efloat\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextDouble",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a double value using the nextDouble() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid double value"
        ]
      }
    },
    {
      "returnType": {
        "name": "double",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextDouble",
      "comment": "Scans the next token of the input as a double. This method will throw InputMismatchException if the next token cannot be translated into a valid double value. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Float regular expression defined above then the token is converted into a double value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Double.parseDouble. If the token matches the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\" is passed to Double.parseDouble as appropriate.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eFloat\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if the input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003edouble\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextBigInteger",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a BigInteger in the default radix using the nextBigInteger() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid \n\u003ccode\u003eBigInteger\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextBigInteger",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a BigInteger in the specified radix using the nextBigInteger() method. The scanner does not advance past any input. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token as an integer"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid \n\u003ccode\u003eBigInteger\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.math.BigInteger",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextBigInteger",
      "comment": "Scans the next token of the input as a BigInteger. An invocation of this method of the form nextBigInteger() behaves in exactly the same way as the invocation nextBigInteger(radix), where radix is the default radix of this scanner.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if the input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003eBigInteger\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.math.BigInteger",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "radix"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextBigInteger",
      "comment": "Scans the next token of the input as a BigInteger. If the next token matches the Integer regular expression defined above then the token is converted into a BigInteger value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the Character.digit, and passing the resulting string to the BigInteger(String, int) constructor with the specified radix. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eradix\u003c/code\u003e - the radix used to interpret the token"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eInteger\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if the input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the radix is out of range"
        ],
        "return": [
          "the \n\u003ccode\u003eBigInteger\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasNextBigDecimal",
      "comment": "Returns true if the next token in this scanner\u0027s input can be interpreted as a BigDecimal using the nextBigDecimal() method. The scanner does not advance past any input.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "true if and only if this scanner\u0027s next token is a valid \n\u003ccode\u003eBigDecimal\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.math.BigDecimal",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "nextBigDecimal",
      "comment": "Scans the next token of the input as a BigDecimal. If the next token matches the Decimal regular expression defined above then the token is converted into a BigDecimal value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the Character.digit, and passing the resulting string to the BigDecimal(String) constructor.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/InputMismatchException.html\" title\u003d\"class in java.util\"\u003eInputMismatchException\u003c/a\u003e\u003c/code\u003e - if the next token does not match the \n\u003ci\u003eDecimal\u003c/i\u003e regular expression, or is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/NoSuchElementException.html\" title\u003d\"class in java.util\"\u003eNoSuchElementException\u003c/a\u003e\u003c/code\u003e - if the input is exhausted",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "the \n\u003ccode\u003eBigDecimal\u003c/code\u003e scanned from the input"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Scanner",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "reset",
      "comment": "Resets this scanner. Resetting a scanner discards all of its explicit state information which may have been changed by invocations of useDelimiter(), useLocale(), or useRadix(). An invocation of this method of the form scanner.reset() behaves in exactly the same way as the invocation \n   scanner.useDelimiter(\"\\\\p{javaWhitespace}+\")\n          .useLocale(Locale.getDefault(Locale.Category.FORMAT))\n          .useRadix(10);",
      "tagMap": {
        "return": [
          "this scanner"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "tokens",
      "comment": "Returns a stream of delimiter-separated tokens from this scanner. The stream contains the same tokens that would be returned, starting from this scanner\u0027s current state, by calling the next() method repeatedly until the hasNext() method returns false. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than close() and ioException() may return undefined results or may cause undefined effects on the returned stream. The returned stream\u0027s source Spliterator is fail-fast and will, on a best-effort basis, throw a ConcurrentModificationException if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its close() method, or by closing the returned stream. Closing the stream will close the underlying scanner. IllegalStateException is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. This method might block waiting for more input.",
      "tagMap": {
        "apiNote": [
          "For example, the following code will create a list of comma-delimited tokens from a string: \n\u003cpre\u003e\u003ccode\u003e\n List\u0026lt;String\u0026gt; result \u003d new Scanner(\"abc,def,,ghi\")\n     .useDelimiter(\",\")\n     .tokens()\n     .collect(Collectors.toList());\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003eThe resulting list would contain \u003ccode\u003e\"abc\"\u003c/code\u003e, \u003ccode\u003e\"def\"\u003c/code\u003e, the empty string, and \u003ccode\u003e\"ghi\"\u003c/code\u003e.\u003c/p\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "a sequential stream of token strings"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "java.util.regex.MatchResult",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.regex.Pattern",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findAll",
      "comment": "Returns a stream of match results from this scanner. The stream contains the same results in the same order that would be returned by calling findWithinHorizon(pattern, 0) and then match() successively as long as findWithinHorizon() finds matches. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than close() and ioException() may return undefined results or may cause undefined effects on the returned stream. The returned stream\u0027s source Spliterator is fail-fast and will, on a best-effort basis, throw a ConcurrentModificationException if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its close() method, or by closing the returned stream. Closing the stream will close the underlying scanner. IllegalStateException is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. As with the findWithinHorizon() methods, this method might block waiting for additional input, and it might buffer an unbounded amount of input searching for a match.",
      "tagMap": {
        "apiNote": [
          "For example, the following code will read a file and return a list of all sequences of characters consisting of seven or more Latin capital letters: \n\u003cpre\u003e\u003ccode\u003e\n try (Scanner sc \u003d new Scanner(Path.of(\"input.txt\"))) {\n     Pattern pat \u003d Pattern.compile(\"[A-Z]{7,}\");\n     List\u0026lt;String\u0026gt; capWords \u003d sc.findAll(pat)\n                               .map(MatchResult::group)\n                               .collect(Collectors.toList());\n }\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern to be matched"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if pattern is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed"
        ],
        "return": [
          "a sequential stream of match results"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.stream.Stream",
        "parameters": [
          {
            "name": "java.util.regex.MatchResult",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "patString"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findAll",
      "comment": "Returns a stream of match results that match the provided pattern string. The effect is equivalent to the following code: \n     scanner.findAll(Pattern.compile(patString))",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/Pattern.html\" title\u003d\"class in java.util.regex\"\u003e\u003ccode\u003ePattern\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003epatString\u003c/code\u003e - the pattern string"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if patString is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this scanner is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/PatternSyntaxException.html\" title\u003d\"class in java.util.regex\"\u003ePatternSyntaxException\u003c/a\u003e\u003c/code\u003e - if the regular expression\u0027s syntax is invalid"
        ],
        "return": [
          "a sequential stream of match results"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.Readable",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified source.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A character source implementing the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Readable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eReadable\u003c/code\u003e\u003c/a\u003e interface"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.io.InputStream",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified input stream. Bytes from the stream are converted into characters using the underlying platform\u0027s default charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - An input stream to be scanned"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.io.InputStream",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "charsetName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified input stream. Bytes from the stream are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - An input stream to be scanned",
          "\u003ccode\u003echarsetName\u003c/code\u003e - The encoding type used to convert bytes from the stream into characters to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the specified character set does not exist"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.io.InputStream",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.nio.charset.Charset",
            "type": "Class"
          },
          "field": {
            "name": "charset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified input stream. Bytes from the stream are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - an input stream to be scanned",
          "\u003ccode\u003echarset\u003c/code\u003e - the charset used to convert bytes from the file into characters to be scanned"
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.FileNotFoundException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.io.File",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the underlying platform\u0027s default charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A file to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/FileNotFoundException.html\" title\u003d\"class in java.io\"\u003eFileNotFoundException\u003c/a\u003e\u003c/code\u003e - if source is not found"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.FileNotFoundException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.io.File",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "charsetName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A file to be scanned",
          "\u003ccode\u003echarsetName\u003c/code\u003e - The encoding type used to convert bytes from the file into characters to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/FileNotFoundException.html\" title\u003d\"class in java.io\"\u003eFileNotFoundException\u003c/a\u003e\u003c/code\u003e - if source is not found",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the specified encoding is not found"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.io.File",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.nio.charset.Charset",
            "type": "Class"
          },
          "field": {
            "name": "charset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A file to be scanned",
          "\u003ccode\u003echarset\u003c/code\u003e - The charset used to convert bytes from the file into characters to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs opening the source"
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.file.Path",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the underlying platform\u0027s default charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - the path to the file to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs opening source"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.file.Path",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "charsetName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - the path to the file to be scanned",
          "\u003ccode\u003echarsetName\u003c/code\u003e - The encoding type used to convert bytes from the file into characters to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs opening source",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the specified encoding is not found"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.file.Path",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.nio.charset.Charset",
            "type": "Class"
          },
          "field": {
            "name": "charset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - the path to the file to be scanned",
          "\u003ccode\u003echarset\u003c/code\u003e - the charset used to convert bytes from the file into characters to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs opening the source"
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified string.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A string to scan"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.nio.channels.ReadableByteChannel",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified channel. Bytes from the source are converted into characters using the underlying platform\u0027s default charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A channel to scan"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.nio.channels.ReadableByteChannel",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "charsetName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified channel. Bytes from the source are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - A channel to scan",
          "\u003ccode\u003echarsetName\u003c/code\u003e - The encoding type used to convert bytes from the channel into characters to be scanned"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the specified character set does not exist"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.nio.channels.ReadableByteChannel",
            "type": "Class"
          },
          "field": {
            "name": "source"
          }
        },
        {
          "type": {
            "name": "java.nio.charset.Charset",
            "type": "Class"
          },
          "field": {
            "name": "charset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a new Scanner that produces values scanned from the specified channel. Bytes from the source are converted into characters using the specified charset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esource\u003c/code\u003e - a channel to scan",
          "\u003ccode\u003echarset\u003c/code\u003e - the encoding type used to convert bytes from the channel into characters to be scanned"
        ],
        "since": [
          "10"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.util.Scanner",
  "comment": "A simple text scanner which can parse primitive types and strings using regular expressions. \n\u003cp\u003eA \u003ccode\u003eScanner\u003c/code\u003e breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various \u003ccode\u003enext\u003c/code\u003e methods. \u003c/p\u003e\n\u003cp\u003eFor example, this code allows a user to read a number from \u003ccode\u003eSystem.in\u003c/code\u003e: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n     Scanner sc \u003d new Scanner(System.in);\n     int i \u003d sc.nextInt();\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eAs another example, this code allows \u003ccode\u003elong\u003c/code\u003e types to be assigned from entries in a file \u003ccode\u003emyNumbers\u003c/code\u003e: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n      Scanner sc \u003d new Scanner(new File(\"myNumbers\"));\n      while (sc.hasNextLong()) {\n          long aLong \u003d sc.nextLong();\n      }\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe scanner can also use delimiters other than whitespace. This example reads several items in from a string: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n     String input \u003d \"1 fish 2 fish red fish blue fish\";\n     Scanner s \u003d new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\n     System.out.println(s.nextInt());\n     System.out.println(s.nextInt());\n     System.out.println(s.next());\n     System.out.println(s.next());\n     s.close();\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e prints the following output: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n     1\n     2\n     red\n     blue\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe same output can be generated with this code, which uses a regular expression to parse all four tokens at once: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n     String input \u003d \"1 fish 2 fish red fish blue fish\";\n     Scanner s \u003d new Scanner(input);\n     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");\n     MatchResult result \u003d s.match();\n     for (int i\u003d1; i\u0026lt;\u003dresult.groupCount(); i++)\n         System.out.println(result.group(i));\n     s.close();\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ca id\u003d\"default-delimiter\"\u003edefault whitespace delimiter\u003c/a\u003e used by a scanner is as recognized by \u003ca href\u003d\"../lang/Character.html#isWhitespace(int)\"\u003e\u003ccode\u003eCharacter.isWhitespace()\u003c/code\u003e\u003c/a\u003e. The \u003ca href\u003d\"#reset()\"\u003e\u003ccode\u003ereset()\u003c/code\u003e\u003c/a\u003e method will reset the value of the scanner\u0027s delimiter to the default whitespace delimiter regardless of whether it was previously changed. \u003c/p\u003e\n\u003cp\u003eA scanning operation may block waiting for input. \u003c/p\u003e\n\u003cp\u003eThe \u003ca href\u003d\"#next()\"\u003e\u003ccode\u003enext()\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#hasNext()\"\u003e\u003ccode\u003ehasNext()\u003c/code\u003e\u003c/a\u003e methods and their companion methods (such as \u003ca href\u003d\"#nextInt()\"\u003e\u003ccode\u003enextInt()\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#hasNextInt()\"\u003e\u003ccode\u003ehasNextInt()\u003c/code\u003e\u003c/a\u003e) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both \u003ccode\u003ehasNext()\u003c/code\u003e and \u003ccode\u003enext()\u003c/code\u003e methods may block waiting for further input. Whether a \u003ccode\u003ehasNext()\u003c/code\u003e method blocks has no connection to whether or not its associated \u003ccode\u003enext()\u003c/code\u003e method will block. The \u003ca href\u003d\"#tokens()\"\u003e\u003ccode\u003etokens()\u003c/code\u003e\u003c/a\u003e method may also block waiting for input. \u003c/p\u003e\n\u003cp\u003eThe \u003ca href\u003d\"#findInLine(java.lang.String)\"\u003e\u003ccode\u003efindInLine()\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#findWithinHorizon(java.lang.String,int)\"\u003e\u003ccode\u003efindWithinHorizon()\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#skip(java.util.regex.Pattern)\"\u003e\u003ccode\u003eskip()\u003c/code\u003e\u003c/a\u003e, and \u003ca href\u003d\"#findAll(java.util.regex.Pattern)\"\u003e\u003ccode\u003efindAll()\u003c/code\u003e\u003c/a\u003e methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input. \u003c/p\u003e\n\u003cp\u003eWhen a scanner throws an \u003ca href\u003d\"InputMismatchException.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eInputMismatchException\u003c/code\u003e\u003c/a\u003e, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method. \u003c/p\u003e\n\u003cp\u003eDepending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern \u003ccode\u003e\"\\\\s+\"\u003c/code\u003e will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern \u003ccode\u003e\"\\\\s\"\u003c/code\u003e could return empty tokens since it only passes one space at a time. \u003c/p\u003e\n\u003cp\u003e A scanner can read text from any object which implements the \u003ca href\u003d\"../lang/Readable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eReadable\u003c/code\u003e\u003c/a\u003e interface. If an invocation of the underlying readable\u0027s \u003ca href\u003d\"../lang/Readable.html#read(java.nio.CharBuffer)\"\u003e\u003ccode\u003eread()\u003c/code\u003e\u003c/a\u003e method throws an \u003ca href\u003d\"../io/IOException.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003eIOException\u003c/code\u003e\u003c/a\u003e then the scanner assumes that the end of the input has been reached. The most recent \u003ccode\u003eIOException\u003c/code\u003e thrown by the underlying readable can be retrieved via the \u003ca href\u003d\"#ioException()\"\u003e\u003ccode\u003eioException()\u003c/code\u003e\u003c/a\u003e method. \u003c/p\u003e\n\u003cp\u003eWhen a \u003ccode\u003eScanner\u003c/code\u003e is closed, it will close its input source if the source implements the \u003ca href\u003d\"../io/Closeable.html\" title\u003d\"interface in java.io\"\u003e\u003ccode\u003eCloseable\u003c/code\u003e\u003c/a\u003e interface. \u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eScanner\u003c/code\u003e is not safe for multithreaded use without external synchronization. \u003c/p\u003e\n\u003cp\u003eUnless otherwise mentioned, passing a \u003ccode\u003enull\u003c/code\u003e parameter into any method of a \u003ccode\u003eScanner\u003c/code\u003e will cause a \u003ccode\u003eNullPointerException\u003c/code\u003e to be thrown. \u003c/p\u003e\n\u003cp\u003eA scanner will default to interpreting numbers as decimal unless a different radix has been set by using the \u003ca href\u003d\"#useRadix(int)\"\u003e\u003ccode\u003euseRadix(int)\u003c/code\u003e\u003c/a\u003e method. The \u003ca href\u003d\"#reset()\"\u003e\u003ccode\u003ereset()\u003c/code\u003e\u003c/a\u003e method will reset the value of the scanner\u0027s radix to \u003ccode\u003e10\u003c/code\u003e regardless of whether it was previously changed. \u003c/p\u003e\n\u003ch2\u003e \u003ca id\u003d\"localized-numbers\"\u003eLocalized numbers\u003c/a\u003e \u003c/h2\u003e \n\u003cp\u003e An instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner\u0027s locale. A scanner\u0027s \u003ca id\u003d\"initial-locale\"\u003einitial locale \u003c/a\u003eis the value returned by the \u003ca href\u003d\"Locale.html#getDefault(java.util.Locale.Category)\"\u003e\u003ccode\u003eLocale.getDefault(Locale.Category.FORMAT)\u003c/code\u003e\u003c/a\u003e method; it may be changed via the \u003ca href\u003d\"#useLocale(java.util.Locale)\"\u003e\u003ccode\u003euseLocale()\u003c/code\u003e\u003c/a\u003e method. The \u003ca href\u003d\"#reset()\"\u003e\u003ccode\u003ereset()\u003c/code\u003e\u003c/a\u003e method will reset the value of the scanner\u0027s locale to the initial locale regardless of whether it was previously changed. \u003c/p\u003e\n\u003cp\u003eThe localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale\u0027s \u003ca href\u003d\"../text/DecimalFormat.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eDecimalFormat\u003c/code\u003e\u003c/a\u003e object, \u003ccode\u003edf\u003c/code\u003e, and its and \u003ca href\u003d\"../text/DecimalFormatSymbols.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e\u003c/a\u003e object, \u003ccode\u003edfs\u003c/code\u003e. \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cdl\u003e \n  \u003cdt\u003e\n   \u003ci\u003eLocalGroupSeparator\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The character used to separate thousands groups, \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edfs.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormatSymbols.html#getGroupingSeparator()\"\u003e\u003ccode\u003egetGroupingSeparator()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n  \u003cdt\u003e\n   \u003ci\u003eLocalDecimalSeparator\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The character used for the decimal point, \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edfs.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormatSymbols.html#getDecimalSeparator()\"\u003e\u003ccode\u003egetDecimalSeparator()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n  \u003cdt\u003e\n   \u003ci\u003eLocalPositivePrefix\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The string that appears before a positive number (may be empty), \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edf.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormat.html#getPositivePrefix()\"\u003e\u003ccode\u003egetPositivePrefix()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n  \u003cdt\u003e\n   \u003ci\u003eLocalPositiveSuffix\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The string that appears after a positive number (may be empty), \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edf.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormat.html#getPositiveSuffix()\"\u003e\u003ccode\u003egetPositiveSuffix()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n  \u003cdt\u003e\n   \u003ci\u003eLocalNegativePrefix\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The string that appears before a negative number (may be empty), \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edf.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormat.html#getNegativePrefix()\"\u003e\u003ccode\u003egetNegativePrefix()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n  \u003cdt\u003e\n   \u003ci\u003eLocalNegativeSuffix\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The string that appears after a negative number (may be empty), \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edf.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormat.html#getNegativeSuffix()\"\u003e\u003ccode\u003egetNegativeSuffix()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n  \u003cdt\u003e\n   \u003ci\u003eLocalNaN\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The string that represents not-a-number for floating-point values, \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edfs.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormatSymbols.html#getNaN()\"\u003e\u003ccode\u003egetNaN()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n  \u003cdt\u003e\n   \u003ci\u003eLocalInfinity\u0026nbsp;\u0026nbsp;\u003c/i\u003e \n  \u003c/dt\u003e\n  \u003cdd\u003e\n   The string that represents infinity for floating-point values, \n   \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\n   \u003ccode\u003edfs.\u003c/code\u003e\n   \u003ca href\u003d\"../text/DecimalFormatSymbols.html#getInfinity()\"\u003e\u003ccode\u003egetInfinity()\u003c/code\u003e\u003c/a\u003e \n  \u003c/dd\u003e\n \u003c/dl\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch3\u003e \u003ca id\u003d\"number-syntax\"\u003eNumber syntax\u003c/a\u003e \u003c/h3\u003e \n\u003cp\u003e The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10). \u003c/p\u003e\n\u003cdl\u003e \n \u003cdt\u003e\n  \u003ci\u003eNonAsciiDigit\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  A non-ASCII character c for which \n  \u003ca href\u003d\"../lang/Character.html#isDigit(char)\"\u003e\u003ccode\u003eCharacter.isDigit\u003c/code\u003e\u003c/a\u003e\n  \u003ccode\u003e(c)\u003c/code\u003e returns\u0026nbsp;true \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eNon0Digit\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e[1-\u003c/code\u003e\n  \u003ci\u003eRmax\u003c/i\u003e\n  \u003ccode\u003e] | \u003c/code\u003e\n  \u003ci\u003eNonASCIIDigit\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eDigit\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e[0-\u003c/code\u003e\n  \u003ci\u003eRmax\u003c/i\u003e\n  \u003ccode\u003e] | \u003c/code\u003e\n  \u003ci\u003eNonASCIIDigit\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eGroupedNumeral\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e(\u0026nbsp;\u003c/code\u003e\n  \u003ci\u003eNon0Digit\u003c/i\u003e \n  \u003ci\u003eDigit\u003c/i\u003e\n  \u003ccode\u003e? \u003c/code\u003e\n  \u003ci\u003eDigit\u003c/i\u003e\n  \u003ccode\u003e?\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\n  \u003ccode\u003e(\u0026nbsp;\u003c/code\u003e\n  \u003ci\u003eLocalGroupSeparator\u003c/i\u003e \n  \u003ci\u003eDigit\u003c/i\u003e \n  \u003ci\u003eDigit\u003c/i\u003e \n  \u003ci\u003eDigit\u003c/i\u003e\n  \u003ccode\u003e )+ )\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eNumeral\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e( ( \u003c/code\u003e\n  \u003ci\u003eDigit\u003c/i\u003e\n  \u003ccode\u003e+ ) | \u003c/code\u003e\n  \u003ci\u003eGroupedNumeral\u003c/i\u003e\n  \u003ccode\u003e )\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ca id\u003d\"Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e:\u003c/a\u003e \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e( [-+]? ( \u003c/code\u003e\n  \u003ci\u003eNumeral\u003c/i\u003e\n  \u003ccode\u003e ) )\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eLocalPositivePrefix\u003c/i\u003e \n  \u003ci\u003eNumeral\u003c/i\u003e \n  \u003ci\u003eLocalPositiveSuffix\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eLocalNegativePrefix\u003c/i\u003e \n  \u003ci\u003eNumeral\u003c/i\u003e \n  \u003ci\u003eLocalNegativeSuffix\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eDecimalNumeral\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ci\u003eNumeral\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eNumeral\u003c/i\u003e \n  \u003ci\u003eLocalDecimalSeparator\u003c/i\u003e \n  \u003ci\u003eDigit\u003c/i\u003e\n  \u003ccode\u003e*\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eLocalDecimalSeparator\u003c/i\u003e \n  \u003ci\u003eDigit\u003c/i\u003e\n  \u003ccode\u003e+\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eExponent\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e( [eE] [+-]? \u003c/code\u003e\n  \u003ci\u003eDigit\u003c/i\u003e\n  \u003ccode\u003e+ )\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ca id\u003d\"Decimal-regex\"\u003e\u003ci\u003eDecimal\u003c/i\u003e:\u003c/a\u003e \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e( [-+]? \u003c/code\u003e\n  \u003ci\u003eDecimalNumeral\u003c/i\u003e \n  \u003ci\u003eExponent\u003c/i\u003e\n  \u003ccode\u003e? )\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eLocalPositivePrefix\u003c/i\u003e \n  \u003ci\u003eDecimalNumeral\u003c/i\u003e \n  \u003ci\u003eLocalPositiveSuffix\u003c/i\u003e \n  \u003ci\u003eExponent\u003c/i\u003e\n  \u003ccode\u003e?\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eLocalNegativePrefix\u003c/i\u003e \n  \u003ci\u003eDecimalNumeral\u003c/i\u003e \n  \u003ci\u003eLocalNegativeSuffix\u003c/i\u003e \n  \u003ci\u003eExponent\u003c/i\u003e\n  \u003ccode\u003e?\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eHexFloat\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e[-+]? 0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+ ([pP][-+]?[0-9]+)?\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eNonNumber\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003eNaN | \u003c/code\u003e\n  \u003ci\u003eLocalNan\u003c/i\u003e\n  \u003ccode\u003e | Infinity | \u003c/code\u003e\n  \u003ci\u003eLocalInfinity\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ci\u003eSignedNonNumber\u003c/i\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ccode\u003e( [-+]? \u003c/code\u003e\n  \u003ci\u003eNonNumber\u003c/i\u003e\n  \u003ccode\u003e )\u003c/code\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eLocalPositivePrefix\u003c/i\u003e \n  \u003ci\u003eNonNumber\u003c/i\u003e \n  \u003ci\u003eLocalPositiveSuffix\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdd\u003e\n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eLocalNegativePrefix\u003c/i\u003e \n  \u003ci\u003eNonNumber\u003c/i\u003e \n  \u003ci\u003eLocalNegativeSuffix\u003c/i\u003e \n \u003c/dd\u003e\n \u003cdt\u003e\n  \u003ca id\u003d\"Float-regex\"\u003e\u003ci\u003eFloat\u003c/i\u003e\u003c/a\u003e: \n \u003c/dt\u003e\n \u003cdd\u003e\n  \u003ci\u003eDecimal\u003c/i\u003e \n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eHexFloat\u003c/i\u003e \n  \u003ccode\u003e| \u003c/code\u003e\n  \u003ci\u003eSignedNonNumber\u003c/i\u003e \n \u003c/dd\u003e\n\u003c/dl\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eWhitespace is not significant in the above regular expressions.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.5"
    ]
  }
}