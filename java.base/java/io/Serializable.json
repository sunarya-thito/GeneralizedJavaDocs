{
  "packageName": "java.io",
  "simpleName": "Serializable",
  "moduleName": "java.base",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "java.io.Serializable",
  "comment": "Serializability of a class is enabled by the class implementing the java.io.Serializable interface. \n\u003cp\u003e\u003cstrong\u003eWarning: Deserialization of untrusted data is inherently dangerous and should be avoided. Untrusted data should be carefully validated according to the \"Serialization and Deserialization\" section of the \u003ca href\u003d\"https://docs.oracle.com/pls/topic/lookup?ctx\u003djavase16\u0026amp;id\u003dsecure_coding_guidelines_javase\"\u003eSecure Coding Guidelines for Java SE\u003c/a\u003e. \u003ca href\u003d\"https://docs.oracle.com/pls/topic/lookup?ctx\u003djavase16\u0026amp;id\u003dserialization_filter_guide\"\u003eSerialization Filtering\u003c/a\u003e describes best practices for defensive use of serial filters. \u003c/strong\u003e\u003c/p\u003e Classes that do not implement this interface will not have any of their state serialized or deserialized. All subtypes of a serializable class are themselves serializable. The serialization interface has no methods or fields and serves only to identify the semantics of being serializable. \n\u003cp\u003e It is possible for subtypes of non-serializable classes to be serialized and deserialized. During serialization, no data will be written for the fields of non-serializable superclasses. During deserialization, the fields of non-serializable superclasses will be initialized using the no-arg constructor of the first (bottommost) non-serializable superclass. This constructor must be accessible to the subclass that is being deserialized. It is an error to declare a class Serializable if this is not the case; the error will be detected at runtime. A serializable subtype may assume responsibility for saving and restoring the state of a non-serializable supertype\u0027s public, protected, and (if accessible) package-access fields. See the \u003ca href\u003d\"../../../../specs/serialization/input.html#the-objectinputstream-class\"\u003e \u003ccite\u003eJava Object Serialization Specification,\u003c/cite\u003e\u003c/a\u003e section 3.1, for a detailed specification of the deserialization process, including handling of serializable and non-serializable classes. \u003c/p\u003e\n\u003cp\u003e When traversing a graph, an object may be encountered that does not support the Serializable interface. In this case the NotSerializableException will be thrown and will identify the class of the non-serializable object. \u003c/p\u003e\n\u003cp\u003e Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures: \u003c/p\u003e\n\u003cpre\u003e private void writeObject(java.io.ObjectOutputStream out)\n     throws IOException\n private void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException;\n private void readObjectNoData()\n     throws ObjectStreamException;\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The default mechanism for saving the Object\u0027s fields can be invoked by calling out.defaultWriteObject. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput. \u003c/p\u003e\n\u003cp\u003eThe readObject method is responsible for reading from the stream and restoring the classes fields. It may call in.defaultReadObject to invoke the default mechanism for restoring the object\u0027s non-static and non-transient fields. The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object. Reading primitive data types is supported by DataInput. \u003c/p\u003e\n\u003cp\u003eThe readObjectNoData method is responsible for initializing the state of the object for its particular class in the event that the serialization stream does not list the given class as a superclass of the object being deserialized. This may occur in cases where the receiving party uses a different version of the deserialized instance\u0027s class than the sending party, and the receiver\u0027s version extends classes that are not extended by the sender\u0027s version. This may also occur if the serialization stream has been tampered; hence, readObjectNoData is useful for initializing deserialized objects properly despite a \"hostile\" or incomplete source stream. \u003c/p\u003e\n\u003cp\u003eSerializable classes that need to designate an alternative object to be used when writing an object to the stream should implement this special method with the exact signature: \u003c/p\u003e\n\u003cpre\u003e ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;\n \u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e This writeReplace method is invoked by serialization if the method exists and it would be accessible from a method defined within the class of the object being serialized. Thus, the method can have private, protected and package-private access. Subclass access to this method follows java accessibility rules. \u003c/p\u003e\n\u003cp\u003e Classes that need to designate a replacement when an instance of it is read from the stream should implement this special method with the exact signature. \u003c/p\u003e\n\u003cpre\u003e ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;\n \u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e This readResolve method follows the same invocation rules and accessibility rules as writeReplace.\u003c/p\u003e\n\u003cp\u003e Enum types are all serializable and receive treatment defined by the \u003ca href\u003d\"../../../../specs/serialization/index.html\"\u003e\u003ccite\u003e Java Object Serialization Specification\u003c/cite\u003e\u003c/a\u003e during serialization and deserialization. Any declarations of the special handling methods discussed above are ignored for enum types.\u003c/p\u003e\n\u003cp\u003e Record classes can implement \u003ccode\u003eSerializable\u003c/code\u003e and receive treatment defined by the \u003ca href\u003d\"../../../../specs/serialization/serial-arch.html#serialization-of-records\"\u003e \u003ccite\u003eJava Object Serialization Specification,\u003c/cite\u003e Section 1.13, \"Serialization of Records\"\u003c/a\u003e. Any declarations of the special handling methods discussed above are ignored for record types.\u003c/p\u003e\n\u003cp\u003e The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender\u0027s class, then deserialization will result in an \u003ca href\u003d\"InvalidClassException.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003eInvalidClassException\u003c/code\u003e\u003c/a\u003e. A serializable class can declare its own serialVersionUID explicitly by declaring a field named \u003ccode\u003e\"serialVersionUID\"\u003c/code\u003e that must be static, final, and of type \u003ccode\u003elong\u003c/code\u003e: \u003c/p\u003e\n\u003cpre\u003e ANY-ACCESS-MODIFIER static final long serialVersionUID \u003d 42L;\n \u003c/pre\u003e If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the \n\u003ca href\u003d\"../../../../specs/serialization/index.html\"\u003e\u003ccite\u003eJava Object Serialization Specification.\u003c/cite\u003e\u003c/a\u003e This specification defines the serialVersionUID of an enum type to be 0L. However, it is \n\u003cem\u003estrongly recommended\u003c/em\u003e that all serializable classes other than enum types explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected \n\u003ccode\u003eInvalidClassException\u003c/code\u003es during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the \n\u003ccode\u003eprivate\u003c/code\u003e modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/ObjectOutputStream.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003eObjectOutputStream\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/ObjectInputStream.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003eObjectInputStream\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/ObjectOutput.html\" title\u003d\"interface in java.io\"\u003e\u003ccode\u003eObjectOutput\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/ObjectInput.html\" title\u003d\"interface in java.io\"\u003e\u003ccode\u003eObjectInput\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/Externalizable.html\" title\u003d\"interface in java.io\"\u003e\u003ccode\u003eExternalizable\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/index.html\"\u003e \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.1"
    ]
  }
}