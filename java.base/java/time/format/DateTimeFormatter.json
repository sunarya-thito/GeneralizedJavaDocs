{
  "packageName": "java.time.format",
  "simpleName": "DateTimeFormatter",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_LOCAL_DATE",
      "comment": "The ISO date formatter that formats or parses a date without an offset, such as \u00272011-12-03\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended local date format. The format consists of: Four digits or more for the year. Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits. Years outside that range will have a prefixed positive or negative symbol. A dash Two digits for the month-of-year. This is pre-padded by zero to ensure two digits. A dash Two digits for the day-of-month. This is pre-padded by zero to ensure two digits. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_OFFSET_DATE",
      "comment": "The ISO date formatter that formats or parses a date with an offset, such as \u00272011-12-03+01:00\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended offset date format. The format consists of: The ISO_LOCAL_DATE The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. Parsing is case insensitive. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_DATE",
      "comment": "The ISO date formatter that formats or parses a date with the offset if available, such as \u00272011-12-03\u0027 or \u00272011-12-03+01:00\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended date format. The format consists of: The ISO_LOCAL_DATE If the offset is not available then the format is complete. The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. Parsing is case insensitive. As this formatter has an optional element, it may be necessary to parse using parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery\u003c?\u003e...). The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_LOCAL_TIME",
      "comment": "The ISO time formatter that formats or parses a time without an offset, such as \u002710:15\u0027 or \u002710:15:30\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended local time format. The format consists of: Two digits for the hour-of-day. This is pre-padded by zero to ensure two digits. A colon Two digits for the minute-of-hour. This is pre-padded by zero to ensure two digits. If the second-of-minute is not available then the format is complete. A colon Two digits for the second-of-minute. This is pre-padded by zero to ensure two digits. If the nano-of-second is zero or not available then the format is complete. A decimal point One to nine digits for the nano-of-second. As many digits will be output as required. The returned formatter has no override chronology or zone. It uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_OFFSET_TIME",
      "comment": "The ISO time formatter that formats or parses a time with an offset, such as \u002710:15+01:00\u0027 or \u002710:15:30+01:00\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended offset time format. The format consists of: The ISO_LOCAL_TIME The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. Parsing is case insensitive. The returned formatter has no override chronology or zone. It uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_TIME",
      "comment": "The ISO time formatter that formats or parses a time, with the offset if available, such as \u002710:15\u0027, \u002710:15:30\u0027 or \u002710:15:30+01:00\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended offset time format. The format consists of: The ISO_LOCAL_TIME If the offset is not available then the format is complete. The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. Parsing is case insensitive. As this formatter has an optional element, it may be necessary to parse using parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery\u003c?\u003e...). The returned formatter has no override chronology or zone. It uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_LOCAL_DATE_TIME",
      "comment": "The ISO date-time formatter that formats or parses a date-time without an offset, such as \u00272011-12-03T10:15:30\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended offset date-time format. The format consists of: The ISO_LOCAL_DATE The letter \u0027T\u0027. Parsing is case insensitive. The ISO_LOCAL_TIME The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_OFFSET_DATE_TIME",
      "comment": "The ISO date-time formatter that formats or parses a date-time with an offset, such as \u00272011-12-03T10:15:30+01:00\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended offset date-time format. The format consists of: The ISO_LOCAL_DATE_TIME The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. The offset parsing is lenient, which allows the minutes and seconds to be optional. Parsing is case insensitive. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_ZONED_DATE_TIME",
      "comment": "The ISO-like date-time formatter that formats or parses a date-time with offset and zone, such as \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027. This returns an immutable formatter capable of formatting and parsing a format that extends the ISO-8601 extended offset date-time format to add the time-zone. The section in square brackets is not part of the ISO-8601 standard. The format consists of: The ISO_OFFSET_DATE_TIME If the zone ID is not available or is a ZoneOffset then the format is complete. An open square bracket \u0027[\u0027. The zone ID. This is not part of the ISO-8601 standard. Parsing is case sensitive. A close square bracket \u0027]\u0027. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_DATE_TIME",
      "comment": "The ISO-like date-time formatter that formats or parses a date-time with the offset and zone if available, such as \u00272011-12-03T10:15:30\u0027, \u00272011-12-03T10:15:30+01:00\u0027 or \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended local or offset date-time format, as well as the extended non-ISO form specifying the time-zone. The format consists of: The ISO_LOCAL_DATE_TIME If the offset is not available to format or parse then the format is complete. The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. If the zone ID is not available or is a ZoneOffset then the format is complete. An open square bracket \u0027[\u0027. The zone ID. This is not part of the ISO-8601 standard. Parsing is case sensitive. A close square bracket \u0027]\u0027. As this formatter has an optional element, it may be necessary to parse using parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery\u003c?\u003e...). The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_ORDINAL_DATE",
      "comment": "The ISO date formatter that formats or parses the ordinal date without an offset, such as \u00272012-337\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended ordinal date format. The format consists of: Four digits or more for the year. Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits. Years outside that range will have a prefixed positive or negative symbol. A dash Three digits for the day-of-year. This is pre-padded by zero to ensure three digits. If the offset is not available to format or parse then the format is complete. The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. Parsing is case insensitive. As this formatter has an optional element, it may be necessary to parse using parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery\u003c?\u003e...). The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_WEEK_DATE",
      "comment": "The ISO date formatter that formats or parses the week-based date without an offset, such as \u00272012-W48-6\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 extended week-based date format. The format consists of: Four digits or more for the week-based-year. Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits. Years outside that range will have a prefixed positive or negative symbol. A dash The letter \u0027W\u0027. Parsing is case insensitive. Two digits for the week-of-week-based-year. This is pre-padded by zero to ensure three digits. A dash One digit for the day-of-week. The value run from Monday (1) to Sunday (7). If the offset is not available to format or parse then the format is complete. The offset ID. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. Parsing is case insensitive. As this formatter has an optional element, it may be necessary to parse using parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery\u003c?\u003e...). The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ISO_INSTANT",
      "comment": "The ISO instant formatter that formats or parses an instant in UTC, such as \u00272011-12-03T10:15:30Z\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 instant format. When formatting, the instant will always be suffixed by \u0027Z\u0027 to indicate UTC. The second-of-minute is always output. The nano-of-second outputs zero, three, six or nine digits as necessary. When parsing, the behaviour of DateTimeFormatterBuilder.appendOffsetId() will be used to parse the offset, converting the instant to UTC as necessary. The time to at least the seconds field is required. Fractional seconds from zero to nine are parsed. The localized decimal style is not used. This is a special case formatter intended to allow a human readable form of an Instant. The Instant class is designed to only represent a point in time and internally stores a value in nanoseconds from a fixed epoch of 1970-01-01Z. As such, an Instant cannot be formatted as a date or time without providing some form of time-zone. This formatter allows the Instant to be formatted, by providing a suitable conversion using ZoneOffset.UTC. The format consists of: The ISO_OFFSET_DATE_TIME where the instant is converted from ChronoField.INSTANT_SECONDS and ChronoField.NANO_OF_SECOND using the UTC offset. Parsing is case insensitive. The returned formatter has no override chronology or zone. It uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "BASIC_ISO_DATE",
      "comment": "The ISO date formatter that formats or parses a date without an offset, such as \u002720111203\u0027. This returns an immutable formatter capable of formatting and parsing the ISO-8601 basic local date format. The format consists of: Four digits for the year. Only years in the range 0000 to 9999 are supported. Two digits for the month-of-year. This is pre-padded by zero to ensure two digits. Two digits for the day-of-month. This is pre-padded by zero to ensure two digits. If the offset is not available to format or parse then the format is complete. The offset ID without colons. If the offset has seconds then they will be handled even though this is not part of the ISO-8601 standard. The offset parsing is lenient, which allows the minutes and seconds to be optional. Parsing is case insensitive. As this formatter has an optional element, it may be necessary to parse using parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery\u003c?\u003e...). The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the STRICT resolver style.",
      "tagMap": {}
    },
    {
      "type": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "RFC_1123_DATE_TIME",
      "comment": "The RFC-1123 date-time formatter, such as \u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027. This returns an immutable formatter capable of formatting and parsing most of the RFC-1123 format. RFC-1123 updates RFC-822 changing the year from two digits to four. This implementation requires a four digit year. This implementation also does not handle North American or military zone names, only \u0027GMT\u0027 and offset amounts. The format consists of: If the day-of-week is not available to format or parse then jump to day-of-month. Three letter day-of-week in English. A comma A space One or two digits for the day-of-month. A space Three letter month-of-year in English. A space Four digits for the year. Only years in the range 0000 to 9999 are supported. A space Two digits for the hour-of-day. This is pre-padded by zero to ensure two digits. A colon Two digits for the minute-of-hour. This is pre-padded by zero to ensure two digits. If the second-of-minute is not available then jump to the next space. A colon Two digits for the second-of-minute. This is pre-padded by zero to ensure two digits. A space The offset ID without colons or seconds. An offset of zero uses \"GMT\". North American zone names and military zone names are not handled. Parsing is case insensitive. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the SMART resolver style.",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "ofPattern",
      "comment": "Creates a formatter using the specified pattern. This method will create a formatter based on a simple pattern of letters and symbols as described in the class documentation. For example, d MMM uuuu will format 2011-12-03 as \u00273 Dec 2011\u0027. The formatter will use the default FORMAT locale. This can be changed using withLocale(Locale) on the returned formatter. Alternatively use the ofPattern(String, Locale) variant of this method. The returned formatter has no override chronology or zone. It uses SMART resolver style.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeFormatterBuilder.html#appendPattern(java.lang.String)\"\u003e\u003ccode\u003eDateTimeFormatterBuilder.appendPattern(String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern to use, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the pattern is invalid"
        ],
        "return": [
          "the formatter based on the pattern, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "pattern"
          }
        },
        {
          "type": {
            "name": "java.util.Locale",
            "type": "Class"
          },
          "field": {
            "name": "locale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "ofPattern",
      "comment": "Creates a formatter using the specified pattern and locale. This method will create a formatter based on a simple pattern of letters and symbols as described in the class documentation. For example, d MMM uuuu will format 2011-12-03 as \u00273 Dec 2011\u0027. The formatter will use the specified locale. This can be changed using withLocale(Locale) on the returned formatter. The returned formatter has no override chronology or zone. It uses SMART resolver style.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeFormatterBuilder.html#appendPattern(java.lang.String)\"\u003e\u003ccode\u003eDateTimeFormatterBuilder.appendPattern(String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003epattern\u003c/code\u003e - the pattern to use, not null",
          "\u003ccode\u003elocale\u003c/code\u003e - the locale to use, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the pattern is invalid"
        ],
        "return": [
          "the formatter based on the pattern, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.format.FormatStyle",
            "type": "Class"
          },
          "field": {
            "name": "dateStyle"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "ofLocalizedDate",
      "comment": "Returns a locale specific date format for the ISO chronology. This returns a formatter that will format or parse a date. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the default FORMAT locale. The locale can be controlled using withLocale(Locale) on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the SMART resolver style.",
      "tagMap": {
        "param": [
          "\u003ccode\u003edateStyle\u003c/code\u003e - the formatter style to obtain, not null"
        ],
        "return": [
          "the date formatter, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.format.FormatStyle",
            "type": "Class"
          },
          "field": {
            "name": "timeStyle"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "ofLocalizedTime",
      "comment": "Returns a locale specific time format for the ISO chronology. This returns a formatter that will format or parse a time. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the default FORMAT locale. The locale can be controlled using withLocale(Locale) on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the SMART resolver style. The FULL and LONG styles typically require a time-zone. When formatting using these styles, a ZoneId must be available, either by using ZonedDateTime or withZone(java.time.ZoneId).",
      "tagMap": {
        "param": [
          "\u003ccode\u003etimeStyle\u003c/code\u003e - the formatter style to obtain, not null"
        ],
        "return": [
          "the time formatter, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.format.FormatStyle",
            "type": "Class"
          },
          "field": {
            "name": "dateTimeStyle"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "ofLocalizedDateTime",
      "comment": "Returns a locale specific date-time formatter for the ISO chronology. This returns a formatter that will format or parse a date-time. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the default FORMAT locale. The locale can be controlled using withLocale(Locale) on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the SMART resolver style. The FULL and LONG styles typically require a time-zone. When formatting using these styles, a ZoneId must be available, either by using ZonedDateTime or withZone(java.time.ZoneId).",
      "tagMap": {
        "param": [
          "\u003ccode\u003edateTimeStyle\u003c/code\u003e - the formatter style to obtain, not null"
        ],
        "return": [
          "the date-time formatter, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.format.FormatStyle",
            "type": "Class"
          },
          "field": {
            "name": "dateStyle"
          }
        },
        {
          "type": {
            "name": "java.time.format.FormatStyle",
            "type": "Class"
          },
          "field": {
            "name": "timeStyle"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "ofLocalizedDateTime",
      "comment": "Returns a locale specific date and time format for the ISO chronology. This returns a formatter that will format or parse a date-time. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the default FORMAT locale. The locale can be controlled using withLocale(Locale) on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the SMART resolver style. The FULL and LONG styles typically require a time-zone. When formatting using these styles, a ZoneId must be available, either by using ZonedDateTime or withZone(java.time.ZoneId).",
      "tagMap": {
        "param": [
          "\u003ccode\u003edateStyle\u003c/code\u003e - the date formatter style to obtain, not null",
          "\u003ccode\u003etimeStyle\u003c/code\u003e - the time formatter style to obtain, not null"
        ],
        "return": [
          "the date, time or date-time formatter, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.temporal.TemporalQuery",
        "parameters": [
          {
            "name": "java.time.Period",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "parsedExcessDays",
      "comment": "A query that provides access to the excess days that were parsed. This returns a singleton query that provides access to additional information from the parse. The query always returns a non-null period, with a zero period returned instead of null. There are two situations where this query may return a non-zero period. If the ResolverStyle is LENIENT and a time is parsed without a date, then the complete result of the parse consists of a LocalTime and an excess Period in days. If the ResolverStyle is SMART and a time is parsed without a date where the time is 24:00:00, then the complete result of the parse consists of a LocalTime of 00:00:00 and an excess Period of one day. In both cases, if a complete ChronoLocalDateTime or Instant is parsed, then the excess days are added to the date part. As a result, this query will return a zero period. The SMART behaviour handles the common \"end of day\" 24:00 value. Processing in LENIENT mode also produces the same result:   Text to parse        Parsed object                         Excess days\n  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n The query can be used as follows:   TemporalAccessor parsed \u003d formatter.parse(str);\n  LocalTime time \u003d parsed.query(LocalTime::from);\n  Period extraDays \u003d parsed.query(DateTimeFormatter.parsedExcessDays());",
      "tagMap": {
        "return": [
          "a query that provides access to the excess days that were parsed"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.temporal.TemporalQuery",
        "parameters": [
          {
            "name": "java.lang.Boolean",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "parsedLeapSecond",
      "comment": "A query that provides access to whether a leap-second was parsed. This returns a singleton query that provides access to additional information from the parse. The query always returns a non-null boolean, true if parsing saw a leap-second, false if not. Instant parsing handles the special \"leap second\" time of \u002723:59:60\u0027. Leap seconds occur at \u002723:59:60\u0027 in the UTC time-zone, but at other local times in different time-zones. To avoid this potential ambiguity, the handling of leap-seconds is limited to DateTimeFormatterBuilder.appendInstant(), as that method always parses the instant with the UTC zone offset. If the time \u002723:59:60\u0027 is received, then a simple conversion is applied, replacing the second-of-minute of 60 with 59. This query can be used on the parse result to determine if the leap-second adjustment was made. The query will return true if it did adjust to remove the leap-second, and false if not. Note that applying a leap-second smoothing mechanism, such as UTC-SLS, is the responsibility of the application, as follows:   TemporalAccessor parsed \u003d formatter.parse(str);\n  Instant instant \u003d parsed.query(Instant::from);\n  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n    // validate leap-second is correct and apply correct smoothing\n  }",
      "tagMap": {
        "return": [
          "a query that provides access to whether a leap-second was parsed"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Locale",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getLocale",
      "comment": "Gets the locale to be used during formatting. This is used to lookup any part of the formatter needing specific localization, such as the text or localized pattern.",
      "tagMap": {
        "return": [
          "the locale of this formatter, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Locale",
            "type": "Class"
          },
          "field": {
            "name": "locale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withLocale",
      "comment": "Returns a copy of this formatter with a new locale. This is used to lookup any part of the formatter needing specific localization, such as the text or localized pattern. The locale is stored as passed in, without further processing. If the locale has Unicode extensions, they may be used later in text processing. To set the chronology, time-zone and decimal style from unicode extensions, see localizedBy(). This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeFormatter.html#localizedBy(java.util.Locale)\"\u003e\u003ccode\u003elocalizedBy(Locale)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elocale\u003c/code\u003e - the new locale, not null"
        ],
        "return": [
          "a formatter based on this formatter with the requested locale, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Locale",
            "type": "Class"
          },
          "field": {
            "name": "locale"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "localizedBy",
      "comment": "Returns a copy of this formatter with localized values of the locale, calendar, region, decimal style and/or timezone, that supersede values in this formatter. This is used to lookup any part of the formatter needing specific localization, such as the text or localized pattern. If the locale contains the \"ca\" (calendar), \"nu\" (numbering system), \"rg\" (region override), and/or \"tz\" (timezone) Unicode extensions, the chronology, numbering system and/or the zone are overridden. If both \"ca\" and \"rg\" are specified, the chronology from the \"ca\" extension supersedes the implicit one from the \"rg\" extension. Same is true for the \"nu\" extension. Unlike the withLocale method, the call to this method may produce a different formatter depending on the order of method chaining with other withXXXX() methods. This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeFormatter.html#withLocale(java.util.Locale)\"\u003e\u003ccode\u003ewithLocale(Locale)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elocale\u003c/code\u003e - the locale, not null"
        ],
        "return": [
          "a formatter based on this formatter with localized values of the calendar, decimal style and/or timezone, that supersede values in this formatter."
        ],
        "since": [
          "10"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DecimalStyle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getDecimalStyle",
      "comment": "Gets the DecimalStyle to be used during formatting.",
      "tagMap": {
        "return": [
          "the locale of this formatter, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.format.DecimalStyle",
            "type": "Class"
          },
          "field": {
            "name": "decimalStyle"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withDecimalStyle",
      "comment": "Returns a copy of this formatter with a new DecimalStyle. This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "param": [
          "\u003ccode\u003edecimalStyle\u003c/code\u003e - the new DecimalStyle, not null"
        ],
        "return": [
          "a formatter based on this formatter with the requested DecimalStyle, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.chrono.Chronology",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getChronology",
      "comment": "Gets the overriding chronology to be used during formatting. This returns the override chronology, used to convert dates. By default, a formatter has no override chronology, returning null. See withChronology(Chronology) for more details on overriding.",
      "tagMap": {
        "return": [
          "the override chronology of this formatter, null if no override"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.chrono.Chronology",
            "type": "Class"
          },
          "field": {
            "name": "chrono"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withChronology",
      "comment": "Returns a copy of this formatter with a new override chronology. This returns a formatter with similar state to this formatter but with the override chronology set. By default, a formatter has no override chronology, returning null. If an override is added, then any date that is formatted or parsed will be affected. When formatting, if the temporal object contains a date, then it will be converted to a date in the override chronology. Whether the temporal contains a date is determined by querying the EPOCH_DAY field. Any time or zone will be retained unaltered unless overridden. If the temporal object does not contain a date, but does contain one or more ChronoField date fields, then a DateTimeException is thrown. In all other cases, the override chronology is added to the temporal, replacing any previous chronology, but without changing the date/time. When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because DateTimeFormatterBuilder.appendChronologyId() was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the ChronoField values into a date according to the date resolving rules of the chronology. This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "param": [
          "\u003ccode\u003echrono\u003c/code\u003e - the new chronology, null if no override"
        ],
        "return": [
          "a formatter based on this formatter with the requested override chronology, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.ZoneId",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getZone",
      "comment": "Gets the overriding zone to be used during formatting. This returns the override zone, used to convert instants. By default, a formatter has no override zone, returning null. See withZone(ZoneId) for more details on overriding.",
      "tagMap": {
        "return": [
          "the override zone of this formatter, null if no override"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.ZoneId",
            "type": "Class"
          },
          "field": {
            "name": "zone"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withZone",
      "comment": "Returns a copy of this formatter with a new override zone. This returns a formatter with similar state to this formatter but with the override zone set. By default, a formatter has no override zone, returning null. If an override is added, then any instant that is formatted or parsed will be affected. When formatting, if the temporal object contains an instant, then it will be converted to a zoned date-time using the override zone. Whether the temporal is an instant is determined by querying the INSTANT_SECONDS field. If the input has a chronology then it will be retained unless overridden. If the input does not have a chronology, such as Instant, then the ISO chronology will be used. If the temporal object does not contain an instant, but does contain an offset then an additional check is made. If the normalized override zone is an offset that differs from the offset of the temporal, then a DateTimeException is thrown. In all other cases, the override zone is added to the temporal, replacing any previous zone, but without changing the date/time. When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because DateTimeFormatterBuilder.appendZoneId() was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times. This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ezone\u003c/code\u003e - the new override zone, null if no override"
        ],
        "return": [
          "a formatter based on this formatter with the requested override zone, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.ResolverStyle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getResolverStyle",
      "comment": "Gets the resolver style to use during parsing. This returns the resolver style, used during the second phase of parsing when fields are resolved into dates and times. By default, a formatter has the SMART resolver style. See withResolverStyle(ResolverStyle) for more details.",
      "tagMap": {
        "return": [
          "the resolver style of this formatter, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.format.ResolverStyle",
            "type": "Class"
          },
          "field": {
            "name": "resolverStyle"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withResolverStyle",
      "comment": "Returns a copy of this formatter with a new resolver style. This returns a formatter with similar state to this formatter but with the resolver style set. By default, a formatter has the SMART resolver style. Changing the resolver style only has an effect during parsing. Parsing a text string occurs in two phases. Phase 1 is a basic text parse according to the fields added to the builder. Phase 2 resolves the parsed field-value pairs into date and/or time objects. The resolver style is used to control how phase 2, resolving, happens. See ResolverStyle for more information on the options available. This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eresolverStyle\u003c/code\u003e - the new resolver style, not null"
        ],
        "return": [
          "a formatter based on this formatter with the requested resolver style, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.time.temporal.TemporalField",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getResolverFields",
      "comment": "Gets the resolver fields to use during parsing. This returns the resolver fields, used during the second phase of parsing when fields are resolved into dates and times. By default, a formatter has no resolver fields, and thus returns null. See withResolverFields(Set) for more details.",
      "tagMap": {
        "return": [
          "the immutable set of resolver fields of this formatter, null if no fields"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.temporal.TemporalField",
            "type": "Class"
          },
          "field": {
            "name": "resolverFields"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withResolverFields",
      "comment": "Returns a copy of this formatter with a new set of resolver fields. This returns a formatter with similar state to this formatter but with the resolver fields set. By default, a formatter has no resolver fields. Changing the resolver fields only has an effect during parsing. Parsing a text string occurs in two phases. Phase 1 is a basic text parse according to the fields added to the builder. Phase 2 resolves the parsed field-value pairs into date and/or time objects. The resolver fields are used to filter the field-value pairs between phase 1 and 2. This can be used to select between two or more ways that a date or time might be resolved. For example, if the formatter consists of year, month, day-of-month and day-of-year, then there are two ways to resolve a date. Calling this method with the arguments YEAR and DAY_OF_YEAR will ensure that the date is resolved using the year and day-of-year, effectively meaning that the month and day-of-month are ignored during the resolving phase. In a similar manner, this method can be used to ignore secondary fields that would otherwise be cross-checked. For example, if the formatter consists of year, month, day-of-month and day-of-week, then there is only one way to resolve a date, but the parsed value for day-of-week will be cross-checked against the resolved date. Calling this method with the arguments YEAR, MONTH_OF_YEAR and DAY_OF_MONTH will ensure that the date is resolved correctly, but without any cross-check for the day-of-week. In implementation terms, this method behaves as follows. The result of the parsing phase can be considered to be a map of field to value. The behavior of this method is to cause that map to be filtered between phase 1 and 2, removing all fields other than those specified as arguments to this method. This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eresolverFields\u003c/code\u003e - the new set of resolver fields, null if no fields"
        ],
        "return": [
          "a formatter based on this formatter with the requested resolver style, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.format.DateTimeFormatter",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.Set",
            "parameters": [
              {
                "name": "java.time.temporal.TemporalField",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "resolverFields"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withResolverFields",
      "comment": "Returns a copy of this formatter with a new set of resolver fields. This returns a formatter with similar state to this formatter but with the resolver fields set. By default, a formatter has no resolver fields. Changing the resolver fields only has an effect during parsing. Parsing a text string occurs in two phases. Phase 1 is a basic text parse according to the fields added to the builder. Phase 2 resolves the parsed field-value pairs into date and/or time objects. The resolver fields are used to filter the field-value pairs between phase 1 and 2. This can be used to select between two or more ways that a date or time might be resolved. For example, if the formatter consists of year, month, day-of-month and day-of-year, then there are two ways to resolve a date. Calling this method with the arguments YEAR and DAY_OF_YEAR will ensure that the date is resolved using the year and day-of-year, effectively meaning that the month and day-of-month are ignored during the resolving phase. In a similar manner, this method can be used to ignore secondary fields that would otherwise be cross-checked. For example, if the formatter consists of year, month, day-of-month and day-of-week, then there is only one way to resolve a date, but the parsed value for day-of-week will be cross-checked against the resolved date. Calling this method with the arguments YEAR, MONTH_OF_YEAR and DAY_OF_MONTH will ensure that the date is resolved correctly, but without any cross-check for the day-of-week. In implementation terms, this method behaves as follows. The result of the parsing phase can be considered to be a map of field to value. The behavior of this method is to cause that map to be filtered between phase 1 and 2, removing all fields other than those specified as arguments to this method. This instance is immutable and unaffected by this method call.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eresolverFields\u003c/code\u003e - the new set of resolver fields, null if no fields"
        ],
        "return": [
          "a formatter based on this formatter with the requested resolver style, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.temporal.TemporalAccessor",
            "type": "Class"
          },
          "field": {
            "name": "temporal"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "format",
      "comment": "Formats a date-time object using this formatter. This formats the date-time to a String using the rules of the formatter.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etemporal\u003c/code\u003e - the temporal object to format, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/DateTimeException.html\" title\u003d\"class in java.time\"\u003eDateTimeException\u003c/a\u003e\u003c/code\u003e - if an error occurs during formatting"
        ],
        "return": [
          "the formatted string, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.temporal.TemporalAccessor",
            "type": "Class"
          },
          "field": {
            "name": "temporal"
          }
        },
        {
          "type": {
            "name": "java.lang.Appendable",
            "type": "Class"
          },
          "field": {
            "name": "appendable"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "formatTo",
      "comment": "Formats a date-time object to an Appendable using this formatter. This outputs the formatted date-time to the specified destination. Appendable is a general purpose interface that is implemented by all key character output classes including StringBuffer, StringBuilder, PrintStream and Writer. Although Appendable methods throw an IOException, this method does not. Instead, any IOException is wrapped in a runtime exception.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etemporal\u003c/code\u003e - the temporal object to format, not null",
          "\u003ccode\u003eappendable\u003c/code\u003e - the appendable to format to, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/DateTimeException.html\" title\u003d\"class in java.time\"\u003eDateTimeException\u003c/a\u003e\u003c/code\u003e - if an error occurs during formatting"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.temporal.TemporalAccessor",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parse",
      "comment": "Fully parses the text producing a temporal object. This parses the entire text producing a temporal object. It is typically more useful to use parse(CharSequence, TemporalQuery). The result of this method is TemporalAccessor which has been resolved, applying basic validation checks to help ensure a valid date-time. If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the text to parse, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeParseException.html\" title\u003d\"class in java.time.format\"\u003eDateTimeParseException\u003c/a\u003e\u003c/code\u003e - if unable to parse the requested result"
        ],
        "return": [
          "the parsed temporal object, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.temporal.TemporalAccessor",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        },
        {
          "type": {
            "name": "java.text.ParsePosition",
            "type": "Class"
          },
          "field": {
            "name": "position"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parse",
      "comment": "Parses the text using this formatter, providing control over the text position. This parses the text without requiring the parse to start from the beginning of the string or finish at the end. The result of this method is TemporalAccessor which has been resolved, applying basic validation checks to help ensure a valid date-time. The text will be parsed from the specified start ParsePosition. The entire length of the text does not have to be parsed, the ParsePosition will be updated with the index at the end of parsing. The operation of this method is slightly different to similar methods using ParsePosition on java.text.Format. That class will return errors using the error index on the ParsePosition. By contrast, this method will throw a DateTimeParseException if an error occurs, with the exception containing the error index. This change in behavior is necessary due to the increased complexity of parsing and resolving dates/times in this API. If the formatter parses the same field more than once with different values, the result will be an error.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the text to parse, not null",
          "\u003ccode\u003eposition\u003c/code\u003e - the position to parse from, updated with length parsed and the index of any error, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeParseException.html\" title\u003d\"class in java.time.format\"\u003eDateTimeParseException\u003c/a\u003e\u003c/code\u003e - if unable to parse the requested result",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if the position is invalid"
        ],
        "return": [
          "the parsed temporal object, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        },
        {
          "type": {
            "name": "java.time.temporal.TemporalQuery",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "query"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parse",
      "comment": "Fully parses the text producing an object of the specified type. Most applications should use this method for parsing. It parses the entire text to produce the required date-time. The query is typically a method reference to a from(TemporalAccessor) method. For example:   LocalDateTime dt \u003d parser.parse(str, LocalDateTime::from);\n If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type of the parsed date-time"
        ],
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the text to parse, not null",
          "\u003ccode\u003equery\u003c/code\u003e - the query defining the type to parse to, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeParseException.html\" title\u003d\"class in java.time.format\"\u003eDateTimeParseException\u003c/a\u003e\u003c/code\u003e - if unable to parse the requested result"
        ],
        "return": [
          "the parsed date-time, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.temporal.TemporalAccessor",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        },
        {
          "type": {
            "name": "java.time.temporal.TemporalQuery",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "queries"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parseBest",
      "comment": "Fully parses the text producing an object of one of the specified types. This parse method is convenient for use when the parser can handle optional elements. For example, a pattern of \u0027uuuu-MM-dd HH.mm[ VV]\u0027 can be fully parsed to a ZonedDateTime, or partially parsed to a LocalDateTime. The queries must be specified in order, starting from the best matching full-parse option and ending with the worst matching minimal parse option. The query is typically a method reference to a from(TemporalAccessor) method. The result is associated with the first type that successfully parses. Normally, applications will use instanceof to check the result. For example:   TemporalAccessor dt \u003d parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);\n  if (dt instanceof ZonedDateTime) {\n   ...\n  } else {\n   ...\n  }\n If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the text to parse, not null",
          "\u003ccode\u003equeries\u003c/code\u003e - the queries defining the types to attempt to parse to, must implement \n\u003ccode\u003eTemporalAccessor\u003c/code\u003e, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if less than 2 types are specified",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/format/DateTimeParseException.html\" title\u003d\"class in java.time.format\"\u003eDateTimeParseException\u003c/a\u003e\u003c/code\u003e - if unable to parse the requested result"
        ],
        "return": [
          "the parsed date-time, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.temporal.TemporalAccessor",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.CharSequence",
            "type": "Class"
          },
          "field": {
            "name": "text"
          }
        },
        {
          "type": {
            "name": "java.text.ParsePosition",
            "type": "Class"
          },
          "field": {
            "name": "position"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parseUnresolved",
      "comment": "Parses the text using this formatter, without resolving the result, intended for advanced use cases. Parsing is implemented as a two-phase operation. First, the text is parsed using the layout defined by the formatter, producing a Map of field to value, a ZoneId and a Chronology. Second, the parsed data is resolved, by validating, combining and simplifying the various fields into more useful ones. This method performs the parsing stage but not the resolving stage. The result of this method is TemporalAccessor which represents the data as seen in the input. Values are not validated, thus parsing a date string of \u00272012-00-65\u0027 would result in a temporal with three fields - year of \u00272012\u0027, month of \u00270\u0027 and day-of-month of \u002765\u0027. The text will be parsed from the specified start ParsePosition. The entire length of the text does not have to be parsed, the ParsePosition will be updated with the index at the end of parsing. Errors are returned using the error index field of the ParsePosition instead of DateTimeParseException. The returned error index will be set to an index indicative of the error. Callers must check for errors before using the result. If the formatter parses the same field more than once with different values, the result will be an error. This method is intended for advanced use cases that need access to the internal state during parsing. Typical application code should use parse(CharSequence, TemporalQuery) or the parse method on the target type.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etext\u003c/code\u003e - the text to parse, not null",
          "\u003ccode\u003eposition\u003c/code\u003e - the position to parse from, updated with length parsed and the index of any error, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/DateTimeException.html\" title\u003d\"class in java.time\"\u003eDateTimeException\u003c/a\u003e\u003c/code\u003e - if some problem occurs during parsing",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if the position is invalid"
        ],
        "return": [
          "the parsed text, null if the parse results in an error"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.text.Format",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toFormat",
      "comment": "Returns this formatter as a java.text.Format instance. The returned Format instance will format any TemporalAccessor and parses to a resolved TemporalAccessor. Exceptions will follow the definitions of Format, see those methods for details about IllegalArgumentException during formatting and ParseException or null during parsing. The format does not support attributing of the returned format string.",
      "tagMap": {
        "return": [
          "this formatter as a classic format instance, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.text.Format",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.temporal.TemporalQuery",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "parseQuery"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toFormat",
      "comment": "Returns this formatter as a java.text.Format instance that will parse using the specified query. The returned Format instance will format any TemporalAccessor and parses to the type specified. The type must be one that is supported by parse(java.lang.CharSequence). Exceptions will follow the definitions of Format, see those methods for details about IllegalArgumentException during formatting and ParseException or null during parsing. The format does not support attributing of the returned format string.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eparseQuery\u003c/code\u003e - the query defining the type to parse to, not null"
        ],
        "return": [
          "this formatter as a classic format instance, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a description of the underlying formatters.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a description of this formatter, not null"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.time.format.DateTimeFormatter",
  "comment": "Formatter for printing and parsing date-time objects. \n\u003cp\u003e This class provides the main application entry point for printing and parsing and provides common implementations of \u003ccode\u003eDateTimeFormatter\u003c/code\u003e: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eUsing predefined constants, such as \u003ca href\u003d\"#ISO_LOCAL_DATE\"\u003e\u003ccode\u003eISO_LOCAL_DATE\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e \n \u003cli\u003eUsing pattern letters, such as \u003ccode\u003euuuu-MMM-dd\u003c/code\u003e\u003c/li\u003e \n \u003cli\u003eUsing localized styles, such as \u003ccode\u003elong\u003c/code\u003e or \u003ccode\u003emedium\u003c/code\u003e\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e More complex formatters are provided by \u003ca href\u003d\"DateTimeFormatterBuilder.html\" title\u003d\"class in java.time.format\"\u003e\u003ccode\u003eDateTimeFormatterBuilder\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e The main date-time classes provide two methods - one for formatting, \u003ccode\u003eformat(DateTimeFormatter formatter)\u003c/code\u003e, and one for parsing, \u003ccode\u003eparse(CharSequence text, DateTimeFormatter formatter)\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003eFor example: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e  LocalDate date \u003d LocalDate.now();\n  String text \u003d date.format(formatter);\n  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e In addition to the format, formatters can be created with desired Locale, Chronology, ZoneId, and DecimalStyle. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"#withLocale(java.util.Locale)\"\u003e\u003ccode\u003ewithLocale\u003c/code\u003e\u003c/a\u003e method returns a new formatter that overrides the locale. The locale affects some aspects of formatting and parsing. For example, the \u003ca href\u003d\"#ofLocalizedDate(java.time.format.FormatStyle)\"\u003e\u003ccode\u003eofLocalizedDate\u003c/code\u003e\u003c/a\u003e provides a formatter that uses the locale specific date format. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"#withChronology(java.time.chrono.Chronology)\"\u003e\u003ccode\u003ewithChronology\u003c/code\u003e\u003c/a\u003e method returns a new formatter that overrides the chronology. If overridden, the date-time value is converted to the chronology before formatting. During parsing the date-time value is converted to the chronology before it is returned. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"#withZone(java.time.ZoneId)\"\u003e\u003ccode\u003ewithZone\u003c/code\u003e\u003c/a\u003e method returns a new formatter that overrides the zone. If overridden, the date-time value is converted to a ZonedDateTime with the requested ZoneId before formatting. During parsing the ZoneId is applied before the value is returned. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"#withDecimalStyle(java.time.format.DecimalStyle)\"\u003e\u003ccode\u003ewithDecimalStyle\u003c/code\u003e\u003c/a\u003e method returns a new formatter that overrides the \u003ca href\u003d\"DecimalStyle.html\" title\u003d\"class in java.time.format\"\u003e\u003ccode\u003eDecimalStyle\u003c/code\u003e\u003c/a\u003e. The DecimalStyle symbols are used for formatting and parsing. \u003c/p\u003e\n\u003cp\u003e Some applications may need to use the older \u003ca href\u003d\"../../text/Format.html\" title\u003d\"class in java.text\"\u003e\u003ccode\u003ejava.text.Format\u003c/code\u003e\u003c/a\u003e class for formatting. The \u003ca href\u003d\"#toFormat()\"\u003e\u003ccode\u003etoFormat()\u003c/code\u003e\u003c/a\u003e method returns an implementation of \u003ccode\u003ejava.text.Format\u003c/code\u003e. \u003c/p\u003e\n\u003ch2 id\u003d\"predefined\"\u003ePredefined Formatters\u003c/h2\u003e \n\u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e \n \u003ccaption\u003e\n  Predefined Formatters\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003eFormatter\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003eExample\u003c/th\u003e \n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#ofLocalizedDate(java.time.format.FormatStyle)\"\u003e\u003ccode\u003eofLocalizedDate(dateStyle)\u003c/code\u003e\u003c/a\u003e \u003c/th\u003e \n   \u003ctd\u003e Formatter with date style from the locale \u003c/td\u003e \n   \u003ctd\u003e \u00272011-12-03\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ofLocalizedTime(java.time.format.FormatStyle)\"\u003e\u003ccode\u003eofLocalizedTime(timeStyle)\u003c/code\u003e\u003c/a\u003e \u003c/th\u003e \n   \u003ctd\u003e Formatter with time style from the locale \u003c/td\u003e \n   \u003ctd\u003e \u002710:15:30\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ofLocalizedDateTime(java.time.format.FormatStyle)\"\u003e\u003ccode\u003eofLocalizedDateTime(dateTimeStyle)\u003c/code\u003e\u003c/a\u003e \u003c/th\u003e \n   \u003ctd\u003e Formatter with a style for date and time from the locale\u003c/td\u003e \n   \u003ctd\u003e \u00273 Jun 2008 11:05:30\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ofLocalizedDateTime(java.time.format.FormatStyle)\"\u003e\u003ccode\u003eofLocalizedDateTime(dateStyle,timeStyle)\u003c/code\u003e\u003c/a\u003e \u003c/th\u003e \n   \u003ctd\u003e Formatter with date and time styles from the locale \u003c/td\u003e \n   \u003ctd\u003e \u00273 Jun 2008 11:05\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#BASIC_ISO_DATE\"\u003e\u003ccode\u003eBASIC_ISO_DATE\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003eBasic ISO date \u003c/td\u003e \n   \u003ctd\u003e\u002720111203\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_LOCAL_DATE\"\u003e\u003ccode\u003eISO_LOCAL_DATE\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e ISO Local Date \u003c/td\u003e \n   \u003ctd\u003e\u00272011-12-03\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_OFFSET_DATE\"\u003e\u003ccode\u003eISO_OFFSET_DATE\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e ISO Date with offset \u003c/td\u003e \n   \u003ctd\u003e\u00272011-12-03+01:00\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_DATE\"\u003e\u003ccode\u003eISO_DATE\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e ISO Date with or without offset \u003c/td\u003e \n   \u003ctd\u003e \u00272011-12-03+01:00\u0027; \u00272011-12-03\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_LOCAL_TIME\"\u003e\u003ccode\u003eISO_LOCAL_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Time without offset \u003c/td\u003e \n   \u003ctd\u003e\u002710:15:30\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_OFFSET_TIME\"\u003e\u003ccode\u003eISO_OFFSET_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Time with offset \u003c/td\u003e \n   \u003ctd\u003e\u002710:15:30+01:00\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_TIME\"\u003e\u003ccode\u003eISO_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Time with or without offset \u003c/td\u003e \n   \u003ctd\u003e\u002710:15:30+01:00\u0027; \u002710:15:30\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_LOCAL_DATE_TIME\"\u003e\u003ccode\u003eISO_LOCAL_DATE_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e ISO Local Date and Time \u003c/td\u003e \n   \u003ctd\u003e\u00272011-12-03T10:15:30\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_OFFSET_DATE_TIME\"\u003e\u003ccode\u003eISO_OFFSET_DATE_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Date Time with Offset \u003c/td\u003e\n   \u003ctd\u003e\u00272011-12-03T10:15:30+01:00\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_ZONED_DATE_TIME\"\u003e\u003ccode\u003eISO_ZONED_DATE_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Zoned Date Time \u003c/td\u003e \n   \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_DATE_TIME\"\u003e\u003ccode\u003eISO_DATE_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Date and time with ZoneId \u003c/td\u003e \n   \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_ORDINAL_DATE\"\u003e\u003ccode\u003eISO_ORDINAL_DATE\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Year and day of year \u003c/td\u003e \n   \u003ctd\u003e\u00272012-337\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_WEEK_DATE\"\u003e\u003ccode\u003eISO_WEEK_DATE\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Year and Week \u003c/td\u003e \n   \u003ctd\u003e\u00272012-W48-6\u0027\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#ISO_INSTANT\"\u003e\u003ccode\u003eISO_INSTANT\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e Date and Time of an Instant \u003c/td\u003e \n   \u003ctd\u003e\u00272011-12-03T10:15:30Z\u0027 \u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e \u003ca href\u003d\"#RFC_1123_DATE_TIME\"\u003e\u003ccode\u003eRFC_1123_DATE_TIME\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e RFC 1123 / RFC 822 \u003c/td\u003e \n   \u003ctd\u003e\u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027\u003c/td\u003e \n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003ch2 id\u003d\"patterns\"\u003ePatterns for Formatting and Parsing\u003c/h2\u003e Patterns are based on a simple sequence of letters and symbols. A pattern is used to create a Formatter using the \n\u003ca href\u003d\"#ofPattern(java.lang.String)\"\u003e\u003ccode\u003eofPattern(String)\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"#ofPattern(java.lang.String,java.util.Locale)\"\u003e\u003ccode\u003eofPattern(String, Locale)\u003c/code\u003e\u003c/a\u003e methods. For example, \n\u003ccode\u003e\"d MMM uuuu\"\u003c/code\u003e will format 2011-12-03 as \u00273\u0026nbsp;Dec\u0026nbsp;2011\u0027. A formatter created from a pattern can be used as many times as necessary, it is immutable and is thread-safe. \n\u003cp\u003e For example: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e  LocalDate date \u003d LocalDate.now();\n  DateTimeFormatter formatter \u003d DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n  String text \u003d date.format(formatter);\n  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e All letters \u0027A\u0027 to \u0027Z\u0027 and \u0027a\u0027 to \u0027z\u0027 are reserved as pattern letters. The following pattern letters are defined: \u003c/p\u003e\n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption\u003e\n  Pattern Letters and Symbols\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"col\"\u003eSymbol\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003eMeaning\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003ePresentation\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003eExamples\u003c/th\u003e \n  \u003c/tr\u003e\n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eG\u003c/th\u003e \n   \u003ctd\u003eera\u003c/td\u003e \n   \u003ctd\u003etext\u003c/td\u003e \n   \u003ctd\u003eAD; Anno Domini; A\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eu\u003c/th\u003e \n   \u003ctd\u003eyear\u003c/td\u003e \n   \u003ctd\u003eyear\u003c/td\u003e \n   \u003ctd\u003e2004; 04\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ey\u003c/th\u003e \n   \u003ctd\u003eyear-of-era\u003c/td\u003e \n   \u003ctd\u003eyear\u003c/td\u003e \n   \u003ctd\u003e2004; 04\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eD\u003c/th\u003e \n   \u003ctd\u003eday-of-year\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e189\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eM/L\u003c/th\u003e \n   \u003ctd\u003emonth-of-year\u003c/td\u003e \n   \u003ctd\u003enumber/text\u003c/td\u003e \n   \u003ctd\u003e7; 07; Jul; July; J\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ed\u003c/th\u003e \n   \u003ctd\u003eday-of-month\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e10\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eg\u003c/th\u003e \n   \u003ctd\u003emodified-julian-day\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e2451334\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eQ/q\u003c/th\u003e \n   \u003ctd\u003equarter-of-year\u003c/td\u003e \n   \u003ctd\u003enumber/text\u003c/td\u003e \n   \u003ctd\u003e3; 03; Q3; 3rd quarter\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eY\u003c/th\u003e \n   \u003ctd\u003eweek-based-year\u003c/td\u003e \n   \u003ctd\u003eyear\u003c/td\u003e \n   \u003ctd\u003e1996; 96\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ew\u003c/th\u003e \n   \u003ctd\u003eweek-of-week-based-year\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e27\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eW\u003c/th\u003e \n   \u003ctd\u003eweek-of-month\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e4\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eE\u003c/th\u003e \n   \u003ctd\u003eday-of-week\u003c/td\u003e \n   \u003ctd\u003etext\u003c/td\u003e \n   \u003ctd\u003eTue; Tuesday; T\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ee/c\u003c/th\u003e \n   \u003ctd\u003elocalized day-of-week\u003c/td\u003e \n   \u003ctd\u003enumber/text\u003c/td\u003e \n   \u003ctd\u003e2; 02; Tue; Tuesday; T\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eF\u003c/th\u003e \n   \u003ctd\u003eday-of-week-in-month\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e3\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ea\u003c/th\u003e \n   \u003ctd\u003eam-pm-of-day\u003c/td\u003e \n   \u003ctd\u003etext\u003c/td\u003e \n   \u003ctd\u003ePM\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eB\u003c/th\u003e \n   \u003ctd\u003eperiod-of-day\u003c/td\u003e \n   \u003ctd\u003etext\u003c/td\u003e \n   \u003ctd\u003ein the morning\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eh\u003c/th\u003e \n   \u003ctd\u003eclock-hour-of-am-pm (1-12)\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e12\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eK\u003c/th\u003e \n   \u003ctd\u003ehour-of-am-pm (0-11)\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e0\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ek\u003c/th\u003e \n   \u003ctd\u003eclock-hour-of-day (1-24)\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e24\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eH\u003c/th\u003e \n   \u003ctd\u003ehour-of-day (0-23)\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e0\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003em\u003c/th\u003e \n   \u003ctd\u003eminute-of-hour\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e30\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003es\u003c/th\u003e \n   \u003ctd\u003esecond-of-minute\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e55\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eS\u003c/th\u003e \n   \u003ctd\u003efraction-of-second\u003c/td\u003e \n   \u003ctd\u003efraction\u003c/td\u003e \n   \u003ctd\u003e978\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eA\u003c/th\u003e \n   \u003ctd\u003emilli-of-day\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e1234\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003en\u003c/th\u003e \n   \u003ctd\u003enano-of-second\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e987654321\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eN\u003c/th\u003e \n   \u003ctd\u003enano-of-day\u003c/td\u003e \n   \u003ctd\u003enumber\u003c/td\u003e \n   \u003ctd\u003e1234000000\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eV\u003c/th\u003e \n   \u003ctd\u003etime-zone ID\u003c/td\u003e \n   \u003ctd\u003ezone-id\u003c/td\u003e \n   \u003ctd\u003eAmerica/Los_Angeles; Z; -08:30\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ev\u003c/th\u003e \n   \u003ctd\u003egeneric time-zone name\u003c/td\u003e \n   \u003ctd\u003ezone-name\u003c/td\u003e \n   \u003ctd\u003ePacific Time; PT\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ez\u003c/th\u003e \n   \u003ctd\u003etime-zone name\u003c/td\u003e \n   \u003ctd\u003ezone-name\u003c/td\u003e \n   \u003ctd\u003ePacific Standard Time; PST\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eO\u003c/th\u003e \n   \u003ctd\u003elocalized zone-offset\u003c/td\u003e \n   \u003ctd\u003eoffset-O\u003c/td\u003e \n   \u003ctd\u003eGMT+8; GMT+08:00; UTC-08:00\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eX\u003c/th\u003e \n   \u003ctd\u003ezone-offset \u0027Z\u0027 for zero\u003c/td\u003e \n   \u003ctd\u003eoffset-X\u003c/td\u003e \n   \u003ctd\u003eZ; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ex\u003c/th\u003e \n   \u003ctd\u003ezone-offset\u003c/td\u003e \n   \u003ctd\u003eoffset-x\u003c/td\u003e \n   \u003ctd\u003e+0000; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eZ\u003c/th\u003e \n   \u003ctd\u003ezone-offset\u003c/td\u003e \n   \u003ctd\u003eoffset-Z\u003c/td\u003e \n   \u003ctd\u003e+0000; -0800; -08:00\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ep\u003c/th\u003e \n   \u003ctd\u003epad next\u003c/td\u003e \n   \u003ctd\u003epad modifier\u003c/td\u003e \n   \u003ctd\u003e1\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003e\u0027\u003c/th\u003e \n   \u003ctd\u003eescape for text\u003c/td\u003e \n   \u003ctd\u003edelimiter\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003e\u0027\u0027\u003c/th\u003e \n   \u003ctd\u003esingle quote\u003c/td\u003e \n   \u003ctd\u003eliteral\u003c/td\u003e \n   \u003ctd\u003e\u0027\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003e[\u003c/th\u003e \n   \u003ctd\u003eoptional section start\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003e]\u003c/th\u003e \n   \u003ctd\u003eoptional section end\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003e#\u003c/th\u003e \n   \u003ctd\u003ereserved for future use\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003e{\u003c/th\u003e \n   \u003ctd\u003ereserved for future use\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003e}\u003c/th\u003e \n   \u003ctd\u003ereserved for future use\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n  \u003c/tr\u003e\n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The count of pattern letters determines the format. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eText\u003c/b\u003e: The text style is determined based on the number of pattern letters used. Less than 4 pattern letters will use the \u003ca href\u003d\"TextStyle.html#SHORT\"\u003e\u003ccode\u003eshort form\u003c/code\u003e\u003c/a\u003e. Exactly 4 pattern letters will use the \u003ca href\u003d\"TextStyle.html#FULL\"\u003e\u003ccode\u003efull form\u003c/code\u003e\u003c/a\u003e. Exactly 5 pattern letters will use the \u003ca href\u003d\"TextStyle.html#NARROW\"\u003e\u003ccode\u003enarrow form\u003c/code\u003e\u003c/a\u003e. Pattern letters \u0027L\u0027, \u0027c\u0027, and \u0027q\u0027 specify the stand-alone form of the text styles. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eNumber\u003c/b\u003e: If the count of letters is one, then the value is output using the minimum number of digits and without padding. Otherwise, the count of digits is used as the width of the output field, with the value zero-padded as necessary. The following pattern letters have constraints on the count of letters. Only one letter of \u0027c\u0027 and \u0027F\u0027 can be specified. Up to two letters of \u0027d\u0027, \u0027H\u0027, \u0027h\u0027, \u0027K\u0027, \u0027k\u0027, \u0027m\u0027, and \u0027s\u0027 can be specified. Up to three letters of \u0027D\u0027 can be specified. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eNumber/Text\u003c/b\u003e: If the count of pattern letters is 3 or greater, use the Text rules above. Otherwise use the Number rules above. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eFraction\u003c/b\u003e: Outputs the nano-of-second field as a fraction-of-second. The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9. If it is less than 9, then the nano-of-second value is truncated, with only the most significant digits being output. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eYear\u003c/b\u003e: The count of letters determines the minimum field width below which padding is used. If the count of letters is two, then a \u003ca href\u003d\"DateTimeFormatterBuilder.html#appendValueReduced(java.time.temporal.TemporalField,int,int,int)\"\u003e\u003ccode\u003ereduced\u003c/code\u003e\u003c/a\u003e two digit form is used. For printing, this outputs the rightmost two digits. For parsing, this will parse using the base value of 2000, resulting in a year within the range 2000 to 2099 inclusive. If the count of letters is less than four (but not two), then the sign is only output for negative years as per \u003ca href\u003d\"SignStyle.html#NORMAL\"\u003e\u003ccode\u003eSignStyle.NORMAL\u003c/code\u003e\u003c/a\u003e. Otherwise, the sign is output if the pad width is exceeded, as per \u003ca href\u003d\"SignStyle.html#EXCEEDS_PAD\"\u003e\u003ccode\u003eSignStyle.EXCEEDS_PAD\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eZoneId\u003c/b\u003e: This outputs the time-zone ID, such as \u0027Europe/Paris\u0027. If the count of letters is two, then the time-zone ID is output. Any other count of letters throws \u003ccode\u003eIllegalArgumentException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eZone names\u003c/b\u003e: This outputs the display name of the time-zone ID. If the pattern letter is \u0027z\u0027 the output is the daylight savings aware zone name. If there is insufficient information to determine whether DST applies, the name ignoring daylight savings time will be used. If the count of letters is one, two or three, then the short name is output. If the count of letters is four, then the full name is output. Five or more letters throws \u003ccode\u003eIllegalArgumentException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e If the pattern letter is \u0027v\u0027 the output provides the zone name ignoring daylight savings time. If the count of letters is one, then the short name is output. If the count of letters is four, then the full name is output. Two, three and five or more letters throw \u003ccode\u003eIllegalArgumentException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eOffset X and x\u003c/b\u003e: This formats the offset based on the number of pattern letters. One letter outputs just the hour, such as \u0027+01\u0027, unless the minute is non-zero in which case the minute is also output, such as \u0027+0130\u0027. Two letters outputs the hour and minute, without a colon, such as \u0027+0130\u0027. Three letters outputs the hour and minute, with a colon, such as \u0027+01:30\u0027. Four letters outputs the hour and minute and optional second, without a colon, such as \u0027+013015\u0027. Five letters outputs the hour and minute and optional second, with a colon, such as \u0027+01:30:15\u0027. Six or more letters throws \u003ccode\u003eIllegalArgumentException\u003c/code\u003e. Pattern letter \u0027X\u0027 (upper case) will output \u0027Z\u0027 when the offset to be output would be zero, whereas pattern letter \u0027x\u0027 (lower case) will output \u0027+00\u0027, \u0027+0000\u0027, or \u0027+00:00\u0027. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eOffset O\u003c/b\u003e: With a non-zero offset, this formats the localized offset based on the number of pattern letters. One letter outputs the \u003ca href\u003d\"TextStyle.html#SHORT\"\u003eshort\u003c/a\u003e form of the localized offset, which is localized offset text, such as \u0027GMT\u0027, with hour without leading zero, optional 2-digit minute and second if non-zero, and colon, for example \u0027GMT+8\u0027. Four letters outputs the \u003ca href\u003d\"TextStyle.html#FULL\"\u003efull\u003c/a\u003e form, which is localized offset text, such as \u0027GMT, with 2-digit hour and minute field, optional second field if non-zero, and colon, for example \u0027GMT+08:00\u0027. If the offset is zero, only localized text is output. Any other count of letters throws \u003ccode\u003eIllegalArgumentException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eOffset Z\u003c/b\u003e: This formats the offset based on the number of pattern letters. One, two or three letters outputs the hour and minute, without a colon, such as \u0027+0130\u0027. The output will be \u0027+0000\u0027 when the offset is zero. Four letters outputs the \u003ca href\u003d\"TextStyle.html#FULL\"\u003efull\u003c/a\u003e form of localized offset, equivalent to four letters of Offset-O. The output will be the corresponding localized offset text if the offset is zero. Five letters outputs the hour, minute, with optional second if non-zero, with colon. It outputs \u0027Z\u0027 if the offset is zero. Six or more letters throws \u003ccode\u003eIllegalArgumentException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003eOptional section\u003c/b\u003e: The optional section markers work exactly like calling \u003ca href\u003d\"DateTimeFormatterBuilder.html#optionalStart()\"\u003e\u003ccode\u003eDateTimeFormatterBuilder.optionalStart()\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"DateTimeFormatterBuilder.html#optionalEnd()\"\u003e\u003ccode\u003eDateTimeFormatterBuilder.optionalEnd()\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e \u003cb\u003ePad modifier\u003c/b\u003e: Modifies the pattern that immediately follows to be padded with spaces. The pad width is determined by the number of pattern letters. This is the same as calling \u003ca href\u003d\"DateTimeFormatterBuilder.html#padNext(int)\"\u003e\u003ccode\u003eDateTimeFormatterBuilder.padNext(int)\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e For example, \u0027ppH\u0027 outputs the hour-of-day padded on the left with spaces to a width of 2. \u003c/p\u003e\n\u003cp\u003e Any unrecognized letter is an error. Any non-letter character, other than \u0027[\u0027, \u0027]\u0027, \u0027{\u0027, \u0027}\u0027, \u0027#\u0027 and the single quote will be output directly. Despite this, it is recommended to use single quotes around all characters that you want to output directly to ensure that future changes do not break your application. \u003c/p\u003e\n\u003ch2 id\u003d\"resolving\"\u003eResolving\u003c/h2\u003e Parsing is implemented as a two-phase operation. First, the text is parsed using the layout defined by the formatter, producing a \n\u003ccode\u003eMap\u003c/code\u003e of field to value, a \n\u003ccode\u003eZoneId\u003c/code\u003e and a \n\u003ccode\u003eChronology\u003c/code\u003e. Second, the parsed data is \n\u003cem\u003eresolved\u003c/em\u003e, by validating, combining and simplifying the various fields into more useful ones. \n\u003cp\u003e Five parsing methods are supplied by this class. Four of these perform both the parse and resolve phases. The fifth method, \u003ca href\u003d\"#parseUnresolved(java.lang.CharSequence,java.text.ParsePosition)\"\u003e\u003ccode\u003eparseUnresolved(CharSequence, ParsePosition)\u003c/code\u003e\u003c/a\u003e, only performs the first phase, leaving the result unresolved. As such, it is essentially a low-level operation. \u003c/p\u003e\n\u003cp\u003e The resolve phase is controlled by two parameters, set on this class. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"ResolverStyle.html\" title\u003d\"enum class in java.time.format\"\u003e\u003ccode\u003eResolverStyle\u003c/code\u003e\u003c/a\u003e is an enum that offers three different approaches, strict, smart and lenient. The smart option is the default. It can be set using \u003ca href\u003d\"#withResolverStyle(java.time.format.ResolverStyle)\"\u003e\u003ccode\u003ewithResolverStyle(ResolverStyle)\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"#withResolverFields(java.time.temporal.TemporalField...)\"\u003e\u003ccode\u003ewithResolverFields(TemporalField...)\u003c/code\u003e\u003c/a\u003e parameter allows the set of fields that will be resolved to be filtered before resolving starts. For example, if the formatter has parsed a year, month, day-of-month and day-of-year, then there are two approaches to resolve a date: (year + month + day-of-month) and (year + day-of-year). The resolver fields allows one of the two approaches to be selected. If no resolver fields are set then both approaches must result in the same date. \u003c/p\u003e\n\u003cp\u003e Resolving separate fields to form a complete date and time is a complex process with behaviour distributed across a number of classes. It follows these steps: \u003c/p\u003e\n\u003col\u003e \n \u003cli\u003eThe chronology is determined. The chronology of the result is either the chronology that was parsed, or if no chronology was parsed, it is the chronology set on this class, or if that is null, it is \u003ccode\u003eIsoChronology\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eThe \u003ccode\u003eChronoField\u003c/code\u003e date fields are resolved. This is achieved using \u003ca href\u003d\"../chrono/Chronology.html#resolveDate(java.util.Map,java.time.format.ResolverStyle)\"\u003e\u003ccode\u003eChronology.resolveDate(Map, ResolverStyle)\u003c/code\u003e\u003c/a\u003e. Documentation about field resolution is located in the implementation of \u003ccode\u003eChronology\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eThe \u003ccode\u003eChronoField\u003c/code\u003e time fields are resolved. This is documented on \u003ca href\u003d\"../temporal/ChronoField.html\" title\u003d\"enum class in java.time.temporal\"\u003e\u003ccode\u003eChronoField\u003c/code\u003e\u003c/a\u003e and is the same for all chronologies. \u003c/li\u003e\n \u003cli\u003eAny fields that are not \u003ccode\u003eChronoField\u003c/code\u003e are processed. This is achieved using \u003ca href\u003d\"../temporal/TemporalField.html#resolve(java.util.Map,java.time.temporal.TemporalAccessor,java.time.format.ResolverStyle)\"\u003e\u003ccode\u003eTemporalField.resolve(Map, TemporalAccessor, ResolverStyle)\u003c/code\u003e\u003c/a\u003e. Documentation about field resolution is located in the implementation of \u003ccode\u003eTemporalField\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eThe \u003ccode\u003eChronoField\u003c/code\u003e date and time fields are re-resolved. This allows fields in step four to produce \u003ccode\u003eChronoField\u003c/code\u003e values and have them be processed into dates and times. \u003c/li\u003e\n \u003cli\u003eA \u003ccode\u003eLocalTime\u003c/code\u003e is formed if there is at least an hour-of-day available. This involves providing default values for minute, second and fraction of second. \u003c/li\u003e\n \u003cli\u003eAny remaining unresolved fields are cross-checked against any date and/or time that was resolved. Thus, an earlier stage would resolve (year + month + day-of-month) to a date, and this stage would check that day-of-week was valid for the date. \u003c/li\u003e\n \u003cli\u003eIf an \u003ca href\u003d\"#parsedExcessDays()\"\u003eexcess number of days\u003c/a\u003e was parsed then it is added to the date if a date is available. \u003c/li\u003e\n \u003cli\u003e If a second-based field is present, but \u003ccode\u003eLocalTime\u003c/code\u003e was not parsed, then the resolver ensures that milli, micro and nano second values are available to meet the contract of \u003ca href\u003d\"../temporal/ChronoField.html\" title\u003d\"enum class in java.time.temporal\"\u003e\u003ccode\u003eChronoField\u003c/code\u003e\u003c/a\u003e. These will be set to zero if missing. \u003c/li\u003e\n \u003cli\u003eIf both date and time were parsed and either an offset or zone is present, the field \u003ca href\u003d\"../temporal/ChronoField.html#INSTANT_SECONDS\"\u003e\u003ccode\u003eChronoField.INSTANT_SECONDS\u003c/code\u003e\u003c/a\u003e is created. If an offset was parsed then the offset will be combined with the \u003ccode\u003eLocalDateTime\u003c/code\u003e to form the instant, with any zone ignored. If a \u003ccode\u003eZoneId\u003c/code\u003e was parsed without an offset then the zone will be combined with the \u003ccode\u003eLocalDateTime\u003c/code\u003e to form the instant using the rules of \u003ca href\u003d\"../chrono/ChronoLocalDateTime.html#atZone(java.time.ZoneId)\"\u003e\u003ccode\u003eChronoLocalDateTime.atZone(ZoneId)\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "implSpec": [
      "This class is immutable and thread-safe."
    ],
    "since": [
      "1.8"
    ]
  }
}