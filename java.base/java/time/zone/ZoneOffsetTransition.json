{
  "packageName": "java.time.zone",
  "simpleName": "ZoneOffsetTransition",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.time.zone.ZoneOffsetTransition",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.LocalDateTime",
            "type": "Class"
          },
          "field": {
            "name": "transition"
          }
        },
        {
          "type": {
            "name": "java.time.ZoneOffset",
            "type": "Class"
          },
          "field": {
            "name": "offsetBefore"
          }
        },
        {
          "type": {
            "name": "java.time.ZoneOffset",
            "type": "Class"
          },
          "field": {
            "name": "offsetAfter"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "of",
      "comment": "Obtains an instance defining a transition between two offsets. Applications should normally obtain an instance from ZoneRules. This factory is only intended for use when creating ZoneRules.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etransition\u003c/code\u003e - the transition date-time at the transition, which never actually occurs, expressed local to the before offset, not null",
          "\u003ccode\u003eoffsetBefore\u003c/code\u003e - the offset before the transition, not null",
          "\u003ccode\u003eoffsetAfter\u003c/code\u003e - the offset at and after the transition, not null"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eoffsetBefore\u003c/code\u003e and \n\u003ccode\u003eoffsetAfter\u003c/code\u003e are equal, or \n\u003ccode\u003etransition.getNano()\u003c/code\u003e returns non-zero value"
        ],
        "return": [
          "the transition, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.Instant",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getInstant",
      "comment": "Gets the transition instant. This is the instant of the discontinuity, which is defined as the first instant that the \u0027after\u0027 offset applies. The methods getInstant(), getDateTimeBefore() and getDateTimeAfter() all represent the same instant.",
      "tagMap": {
        "return": [
          "the transition instant, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "long",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toEpochSecond",
      "comment": "Gets the transition instant as an epoch second.",
      "tagMap": {
        "return": [
          "the transition epoch second"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.LocalDateTime",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getDateTimeBefore",
      "comment": "Gets the local transition date-time, as would be expressed with the \u0027before\u0027 offset. This is the date-time where the discontinuity begins expressed with the \u0027before\u0027 offset. At this instant, the \u0027after\u0027 offset is actually used, therefore the combination of this date-time and the \u0027before\u0027 offset will never occur. The combination of the \u0027before\u0027 date-time and offset represents the same instant as the \u0027after\u0027 date-time and offset.",
      "tagMap": {
        "return": [
          "the transition date-time expressed with the before offset, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.LocalDateTime",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getDateTimeAfter",
      "comment": "Gets the local transition date-time, as would be expressed with the \u0027after\u0027 offset. This is the first date-time after the discontinuity, when the new offset applies. The combination of the \u0027before\u0027 date-time and offset represents the same instant as the \u0027after\u0027 date-time and offset.",
      "tagMap": {
        "return": [
          "the transition date-time expressed with the after offset, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.ZoneOffset",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getOffsetBefore",
      "comment": "Gets the offset before the transition. This is the offset in use before the instant of the transition.",
      "tagMap": {
        "return": [
          "the offset before the transition, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.ZoneOffset",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getOffsetAfter",
      "comment": "Gets the offset after the transition. This is the offset in use on and after the instant of the transition.",
      "tagMap": {
        "return": [
          "the offset after the transition, not null"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.time.Duration",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getDuration",
      "comment": "Gets the duration of the transition. In most cases, the transition duration is one hour, however this is not always the case. The duration will be positive for a gap and negative for an overlap. Time-zones are second-based, so the nanosecond part of the duration will be zero.",
      "tagMap": {
        "return": [
          "the duration of the transition, positive for gaps, negative for overlaps"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isGap",
      "comment": "Does this transition represent a gap in the local time-line. Gaps occur where there are local date-times that simply do not exist. An example would be when the offset changes from +01:00 to +02:00. This might be described as \u0027the clocks will move forward one hour tonight at 1am\u0027.",
      "tagMap": {
        "return": [
          "true if this transition is a gap, false if it is an overlap"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isOverlap",
      "comment": "Does this transition represent an overlap in the local time-line. Overlaps occur where there are local date-times that exist twice. An example would be when the offset changes from +02:00 to +01:00. This might be described as \u0027the clocks will move back one hour tonight at 2am\u0027.",
      "tagMap": {
        "return": [
          "true if this transition is an overlap, false if it is a gap"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.ZoneOffset",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isValidOffset",
      "comment": "Checks if the specified offset is valid during this transition. This checks to see if the given offset will be valid at some point in the transition. A gap will always return false. An overlap will return true if the offset is either the before or after offset.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset to check, null returns false"
        ],
        "return": [
          "true if the offset is valid during the transition"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.time.zone.ZoneOffsetTransition",
            "type": "Class"
          },
          "field": {
            "name": "transition"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "compareTo",
      "comment": "Compares this transition to another based on the transition instant. This compares the instants of each transition. The offsets are ignored, making this order inconsistent with equals.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html#compareTo(T)\"\u003ecompareTo\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003eComparable\u003c/a\u003e\u0026lt;\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/time/zone/ZoneOffsetTransition.html\" title\u003d\"class in java.time.zone\"\u003eZoneOffsetTransition\u003c/a\u003e\u0026gt;\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003etransition\u003c/code\u003e - the transition to compare to, not null"
        ],
        "return": [
          "the comparator value, negative if less, positive if greater"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "other"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "equals",
      "comment": "Checks if this object equals another. The entire state of the object is compared.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/HashMap.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eHashMap\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eother\u003c/code\u003e - the other object to compare to, null returns false"
        ],
        "return": [
          "true if equal"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hashCode",
      "comment": "Returns a suitable hash code.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#identityHashCode(java.lang.Object)\"\u003e\u003ccode\u003eSystem.identityHashCode(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "the hash code"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a string describing this object.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a string for debugging, not null"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.time.zone.ZoneOffsetTransition",
  "comment": "A transition between two offsets caused by a discontinuity in the local time-line. \n\u003cp\u003e A transition between two offsets is normally the result of a daylight savings cutover. The discontinuity is normally a gap in spring and an overlap in autumn. \u003ccode\u003eZoneOffsetTransition\u003c/code\u003e models the transition between the two offsets. \u003c/p\u003e\n\u003cp\u003e Gaps occur where there are local date-times that simply do not exist. An example would be when the offset changes from \u003ccode\u003e+03:00\u003c/code\u003e to \u003ccode\u003e+04:00\u003c/code\u003e. This might be described as \u0027the clocks will move forward one hour tonight at 1am\u0027. \u003c/p\u003e\n\u003cp\u003e Overlaps occur where there are local date-times that exist twice. An example would be when the offset changes from \u003ccode\u003e+04:00\u003c/code\u003e to \u003ccode\u003e+03:00\u003c/code\u003e. This might be described as \u0027the clocks will move back one hour tonight at 2am\u0027.\u003c/p\u003e",
  "tagMap": {
    "implSpec": [
      "This class is immutable and thread-safe."
    ],
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#java.time.zone.ZoneOffsetTransition\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "since": [
      "1.8"
    ]
  }
}