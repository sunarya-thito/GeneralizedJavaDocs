{
  "packageName": "java.nio",
  "simpleName": "Buffer",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "capacity",
      "comment": "Returns this buffer\u0027s capacity.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The capacity of this buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "position",
      "comment": "Returns this buffer\u0027s position.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The position of this buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "position",
      "comment": "Sets this buffer\u0027s position. If the mark is defined and larger than the new position then it is discarded.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enewPosition\u003c/code\u003e - The new position value; must be non-negative and no larger than the current limit"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the preconditions on \n\u003ccode\u003enewPosition\u003c/code\u003e do not hold"
        ],
        "return": [
          "This buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "limit",
      "comment": "Returns this buffer\u0027s limit.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The limit of this buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "limit",
      "comment": "Sets this buffer\u0027s limit. If the position is larger than the new limit then it is set to the new limit. If the mark is defined and larger than the new limit then it is discarded.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003enewLimit\u003c/code\u003e - The new limit value; must be non-negative and no larger than this buffer\u0027s capacity"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the preconditions on \n\u003ccode\u003enewLimit\u003c/code\u003e do not hold"
        ],
        "return": [
          "This buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "mark",
      "comment": "Sets this buffer\u0027s mark at its position.",
      "annotations": [],
      "tagMap": {
        "return": [
          "This buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "reset",
      "comment": "Resets this buffer\u0027s position to the previously-marked position. Invoking this method neither changes nor discards the mark\u0027s value.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/InvalidMarkException.html\" title\u003d\"class in java.nio\"\u003eInvalidMarkException\u003c/a\u003e\u003c/code\u003e - If the mark has not been set"
        ],
        "return": [
          "This buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "clear",
      "comment": "Clears this buffer. The position is set to zero, the limit is set to the capacity, and the mark is discarded. Invoke this method before using a sequence of channel-read or put operations to fill this buffer. For example:  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data This method does not actually erase the data in the buffer, but it is named as if it did because it will most often be used in situations in which that might as well be the case.",
      "annotations": [],
      "tagMap": {
        "return": [
          "This buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "flip",
      "comment": "Flips this buffer. The limit is set to the current position and then the position is set to zero. If the mark is defined then it is discarded. After a sequence of channel-read or put operations, invoke this method to prepare for a sequence of channel-write or relative get operations. For example:  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel This method is often used in conjunction with the compact method when transferring data from one place to another.",
      "annotations": [],
      "tagMap": {
        "return": [
          "This buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "rewind",
      "comment": "Rewinds this buffer. The position is set to zero and the mark is discarded. Invoke this method before a sequence of channel-write or get operations, assuming that the limit has already been set appropriately. For example:  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array",
      "annotations": [],
      "tagMap": {
        "return": [
          "This buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "remaining",
      "comment": "Returns the number of elements between the current position and the limit.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The number of elements remaining in this buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "hasRemaining",
      "comment": "Tells whether there are any elements between the current position and the limit.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, there is at least one element remaining in this buffer"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "isReadOnly",
      "comment": "Tells whether or not this buffer is read-only.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, this buffer is read-only"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "hasArray",
      "comment": "Tells whether or not this buffer is backed by an accessible array. If this method returns true then the array and arrayOffset methods may safely be invoked.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, this buffer is backed by an array and is not read-only"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "array",
      "comment": "Returns the array that backs this buffer (optional operation). This method is intended to allow array-backed buffers to be passed to native code more efficiently. Concrete subclasses provide more strongly-typed return values for this method. Modifications to this buffer\u0027s content will cause the returned array\u0027s content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - If this buffer is backed by an array but is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - If this buffer is not backed by an accessible array"
        ],
        "return": [
          "The array that backs this buffer"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "arrayOffset",
      "comment": "Returns the offset within this buffer\u0027s backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - If this buffer is backed by an array but is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - If this buffer is not backed by an accessible array"
        ],
        "return": [
          "The offset within this buffer\u0027s array of the first element of the buffer"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "isDirect",
      "comment": "Tells whether or not this buffer is direct.",
      "annotations": [],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, this buffer is direct"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "slice",
      "comment": "Creates a new buffer whose content is a shared subsequence of this buffer\u0027s content. The content of the new buffer will start at this buffer\u0027s current position. Changes to this buffer\u0027s content will be visible in the new buffer, and vice versa; the two buffers\u0027 position, limit, and mark values will be independent. The new buffer\u0027s position will be zero, its capacity and its limit will be the number of elements remaining in this buffer, its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The new buffer"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "slice",
      "comment": "Creates a new buffer whose content is a shared subsequence of this buffer\u0027s content. The content of the new buffer will start at position index in this buffer, and will contain length elements. Changes to this buffer\u0027s content will be visible in the new buffer, and vice versa; the two buffers\u0027 position, limit, and mark values will be independent. The new buffer\u0027s position will be zero, its capacity and its limit will be length, its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eindex\u003c/code\u003e - The position in this buffer at which the content of the new buffer will start; must be non-negative and no larger than \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/Buffer.html#limit()\"\u003e\u003ccode\u003elimit()\u003c/code\u003e\u003c/a\u003e",
          "\u003ccode\u003elength\u003c/code\u003e - The number of elements the new buffer will contain; must be non-negative and no larger than \n\u003ccode\u003elimit() - index\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003eindex\u003c/code\u003e is negative or greater than \n\u003ccode\u003elimit()\u003c/code\u003e, \n\u003ccode\u003elength\u003c/code\u003e is negative, or \n\u003ccode\u003elength \u0026gt; limit() - index\u003c/code\u003e"
        ],
        "return": [
          "The new buffer"
        ],
        "since": [
          "13"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.Buffer",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "duplicate",
      "comment": "Creates a new buffer that shares this buffer\u0027s content. The content of the new buffer will be that of this buffer. Changes to this buffer\u0027s content will be visible in the new buffer, and vice versa; the two buffers\u0027 position, limit, and mark values will be independent. The new buffer\u0027s capacity, limit, position and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The new buffer"
        ],
        "since": [
          "9"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.nio.Buffer",
  "comment": "A container for data of a specific primitive type. \n\u003cp\u003e A buffer is a linear, finite sequence of elements of a specific primitive type. Aside from its content, the essential properties of a buffer are its capacity, limit, and position: \u003c/p\u003e \n\u003cblockquote\u003e \n \u003cp\u003e A buffer\u0027s \u003ci\u003ecapacity\u003c/i\u003e is the number of elements it contains. The capacity of a buffer is never negative and never changes. \u003c/p\u003e \n \u003cp\u003e A buffer\u0027s \u003ci\u003elimit\u003c/i\u003e is the index of the first element that should not be read or written. A buffer\u0027s limit is never negative and is never greater than its capacity. \u003c/p\u003e \n \u003cp\u003e A buffer\u0027s \u003ci\u003eposition\u003c/i\u003e is the index of the next element to be read or written. A buffer\u0027s position is never negative and is never greater than its limit. \u003c/p\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e There is one subclass of this class for each non-boolean primitive type. \u003c/p\u003e\n\u003ch2\u003e Transferring data \u003c/h2\u003e \n\u003cp\u003e Each subclass of this class defines two categories of \u003ci\u003eget\u003c/i\u003e and \u003ci\u003eput\u003c/i\u003e operations: \u003c/p\u003e \n\u003cblockquote\u003e \n \u003cp\u003e \u003ci\u003eRelative\u003c/i\u003e operations read or write one or more elements starting at the current position and then increment the position by the number of elements transferred. If the requested transfer exceeds the limit then a relative \u003ci\u003eget\u003c/i\u003e operation throws a \u003ca href\u003d\"BufferUnderflowException.html\" title\u003d\"class in java.nio\"\u003e\u003ccode\u003eBufferUnderflowException\u003c/code\u003e\u003c/a\u003e and a relative \u003ci\u003eput\u003c/i\u003e operation throws a \u003ca href\u003d\"BufferOverflowException.html\" title\u003d\"class in java.nio\"\u003e\u003ccode\u003eBufferOverflowException\u003c/code\u003e\u003c/a\u003e; in either case, no data is transferred. \u003c/p\u003e \n \u003cp\u003e \u003ci\u003eAbsolute\u003c/i\u003e operations take an explicit element index and do not affect the position. Absolute \u003ci\u003eget\u003c/i\u003e and \u003ci\u003eput\u003c/i\u003e operations throw an \u003ca href\u003d\"../lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eIndexOutOfBoundsException\u003c/code\u003e\u003c/a\u003e if the index argument exceeds the limit. \u003c/p\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e Data may also, of course, be transferred in to or out of a buffer by the I/O operations of an appropriate channel, which are always relative to the current position. \u003c/p\u003e\n\u003ch2\u003e Marking and resetting \u003c/h2\u003e \n\u003cp\u003e A buffer\u0027s \u003ci\u003emark\u003c/i\u003e is the index to which its position will be reset when the \u003ca href\u003d\"#reset()\"\u003e\u003ccode\u003ereset\u003c/code\u003e\u003c/a\u003e method is invoked. The mark is not always defined, but when it is defined it is never negative and is never greater than the position. If the mark is defined then it is discarded when the position or the limit is adjusted to a value smaller than the mark. If the mark is not defined then invoking the \u003ca href\u003d\"#reset()\"\u003e\u003ccode\u003ereset\u003c/code\u003e\u003c/a\u003e method causes an \u003ca href\u003d\"InvalidMarkException.html\" title\u003d\"class in java.nio\"\u003e\u003ccode\u003eInvalidMarkException\u003c/code\u003e\u003c/a\u003e to be thrown. \u003c/p\u003e\n\u003ch2\u003e Invariants \u003c/h2\u003e \n\u003cp\u003e The following invariant holds for the mark, position, limit, and capacity values: \u003c/p\u003e\n\u003cblockquote\u003e \n \u003ccode\u003e0\u003c/code\u003e \n \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e \n \u003ci\u003emark\u003c/i\u003e \n \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e \n \u003ci\u003eposition\u003c/i\u003e \n \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e \n \u003ci\u003elimit\u003c/i\u003e \n \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e \n \u003ci\u003ecapacity\u003c/i\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e A newly-created buffer always has a position of zero and a mark that is undefined. The initial limit may be zero, or it may be some other value that depends upon the type of the buffer and the manner in which it is constructed. Each element of a newly-allocated buffer is initialized to zero. \u003c/p\u003e\n\u003ch2\u003e Additional operations \u003c/h2\u003e \n\u003cp\u003e In addition to methods for accessing the position, limit, and capacity values and for marking and resetting, this class also defines the following operations upon buffers: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003cp\u003e \u003ca href\u003d\"#clear()\"\u003e\u003ccode\u003eclear()\u003c/code\u003e\u003c/a\u003e makes a buffer ready for a new sequence of channel-read or relative \u003ci\u003eput\u003c/i\u003e operations: It sets the limit to the capacity and the position to zero. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e \u003ca href\u003d\"#flip()\"\u003e\u003ccode\u003eflip()\u003c/code\u003e\u003c/a\u003e makes a buffer ready for a new sequence of channel-write or relative \u003ci\u003eget\u003c/i\u003e operations: It sets the limit to the current position and then sets the position to zero. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e \u003ca href\u003d\"#rewind()\"\u003e\u003ccode\u003erewind()\u003c/code\u003e\u003c/a\u003e makes a buffer ready for re-reading the data that it already contains: It leaves the limit unchanged and sets the position to zero. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#slice()\"\u003e\u003ccode\u003eslice()\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#slice(int,int)\"\u003e\u003ccode\u003eslice(index,length)\u003c/code\u003e\u003c/a\u003e methods create a subsequence of a buffer: They leave the limit and the position unchanged. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e \u003ca href\u003d\"#duplicate()\"\u003e\u003ccode\u003eduplicate()\u003c/code\u003e\u003c/a\u003e creates a shallow copy of a buffer: It leaves the limit and the position unchanged. \u003c/p\u003e\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e Read-only buffers \u003c/h2\u003e \n\u003cp\u003e Every buffer is readable, but not every buffer is writable. The mutation methods of each buffer class are specified as \u003ci\u003eoptional operations\u003c/i\u003e that will throw a \u003ca href\u003d\"ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003e\u003ccode\u003eReadOnlyBufferException\u003c/code\u003e\u003c/a\u003e when invoked upon a read-only buffer. A read-only buffer does not allow its content to be changed, but its mark, position, and limit values are mutable. Whether or not a buffer is read-only may be determined by invoking its \u003ca href\u003d\"#isReadOnly()\"\u003e\u003ccode\u003eisReadOnly\u003c/code\u003e\u003c/a\u003e method. \u003c/p\u003e\n\u003ch2\u003e Thread safety \u003c/h2\u003e \n\u003cp\u003e Buffers are not safe for use by multiple concurrent threads. If a buffer is to be used by more than one thread then access to the buffer should be controlled by appropriate synchronization. \u003c/p\u003e\n\u003ch2\u003e Invocation chaining \u003c/h2\u003e \n\u003cp\u003e Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked. This allows method invocations to be chained; for example, the sequence of statements \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e b.flip();\n b.position(23);\n b.limit(42);\u003c/pre\u003e\n\u003c/blockquote\u003e can be replaced by the single, more compact statement \n\u003cblockquote\u003e\n \u003cpre\u003e b.flip().position(23).limit(42);\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.4"
    ]
  }
}