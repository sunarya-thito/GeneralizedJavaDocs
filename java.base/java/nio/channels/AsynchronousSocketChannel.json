{
  "packageName": "java.nio.channels",
  "simpleName": "AsynchronousSocketChannel",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.nio.channels.spi.AsynchronousChannelProvider",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "provider",
      "comment": "Returns the provider that created this channel.",
      "annotations": [],
      "tagMap": {
        "return": [
          "The provider that created this channel"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.channels.AsynchronousSocketChannel",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.AsynchronousChannelGroup",
            "type": "Class"
          },
          "name": "group",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "open",
      "comment": "Opens an asynchronous socket channel. The new channel is created by invoking the openAsynchronousSocketChannel method on the AsynchronousChannelProvider that created the group. If the group parameter is null then the resulting channel is created by the system-wide default provider, and bound to the default group.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003egroup\u003c/code\u003e - The group to which the newly constructed channel should be bound, or \n\u003ccode\u003enull\u003c/code\u003e for the default group"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group is shutdown",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If an I/O error occurs"
        ],
        "return": [
          "A new asynchronous socket channel"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.channels.AsynchronousSocketChannel",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "open",
      "comment": "Opens an asynchronous socket channel. This method returns an asynchronous socket channel that is bound to the default group.This method is equivalent to evaluating the expression:  open((AsynchronousChannelGroup)null);",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If an I/O error occurs"
        ],
        "return": [
          "A new asynchronous socket channel"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.channels.AsynchronousSocketChannel",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.net.SocketAddress",
            "type": "Class"
          },
          "name": "local",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "bind",
      "comment": "Description copied from interface: NetworkChannel",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NetworkChannel.html#getLocalAddress()\"\u003e\u003ccode\u003eNetworkChannel.getLocalAddress()\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NetworkChannel.html#bind(java.net.SocketAddress)\"\u003ebind\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NetworkChannel.html\" title\u003d\"interface in java.nio.channels\"\u003eNetworkChannel\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003elocal\u003c/code\u003e - The address to bind the socket, or \n\u003ccode\u003enull\u003c/code\u003e to bind the socket to an automatically assigned socket address"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ConnectionPendingException.html\" title\u003d\"class in java.nio.channels\"\u003eConnectionPendingException\u003c/a\u003e\u003c/code\u003e - If a connection operation is already in progress on this channel",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AlreadyBoundException.html\" title\u003d\"class in java.nio.channels\"\u003eAlreadyBoundException\u003c/a\u003e\u003c/code\u003e - If the socket is already bound",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/UnsupportedAddressTypeException.html\" title\u003d\"class in java.nio.channels\"\u003eUnsupportedAddressTypeException\u003c/a\u003e\u003c/code\u003e - If the type of the given address is not supported",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ClosedChannelException.html\" title\u003d\"class in java.nio.channels\"\u003eClosedChannelException\u003c/a\u003e\u003c/code\u003e - If the channel is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If some other I/O error occurs",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If a security manager has been installed and its \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkListen(int)\"\u003e\u003ccode\u003echeckListen\u003c/code\u003e\u003c/a\u003e method denies the operation"
        ],
        "return": [
          "This channel"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.channels.AsynchronousSocketChannel",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.net.SocketOption",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "name": "name",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "T",
            "type": "Class"
          },
          "name": "value",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setOption",
      "comment": "Description copied from interface: NetworkChannel",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - The type of the socket option value"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/StandardSocketOptions.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eStandardSocketOptions\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NetworkChannel.html#setOption(java.net.SocketOption,T)\"\u003esetOption\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NetworkChannel.html\" title\u003d\"interface in java.nio.channels\"\u003eNetworkChannel\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - The socket option",
          "\u003ccode\u003evalue\u003c/code\u003e - The value of the socket option. A value of \n\u003ccode\u003enull\u003c/code\u003e may be a valid value for some socket options."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the value is not a valid value for this socket option",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ClosedChannelException.html\" title\u003d\"class in java.nio.channels\"\u003eClosedChannelException\u003c/a\u003e\u003c/code\u003e - If this channel is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If an I/O error occurs"
        ],
        "return": [
          "This channel"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.channels.AsynchronousSocketChannel",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "shutdownInput",
      "comment": "Shutdown the connection for reading without closing the channel. Once shutdown for reading then further reads on the channel will return -1, the end-of-stream indication. If the input side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding read operation is system dependent and therefore not specified. The effect, if any, when there is data in the socket receive buffer that has not been read, or data arrives subsequently, is also system dependent.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ClosedChannelException.html\" title\u003d\"class in java.nio.channels\"\u003eClosedChannelException\u003c/a\u003e\u003c/code\u003e - If this channel is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If some other I/O error occurs"
        ],
        "return": [
          "The channel"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.nio.channels.AsynchronousSocketChannel",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "shutdownOutput",
      "comment": "Shutdown the connection for writing without closing the channel. Once shutdown for writing then further attempts to write to the channel will throw ClosedChannelException. If the output side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding write operation is system dependent and therefore not specified.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ClosedChannelException.html\" title\u003d\"class in java.nio.channels\"\u003eClosedChannelException\u003c/a\u003e\u003c/code\u003e - If this channel is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If some other I/O error occurs"
        ],
        "return": [
          "The channel"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.SocketAddress",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getRemoteAddress",
      "comment": "Returns the remote address to which this channel\u0027s socket is connected. Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ClosedChannelException.html\" title\u003d\"class in java.nio.channels\"\u003eClosedChannelException\u003c/a\u003e\u003c/code\u003e - If the channel is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If an I/O error occurs"
        ],
        "return": [
          "The remote address; \n\u003ccode\u003enull\u003c/code\u003e if the channel\u0027s socket is not connected"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.net.SocketAddress",
            "type": "Class"
          },
          "name": "remote",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "A",
            "type": "Class"
          },
          "name": "attachment",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.CompletionHandler",
            "parameters": [
              {
                "name": "java.lang.Void",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "name": "A",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "handler",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "connect",
      "comment": "Connects this channel. This method initiates an operation to connect this channel. The handler parameter is a completion handler that is invoked when the connection is successfully established or connection cannot be established. If the connection cannot be established then the channel is closed. This method performs exactly the same security checks as the Socket class. That is, if a security manager has been installed then this method verifies that its checkConnect method permits connecting to the address and port number of the given remote endpoint.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - The type of the attachment"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousSocketChannel.html#getRemoteAddress()\"\u003e\u003ccode\u003egetRemoteAddress()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eremote\u003c/code\u003e - The remote address to which this channel is to be connected",
          "\u003ccode\u003eattachment\u003c/code\u003e - The object to attach to the I/O operation; can be \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003ehandler\u003c/code\u003e - The handler for consuming the result"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/UnresolvedAddressException.html\" title\u003d\"class in java.nio.channels\"\u003eUnresolvedAddressException\u003c/a\u003e\u003c/code\u003e - If the given remote address is not fully resolved",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/UnsupportedAddressTypeException.html\" title\u003d\"class in java.nio.channels\"\u003eUnsupportedAddressTypeException\u003c/a\u003e\u003c/code\u003e - If the type of the given remote address is not supported",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AlreadyConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eAlreadyConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is already connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ConnectionPendingException.html\" title\u003d\"class in java.nio.channels\"\u003eConnectionPendingException\u003c/a\u003e\u003c/code\u003e - If a connection operation is already in progress on this channel",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group has terminated",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If a security manager has been installed and it does not permit access to the given remote endpoint"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.concurrent.Future",
        "parameters": [
          {
            "name": "java.lang.Void",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.net.SocketAddress",
            "type": "Class"
          },
          "name": "remote",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "connect",
      "comment": "Connects this channel. This method initiates an operation to connect this channel. This method behaves in exactly the same manner as the connect(SocketAddress, Object, CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future\u0027s get method returns null on successful completion.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eremote\u003c/code\u003e - The remote address to which this channel is to be connected"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/UnresolvedAddressException.html\" title\u003d\"class in java.nio.channels\"\u003eUnresolvedAddressException\u003c/a\u003e\u003c/code\u003e - If the given remote address is not fully resolved",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/UnsupportedAddressTypeException.html\" title\u003d\"class in java.nio.channels\"\u003eUnsupportedAddressTypeException\u003c/a\u003e\u003c/code\u003e - If the type of the given remote address is not supported",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AlreadyConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eAlreadyConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is already connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ConnectionPendingException.html\" title\u003d\"class in java.nio.channels\"\u003eConnectionPendingException\u003c/a\u003e\u003c/code\u003e - If a connection operation is already in progress on this channel",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If a security manager has been installed and it does not permit access to the given remote endpoint"
        ],
        "return": [
          "A \n\u003ccode\u003eFuture\u003c/code\u003e object representing the pending result"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "dst",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "timeout",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.concurrent.TimeUnit",
            "type": "Class"
          },
          "name": "unit",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "A",
            "type": "Class"
          },
          "name": "attachment",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.CompletionHandler",
            "parameters": [
              {
                "name": "java.lang.Integer",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "name": "A",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "handler",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "read",
      "comment": "Reads a sequence of bytes from this channel into the given buffer. This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The handler parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream. If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown. Otherwise this method works in the same manner as the AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler) method.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - The type of the attachment"
        ],
        "param": [
          "\u003ccode\u003edst\u003c/code\u003e - The buffer into which bytes are to be transferred",
          "\u003ccode\u003etimeout\u003c/code\u003e - The maximum time for the I/O operation to complete",
          "\u003ccode\u003eunit\u003c/code\u003e - The time unit of the \n\u003ccode\u003etimeout\u003c/code\u003e argument",
          "\u003ccode\u003eattachment\u003c/code\u003e - The object to attach to the I/O operation; can be \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003ehandler\u003c/code\u003e - The handler for consuming the result"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the buffer is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ReadPendingException.html\" title\u003d\"class in java.nio.channels\"\u003eReadPendingException\u003c/a\u003e\u003c/code\u003e - If a read operation is already in progress on this channel",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group has terminated"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "dst",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "A",
            "type": "Class"
          },
          "name": "attachment",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.CompletionHandler",
            "parameters": [
              {
                "name": "java.lang.Integer",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "name": "A",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "handler",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "read",
      "comment": "Description copied from interface: AsynchronousByteChannel",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - The type of the attachment"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html#read(java.nio.ByteBuffer,A,java.nio.channels.CompletionHandler)\"\u003eread\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html\" title\u003d\"interface in java.nio.channels\"\u003eAsynchronousByteChannel\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003edst\u003c/code\u003e - The buffer into which bytes are to be transferred",
          "\u003ccode\u003eattachment\u003c/code\u003e - The object to attach to the I/O operation; can be \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003ehandler\u003c/code\u003e - The completion handler"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the buffer is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ReadPendingException.html\" title\u003d\"class in java.nio.channels\"\u003eReadPendingException\u003c/a\u003e\u003c/code\u003e - If the channel does not allow more than one read to be outstanding and a previous read has not completed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group has terminated"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.concurrent.Future",
        "parameters": [
          {
            "name": "java.lang.Integer",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "dst",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "read",
      "comment": "Description copied from interface: AsynchronousByteChannel",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html#read(java.nio.ByteBuffer)\"\u003eread\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html\" title\u003d\"interface in java.nio.channels\"\u003eAsynchronousByteChannel\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003edst\u003c/code\u003e - The buffer into which bytes are to be transferred"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the buffer is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ReadPendingException.html\" title\u003d\"class in java.nio.channels\"\u003eReadPendingException\u003c/a\u003e\u003c/code\u003e - If the channel does not allow more than one read to be outstanding and a previous read has not completed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected"
        ],
        "return": [
          "A Future representing the result of the operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "dsts",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "length",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "timeout",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.concurrent.TimeUnit",
            "type": "Class"
          },
          "name": "unit",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "A",
            "type": "Class"
          },
          "name": "attachment",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.CompletionHandler",
            "parameters": [
              {
                "name": "java.lang.Long",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "name": "A",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "handler",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "read",
      "comment": "Reads a sequence of bytes from this channel into a subsequence of the given buffers. This operation, sometimes called a scattering read, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The handler parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream. This method initiates a read of up to r bytes from this channel, where r is the total number of bytes remaining in the specified subsequence of the given buffer array, that is,  dsts[offset].remaining()\n     + dsts[offset+1].remaining()\n     + ... + dsts[offset+length-1].remaining() at the moment that the read is attempted. Suppose that a byte sequence of length n is read, where 0 \u003c n \u003c\u003d r. Up to the first dsts[offset].remaining() bytes of this sequence are transferred into buffer dsts[offset], up to the next dsts[offset+1].remaining() bytes are transferred into buffer dsts[offset+1], and so forth, until the entire byte sequence is transferred into the given buffers. As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer\u0027s limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - The type of the attachment"
        ],
        "param": [
          "\u003ccode\u003edsts\u003c/code\u003e - The buffers into which bytes are to be transferred",
          "\u003ccode\u003eoffset\u003c/code\u003e - The offset within the buffer array of the first buffer into which bytes are to be transferred; must be non-negative and no larger than \n\u003ccode\u003edsts.length\u003c/code\u003e",
          "\u003ccode\u003elength\u003c/code\u003e - The maximum number of buffers to be accessed; must be non-negative and no larger than \n\u003ccode\u003edsts.length - offset\u003c/code\u003e",
          "\u003ccode\u003etimeout\u003c/code\u003e - The maximum time for the I/O operation to complete",
          "\u003ccode\u003eunit\u003c/code\u003e - The time unit of the \n\u003ccode\u003etimeout\u003c/code\u003e argument",
          "\u003ccode\u003eattachment\u003c/code\u003e - The object to attach to the I/O operation; can be \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003ehandler\u003c/code\u003e - The handler for consuming the result"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If the pre-conditions for the \n\u003ccode\u003eoffset\u003c/code\u003e and \n\u003ccode\u003elength\u003c/code\u003e parameter aren\u0027t met",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the buffer is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ReadPendingException.html\" title\u003d\"class in java.nio.channels\"\u003eReadPendingException\u003c/a\u003e\u003c/code\u003e - If a read operation is already in progress on this channel",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group has terminated"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "src",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "timeout",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.concurrent.TimeUnit",
            "type": "Class"
          },
          "name": "unit",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "A",
            "type": "Class"
          },
          "name": "attachment",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.CompletionHandler",
            "parameters": [
              {
                "name": "java.lang.Integer",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "name": "A",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "handler",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "write",
      "comment": "Writes a sequence of bytes to this channel from the given buffer. This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The handler parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown. Otherwise this method works in the same manner as the AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler) method.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - The type of the attachment"
        ],
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - The buffer from which bytes are to be retrieved",
          "\u003ccode\u003etimeout\u003c/code\u003e - The maximum time for the I/O operation to complete",
          "\u003ccode\u003eunit\u003c/code\u003e - The time unit of the \n\u003ccode\u003etimeout\u003c/code\u003e argument",
          "\u003ccode\u003eattachment\u003c/code\u003e - The object to attach to the I/O operation; can be \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003ehandler\u003c/code\u003e - The handler for consuming the result"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/WritePendingException.html\" title\u003d\"class in java.nio.channels\"\u003eWritePendingException\u003c/a\u003e\u003c/code\u003e - If a write operation is already in progress on this channel",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group has terminated"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "src",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "A",
            "type": "Class"
          },
          "name": "attachment",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.CompletionHandler",
            "parameters": [
              {
                "name": "java.lang.Integer",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "name": "A",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "handler",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "write",
      "comment": "Description copied from interface: AsynchronousByteChannel",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - The type of the attachment"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html#write(java.nio.ByteBuffer,A,java.nio.channels.CompletionHandler)\"\u003ewrite\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html\" title\u003d\"interface in java.nio.channels\"\u003eAsynchronousByteChannel\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - The buffer from which bytes are to be retrieved",
          "\u003ccode\u003eattachment\u003c/code\u003e - The object to attach to the I/O operation; can be \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003ehandler\u003c/code\u003e - The completion handler object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/WritePendingException.html\" title\u003d\"class in java.nio.channels\"\u003eWritePendingException\u003c/a\u003e\u003c/code\u003e - If the channel does not allow more than one write to be outstanding and a previous write has not completed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group has terminated"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.concurrent.Future",
        "parameters": [
          {
            "name": "java.lang.Integer",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "src",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "write",
      "comment": "Description copied from interface: AsynchronousByteChannel",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html#write(java.nio.ByteBuffer)\"\u003ewrite\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/AsynchronousByteChannel.html\" title\u003d\"interface in java.nio.channels\"\u003eAsynchronousByteChannel\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - The buffer from which bytes are to be retrieved"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/WritePendingException.html\" title\u003d\"class in java.nio.channels\"\u003eWritePendingException\u003c/a\u003e\u003c/code\u003e - If the channel does not allow more than one write to be outstanding and a previous write has not completed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected"
        ],
        "return": [
          "A Future representing the result of the operation"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "srcs",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "length",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "long",
            "type": "Class"
          },
          "name": "timeout",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.util.concurrent.TimeUnit",
            "type": "Class"
          },
          "name": "unit",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "A",
            "type": "Class"
          },
          "name": "attachment",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.CompletionHandler",
            "parameters": [
              {
                "name": "java.lang.Long",
                "type": "Class"
              },
              {
                "lowerBounds": [
                  {
                    "name": "A",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "name": "handler",
          "varargs": false
        }
      ],
      "genericParameters": [
        {
          "name": "A",
          "type": "Variable"
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "write",
      "comment": "Writes a sequence of bytes to this channel from a subsequence of the given buffers. This operation, sometimes called a gathering write, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The handler parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. This method initiates a write of up to r bytes to this channel, where r is the total number of bytes remaining in the specified subsequence of the given buffer array, that is,  srcs[offset].remaining()\n     + srcs[offset+1].remaining()\n     + ... + srcs[offset+length-1].remaining() at the moment that the write is attempted. Suppose that a byte sequence of length n is written, where 0 \u003c n \u003c\u003d r. Up to the first srcs[offset].remaining() bytes of this sequence are written from buffer srcs[offset], up to the next srcs[offset+1].remaining() bytes are written from buffer srcs[offset+1], and so forth, until the entire byte sequence is written. As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer\u0027s limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.",
      "annotations": [],
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eA\u003c/code\u003e - The type of the attachment"
        ],
        "param": [
          "\u003ccode\u003esrcs\u003c/code\u003e - The buffers from which bytes are to be retrieved",
          "\u003ccode\u003eoffset\u003c/code\u003e - The offset within the buffer array of the first buffer from which bytes are to be retrieved; must be non-negative and no larger than \n\u003ccode\u003esrcs.length\u003c/code\u003e",
          "\u003ccode\u003elength\u003c/code\u003e - The maximum number of buffers to be accessed; must be non-negative and no larger than \n\u003ccode\u003esrcs.length - offset\u003c/code\u003e",
          "\u003ccode\u003etimeout\u003c/code\u003e - The maximum time for the I/O operation to complete",
          "\u003ccode\u003eunit\u003c/code\u003e - The time unit of the \n\u003ccode\u003etimeout\u003c/code\u003e argument",
          "\u003ccode\u003eattachment\u003c/code\u003e - The object to attach to the I/O operation; can be \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003ehandler\u003c/code\u003e - The handler for consuming the result"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If the pre-conditions for the \n\u003ccode\u003eoffset\u003c/code\u003e and \n\u003ccode\u003elength\u003c/code\u003e parameter aren\u0027t met",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/WritePendingException.html\" title\u003d\"class in java.nio.channels\"\u003eWritePendingException\u003c/a\u003e\u003c/code\u003e - If a write operation is already in progress on this channel",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NotYetConnectedException.html\" title\u003d\"class in java.nio.channels\"\u003eNotYetConnectedException\u003c/a\u003e\u003c/code\u003e - If this channel is not yet connected",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ShutdownChannelGroupException.html\" title\u003d\"class in java.nio.channels\"\u003eShutdownChannelGroupException\u003c/a\u003e\u003c/code\u003e - If the channel group has terminated"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.SocketAddress",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getLocalAddress",
      "comment": "Returns the socket address that this channel\u0027s socket is bound to. Where the channel is bound to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port of the channel\u0027s socket is returned.",
      "annotations": [],
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NetworkChannel.html#getLocalAddress()\"\u003egetLocalAddress\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/NetworkChannel.html\" title\u003d\"interface in java.nio.channels\"\u003eNetworkChannel\u003c/a\u003e\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ClosedChannelException.html\" title\u003d\"class in java.nio.channels\"\u003eClosedChannelException\u003c/a\u003e\u003c/code\u003e - If the channel is closed",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - If an I/O error occurs"
        ],
        "return": [
          "The \n\u003ccode\u003eSocketAddress\u003c/code\u003e that the socket is bound to, or the \n\u003ccode\u003eSocketAddress\u003c/code\u003e representing the loopback address if denied by the security manager, or \n\u003ccode\u003enull\u003c/code\u003e if the channel\u0027s socket is not bound"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.channels.spi.AsynchronousChannelProvider",
            "type": "Class"
          },
          "name": "provider",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Initializes a new instance of this class.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eprovider\u003c/code\u003e - The provider that created this channel"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.nio.channels.AsynchronousSocketChannel",
  "annotations": [],
  "tagMap": {
    "since": [
      "1.7"
    ]
  }
}