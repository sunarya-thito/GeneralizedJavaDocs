{
  "packageName": "java.net",
  "simpleName": "URI",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.net.URI",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "str"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "create",
      "comment": "Creates a URI by parsing the given string. This convenience factory method works as if by invoking the URI(String) constructor; any URISyntaxException thrown by the constructor is caught and wrapped in a new IllegalArgumentException object, which is then thrown. This method is provided for use in situations where it is known that the given string is a legal URI, for example for URI constants declared within a program, and so it would be considered a programming error for the string not to parse as such. The constructors, which throw URISyntaxException directly, should be used in situations where a URI is being constructed from user input or from some other source that may be prone to errors.",
      "tagMap": {
        "param": [
          "\u003ccode\u003estr\u003c/code\u003e - The string to be parsed into a URI"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003estr\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the given string violates RFC\u0026nbsp;2396"
        ],
        "return": [
          "The new URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.URI",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.net.URISyntaxException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parseServerAuthority",
      "comment": "Attempts to parse this URI\u0027s authority component, if defined, into user-information, host, and port components. If this URI\u0027s authority component has already been recognized as being server-based then it will already have been parsed into user-information, host, and port components. In this case, or if this URI has no authority component, this method simply returns this URI. Otherwise this method attempts once more to parse the authority component into user-information, host, and port components, and throws an exception describing why the authority component could not be parsed in that way. This method is provided because the generic URI syntax specified in RFC 2396 cannot always distinguish a malformed server-based authority from a legitimate registry-based authority. It must therefore treat some instances of the former as instances of the latter. The authority component in the URI string \"//foo:bar\", for example, is not a legal server-based authority but it is legal as a registry-based authority. In many common situations, for example when working URIs that are known to be either URNs or URLs, the hierarchical URIs being used will always be server-based. They therefore must either be parsed as such or treated as an error. In these cases a statement such as URI u \u003d new URI(str).parseServerAuthority(); can be used to ensure that u always refers to a URI that, if it has an authority component, has a server-based authority with proper user-information, host, and port components. Invoking this method also ensures that if the authority could not be parsed in that way then an appropriate diagnostic message can be issued based upon the exception that is thrown.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URISyntaxException.html\" title\u003d\"class in java.net\"\u003eURISyntaxException\u003c/a\u003e\u003c/code\u003e - If the authority component of this URI is defined but cannot be parsed as a server-based authority according to RFC\u0026nbsp;2396"
        ],
        "return": [
          "A URI whose authority field has been parsed as a server-based authority"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.URI",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "normalize",
      "comment": "Normalizes this URI\u0027s path. If this URI is opaque, or if its path is already in normal form, then this URI is returned. Otherwise a new URI is constructed that is identical to this URI except that its path is computed by normalizing this URI\u0027s path in a manner consistent with RFC 2396, section 5.2, step 6, sub-steps c through f; that is: All \".\" segments are removed. If a \"..\" segment is preceded by a non-\"..\" segment then both of these segments are removed. This step is repeated until it is no longer applicable. If the path is relative, and if its first segment contains a colon character (\u0027:\u0027), then a \".\" segment is prepended. This prevents a relative URI with a path such as \"a:b/c/d\" from later being re-parsed as an opaque URI with a scheme of \"a\" and a scheme-specific part of \"b/c/d\". (Deviation from RFC 2396) A normalized path will begin with one or more \"..\" segments if there were insufficient non-\"..\" segments preceding them to allow their removal. A normalized path will begin with a \".\" segment if one was inserted by step 3 above. Otherwise, a normalized path will not contain any \".\" or \"..\" segments.",
      "tagMap": {
        "return": [
          "A URI equivalent to this URI, but whose path is in normal form"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.URI",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.net.URI",
            "type": "Class"
          },
          "field": {
            "name": "uri"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "resolve",
      "comment": "Resolves the given URI against this URI. If the given URI is already absolute, or if this URI is opaque, then the given URI is returned. If the given URI\u0027s fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as \"#foo\", to be usefully resolved against a base URI. Otherwise this method constructs a new hierarchical URI in a manner consistent with RFC 2396, section 5.2; that is: A new URI is constructed with this URI\u0027s scheme and the given URI\u0027s query and fragment components. If the given URI has an authority component then the new URI\u0027s authority and path are taken from the given URI. Otherwise the new URI\u0027s authority component is copied from this URI, and its path is computed as follows: If the given URI\u0027s path is absolute then the new URI\u0027s path is taken from the given URI. Otherwise the given URI\u0027s path is relative, and so the new URI\u0027s path is computed by resolving the path of the given URI against the path of this URI. This is done by concatenating all but the last segment of this URI\u0027s path, if any, with the given URI\u0027s path and then normalizing the result as if by invoking the normalize method. The result of this method is absolute if, and only if, either this URI is absolute or the given URI is absolute.",
      "tagMap": {
        "param": [
          "\u003ccode\u003euri\u003c/code\u003e - The URI to be resolved against this URI"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003euri\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "The resulting URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.URI",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "str"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "resolve",
      "comment": "Constructs a new URI by parsing the given string and then resolving it against this URI. This convenience method works as if invoking it were equivalent to evaluating the expression resolve(URI.create(str)).",
      "tagMap": {
        "param": [
          "\u003ccode\u003estr\u003c/code\u003e - The string to be parsed into a URI"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003estr\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the given string violates RFC\u0026nbsp;2396"
        ],
        "return": [
          "The resulting URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.URI",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.net.URI",
            "type": "Class"
          },
          "field": {
            "name": "uri"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "relativize",
      "comment": "Relativizes the given URI against this URI. The relativization of the given URI against this URI is computed as follows: If either this URI or the given URI are opaque, or if the scheme and authority components of the two URIs are not identical, or if the path of this URI is not a prefix of the path of the given URI, then the given URI is returned. Otherwise a new relative hierarchical URI is constructed with query and fragment components taken from the given URI and with a path component computed by removing this URI\u0027s path from the beginning of the given URI\u0027s path.",
      "tagMap": {
        "param": [
          "\u003ccode\u003euri\u003c/code\u003e - The URI to be relativized against this URI"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003euri\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "The resulting URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.net.URL",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.net.MalformedURLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toURL",
      "comment": "Constructs a URL from this URI. This convenience method works as if invoking it were equivalent to evaluating the expression new URL(this.toString()) after first checking that this URI is absolute.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If this URL is not absolute",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/MalformedURLException.html\" title\u003d\"class in java.net\"\u003eMalformedURLException\u003c/a\u003e\u003c/code\u003e - If a protocol handler for the URL could not be found, or if some other error occurred while constructing the URL"
        ],
        "return": [
          "A URL constructed from this URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getScheme",
      "comment": "Returns the scheme component of this URI. The scheme component of a URI, if defined, only contains characters in the alphanum category and in the string \"-.+\". A scheme always starts with an alpha character. The scheme component of a URI cannot contain escaped octets, hence this method does not perform any decoding.",
      "tagMap": {
        "return": [
          "The scheme component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the scheme is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isAbsolute",
      "comment": "Tells whether or not this URI is absolute. A URI is absolute if, and only if, it has a scheme component.",
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, this URI is absolute"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isOpaque",
      "comment": "Tells whether or not this URI is opaque. A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character (\u0027/\u0027). An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined.",
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, this URI is opaque"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getRawSchemeSpecificPart",
      "comment": "Returns the raw scheme-specific part of this URI. The scheme-specific part is never undefined, though it may be empty. The scheme-specific part of a URI only contains legal URI characters.",
      "tagMap": {
        "return": [
          "The raw scheme-specific part of this URI (never \n\u003ccode\u003enull\u003c/code\u003e)"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getSchemeSpecificPart",
      "comment": "Returns the decoded scheme-specific part of this URI. The string returned by this method is equal to that returned by the getRawSchemeSpecificPart method except that all sequences of escaped octets are decoded.",
      "tagMap": {
        "return": [
          "The decoded scheme-specific part of this URI (never \n\u003ccode\u003enull\u003c/code\u003e)"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getRawAuthority",
      "comment": "Returns the raw authority component of this URI. The authority component of a URI, if defined, only contains the commercial-at character (\u0027@\u0027) and characters in the unreserved, punct, escaped, and other categories. If the authority is server-based then it is further constrained to have valid user-information, host, and port components.",
      "tagMap": {
        "return": [
          "The raw authority component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the authority is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getAuthority",
      "comment": "Returns the decoded authority component of this URI. The string returned by this method is equal to that returned by the getRawAuthority method except that all sequences of escaped octets are decoded.",
      "tagMap": {
        "return": [
          "The decoded authority component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the authority is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getRawUserInfo",
      "comment": "Returns the raw user-information component of this URI. The user-information component of a URI, if defined, only contains characters in the unreserved, punct, escaped, and other categories.",
      "tagMap": {
        "return": [
          "The raw user-information component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the user information is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getUserInfo",
      "comment": "Returns the decoded user-information component of this URI. The string returned by this method is equal to that returned by the getRawUserInfo method except that all sequences of escaped octets are decoded.",
      "tagMap": {
        "return": [
          "The decoded user-information component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the user information is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getHost",
      "comment": "Returns the host component of this URI. The host component of a URI, if defined, will have one of the following forms: A domain name consisting of one or more labels separated by period characters (\u0027.\u0027), optionally followed by a period character. Each label consists of alphanum characters as well as hyphen characters (\u0027-\u0027), though hyphens never occur as the first or last characters in a label. The rightmost label of a domain name consisting of two or more labels, begins with an alpha character. A dotted-quad IPv4 address of the form digit+.digit+.digit+.digit+, where no digit sequence is longer than three characters and no sequence has a value larger than 255. An IPv6 address enclosed in square brackets (\u0027[\u0027 and \u0027]\u0027) and consisting of hexadecimal digits, colon characters (\u0027:\u0027), and possibly an embedded IPv4 address. The full syntax of IPv6 addresses is specified in RFC 2373: IPv6 Addressing Architecture. The host component of a URI cannot contain escaped octets, hence this method does not perform any decoding.",
      "tagMap": {
        "return": [
          "The host component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the host is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPort",
      "comment": "Returns the port number of this URI. The port component of a URI, if defined, is a non-negative integer.",
      "tagMap": {
        "return": [
          "The port component of this URI, or \n\u003ccode\u003e-1\u003c/code\u003e if the port is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getRawPath",
      "comment": "Returns the raw path component of this URI. The path component of a URI, if defined, only contains the slash character (\u0027/\u0027), the commercial-at character (\u0027@\u0027), and characters in the unreserved, punct, escaped, and other categories.",
      "tagMap": {
        "return": [
          "The path component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the path is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPath",
      "comment": "Returns the decoded path component of this URI. The string returned by this method is equal to that returned by the getRawPath method except that all sequences of escaped octets are decoded.",
      "tagMap": {
        "return": [
          "The decoded path component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the path is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getRawQuery",
      "comment": "Returns the raw query component of this URI. The query component of a URI, if defined, only contains legal URI characters.",
      "tagMap": {
        "return": [
          "The raw query component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the query is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getQuery",
      "comment": "Returns the decoded query component of this URI. The string returned by this method is equal to that returned by the getRawQuery method except that all sequences of escaped octets are decoded.",
      "tagMap": {
        "return": [
          "The decoded query component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the query is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getRawFragment",
      "comment": "Returns the raw fragment component of this URI. The fragment component of a URI, if defined, only contains legal URI characters.",
      "tagMap": {
        "return": [
          "The raw fragment component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the fragment is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFragment",
      "comment": "Returns the decoded fragment component of this URI. The string returned by this method is equal to that returned by the getRawFragment method except that all sequences of escaped octets are decoded.",
      "tagMap": {
        "return": [
          "The decoded fragment component of this URI, or \n\u003ccode\u003enull\u003c/code\u003e if the fragment is undefined"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "ob"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "equals",
      "comment": "Tests this URI for equality with another object. If the given object is not a URI then this method immediately returns false. For two URIs to be considered equal requires that either both are opaque or both are hierarchical. Their schemes must either both be undefined or else be equal without regard to case. Their fragments must either both be undefined or else be equal. For two opaque URIs to be considered equal, their scheme-specific parts must be equal. For two hierarchical URIs to be considered equal, their paths must be equal and their queries must either both be undefined or else be equal. Their authorities must either both be undefined, or both be registry-based, or both be server-based. If their authorities are defined and are registry-based, then they must be equal. If their authorities are defined and are server-based, then their hosts must be equal without regard to case, their port numbers must be equal, and their user-information components must be equal. When testing the user-information, path, query, fragment, authority, or scheme-specific parts of two URIs for equality, the raw forms rather than the encoded forms of these components are compared and the hexadecimal digits of escaped octets are compared without regard to case. This method satisfies the general contract of the Object.equals method.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/HashMap.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eHashMap\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eob\u003c/code\u003e - The object to which this object is to be compared"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if, and only if, the given object is a URI that is identical to this URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hashCode",
      "comment": "Returns a hash-code value for this URI. The hash code is based upon all of the URI\u0027s components, and satisfies the general contract of the Object.hashCode method.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#identityHashCode(java.lang.Object)\"\u003e\u003ccode\u003eSystem.identityHashCode(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "A hash-code value for this URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.net.URI",
            "type": "Class"
          },
          "field": {
            "name": "that"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "compareTo",
      "comment": "Compares this URI to another object, which must be a URI. When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the String.compareTo method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms and the hexadecimal digits of escaped octets are compared without regard to case. The ordering of URIs is defined as follows: Two URIs with different schemes are ordered according the ordering of their schemes, without regard to case. A hierarchical URI is considered to be less than an opaque URI with an identical scheme. Two opaque URIs with identical schemes are ordered according to the ordering of their scheme-specific parts. Two opaque URIs with identical schemes and scheme-specific parts are ordered according to the ordering of their fragments. Two hierarchical URIs with identical schemes are ordered according to the ordering of their authority components: If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports. If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components. Finally, two hierarchical URIs with identical schemes and authority components are ordered according to the ordering of their paths; if their paths are identical then they are ordered according to the ordering of their queries; if the queries are identical then they are ordered according to the order of their fragments. This method satisfies the general contract of the Comparable.compareTo method.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html#compareTo(T)\"\u003ecompareTo\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003eComparable\u003c/a\u003e\u0026lt;\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URI.html\" title\u003d\"class in java.net\"\u003eURI\u003c/a\u003e\u0026gt;\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003ethat\u003c/code\u003e - The object to which this URI is to be compared"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - If the given object is not a URI"
        ],
        "return": [
          "A negative integer, zero, or a positive integer as this URI is less than, equal to, or greater than the given URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns the content of this URI as a string. If this URI was created by invoking one of the constructors in this class then a string equivalent to the original input string, or to the string computed from the originally-given components, as appropriate, is returned. Otherwise this URI was created by normalization, resolution, or relativization, and so a string is constructed from this URI\u0027s components according to the rules specified in RFC 2396, section 5.2, step 7.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "The string form of this URI"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toASCIIString",
      "comment": "Returns the content of this URI as a US-ASCII string. If this URI does not contain any characters in the other category then an invocation of this method will return the same value as an invocation of the toString method. Otherwise this method works as if by invoking that method and then encoding the result.",
      "tagMap": {
        "return": [
          "The string form of this URI, encoded as needed so that it only contains characters in the US-ASCII charset"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.net.URISyntaxException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "str"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a URI by parsing the given string. This constructor parses the given string exactly as specified by the grammar in RFC 2396, Appendix A, except for the following deviations: An empty authority component is permitted as long as it is followed by a non-empty path, a query component, or a fragment component. This allows the parsing of URIs such as \"file:///foo/bar\", which seems to be the intent of RFC 2396 although the grammar does not permit it. If the authority component is empty then the user-information, host, and port components are undefined. Empty relative paths are permitted; this seems to be the intent of RFC 2396 although the grammar does not permit it. The primary consequence of this deviation is that a standalone fragment such as \"#foo\" parses as a relative URI with an empty path and the given fragment, and can be usefully resolved against a base URI. IPv4 addresses in host components are parsed rigorously, as specified by RFC 2732: Each element of a dotted-quad address must contain no more than three decimal digits. Each element is further constrained to have a value no greater than 255. Hostnames in host components that comprise only a single domain label are permitted to start with an alphanum character. This seems to be the intent of RFC 2396 section 3.2.2 although the grammar does not permit it. The consequence of this deviation is that the authority component of a hierarchical URI such as s://123, will parse as a server-based authority. IPv6 addresses are permitted for the host component. An IPv6 address must be enclosed in square brackets (\u0027[\u0027 and \u0027]\u0027) as specified by RFC 2732. The IPv6 address itself must parse according to RFC 2373. IPv6 addresses are further constrained to describe no more than sixteen bytes of address information, a constraint implicit in RFC 2373 but not expressible in the grammar. Characters in the other category are permitted wherever RFC 2396 permits escaped octets, that is, in the user-information, path, query, and fragment components, as well as in the authority component if the authority is registry-based. This allows URIs to contain Unicode characters beyond those in the US-ASCII character set.",
      "tagMap": {
        "param": [
          "\u003ccode\u003estr\u003c/code\u003e - The string to be parsed into a URI"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003estr\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URISyntaxException.html\" title\u003d\"class in java.net\"\u003eURISyntaxException\u003c/a\u003e\u003c/code\u003e - If the given string violates RFC\u0026nbsp;2396, as augmented by the above deviations"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.net.URISyntaxException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "scheme"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "userInfo"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "host"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "port"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "path"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "query"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "fragment"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a hierarchical URI from the given components. If a scheme is given then the path, if also given, must either be empty or begin with a slash character (\u0027/\u0027). Otherwise a component of the new URI may be left undefined by passing null for the corresponding parameter or, in the case of the port parameter, by passing -1. This constructor first builds a URI string from the given components according to the rules specified in RFC 2396, section 5.2, step 7: Initially, the result string is empty. If a scheme is given then it is appended to the result, followed by a colon character (\u0027:\u0027). If user information, a host, or a port are given then the string \"//\" is appended. If user information is given then it is appended, followed by a commercial-at character (\u0027@\u0027). Any character not in the unreserved, punct, escaped, or other categories is quoted. If a host is given then it is appended. If the host is a literal IPv6 address but is not enclosed in square brackets (\u0027[\u0027 and \u0027]\u0027) then the square brackets are added. If a port number is given then a colon character (\u0027:\u0027) is appended, followed by the port number in decimal. If a path is given then it is appended. Any character not in the unreserved, punct, escaped, or other categories, and not equal to the slash character (\u0027/\u0027) or the commercial-at character (\u0027@\u0027), is quoted. If a query is given then a question-mark character (\u0027?\u0027) is appended, followed by the query. Any character that is not a legal URI character is quoted. Finally, if a fragment is given then a hash character (\u0027#\u0027) is appended, followed by the fragment. Any character that is not a legal URI character is quoted. The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003escheme\u003c/code\u003e - Scheme name",
          "\u003ccode\u003euserInfo\u003c/code\u003e - User name and authorization information",
          "\u003ccode\u003ehost\u003c/code\u003e - Host name",
          "\u003ccode\u003eport\u003c/code\u003e - Port number",
          "\u003ccode\u003epath\u003c/code\u003e - Path",
          "\u003ccode\u003equery\u003c/code\u003e - Query",
          "\u003ccode\u003efragment\u003c/code\u003e - Fragment"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URISyntaxException.html\" title\u003d\"class in java.net\"\u003eURISyntaxException\u003c/a\u003e\u003c/code\u003e - If both a scheme and a path are given but the path is relative, if the URI string constructed from the given components violates RFC\u0026nbsp;2396, or if the authority component of the string is present but cannot be parsed as a server-based authority"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.net.URISyntaxException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "scheme"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "authority"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "path"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "query"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "fragment"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a hierarchical URI from the given components. If a scheme is given then the path, if also given, must either be empty or begin with a slash character (\u0027/\u0027). Otherwise a component of the new URI may be left undefined by passing null for the corresponding parameter. This constructor first builds a URI string from the given components according to the rules specified in RFC 2396, section 5.2, step 7: Initially, the result string is empty. If a scheme is given then it is appended to the result, followed by a colon character (\u0027:\u0027). If an authority is given then the string \"//\" is appended, followed by the authority. If the authority contains a literal IPv6 address then the address must be enclosed in square brackets (\u0027[\u0027 and \u0027]\u0027). Any character not in the unreserved, punct, escaped, or other categories, and not equal to the commercial-at character (\u0027@\u0027), is quoted. If a path is given then it is appended. Any character not in the unreserved, punct, escaped, or other categories, and not equal to the slash character (\u0027/\u0027) or the commercial-at character (\u0027@\u0027), is quoted. If a query is given then a question-mark character (\u0027?\u0027) is appended, followed by the query. Any character that is not a legal URI character is quoted. Finally, if a fragment is given then a hash character (\u0027#\u0027) is appended, followed by the fragment. Any character that is not a legal URI character is quoted. The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003escheme\u003c/code\u003e - Scheme name",
          "\u003ccode\u003eauthority\u003c/code\u003e - Authority",
          "\u003ccode\u003epath\u003c/code\u003e - Path",
          "\u003ccode\u003equery\u003c/code\u003e - Query",
          "\u003ccode\u003efragment\u003c/code\u003e - Fragment"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URISyntaxException.html\" title\u003d\"class in java.net\"\u003eURISyntaxException\u003c/a\u003e\u003c/code\u003e - If both a scheme and a path are given but the path is relative, if the URI string constructed from the given components violates RFC\u0026nbsp;2396, or if the authority component of the string is present but cannot be parsed as a server-based authority"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.net.URISyntaxException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "scheme"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "host"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "path"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "fragment"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a hierarchical URI from the given components. A component may be left undefined by passing null. This convenience constructor works as if by invoking the seven-argument constructor as follows: new URI(scheme, null, host, -1, path, null, fragment);",
      "tagMap": {
        "param": [
          "\u003ccode\u003escheme\u003c/code\u003e - Scheme name",
          "\u003ccode\u003ehost\u003c/code\u003e - Host name",
          "\u003ccode\u003epath\u003c/code\u003e - Path",
          "\u003ccode\u003efragment\u003c/code\u003e - Fragment"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URISyntaxException.html\" title\u003d\"class in java.net\"\u003eURISyntaxException\u003c/a\u003e\u003c/code\u003e - If the URI string constructed from the given components violates RFC\u0026nbsp;2396"
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.net.URISyntaxException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "scheme"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "ssp"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "fragment"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a URI from the given components. A component may be left undefined by passing null. This constructor first builds a URI in string form using the given components as follows: Initially, the result string is empty. If a scheme is given then it is appended to the result, followed by a colon character (\u0027:\u0027). If a scheme-specific part is given then it is appended. Any character that is not a legal URI character is quoted. Finally, if a fragment is given then a hash character (\u0027#\u0027) is appended to the string, followed by the fragment. Any character that is not a legal URI character is quoted. The resulting URI string is then parsed in order to create the new URI instance as if by invoking the URI(String) constructor; this may cause a URISyntaxException to be thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003escheme\u003c/code\u003e - Scheme name",
          "\u003ccode\u003essp\u003c/code\u003e - Scheme-specific part",
          "\u003ccode\u003efragment\u003c/code\u003e - Fragment"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URISyntaxException.html\" title\u003d\"class in java.net\"\u003eURISyntaxException\u003c/a\u003e\u003c/code\u003e - If the URI string constructed from the given components violates RFC\u0026nbsp;2396"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.net.URI",
  "comment": "Represents a Uniform Resource Identifier (URI) reference. \n\u003cp\u003e Aside from some minor deviations noted below, an instance of this class represents a URI reference as defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2396.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2396: Uniform Resource Identifiers (URI): Generic Syntax\u003c/i\u003e\u003c/a\u003e, amended by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2732.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2732: Format for Literal IPv6 Addresses in URLs\u003c/i\u003e\u003c/a\u003e. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described \u003ca href\u003d\"Inet6Address.html#scoped\"\u003ehere\u003c/a\u003e. This class provides constructors for creating URI instances from their components or by parsing their string forms, methods for accessing the various components of an instance, and methods for normalizing, resolving, and relativizing URI instances. Instances of this class are immutable. \u003c/p\u003e\n\u003ch2\u003e URI syntax and components \u003c/h2\u003e At the highest level a URI reference (hereinafter simply \"URI\") in string form has the syntax \n\u003cblockquote\u003e\n  [\n \u003ci\u003escheme\u003c/i\u003e\n \u003cb\u003e\u003ccode\u003e:\u003c/code\u003e\u003c/b\u003e]\n \u003ci\u003escheme-specific-part\u003c/i\u003e[\n \u003cb\u003e\u003ccode\u003e#\u003c/code\u003e\u003c/b\u003e\n \u003ci\u003efragment\u003c/i\u003e] \n\u003c/blockquote\u003e where square brackets [...] delineate optional components and the characters \n\u003cb\u003e\u003ccode\u003e:\u003c/code\u003e\u003c/b\u003e and \n\u003cb\u003e\u003ccode\u003e#\u003c/code\u003e\u003c/b\u003e stand for themselves. \n\u003cp\u003e An \u003ci\u003eabsolute\u003c/i\u003e URI specifies a scheme; a URI that is not absolute is said to be \u003ci\u003erelative\u003c/i\u003e. URIs are also classified according to whether they are \u003ci\u003eopaque\u003c/i\u003e or \u003ci\u003ehierarchical\u003c/i\u003e. \u003c/p\u003e\n\u003cp\u003e An \u003ci\u003eopaque\u003c/i\u003e URI is an absolute URI whose scheme-specific part does not begin with a slash character (\u003ccode\u003e\u0027/\u0027\u003c/code\u003e). Opaque URIs are not subject to further parsing. Some examples of opaque URIs are: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cul style\u003d\"list-style-type:none\"\u003e \n  \u003cli\u003e\u003ccode\u003emailto:java-net@www.example.com\u003c/code\u003e\u003c/li\u003e \n  \u003cli\u003e\u003ccode\u003enews:comp.lang.java\u003c/code\u003e\u003c/li\u003e \n  \u003cli\u003e\u003ccode\u003eurn:isbn:096139210x\u003c/code\u003e\u003c/li\u003e \n \u003c/ul\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e A \u003ci\u003ehierarchical\u003c/i\u003e URI is either an absolute URI whose scheme-specific part begins with a slash character, or a relative URI, that is, a URI that does not specify a scheme. Some examples of hierarchical URIs are: \u003c/p\u003e\n\u003cblockquote\u003e \n \u003ccode\u003ehttp://example.com/languages/java/\u003c/code\u003e\n \u003cbr\u003e \n \u003ccode\u003esample/a/index.html#28\u003c/code\u003e\n \u003cbr\u003e \n \u003ccode\u003e../../demo/b/index.html\u003c/code\u003e\n \u003cbr\u003e \n \u003ccode\u003efile:///~/calendar\u003c/code\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e A hierarchical URI is subject to further parsing according to the syntax \u003c/p\u003e\n\u003cblockquote\u003e\n  [\n \u003ci\u003escheme\u003c/i\u003e\n \u003cb\u003e\u003ccode\u003e:\u003c/code\u003e\u003c/b\u003e][\n \u003cb\u003e\u003ccode\u003e//\u003c/code\u003e\u003c/b\u003e\n \u003ci\u003eauthority\u003c/i\u003e][\n \u003ci\u003epath\u003c/i\u003e][\n \u003cb\u003e\u003ccode\u003e?\u003c/code\u003e\u003c/b\u003e\n \u003ci\u003equery\u003c/i\u003e][\n \u003cb\u003e\u003ccode\u003e#\u003c/code\u003e\u003c/b\u003e\n \u003ci\u003efragment\u003c/i\u003e] \n\u003c/blockquote\u003e where the characters \n\u003cb\u003e\u003ccode\u003e:\u003c/code\u003e\u003c/b\u003e, \n\u003cb\u003e\u003ccode\u003e/\u003c/code\u003e\u003c/b\u003e, \n\u003cb\u003e\u003ccode\u003e?\u003c/code\u003e\u003c/b\u003e, and \n\u003cb\u003e\u003ccode\u003e#\u003c/code\u003e\u003c/b\u003e stand for themselves. The scheme-specific part of a hierarchical URI consists of the characters between the scheme and fragment components. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The authority component of a hierarchical URI is, if specified, either \u003ci\u003eserver-based\u003c/i\u003e or \u003ci\u003eregistry-based\u003c/i\u003e. A server-based authority parses according to the familiar syntax \u003c/p\u003e\n\u003cblockquote\u003e\n  [\n \u003ci\u003euser-info\u003c/i\u003e\n \u003cb\u003e\u003ccode\u003e@\u003c/code\u003e\u003c/b\u003e]\n \u003ci\u003ehost\u003c/i\u003e[\n \u003cb\u003e\u003ccode\u003e:\u003c/code\u003e\u003c/b\u003e\n \u003ci\u003eport\u003c/i\u003e] \n\u003c/blockquote\u003e where the characters \n\u003cb\u003e\u003ccode\u003e@\u003c/code\u003e\u003c/b\u003e and \n\u003cb\u003e\u003ccode\u003e:\u003c/code\u003e\u003c/b\u003e stand for themselves. Nearly all URI schemes currently in use are server-based. An authority component that does not parse in this way is considered to be registry-based. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The path component of a hierarchical URI is itself said to be absolute if it begins with a slash character (\u003ccode\u003e\u0027/\u0027\u003c/code\u003e); otherwise it is relative. The path of a hierarchical URI that is either absolute or specifies an authority is always absolute. \u003c/p\u003e\n\u003cp\u003e All told, then, a URI instance has the following nine components: \u003c/p\u003e\n\u003ctable class\u003d\"striped\" style\u003d\"margin-left:2em\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n  Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"col\"\u003eComponent\u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003eType\u003c/th\u003e\n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody style\u003d\"text-align:left\"\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003escheme\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003escheme-specific-part\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eauthority\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003euser-info\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003ehost\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003eport\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003epath\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003equery\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\"\u003efragment\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e In a given instance any particular component is either \n\u003ci\u003eundefined\u003c/i\u003e or \n\u003ci\u003edefined\u003c/i\u003e with a distinct value. Undefined string components are represented by \n\u003ccode\u003enull\u003c/code\u003e, while undefined integer components are represented by \n\u003ccode\u003e-1\u003c/code\u003e. A string component may be defined to have the empty string as its value; this is not equivalent to that component being undefined. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Whether a particular component is or is not defined in an instance depends upon the type of the URI being represented. An absolute URI has a scheme component. An opaque URI has a scheme, a scheme-specific part, and possibly a fragment, but has no other components. A hierarchical URI always has a path (though it may be empty) and a scheme-specific-part (which at least contains the path), and may have any of the other components. If the authority component is present and is server-based then the host component will be defined and the user-information and port components may be defined. \u003c/p\u003e\n\u003ch3\u003e Operations on URI instances \u003c/h3\u003e The key operations supported by this class are those of \n\u003ci\u003enormalization\u003c/i\u003e, \n\u003ci\u003eresolution\u003c/i\u003e, and \n\u003ci\u003erelativization\u003c/i\u003e. \n\u003cp\u003e \u003ci\u003eNormalization\u003c/i\u003e is the process of removing unnecessary \u003ccode\u003e\".\"\u003c/code\u003e and \u003ccode\u003e\"..\"\u003c/code\u003e segments from the path component of a hierarchical URI. Each \u003ccode\u003e\".\"\u003c/code\u003e segment is simply removed. A \u003ccode\u003e\"..\"\u003c/code\u003e segment is removed only if it is preceded by a non-\u003ccode\u003e\"..\"\u003c/code\u003e segment. Normalization has no effect upon opaque URIs. \u003c/p\u003e\n\u003cp\u003e \u003ci\u003eResolution\u003c/i\u003e is the process of resolving one URI against another, \u003ci\u003ebase\u003c/i\u003e URI. The resulting URI is constructed from components of both URIs in the manner specified by RFC\u0026nbsp;2396, taking components from the base URI for those not specified in the original. For hierarchical URIs, the path of the original is resolved against the path of the base and then normalized. The result, for example, of resolving \u003c/p\u003e\n\u003cblockquote\u003e \n \u003ccode\u003esample/a/index.html#28\u003c/code\u003e \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(1) \n\u003c/blockquote\u003e against the base URI \n\u003ccode\u003ehttp://example.com/languages/java/\u003c/code\u003e is the result URI \n\u003cblockquote\u003e \n \u003ccode\u003ehttp://example.com/languages/java/sample/a/index.html#28\u003c/code\u003e \n\u003c/blockquote\u003e Resolving the relative URI \n\u003cblockquote\u003e \n \u003ccode\u003e../../demo/b/index.html\u003c/code\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(2) \n\u003c/blockquote\u003e against this result yields, in turn, \n\u003cblockquote\u003e \n \u003ccode\u003ehttp://example.com/languages/java/demo/b/index.html\u003c/code\u003e \n\u003c/blockquote\u003e Resolution of both absolute and relative URIs, and of both absolute and relative paths in the case of hierarchical URIs, is supported. Resolving the URI \n\u003ccode\u003efile:///~calendar\u003c/code\u003e against any other URI simply yields the original URI, since it is absolute. Resolving the relative URI (2) above against the relative base URI (1) yields the normalized, but still relative, URI \n\u003cblockquote\u003e \n \u003ccode\u003edemo/b/index.html\u003c/code\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003ci\u003eRelativization\u003c/i\u003e, finally, is the inverse of resolution: For any two normalized URIs \u003ci\u003eu\u003c/i\u003e and\u0026nbsp;\u003ci\u003ev\u003c/i\u003e, \u003c/p\u003e\n\u003cblockquote\u003e \n \u003ci\u003eu\u003c/i\u003e\n \u003ccode\u003e.relativize(\u003c/code\u003e\n \u003ci\u003eu\u003c/i\u003e\n \u003ccode\u003e.resolve(\u003c/code\u003e\n \u003ci\u003ev\u003c/i\u003e\n \u003ccode\u003e)).equals(\u003c/code\u003e\n \u003ci\u003ev\u003c/i\u003e\n \u003ccode\u003e)\u003c/code\u003e\u0026nbsp;\u0026nbsp;and\n \u003cbr\u003e \n \u003ci\u003eu\u003c/i\u003e\n \u003ccode\u003e.resolve(\u003c/code\u003e\n \u003ci\u003eu\u003c/i\u003e\n \u003ccode\u003e.relativize(\u003c/code\u003e\n \u003ci\u003ev\u003c/i\u003e\n \u003ccode\u003e)).equals(\u003c/code\u003e\n \u003ci\u003ev\u003c/i\u003e\n \u003ccode\u003e)\u003c/code\u003e\u0026nbsp;\u0026nbsp;.\n \u003cbr\u003e \n\u003c/blockquote\u003e This operation is often useful when constructing a document containing URIs that must be made relative to the base URI of the document wherever possible. For example, relativizing the URI \n\u003cblockquote\u003e \n \u003ccode\u003ehttp://example.com/languages/java/sample/a/index.html#28\u003c/code\u003e \n\u003c/blockquote\u003e against the base URI \n\u003cblockquote\u003e \n \u003ccode\u003ehttp://example.com/languages/java/\u003c/code\u003e \n\u003c/blockquote\u003e yields the relative URI \n\u003ccode\u003esample/a/index.html#28\u003c/code\u003e. \n\u003cp\u003e\u003c/p\u003e\n\u003ch3\u003e Character categories \u003c/h3\u003e RFC\u0026nbsp;2396 specifies precisely which characters are permitted in the various components of a URI reference. The following categories, most of which are taken from that specification, are used below to describe these constraints: \n\u003ctable class\u003d\"striped\" style\u003d\"margin-left:2em\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n  Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"col\"\u003eCategory\u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody style\u003d\"text-align:left\"\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003ealpha\u003c/th\u003e \n   \u003ctd\u003eThe US-ASCII alphabetic characters, \u003ccode\u003e\u0027A\u0027\u003c/code\u003e\u0026nbsp;through\u0026nbsp;\u003ccode\u003e\u0027Z\u0027\u003c/code\u003e and \u003ccode\u003e\u0027a\u0027\u003c/code\u003e\u0026nbsp;through\u0026nbsp;\u003ccode\u003e\u0027z\u0027\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003edigit\u003c/th\u003e \n   \u003ctd\u003eThe US-ASCII decimal digit characters, \u003ccode\u003e\u00270\u0027\u003c/code\u003e\u0026nbsp;through\u0026nbsp;\u003ccode\u003e\u00279\u0027\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003ealphanum\u003c/th\u003e \n   \u003ctd\u003eAll \u003ci\u003ealpha\u003c/i\u003e and \u003ci\u003edigit\u003c/i\u003e characters\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003eunreserved\u003c/th\u003e \n   \u003ctd\u003eAll \u003ci\u003ealphanum\u003c/i\u003e characters together with those in the string \u003ccode\u003e\"_-!.~\u0027()*\"\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003epunct\u003c/th\u003e \n   \u003ctd\u003eThe characters in the string \u003ccode\u003e\",;:$\u0026amp;+\u003d\"\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003ereserved\u003c/th\u003e \n   \u003ctd\u003eAll \u003ci\u003epunct\u003c/i\u003e characters together with those in the string \u003ccode\u003e\"?/[]@\"\u003c/code\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003eescaped\u003c/th\u003e \n   \u003ctd\u003eEscaped octets, that is, triplets consisting of the percent character (\u003ccode\u003e\u0027%\u0027\u003c/code\u003e) followed by two hexadecimal digits (\u003ccode\u003e\u00270\u0027\u003c/code\u003e-\u003ccode\u003e\u00279\u0027\u003c/code\u003e, \u003ccode\u003e\u0027A\u0027\u003c/code\u003e-\u003ccode\u003e\u0027F\u0027\u003c/code\u003e, and \u003ccode\u003e\u0027a\u0027\u003c/code\u003e-\u003ccode\u003e\u0027f\u0027\u003c/code\u003e)\u003c/td\u003e\n  \u003c/tr\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"row\" style\u003d\"vertical-align:top\"\u003eother\u003c/th\u003e \n   \u003ctd\u003eThe Unicode characters that are not in the US-ASCII character set, are not control characters (according to the \u003ca href\u003d\"../lang/Character.html#isISOControl(int)\"\u003e\u003ccode\u003eCharacter.isISOControl\u003c/code\u003e\u003c/a\u003e method), and are not space characters (according to the \u003ca href\u003d\"../lang/Character.html#isSpaceChar(int)\"\u003e\u003ccode\u003eCharacter.isSpaceChar\u003c/code\u003e\u003c/a\u003e method)\u0026nbsp;\u0026nbsp;\u003ci\u003e(\u003cb\u003eDeviation from RFC 2396\u003c/b\u003e, which is limited to US-ASCII)\u003c/i\u003e\u003c/td\u003e\n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003e\u003ca id\u003d\"legal-chars\"\u003e\u003c/a\u003e The set of all legal URI characters consists of the \u003ci\u003eunreserved\u003c/i\u003e, \u003ci\u003ereserved\u003c/i\u003e, \u003ci\u003eescaped\u003c/i\u003e, and \u003ci\u003eother\u003c/i\u003e characters. \u003c/p\u003e\n\u003ch3\u003e Escaped octets, quotation, encoding, and decoding \u003c/h3\u003e RFC 2396 allows escaped octets to appear in the user-info, path, query, and fragment components. Escaping serves two purposes in URIs: \n\u003cul\u003e \n \u003cli\u003e\u003cp\u003e To \u003ci\u003eencode\u003c/i\u003e non-US-ASCII characters when a URI is required to conform strictly to RFC\u0026nbsp;2396 by not containing any \u003ci\u003eother\u003c/i\u003e characters. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e To \u003ci\u003equote\u003c/i\u003e characters that are otherwise illegal in a component. The user-info, path, query, and fragment components differ slightly in terms of which characters are considered legal and illegal. \u003c/p\u003e\u003c/li\u003e \n\u003c/ul\u003e These purposes are served in this class by three related operations: \n\u003cul\u003e \n \u003cli\u003e\u003cp\u003e\u003ca id\u003d\"encode\"\u003e\u003c/a\u003e A character is \u003ci\u003eencoded\u003c/i\u003e by replacing it with the sequence of escaped octets that represent that character in the UTF-8 character set. The Euro currency symbol (\u003ccode\u003e\u0027\\u20AC\u0027\u003c/code\u003e), for example, is encoded as \u003ccode\u003e\"%E2%82%AC\"\u003c/code\u003e. \u003ci\u003e(\u003cb\u003eDeviation from RFC\u0026nbsp;2396\u003c/b\u003e, which does not specify any particular character set.)\u003c/i\u003e \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e\u003ca id\u003d\"quote\"\u003e\u003c/a\u003e An illegal character is \u003ci\u003equoted\u003c/i\u003e simply by encoding it. The space character, for example, is quoted by replacing it with \u003ccode\u003e\"%20\"\u003c/code\u003e. UTF-8 contains US-ASCII, hence for US-ASCII characters this transformation has exactly the effect required by RFC\u0026nbsp;2396. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e\u003ca id\u003d\"decode\"\u003e\u003c/a\u003e A sequence of escaped octets is \u003ci\u003edecoded\u003c/i\u003e by replacing it with the sequence of characters that it represents in the UTF-8 character set. UTF-8 contains US-ASCII, hence decoding has the effect of de-quoting any quoted US-ASCII characters as well as that of decoding any encoded non-US-ASCII characters. If a \u003ca href\u003d\"../nio/charset/CharsetDecoder.html#ce\"\u003edecoding error\u003c/a\u003e occurs when decoding the escaped octets then the erroneous octets are replaced by \u003ccode\u003e\u0027\\uFFFD\u0027\u003c/code\u003e, the Unicode replacement character. \u003c/p\u003e\u003c/li\u003e \n\u003c/ul\u003e These operations are exposed in the constructors and methods of this class as follows: \n\u003cul\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#%3Cinit%3E(java.lang.String)\"\u003esingle-argument constructor\u003c/a\u003e requires any illegal characters in its argument to be quoted and preserves any escaped octets and \u003ci\u003eother\u003c/i\u003e characters that are present. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)\"\u003emulti-argument constructors\u003c/a\u003e quote illegal characters as required by the components in which they appear. The percent character (\u003ccode\u003e\u0027%\u0027\u003c/code\u003e) is always quoted by these constructors. Any \u003ci\u003eother\u003c/i\u003e characters are preserved. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#getRawUserInfo()\"\u003e\u003ccode\u003egetRawUserInfo\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getRawPath()\"\u003e\u003ccode\u003egetRawPath\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getRawQuery()\"\u003e\u003ccode\u003egetRawQuery\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getRawFragment()\"\u003e\u003ccode\u003egetRawFragment\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getRawAuthority()\"\u003e\u003ccode\u003egetRawAuthority\u003c/code\u003e\u003c/a\u003e, and \u003ca href\u003d\"#getRawSchemeSpecificPart()\"\u003e\u003ccode\u003egetRawSchemeSpecificPart\u003c/code\u003e\u003c/a\u003e methods return the values of their corresponding components in raw form, without interpreting any escaped octets. The strings returned by these methods may contain both escaped octets and \u003ci\u003eother\u003c/i\u003e characters, and will not contain any illegal characters. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#getUserInfo()\"\u003e\u003ccode\u003egetUserInfo\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getPath()\"\u003e\u003ccode\u003egetPath\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getQuery()\"\u003e\u003ccode\u003egetQuery\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getFragment()\"\u003e\u003ccode\u003egetFragment\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAuthority()\"\u003e\u003ccode\u003egetAuthority\u003c/code\u003e\u003c/a\u003e, and \u003ca href\u003d\"#getSchemeSpecificPart()\"\u003e\u003ccode\u003egetSchemeSpecificPart\u003c/code\u003e\u003c/a\u003e methods decode any escaped octets in their corresponding components. The strings returned by these methods may contain both \u003ci\u003eother\u003c/i\u003e characters and illegal characters, and will not contain any escaped octets. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#toString()\"\u003e\u003ccode\u003etoString\u003c/code\u003e\u003c/a\u003e method returns a URI string with all necessary quotation but which may contain \u003ci\u003eother\u003c/i\u003e characters. \u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003e The \u003ca href\u003d\"#toASCIIString()\"\u003e\u003ccode\u003etoASCIIString\u003c/code\u003e\u003c/a\u003e method returns a fully quoted and encoded URI string that does not contain any \u003ci\u003eother\u003c/i\u003e characters. \u003c/p\u003e\u003c/li\u003e \n\u003c/ul\u003e \n\u003ch3\u003e Identities \u003c/h3\u003e For any URI \n\u003ci\u003eu\u003c/i\u003e, it is always the case that \n\u003cblockquote\u003e \n \u003ccode\u003enew URI(\u003c/code\u003e\n \u003ci\u003eu\u003c/i\u003e\n \u003ccode\u003e.toString()).equals(\u003c/code\u003e\n \u003ci\u003eu\u003c/i\u003e\n \u003ccode\u003e)\u003c/code\u003e\u0026nbsp;. \n\u003c/blockquote\u003e For any URI \n\u003ci\u003eu\u003c/i\u003e that does not contain redundant syntax such as two slashes before an empty authority (as in \n\u003ccode\u003efile:///tmp/\u003c/code\u003e\u0026nbsp;) or a colon following a host name but no port (as in \n\u003ccode\u003ehttp://www.example.com:\u003c/code\u003e\u0026nbsp;), and that does not encode characters except those that must be quoted, the following identities also hold: \n\u003cpre\u003e     new URI(\u003ci\u003eu\u003c/i\u003e.getScheme(),\n             \u003ci\u003eu\u003c/i\u003e.getSchemeSpecificPart(),\n             \u003ci\u003eu\u003c/i\u003e.getFragment())\n     .equals(\u003ci\u003eu\u003c/i\u003e)\u003c/pre\u003e in all cases, \n\u003cpre\u003e     new URI(\u003ci\u003eu\u003c/i\u003e.getScheme(),\n             \u003ci\u003eu\u003c/i\u003e.getAuthority(),\n             \u003ci\u003eu\u003c/i\u003e.getPath(), \u003ci\u003eu\u003c/i\u003e.getQuery(),\n             \u003ci\u003eu\u003c/i\u003e.getFragment())\n     .equals(\u003ci\u003eu\u003c/i\u003e)\u003c/pre\u003e if \n\u003ci\u003eu\u003c/i\u003e is hierarchical, and \n\u003cpre\u003e     new URI(\u003ci\u003eu\u003c/i\u003e.getScheme(),\n             \u003ci\u003eu\u003c/i\u003e.getUserInfo(), \u003ci\u003eu\u003c/i\u003e.getHost(), \u003ci\u003eu\u003c/i\u003e.getPort(),\n             \u003ci\u003eu\u003c/i\u003e.getPath(), \u003ci\u003eu\u003c/i\u003e.getQuery(),\n             \u003ci\u003eu\u003c/i\u003e.getFragment())\n     .equals(\u003ci\u003eu\u003c/i\u003e)\u003c/pre\u003e if \n\u003ci\u003eu\u003c/i\u003e is hierarchical and has either no authority or a server-based authority. \n\u003ch3\u003e URIs, URLs, and URNs \u003c/h3\u003e A URI is a uniform resource \n\u003ci\u003eidentifier\u003c/i\u003e while a URL is a uniform resource \n\u003ci\u003elocator\u003c/i\u003e. Hence every URL is a URI, abstractly speaking, but not every URI is a URL. This is because there is another subcategory of URIs, uniform resource \n\u003ci\u003enames\u003c/i\u003e (URNs), which name resources but do not specify how to locate them. The \n\u003ccode\u003emailto\u003c/code\u003e, \n\u003ccode\u003enews\u003c/code\u003e, and \n\u003ccode\u003eisbn\u003c/code\u003e URIs shown above are examples of URNs. \n\u003cp\u003e The conceptual distinction between URIs and URLs is reflected in the differences between this class and the \u003ca href\u003d\"URL.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eURL\u003c/code\u003e\u003c/a\u003e class. \u003c/p\u003e\n\u003cp\u003e An instance of this class represents a URI reference in the syntactic sense defined by RFC\u0026nbsp;2396. A URI may be either absolute or relative. A URI string is parsed according to the generic syntax without regard to the scheme, if any, that it specifies. No lookup of the host, if any, is performed, and no scheme-dependent stream handler is constructed. Equality, hashing, and comparison are defined strictly in terms of the character content of the instance. In other words, a URI instance is little more than a structured string that supports the syntactic, scheme-independent operations of comparison, normalization, resolution, and relativization. \u003c/p\u003e\n\u003cp\u003e An instance of the \u003ca href\u003d\"URL.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eURL\u003c/code\u003e\u003c/a\u003e class, by contrast, represents the syntactic components of a URL together with some of the information required to access the resource that it describes. A URL must be absolute, that is, it must always specify a scheme. A URL string is parsed according to its scheme. A stream handler is always established for a URL, and in fact it is impossible to create a URL instance for a scheme for which no handler is available. Equality and hashing depend upon both the scheme and the Internet address of the host, if any; comparison is not defined. In other words, a URL is a structured string that supports the syntactic operation of resolution as well as the network I/O operations of looking up the host and opening a connection to the specified resource.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"http://www.ietf.org/rfc/rfc2279.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2279: UTF-8, a transformation format of ISO 10646\u003c/i\u003e\u003c/a\u003e, \n\u003cbr\u003e\n\u003ca href\u003d\"http://www.ietf.org/rfc/rfc2373.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2373: IPv6 Addressing Architecture\u003c/i\u003e\u003c/a\u003e, \n\u003cbr\u003e\n\u003ca href\u003d\"http://www.ietf.org/rfc/rfc2396.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2396: Uniform Resource Identifiers (URI): Generic Syntax\u003c/i\u003e\u003c/a\u003e, \n\u003cbr\u003e\n\u003ca href\u003d\"http://www.ietf.org/rfc/rfc2732.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2732: Format for Literal IPv6 Addresses in URLs\u003c/i\u003e\u003c/a\u003e, \n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URISyntaxException.html\"\u003eURISyntaxException\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#java.net.URI\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "apiNote": [
      "Applications working with file paths and file URIs should take great care to use the appropriate methods to convert between the two. The \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/file/Path.html#of(java.net.URI)\"\u003e\u003ccode\u003ePath.of(URI)\u003c/code\u003e\u003c/a\u003e factory method and the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#%3Cinit%3E(java.net.URI)\"\u003e\u003ccode\u003eFile(URI)\u003c/code\u003e\u003c/a\u003e constructor can be used to create \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/file/Path.html\" title\u003d\"interface in java.nio.file\"\u003e\u003ccode\u003ePath\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003eFile\u003c/code\u003e\u003c/a\u003e objects from a file URI. \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/file/Path.html#toUri()\"\u003e\u003ccode\u003ePath.toUri()\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#toURI()\"\u003e\u003ccode\u003eFile.toURI()\u003c/code\u003e\u003c/a\u003e can be used to create a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URI.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eURI\u003c/code\u003e\u003c/a\u003e from a file path. Applications should never try to \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URI.html#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)\"\u003econstruct\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URI.html#%3Cinit%3E(java.lang.String)\"\u003eparse\u003c/a\u003e, or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/URI.html#resolve(java.lang.String)\"\u003eresolve\u003c/a\u003e a \n\u003ccode\u003eURI\u003c/code\u003e from the direct string representation of a \n\u003ccode\u003eFile\u003c/code\u003e or \n\u003ccode\u003ePath\u003c/code\u003e instance. \n\u003cp\u003e Some components of a URL or URI, such as \u003ci\u003euserinfo\u003c/i\u003e, may be abused to construct misleading URLs or URIs. Applications that deal with URLs or URIs should take into account the recommendations advised in \u003ca href\u003d\"https://tools.ietf.org/html/rfc3986#section-7\"\u003eRFC3986, Section 7, Security Considerations\u003c/a\u003e.\u003c/p\u003e"
    ],
    "since": [
      "1.4"
    ]
  }
}