{
  "packageName": "java.lang",
  "simpleName": "Comparable",
  "moduleName": "java.base",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "compareTo",
      "comment": "Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object. The implementor must ensure sgn(x.compareTo(y)) \u003d\u003d -sgn(y.compareTo(x)) for all x and y. (This implies that x.compareTo(y) must throw an exception iff y.compareTo(x) throws an exception.) The implementor must also ensure that the relation is transitive: (x.compareTo(y) \u003e 0 \u0026\u0026 y.compareTo(z) \u003e 0) implies x.compareTo(z) \u003e 0. Finally, the implementor must ensure that x.compareTo(y)\u003d\u003d0 implies that sgn(x.compareTo(z)) \u003d\u003d sgn(y.compareTo(z)), for all z. It is strongly recommended, but not strictly required that (x.compareTo(y)\u003d\u003d0) \u003d\u003d (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\" In the foregoing description, the notation sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value of expression is negative, zero, or positive, respectively.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eo\u003c/code\u003e - the object to be compared."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the specified object is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the specified object\u0027s type prevents it from being compared to this object."
        ],
        "return": [
          "a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object."
        ]
      }
    }
  ],
  "genericParameters": [
    {
      "name": "T",
      "type": "Variable"
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "java.lang.Comparable",
  "comment": "This interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class\u0027s \n\u003ci\u003enatural ordering\u003c/i\u003e, and the class\u0027s \n\u003ccode\u003ecompareTo\u003c/code\u003e method is referred to as its \n\u003ci\u003enatural comparison method\u003c/i\u003e.\n\u003cp\u003e Lists (and arrays) of objects that implement this interface can be sorted automatically by \u003ca href\u003d\"../util/Collections.html#sort(java.util.List)\"\u003e\u003ccode\u003eCollections.sort\u003c/code\u003e\u003c/a\u003e (and \u003ca href\u003d\"../util/Arrays.html#sort(java.lang.Object%5B%5D)\"\u003e\u003ccode\u003eArrays.sort\u003c/code\u003e\u003c/a\u003e). Objects that implement this interface can be used as keys in a \u003ca href\u003d\"../util/SortedMap.html\" title\u003d\"interface in java.util\"\u003esorted map\u003c/a\u003e or as elements in a \u003ca href\u003d\"../util/SortedSet.html\" title\u003d\"interface in java.util\"\u003esorted set\u003c/a\u003e, without the need to specify a \u003ca href\u003d\"../util/Comparator.html\" title\u003d\"interface in java.util\"\u003ecomparator\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e The natural ordering for a class \u003ccode\u003eC\u003c/code\u003e is said to be \u003ci\u003econsistent with equals\u003c/i\u003e if and only if \u003ccode\u003ee1.compareTo(e2) \u003d\u003d 0\u003c/code\u003e has the same boolean value as \u003ccode\u003ee1.equals(e2)\u003c/code\u003e for every \u003ccode\u003ee1\u003c/code\u003e and \u003ccode\u003ee2\u003c/code\u003e of class \u003ccode\u003eC\u003c/code\u003e. Note that \u003ccode\u003enull\u003c/code\u003e is not an instance of any class, and \u003ccode\u003ee.compareTo(null)\u003c/code\u003e should throw a \u003ccode\u003eNullPointerException\u003c/code\u003e even though \u003ccode\u003ee.equals(null)\u003c/code\u003e returns \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e It is strongly recommended (though not required) that natural orderings be consistent with equals. This is so because sorted sets (and sorted maps) without explicit comparators behave \"strangely\" when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates the general contract for set (or map), which is defined in terms of the \u003ccode\u003eequals\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003e For example, if one adds two keys \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e such that \u003ccode\u003e(!a.equals(b) \u0026amp;\u0026amp; a.compareTo(b) \u003d\u003d 0)\u003c/code\u003e to a sorted set that does not use an explicit comparator, the second \u003ccode\u003eadd\u003c/code\u003e operation returns false (and the size of the sorted set does not increase) because \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are equivalent from the sorted set\u0027s perspective.\u003c/p\u003e\n\u003cp\u003e Virtually all Java core classes that implement \u003ccode\u003eComparable\u003c/code\u003e have natural orderings that are consistent with equals. One exception is \u003ccode\u003ejava.math.BigDecimal\u003c/code\u003e, whose natural ordering equates \u003ccode\u003eBigDecimal\u003c/code\u003e objects with equal values and different precisions (such as 4.0 and 4.00).\u003c/p\u003e\n\u003cp\u003e For the mathematically inclined, the \u003ci\u003erelation\u003c/i\u003e that defines the natural ordering on a given class C is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n       {(x, y) such that x.compareTo(y) \u0026lt;\u003d 0}.\n \u003c/code\u003e\u003c/pre\u003e The \n\u003ci\u003equotient\u003c/i\u003e for this total order is: \n\u003cpre\u003e\u003ccode\u003e\n       {(x, y) such that x.compareTo(y) \u003d\u003d 0}.\n \u003c/code\u003e\u003c/pre\u003e It follows immediately from the contract for \n\u003ccode\u003ecompareTo\u003c/code\u003e that the quotient is an \n\u003ci\u003eequivalence relation\u003c/i\u003e on \n\u003ccode\u003eC\u003c/code\u003e, and that the natural ordering is a \n\u003ci\u003etotal order\u003c/i\u003e on \n\u003ccode\u003eC\u003c/code\u003e. When we say that a class\u0027s natural ordering is \n\u003ci\u003econsistent with equals\u003c/i\u003e, we mean that the quotient for the natural ordering is the equivalence relation defined by the class\u0027s \n\u003ca href\u003d\"Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eequals(Object)\u003c/code\u003e\u003c/a\u003e method:\n\u003cpre\u003e     {(x, y) such that x.equals(y)}. \u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e This interface is a member of the \u003ca href\u003d\"../../../java.base/java/util/package-summary.html#CollectionsFramework\"\u003e Java Collections Framework\u003c/a\u003e.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Comparator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eComparator\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.2"
    ]
  }
}