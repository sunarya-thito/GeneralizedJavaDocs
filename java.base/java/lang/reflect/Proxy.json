{
  "packageName": "java.lang.reflect",
  "simpleName": "Proxy",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "java.lang.reflect.InvocationHandler",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 4,
      "name": "h",
      "comment": "the invocation handler for this proxy instance.",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.ClassLoader",
            "type": "Class"
          },
          "field": {
            "name": "loader"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "interfaces"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getProxyClass",
      "comment": "Returns the java.lang.Class object for a proxy class given a class loader and an array of interfaces. The proxy class will be defined by the specified class loader and will implement all of the supplied interfaces. If any of the given interfaces is non-public, the proxy class will be non-public. If a proxy class for the same permutation of interfaces has already been defined by the class loader, then the existing proxy class will be returned; otherwise, a proxy class for those interfaces will be generated dynamically and defined by the class loader.",
      "annotations": [
        {
          "type": "Deprecated"
        }
      ],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Proxy.html#membership\"\u003ePackage and Module Membership of Proxy Class\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eloader\u003c/code\u003e - the class loader to define the proxy class",
          "\u003ccode\u003einterfaces\u003c/code\u003e - the list of interfaces for the proxy class to implement"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any of the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Proxy.html#restrictions\"\u003e restrictions\u003c/a\u003e on the parameters are violated",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager, \n\u003cem\u003es\u003c/em\u003e, is present and any of the following conditions is met: \n\u003cul\u003e \n \u003cli\u003e the given \u003ccode\u003eloader\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e and the caller\u0027s class loader is not \u003ccode\u003enull\u003c/code\u003e and the invocation of \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkPermission(java.security.Permission)\"\u003e\u003ccode\u003es.checkPermission\u003c/code\u003e\u003c/a\u003e with \u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e permission denies access.\u003c/li\u003e \n \u003cli\u003e for each proxy interface, \u003ccode\u003eintf\u003c/code\u003e, the caller\u0027s class loader is not the same as or an ancestor of the class loader for \u003ccode\u003eintf\u003c/code\u003e and invocation of \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)\"\u003e\u003ccode\u003es.checkPackageAccess()\u003c/code\u003e\u003c/a\u003e denies access to \u003ccode\u003eintf\u003c/code\u003e.\u003c/li\u003e \n\u003c/ul\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003einterfaces\u003c/code\u003e array argument or any of its elements are \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "a proxy class that is defined in the specified class loader and that implements the specified interfaces"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.ClassLoader",
            "type": "Class"
          },
          "field": {
            "name": "loader"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "interfaces"
          }
        },
        {
          "type": {
            "name": "java.lang.reflect.InvocationHandler",
            "type": "Class"
          },
          "field": {
            "name": "h"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "newProxyInstance",
      "comment": "Returns a proxy instance for the specified interfaces that dispatches method invocations to the specified invocation handler. IllegalArgumentException will be thrown if any of the following restrictions is violated: All of Class objects in the given interfaces array must represent non-hidden interfaces, not classes or primitive types. No two elements in the interfaces array may refer to identical Class objects. All of the interface types must be visible by name through the specified class loader. In other words, for class loader cl and every interface i, the following expression must be true: Class.forName(i.getName(), false, cl) \u003d\u003d i All of the types referenced by all public method signatures of the specified interfaces and those inherited by their superinterfaces must be visible by name through the specified class loader. All non-public interfaces must be in the same package and module, defined by the specified class loader and the module of the non-public interfaces can access all of the interface types; otherwise, it would not be possible for the proxy class to implement all of the interfaces, regardless of what package it is defined in. For any set of member methods of the specified interfaces that have the same signature: If the return type of any of the methods is a primitive type or void, then all of the methods must have that same return type. Otherwise, one of the methods must have a return type that is assignable to all of the return types of the rest of the methods. The resulting proxy class must not exceed any limits imposed on classes by the virtual machine. For example, the VM may limit the number of interfaces that a class may implement to 65535; in that case, the size of the interfaces array must not exceed 65535. Note that the order of the specified proxy interfaces is significant: two requests for a proxy class with the same combination of interfaces but in a different order will result in two distinct proxy classes.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Proxy.html#membership\"\u003ePackage and Module Membership of Proxy Class\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eloader\u003c/code\u003e - the class loader to define the proxy class",
          "\u003ccode\u003einterfaces\u003c/code\u003e - the list of interfaces for the proxy class to implement",
          "\u003ccode\u003eh\u003c/code\u003e - the invocation handler to dispatch method invocations to"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any of the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Proxy.html#restrictions\"\u003e restrictions\u003c/a\u003e on the parameters are violated",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager, \n\u003cem\u003es\u003c/em\u003e, is present and any of the following conditions is met: \n\u003cul\u003e \n \u003cli\u003e the given \u003ccode\u003eloader\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e and the caller\u0027s class loader is not \u003ccode\u003enull\u003c/code\u003e and the invocation of \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkPermission(java.security.Permission)\"\u003e\u003ccode\u003es.checkPermission\u003c/code\u003e\u003c/a\u003e with \u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e permission denies access;\u003c/li\u003e \n \u003cli\u003e for each proxy interface, \u003ccode\u003eintf\u003c/code\u003e, the caller\u0027s class loader is not the same as or an ancestor of the class loader for \u003ccode\u003eintf\u003c/code\u003e and invocation of \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)\"\u003e\u003ccode\u003es.checkPackageAccess()\u003c/code\u003e\u003c/a\u003e denies access to \u003ccode\u003eintf\u003c/code\u003e;\u003c/li\u003e \n \u003cli\u003e any of the given proxy interfaces is non-public and the caller class is not in the same \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Package.html\" title\u003d\"class in java.lang\"\u003eruntime package\u003c/a\u003e as the non-public interface and the invocation of \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkPermission(java.security.Permission)\"\u003e\u003ccode\u003es.checkPermission\u003c/code\u003e\u003c/a\u003e with \u003ccode\u003eReflectPermission(\"newProxyInPackage.{package name}\")\u003c/code\u003e permission denies access.\u003c/li\u003e \n\u003c/ul\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003einterfaces\u003c/code\u003e array argument or any of its elements are \n\u003ccode\u003enull\u003c/code\u003e, or if the invocation handler, \n\u003ccode\u003eh\u003c/code\u003e, is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "a proxy instance with the specified invocation handler of a proxy class that is defined by the specified class loader and that implements the specified interfaces"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "cl"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "isProxyClass",
      "comment": "Returns true if the given class is a proxy class.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ecl\u003c/code\u003e - the class to test"
        ],
        "implNote": [
          "The reliability of this method is important for the ability to use it to make security decisions, so its implementation should not just test if the class in question extends \n\u003ccode\u003eProxy\u003c/code\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ecl\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the class is a proxy class and \n\u003ccode\u003efalse\u003c/code\u003e otherwise"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.reflect.InvocationHandler",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "proxy"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "getInvocationHandler",
      "comment": "Returns the invocation handler for the specified proxy instance.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eproxy\u003c/code\u003e - the proxy instance to return the invocation handler for"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the argument is not a proxy instance",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager, \n\u003cem\u003es\u003c/em\u003e, is present and the caller\u0027s class loader is not the same as or an ancestor of the class loader for the invocation handler and invocation of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)\"\u003e\u003ccode\u003es.checkPackageAccess()\u003c/code\u003e\u003c/a\u003e denies access to the invocation handler\u0027s class."
        ],
        "return": [
          "the invocation handler for the proxy instance"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.reflect.InvocationHandler",
            "type": "Class"
          },
          "field": {
            "name": "h"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Constructs a new Proxy instance from a subclass (typically, a dynamic proxy class) with the specified value for its invocation handler.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eh\u003c/code\u003e - the invocation handler for this proxy instance"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the given invocation handler, \n\u003ccode\u003eh\u003c/code\u003e, is \n\u003ccode\u003enull\u003c/code\u003e."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.lang.reflect.Proxy",
  "comment": "\u003ccode\u003eProxy\u003c/code\u003e provides static methods for creating objects that act like instances of interfaces but allow for customized method invocation. To create a proxy instance for some interface \n\u003ccode\u003eFoo\u003c/code\u003e: \n\u003cpre\u003e\u003ccode\u003e\n     InvocationHandler handler \u003d new MyInvocationHandler(...);\n     Foo f \u003d (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),\n                                          new Class\u0026lt;?\u0026gt;[] { Foo.class },\n                                          handler);\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e A \u003cem\u003eproxy class\u003c/em\u003e is a class created at runtime that implements a specified list of interfaces, known as \u003cem\u003eproxy interfaces\u003c/em\u003e. A \u003cem\u003eproxy instance\u003c/em\u003e is an instance of a proxy class. Each proxy instance has an associated \u003ci\u003einvocation handler\u003c/i\u003e object, which implements the interface \u003ca href\u003d\"InvocationHandler.html\" title\u003d\"interface in java.lang.reflect\"\u003e\u003ccode\u003eInvocationHandler\u003c/code\u003e\u003c/a\u003e. A method invocation on a proxy instance through one of its proxy interfaces will be dispatched to the \u003ca href\u003d\"InvocationHandler.html#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)\"\u003e\u003ccode\u003einvoke\u003c/code\u003e\u003c/a\u003e method of the instance\u0027s invocation handler, passing the proxy instance, a \u003ccode\u003ejava.lang.reflect.Method\u003c/code\u003e object identifying the method that was invoked, and an array of type \u003ccode\u003eObject\u003c/code\u003e containing the arguments. The invocation handler processes the encoded method invocation as appropriate and the result that it returns will be returned as the result of the method invocation on the proxy instance. \u003c/p\u003e\n\u003cp\u003eA proxy class has the following properties: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eThe unqualified name of a proxy class is unspecified. The space of class names that begin with the string \u003ccode\u003e\"$Proxy\"\u003c/code\u003e should be, however, reserved for proxy classes. \u003c/li\u003e\n \u003cli\u003eThe package and module in which a proxy class is defined is specified \u003ca href\u003d\"#membership\"\u003ebelow\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003eA proxy class is \u003cem\u003efinal and non-abstract\u003c/em\u003e. \u003c/li\u003e\n \u003cli\u003eA proxy class extends \u003ccode\u003ejava.lang.reflect.Proxy\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eA proxy class implements exactly the interfaces specified at its creation, in the same order. Invoking \u003ca href\u003d\"../Class.html#getInterfaces()\"\u003e\u003ccode\u003egetInterfaces\u003c/code\u003e\u003c/a\u003e on its \u003ccode\u003eClass\u003c/code\u003e object will return an array containing the same list of interfaces (in the order specified at its creation), invoking \u003ca href\u003d\"../Class.html#getMethods()\"\u003e\u003ccode\u003egetMethods\u003c/code\u003e\u003c/a\u003e on its \u003ccode\u003eClass\u003c/code\u003e object will return an array of \u003ccode\u003eMethod\u003c/code\u003e objects that include all of the methods in those interfaces, and invoking \u003ccode\u003egetMethod\u003c/code\u003e will find methods in the proxy interfaces as would be expected. \u003c/li\u003e\n \u003cli\u003eThe \u003ca href\u003d\"../../security/ProtectionDomain.html\" title\u003d\"class in java.security\"\u003e\u003ccode\u003eProtectionDomain\u003c/code\u003e\u003c/a\u003e of a proxy class is the same as that of system classes loaded by the bootstrap class loader, such as \u003ccode\u003ejava.lang.Object\u003c/code\u003e, because the code for a proxy class is generated by trusted system code. This protection domain will typically be granted \u003ccode\u003ejava.security.AllPermission\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eThe \u003ca href\u003d\"#isProxyClass(java.lang.Class)\"\u003e\u003ccode\u003eProxy.isProxyClass\u003c/code\u003e\u003c/a\u003e method can be used to determine if a given class is a proxy class. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eA proxy instance has the following properties: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eGiven a proxy instance \u003ccode\u003eproxy\u003c/code\u003e and one of the interfaces, \u003ccode\u003eFoo\u003c/code\u003e, implemented by its proxy class, the following expression will return true: \u003cpre\u003e     \u003ccode\u003eproxy instanceof Foo\u003c/code\u003e\n \u003c/pre\u003e and the following cast operation will succeed (rather than throwing a \u003ccode\u003eClassCastException\u003c/code\u003e): \u003cpre\u003e     \u003ccode\u003e(Foo) proxy\u003c/code\u003e\n \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003eEach proxy instance has an associated invocation handler, the one that was passed to its constructor. The static \u003ca href\u003d\"#getInvocationHandler(java.lang.Object)\"\u003e\u003ccode\u003eProxy.getInvocationHandler\u003c/code\u003e\u003c/a\u003e method will return the invocation handler associated with the proxy instance passed as its argument. \u003c/li\u003e\n \u003cli\u003eAn interface method invocation on a proxy instance will be encoded and dispatched to the invocation handler\u0027s \u003ca href\u003d\"InvocationHandler.html#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)\"\u003e\u003ccode\u003einvoke\u003c/code\u003e\u003c/a\u003e method as described in the documentation for that method. \u003c/li\u003e\n \u003cli\u003eA proxy interface may define a default method or inherit a default method from its superinterface directly or indirectly. An invocation handler can invoke a default method of a proxy interface by calling \u003ca href\u003d\"InvocationHandler.html#invokeDefault(java.lang.Object,java.lang.reflect.Method,java.lang.Object...)\"\u003e\u003ccode\u003eInvocationHandler::invokeDefault\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003eAn invocation of the \u003ccode\u003ehashCode\u003c/code\u003e, \u003ccode\u003eequals\u003c/code\u003e, or \u003ccode\u003etoString\u003c/code\u003e methods declared in \u003ccode\u003ejava.lang.Object\u003c/code\u003e on a proxy instance will be encoded and dispatched to the invocation handler\u0027s \u003ccode\u003einvoke\u003c/code\u003e method in the same manner as interface method invocations are encoded and dispatched, as described above. The declaring class of the \u003ccode\u003eMethod\u003c/code\u003e object passed to \u003ccode\u003einvoke\u003c/code\u003e will be \u003ccode\u003ejava.lang.Object\u003c/code\u003e. Other public methods of a proxy instance inherited from \u003ccode\u003ejava.lang.Object\u003c/code\u003e are not overridden by a proxy class, so invocations of those methods behave like they do for instances of \u003ccode\u003ejava.lang.Object\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"membership\"\u003ePackage and Module Membership of Proxy Class\u003c/a\u003e\u003c/h2\u003e The package and module to which a proxy class belongs are chosen such that the accessibility of the proxy class is in line with the accessibility of the proxy interfaces. Specifically, the package and the module membership of a proxy class defined via the \n\u003ca href\u003d\"#getProxyClass(java.lang.ClassLoader,java.lang.Class...)\"\u003e\u003ccode\u003egetProxyClass(ClassLoader, Class[])\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)\"\u003e\u003ccode\u003enewProxyInstance(ClassLoader, Class[], InvocationHandler)\u003c/code\u003e\u003c/a\u003e methods is specified as follows: \n\u003col\u003e \n \u003cli\u003eIf all the proxy interfaces are in \u003cem\u003eexported\u003c/em\u003e or \u003cem\u003eopen\u003c/em\u003e packages: \n  \u003col type\u003d\"a\"\u003e \n   \u003cli\u003eif all the proxy interfaces are \u003cem\u003epublic\u003c/em\u003e, then the proxy class is \u003cem\u003epublic\u003c/em\u003e in an unconditionally exported but non-open package. The name of the package and the module are unspecified.\u003c/li\u003e \n   \u003cli\u003eif at least one of all the proxy interfaces is \u003cem\u003enon-public\u003c/em\u003e, then the proxy class is \u003cem\u003enon-public\u003c/em\u003e in the package and module of the non-public interfaces. All the non-public interfaces must be in the same package and module; otherwise, proxying them is \u003ca href\u003d\"#restrictions\"\u003enot possible\u003c/a\u003e.\u003c/li\u003e \n  \u003c/ol\u003e \u003c/li\u003e \n \u003cli\u003eIf at least one proxy interface is in a package that is \u003cem\u003enon-exported\u003c/em\u003e and \u003cem\u003enon-open\u003c/em\u003e: \n  \u003col type\u003d\"a\"\u003e \n   \u003cli\u003eif all the proxy interfaces are \u003cem\u003epublic\u003c/em\u003e, then the proxy class is \u003cem\u003epublic\u003c/em\u003e in a \u003cem\u003enon-exported\u003c/em\u003e, \u003cem\u003enon-open\u003c/em\u003e package of \u003ca href\u003d\"#dynamicmodule\"\u003e\u003cem\u003edynamic module\u003c/em\u003e.\u003c/a\u003e The names of the package and the module are unspecified.\u003c/li\u003e \n   \u003cli\u003eif at least one of all the proxy interfaces is \u003cem\u003enon-public\u003c/em\u003e, then the proxy class is \u003cem\u003enon-public\u003c/em\u003e in the package and module of the non-public interfaces. All the non-public interfaces must be in the same package and module; otherwise, proxying them is \u003ca href\u003d\"#restrictions\"\u003enot possible\u003c/a\u003e.\u003c/li\u003e \n  \u003c/ol\u003e \u003c/li\u003e \n\u003c/ol\u003e \n\u003cp\u003e Note that if proxy interfaces with a mix of accessibilities -- for example, an exported public interface and a non-exported non-public interface -- are proxied by the same instance, then the proxy class\u0027s accessibility is governed by the least accessible proxy interface. \u003c/p\u003e\n\u003cp\u003e Note that it is possible for arbitrary code to obtain access to a proxy class in an open package with \u003ca href\u003d\"AccessibleObject.html#setAccessible(java.lang.reflect.AccessibleObject%5B%5D,boolean)\"\u003e\u003ccode\u003esetAccessible\u003c/code\u003e\u003c/a\u003e, whereas a proxy class in a non-open package is never accessible to code outside the module of the proxy class. \u003c/p\u003e\n\u003cp\u003e Throughout this specification, a \"non-exported package\" refers to a package that is not exported to all modules, and a \"non-open package\" refers to a package that is not open to all modules. Specifically, these terms refer to a package that either is not exported/open by its containing module or is exported/open in a qualified fashion by its containing module. \u003c/p\u003e\n\u003ch3\u003e\u003ca id\u003d\"dynamicmodule\"\u003eDynamic Modules\u003c/a\u003e\u003c/h3\u003e \n\u003cp\u003e A dynamic module is a named module generated at runtime. A proxy class defined in a dynamic module is encapsulated and not accessible to any module. Calling \u003ca href\u003d\"Constructor.html#newInstance(java.lang.Object...)\"\u003e\u003ccode\u003eConstructor.newInstance(Object...)\u003c/code\u003e\u003c/a\u003e on a proxy class in a dynamic module will throw \u003ccode\u003eIllegalAccessException\u003c/code\u003e; \u003ccode\u003eProxy.newProxyInstance\u003c/code\u003e method should be used instead. \u003c/p\u003e\n\u003cp\u003e A dynamic module can read the modules of all of the superinterfaces of a proxy class and the modules of the classes and interfaces referenced by all public method signatures of a proxy class. If a superinterface or a referenced class or interface, say \u003ccode\u003eT\u003c/code\u003e, is in a non-exported package, the \u003ca href\u003d\"../Module.html\" title\u003d\"class in java.lang\"\u003emodule\u003c/a\u003e of \u003ccode\u003eT\u003c/code\u003e is updated to export the package of \u003ccode\u003eT\u003c/code\u003e to the dynamic module. \u003c/p\u003e\n\u003ch3\u003eMethods Duplicated in Multiple Proxy Interfaces\u003c/h3\u003e \n\u003cp\u003eWhen two or more proxy interfaces contain a method with the same name and parameter signature, the order of the proxy class\u0027s interfaces becomes significant. When such a \u003ci\u003eduplicate method\u003c/i\u003e is invoked on a proxy instance, the \u003ccode\u003eMethod\u003c/code\u003e object passed to the invocation handler will not necessarily be the one whose declaring class is assignable from the reference type of the interface that the proxy\u0027s method was invoked through. This limitation exists because the corresponding method implementation in the generated proxy class cannot determine which interface it was invoked through. Therefore, when a duplicate method is invoked on a proxy instance, the \u003ccode\u003eMethod\u003c/code\u003e object for the method in the foremost interface that contains the method (either directly or inherited through a superinterface) in the proxy class\u0027s list of interfaces is passed to the invocation handler\u0027s \u003ccode\u003einvoke\u003c/code\u003e method, regardless of the reference type through which the method invocation occurred. \u003c/p\u003e\n\u003cp\u003eIf a proxy interface contains a method with the same name and parameter signature as the \u003ccode\u003ehashCode\u003c/code\u003e, \u003ccode\u003eequals\u003c/code\u003e, or \u003ccode\u003etoString\u003c/code\u003e methods of \u003ccode\u003ejava.lang.Object\u003c/code\u003e, when such a method is invoked on a proxy instance, the \u003ccode\u003eMethod\u003c/code\u003e object passed to the invocation handler will have \u003ccode\u003ejava.lang.Object\u003c/code\u003e as its declaring class. In other words, the public, non-final methods of \u003ccode\u003ejava.lang.Object\u003c/code\u003e logically precede all of the proxy interfaces for the determination of which \u003ccode\u003eMethod\u003c/code\u003e object to pass to the invocation handler. \u003c/p\u003e\n\u003cp\u003eNote also that when a duplicate method is dispatched to an invocation handler, the \u003ccode\u003einvoke\u003c/code\u003e method may only throw checked exception types that are assignable to one of the exception types in the \u003ccode\u003ethrows\u003c/code\u003e clause of the method in \u003ci\u003eall\u003c/i\u003e of the proxy interfaces that it can be invoked through. If the \u003ccode\u003einvoke\u003c/code\u003e method throws a checked exception that is not assignable to any of the exception types declared by the method in one of the proxy interfaces that it can be invoked through, then an unchecked \u003ccode\u003eUndeclaredThrowableException\u003c/code\u003e will be thrown by the invocation on the proxy instance. This restriction means that not all of the exception types returned by invoking \u003ccode\u003egetExceptionTypes\u003c/code\u003e on the \u003ccode\u003eMethod\u003c/code\u003e object passed to the \u003ccode\u003einvoke\u003c/code\u003e method can necessarily be thrown successfully by the \u003ccode\u003einvoke\u003c/code\u003e method.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/InvocationHandler.html\" title\u003d\"interface in java.lang.reflect\"\u003e\u003ccode\u003eInvocationHandler\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#java.lang.reflect.Proxy\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "since": [
      "1.3"
    ]
  }
}