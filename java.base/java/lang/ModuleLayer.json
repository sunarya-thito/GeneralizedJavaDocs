{
  "packageName": "java.lang",
  "simpleName": "ModuleLayer",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.ModuleLayer",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.Configuration",
            "type": "Class"
          },
          "field": {
            "name": "cf"
          }
        },
        {
          "type": {
            "name": "java.lang.ClassLoader",
            "type": "Class"
          },
          "field": {
            "name": "parentLoader"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "defineModulesWithOneLoader",
      "comment": "Creates a new module layer, with this layer as its parent, by defining the modules in the given Configuration to the Java virtual machine. This method creates one class loader and defines all modules to that class loader. The parent of each class loader is the given parent class loader. This method works exactly as specified by the static defineModulesWithOneLoader method when invoked with this layer as the parent. In other words, if this layer is thisLayer then this method is equivalent to invoking:  \n     ModuleLayer.defineModulesWithOneLoader(cf, List.of(thisLayer), parentLoader).layer();",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ModuleLayer.html#findLoader(java.lang.String)\"\u003e\u003ccode\u003efindLoader(java.lang.String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ecf\u003c/code\u003e - The configuration for the layer",
          "\u003ccode\u003eparentLoader\u003c/code\u003e - The parent class loader for the class loader created by this method; may be \n\u003ccode\u003enull\u003c/code\u003e for the bootstrap class loader"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the given configuration has more than one parent or the parent of the configuration is not the configuration for this layer",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LayerInstantiationException.html\" title\u003d\"class in java.lang\"\u003eLayerInstantiationException\u003c/a\u003e\u003c/code\u003e - If the layer cannot be created for any of the reasons specified by the static \n\u003ccode\u003edefineModulesWithOneLoader\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003eRuntimePermission(\"createClassLoader\")\u003c/code\u003e or \n\u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e is denied by the security manager"
        ],
        "return": [
          "The newly created layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ModuleLayer",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.Configuration",
            "type": "Class"
          },
          "field": {
            "name": "cf"
          }
        },
        {
          "type": {
            "name": "java.lang.ClassLoader",
            "type": "Class"
          },
          "field": {
            "name": "parentLoader"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "defineModulesWithManyLoaders",
      "comment": "Creates a new module layer, with this layer as its parent, by defining the modules in the given Configuration to the Java virtual machine. Each module is defined to its own ClassLoader created by this method. The parent of each class loader is the given parent class loader. This method works exactly as specified by the static defineModulesWithManyLoaders method when invoked with this layer as the parent. In other words, if this layer is thisLayer then this method is equivalent to invoking:  \n     ModuleLayer.defineModulesWithManyLoaders(cf, List.of(thisLayer), parentLoader).layer();",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ModuleLayer.html#findLoader(java.lang.String)\"\u003e\u003ccode\u003efindLoader(java.lang.String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ecf\u003c/code\u003e - The configuration for the layer",
          "\u003ccode\u003eparentLoader\u003c/code\u003e - The parent class loader for each of the class loaders created by this method; may be \n\u003ccode\u003enull\u003c/code\u003e for the bootstrap class loader"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the given configuration has more than one parent or the parent of the configuration is not the configuration for this layer",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LayerInstantiationException.html\" title\u003d\"class in java.lang\"\u003eLayerInstantiationException\u003c/a\u003e\u003c/code\u003e - If the layer cannot be created for any of the reasons specified by the static \n\u003ccode\u003edefineModulesWithManyLoaders\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003eRuntimePermission(\"createClassLoader\")\u003c/code\u003e or \n\u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e is denied by the security manager"
        ],
        "return": [
          "The newly created layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ModuleLayer",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.Configuration",
            "type": "Class"
          },
          "field": {
            "name": "cf"
          }
        },
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              },
              {
                "name": "java.lang.ClassLoader",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clf"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "defineModules",
      "comment": "Creates a new module layer, with this layer as its parent, by defining the modules in the given Configuration to the Java virtual machine. Each module is mapped, by name, to its class loader by means of the given function. This method works exactly as specified by the static defineModules method when invoked with this layer as the parent. In other words, if this layer is thisLayer then this method is equivalent to invoking:  \n     ModuleLayer.defineModules(cf, List.of(thisLayer), clf).layer();",
      "tagMap": {
        "param": [
          "\u003ccode\u003ecf\u003c/code\u003e - The configuration for the layer",
          "\u003ccode\u003eclf\u003c/code\u003e - The function to map a module name to a class loader"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the given configuration has more than one parent or the parent of the configuration is not the configuration for this layer",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LayerInstantiationException.html\" title\u003d\"class in java.lang\"\u003eLayerInstantiationException\u003c/a\u003e\u003c/code\u003e - If the layer cannot be created for any of the reasons specified by the static \n\u003ccode\u003edefineModules\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e is denied by the security manager"
        ],
        "return": [
          "The newly created layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ModuleLayer$Controller",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.Configuration",
            "type": "Class"
          },
          "field": {
            "name": "cf"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.ModuleLayer",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "parentLayers"
          }
        },
        {
          "type": {
            "name": "java.lang.ClassLoader",
            "type": "Class"
          },
          "field": {
            "name": "parentLoader"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "defineModulesWithOneLoader",
      "comment": "Creates a new module layer by defining the modules in the given Configuration to the Java virtual machine. This method creates one class loader and defines all modules to that class loader. The class loader created by this method implements direct delegation when loading classes from modules. If the loadClass method is invoked to load a class then it uses the package name of the class to map it to a module. This may be a module in this layer and hence defined to the same class loader. It may be a package in a module in a parent layer that is exported to one or more of the modules in this layer. The class loader delegates to the class loader of the module, throwing ClassNotFoundException if not found by that class loader. When loadClass is invoked to load classes that do not map to a module then it delegates to the parent class loader. The class loader created by this method locates resources (getResource, getResources, and other resource methods) in all modules in the layer before searching the parent class loader. Attempting to create a layer with all modules defined to the same class loader can fail for the following reasons: Overlapping packages: Two or more modules in the configuration have the same package. Split delegation: The resulting class loader would need to delegate to more than one class loader in order to load classes in a specific package. In addition, a layer cannot be created if the configuration contains a module named \"java.base\", or a module contains a package named \"java\" or a package with a name starting with \"java.\". If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ModuleLayer.html#findLoader(java.lang.String)\"\u003e\u003ccode\u003efindLoader(java.lang.String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ecf\u003c/code\u003e - The configuration for the layer",
          "\u003ccode\u003eparentLayers\u003c/code\u003e - The list of parent layers in search order",
          "\u003ccode\u003eparentLoader\u003c/code\u003e - The parent class loader for the class loader created by this method; may be \n\u003ccode\u003enull\u003c/code\u003e for the bootstrap class loader"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the parent(s) of the given configuration do not match the configuration of the parent layers, including order",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LayerInstantiationException.html\" title\u003d\"class in java.lang\"\u003eLayerInstantiationException\u003c/a\u003e\u003c/code\u003e - If all modules cannot be defined to the same class loader for any of the reasons listed above",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003eRuntimePermission(\"createClassLoader\")\u003c/code\u003e or \n\u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e is denied by the security manager"
        ],
        "return": [
          "A controller that controls the newly created layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ModuleLayer$Controller",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.Configuration",
            "type": "Class"
          },
          "field": {
            "name": "cf"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.ModuleLayer",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "parentLayers"
          }
        },
        {
          "type": {
            "name": "java.lang.ClassLoader",
            "type": "Class"
          },
          "field": {
            "name": "parentLoader"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "defineModulesWithManyLoaders",
      "comment": "Creates a new module layer by defining the modules in the given Configuration to the Java virtual machine. Each module is defined to its own ClassLoader created by this method. The parent of each class loader is the given parent class loader. The class loaders created by this method implement direct delegation when loading classes from modules. If the loadClass method is invoked to load a class then it uses the package name of the class to map it to a module. The package may be in the module defined to the class loader. The package may be exported by another module in this layer to the module defined to the class loader. It may be in a package exported by a module in a parent layer. The class loader delegates to the class loader of the module, throwing ClassNotFoundException if not found by that class loader. When loadClass is invoked to load a class that does not map to a module then it delegates to the parent class loader. The class loaders created by this method locate resources (getResource, getResources, and other resource methods) in the module defined to the class loader before searching the parent class loader. If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ModuleLayer.html#findLoader(java.lang.String)\"\u003e\u003ccode\u003efindLoader(java.lang.String)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ecf\u003c/code\u003e - The configuration for the layer",
          "\u003ccode\u003eparentLayers\u003c/code\u003e - The list of parent layers in search order",
          "\u003ccode\u003eparentLoader\u003c/code\u003e - The parent class loader for each of the class loaders created by this method; may be \n\u003ccode\u003enull\u003c/code\u003e for the bootstrap class loader"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the parent(s) of the given configuration do not match the configuration of the parent layers, including order",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LayerInstantiationException.html\" title\u003d\"class in java.lang\"\u003eLayerInstantiationException\u003c/a\u003e\u003c/code\u003e - If the layer cannot be created because the configuration contains a module named \"\n\u003ccode\u003ejava.base\u003c/code\u003e\" or a module contains a package named \"\n\u003ccode\u003ejava\u003c/code\u003e\" or a package with a name starting with \"\n\u003ccode\u003ejava.\u003c/code\u003e\"",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003eRuntimePermission(\"createClassLoader\")\u003c/code\u003e or \n\u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e is denied by the security manager"
        ],
        "return": [
          "A controller that controls the newly created layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ModuleLayer$Controller",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.Configuration",
            "type": "Class"
          },
          "field": {
            "name": "cf"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.ModuleLayer",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "parentLayers"
          }
        },
        {
          "type": {
            "name": "java.util.function.Function",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              },
              {
                "name": "java.lang.ClassLoader",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "clf"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "defineModules",
      "comment": "Creates a new module layer by defining the modules in the given Configuration to the Java virtual machine. The given function maps each module in the configuration, by name, to a class loader. Creating the layer informs the Java virtual machine about the classes that may be loaded so that the Java virtual machine knows which module that each class is a member of. The class loader delegation implemented by the class loaders must respect module readability. The class loaders should be parallel-capable so as to avoid deadlocks during class loading. In addition, the entity creating a new layer with this method should arrange that the class loaders be ready to load from these modules before there are any attempts to load classes or resources. Creating a layer can fail for the following reasons: Two or more modules with the same package are mapped to the same class loader. A module is mapped to a class loader that already has a module of the same name defined to it. A module is mapped to a class loader that has already defined types in any of the packages in the module. In addition, a layer cannot be created if the configuration contains a module named \"java.base\", a configuration contains a module with a package named \"java\" or a package name starting with \"java.\", or the function to map a module name to a class loader returns null or the platform class loader. If the function to map a module name to class loader throws an error or runtime exception then it is propagated to the caller of this method.",
      "tagMap": {
        "apiNote": [
          "It is implementation specific as to whether creating a layer with this method is an atomic operation or not. Consequentially it is possible for this method to fail with some modules, but not all, defined to the Java virtual machine."
        ],
        "param": [
          "\u003ccode\u003ecf\u003c/code\u003e - The configuration for the layer",
          "\u003ccode\u003eparentLayers\u003c/code\u003e - The list of parent layers in search order",
          "\u003ccode\u003eclf\u003c/code\u003e - The function to map a module name to a class loader"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the parent(s) of the given configuration do not match the configuration of the parent layers, including order",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LayerInstantiationException.html\" title\u003d\"class in java.lang\"\u003eLayerInstantiationException\u003c/a\u003e\u003c/code\u003e - If creating the layer fails for any of the reasons listed above",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If \n\u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e is denied by the security manager"
        ],
        "return": [
          "A controller that controls the newly created layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.module.Configuration",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "configuration",
      "comment": "Returns the configuration for this layer.",
      "tagMap": {
        "return": [
          "The configuration for this layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "java.lang.ModuleLayer",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parents",
      "comment": "Returns an unmodifiable list of this layer\u0027s parents, in search order. If this is the empty layer then an empty list is returned.",
      "tagMap": {
        "return": [
          "A possibly-empty unmodifiable list of this layer\u0027s parents"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.Module",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "modules",
      "comment": "Returns an unmodifiable set of the modules in this layer.",
      "tagMap": {
        "return": [
          "A possibly-empty unmodifiable set of the modules in this layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "name": "java.lang.Module",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findModule",
      "comment": "Returns the module with the given name in this layer, or if not in this layer, the parent layers. Finding a module in parent layers is equivalent to invoking findModule on each parent, in search order, until the module is found or all parents have been searched. In a tree of layers then this is equivalent to a depth-first search.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - The name of the module to find"
        ],
        "return": [
          "The module with the given name or an empty \n\u003ccode\u003eOptional\u003c/code\u003e if there isn\u0027t a module with this name in this layer or any parent layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ClassLoader",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findLoader",
      "comment": "Returns the ClassLoader for the module with the given name. If a module of the given name is not in this layer then the parent layers are searched in the manner specified by findModule. If there is a security manager then its checkPermission method is called with a RuntimePermission(\"getClassLoader\") permission to check that the caller is allowed to get access to the class loader.",
      "tagMap": {
        "apiNote": [
          "This method does not return an \n\u003ccode\u003eOptional\u0026lt;ClassLoader\u0026gt;\u003c/code\u003e because `null` must be used to represent the bootstrap class loader."
        ],
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - The name of the module to find"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if a module of the given name is not defined in this layer or any parent of this layer",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if denied by the security manager"
        ],
        "return": [
          "The ClassLoader that the module is defined to"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a string describing this module layer.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "A possibly empty string describing this module layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ModuleLayer",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "empty",
      "comment": "Returns the empty layer. There are no modules in the empty layer. It has no parents.",
      "tagMap": {
        "return": [
          "The empty layer"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ModuleLayer",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "boot",
      "comment": "Returns the boot layer. The boot layer contains at least one module, java.base. Its parent is the empty layer.",
      "tagMap": {
        "apiNote": [
          "This method returns \n\u003ccode\u003enull\u003c/code\u003e during startup and before the boot layer is fully initialized."
        ],
        "return": [
          "The boot layer"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.lang.ModuleLayer$Controller"
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.lang.ModuleLayer",
  "comment": "A layer of modules in the Java virtual machine. \n\u003cp\u003e A layer is created from a graph of modules in a \u003ca href\u003d\"module/Configuration.html\" title\u003d\"class in java.lang.module\"\u003e\u003ccode\u003eConfiguration\u003c/code\u003e\u003c/a\u003e and a function that maps each module to a \u003ca href\u003d\"ClassLoader.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eClassLoader\u003c/code\u003e\u003c/a\u003e. Creating a layer informs the Java virtual machine about the classes that may be loaded from the modules so that the Java virtual machine knows which module that each class is a member of. \u003c/p\u003e \n\u003cp\u003e Creating a layer creates a \u003ca href\u003d\"Module.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eModule\u003c/code\u003e\u003c/a\u003e object for each \u003ca href\u003d\"module/ResolvedModule.html\" title\u003d\"class in java.lang.module\"\u003e\u003ccode\u003eResolvedModule\u003c/code\u003e\u003c/a\u003e in the configuration. For each resolved module that is \u003ca href\u003d\"module/ResolvedModule.html#reads()\"\u003e\u003ccode\u003eread\u003c/code\u003e\u003c/a\u003e, the \u003ccode\u003eModule\u003c/code\u003e \u003ca href\u003d\"Module.html#canRead(java.lang.Module)\"\u003e\u003ccode\u003ereads\u003c/code\u003e\u003c/a\u003e the corresponding run-time \u003ccode\u003eModule\u003c/code\u003e, which may be in the same layer or a \u003ca href\u003d\"#parents()\"\u003e\u003ccode\u003eparent\u003c/code\u003e\u003c/a\u003e layer. \u003c/p\u003e \n\u003cp\u003e The \u003ca href\u003d\"#defineModulesWithOneLoader(java.lang.module.Configuration,java.lang.ClassLoader)\"\u003e\u003ccode\u003edefineModulesWithOneLoader\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#defineModulesWithManyLoaders(java.lang.module.Configuration,java.lang.ClassLoader)\"\u003e\u003ccode\u003edefineModulesWithManyLoaders\u003c/code\u003e\u003c/a\u003e methods provide convenient ways to create a module layer where all modules are mapped to a single class loader or where each module is mapped to its own class loader. The \u003ca href\u003d\"#defineModules(java.lang.module.Configuration,java.util.function.Function)\"\u003e\u003ccode\u003edefineModules\u003c/code\u003e\u003c/a\u003e method is for more advanced cases where modules are mapped to custom class loaders by means of a function specified to the method. Each of these methods has an instance and static variant. The instance methods create a layer with the receiver as the parent layer. The static methods are for more advanced cases where there can be more than one parent layer or where a \u003ca href\u003d\"ModuleLayer.Controller.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eController\u003c/code\u003e\u003c/a\u003e is needed to control modules in the layer \u003c/p\u003e \n\u003cp\u003e A Java virtual machine has at least one non-empty layer, the \u003ca href\u003d\"#boot()\"\u003e\u003ccode\u003eboot\u003c/code\u003e\u003c/a\u003e layer, that is created when the Java virtual machine is started. The boot layer contains module \u003ccode\u003ejava.base\u003c/code\u003e and is the only layer in the Java virtual machine with a module named \"\u003ccode\u003ejava.base\u003c/code\u003e\". The modules in the boot layer are mapped to the bootstrap class loader and other class loaders that are \u003ca href\u003d\"ClassLoader.html#builtinLoaders\"\u003e built-in\u003c/a\u003e into the Java virtual machine. The boot layer will often be the \u003ca href\u003d\"#parents()\"\u003e\u003ccode\u003eparent\u003c/code\u003e\u003c/a\u003e when creating additional layers. \u003c/p\u003e \n\u003cp\u003e Each \u003ccode\u003eModule\u003c/code\u003e in a layer is created so that it \u003ca href\u003d\"Module.html#isExported(java.lang.String)\"\u003e\u003ccode\u003eexports\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"Module.html#isOpen(java.lang.String)\"\u003e\u003ccode\u003eopens\u003c/code\u003e\u003c/a\u003e the packages described by its \u003ca href\u003d\"module/ModuleDescriptor.html\" title\u003d\"class in java.lang.module\"\u003e\u003ccode\u003eModuleDescriptor\u003c/code\u003e\u003c/a\u003e. Qualified exports (where a package is exported to a set of target modules rather than all modules) are reified when creating the layer as follows: \u003c/p\u003e \n\u003cul\u003e \n \u003cli\u003e If module \u003ccode\u003eX\u003c/code\u003e exports a package to \u003ccode\u003eY\u003c/code\u003e, and if the runtime \u003ccode\u003eModule\u003c/code\u003e \u003ccode\u003eX\u003c/code\u003e reads \u003ccode\u003eModule\u003c/code\u003e \u003ccode\u003eY\u003c/code\u003e, then the package is exported to \u003ccode\u003eModule\u003c/code\u003e \u003ccode\u003eY\u003c/code\u003e (which may be in the same layer as \u003ccode\u003eX\u003c/code\u003e or a parent layer). \u003c/li\u003e \n \u003cli\u003e If module \u003ccode\u003eX\u003c/code\u003e exports a package to \u003ccode\u003eY\u003c/code\u003e, and if the runtime \u003ccode\u003eModule\u003c/code\u003e \u003ccode\u003eX\u003c/code\u003e does not read \u003ccode\u003eY\u003c/code\u003e then target \u003ccode\u003eY\u003c/code\u003e is located as if by invoking \u003ca href\u003d\"#findModule(java.lang.String)\"\u003e\u003ccode\u003efindModule\u003c/code\u003e\u003c/a\u003e to find the module in the layer or its parent layers. If \u003ccode\u003eY\u003c/code\u003e is found then the package is exported to the instance of \u003ccode\u003eY\u003c/code\u003e that was found. If \u003ccode\u003eY\u003c/code\u003e is not found then the qualified export is ignored. \u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e Qualified opens are handled in same way as qualified exports. \u003c/p\u003e \n\u003cp\u003e As when creating a \u003ccode\u003eConfiguration\u003c/code\u003e, \u003ca href\u003d\"module/ModuleDescriptor.html#isAutomatic()\"\u003e\u003ccode\u003eautomatic\u003c/code\u003e\u003c/a\u003e modules receive special treatment when creating a layer. An automatic module is created in the Java virtual machine as a \u003ccode\u003eModule\u003c/code\u003e that reads every unnamed \u003ccode\u003e Module\u003c/code\u003e in the Java virtual machine. \u003c/p\u003e \n\u003cp\u003e Unless otherwise specified, passing a \u003ccode\u003enull\u003c/code\u003e argument to a method in this class causes a \u003ca href\u003d\"NullPointerException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eNullPointerException\u003c/code\u003e\u003c/a\u003e to be thrown. \u003c/p\u003e \n\u003ch2\u003e Example usage: \u003c/h2\u003e \n\u003cp\u003e This example creates a configuration by resolving a module named \"\u003ccode\u003emyapp\u003c/code\u003e\" with the configuration for the boot layer as the parent. It then creates a new layer with the modules in this configuration. All modules are defined to the same class loader. \u003c/p\u003e \n\u003cpre\u003e\u003ccode\u003e\n     ModuleFinder finder \u003d ModuleFinder.of(dir1, dir2, dir3);\n\n     ModuleLayer parent \u003d ModuleLayer.boot();\n\n     Configuration cf \u003d parent.configuration().resolve(finder, ModuleFinder.of(), Set.of(\"myapp\"));\n\n     ClassLoader scl \u003d ClassLoader.getSystemClassLoader();\n\n     ModuleLayer layer \u003d parent.defineModulesWithOneLoader(cf, scl);\n\n     Class\u0026lt;?\u0026gt; c \u003d layer.findLoader(\"myapp\").loadClass(\"app.Main\");\n \u003c/code\u003e\u003c/pre\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Module.html#getLayer()\"\u003e\u003ccode\u003eModule.getLayer()\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "9"
    ]
  }
}