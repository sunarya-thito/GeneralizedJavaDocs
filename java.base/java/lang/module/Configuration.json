{
  "packageName": "java.lang.module",
  "simpleName": "Configuration",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.module.Configuration",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "before"
          }
        },
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "after"
          }
        },
        {
          "type": {
            "name": "java.util.Collection",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "roots"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "resolve",
      "comment": "Resolves a collection of root modules, with this configuration as its parent, to create a new configuration. This method works exactly as specified by the static resolve method when invoked with this configuration as the parent. In other words, if this configuration is cf then this method is equivalent to invoking:  \n     Configuration.resolve(before, List.of(cf), after, roots);",
      "tagMap": {
        "param": [
          "\u003ccode\u003ebefore\u003c/code\u003e - The \n\u003cem\u003ebefore\u003c/em\u003e module finder to find modules",
          "\u003ccode\u003eafter\u003c/code\u003e - The \n\u003cem\u003eafter\u003c/em\u003e module finder to locate modules when not located by the \n\u003ccode\u003ebefore\u003c/code\u003e module finder or in parent configurations",
          "\u003ccode\u003eroots\u003c/code\u003e - The possibly-empty collection of module names of the modules to resolve"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/FindException.html\" title\u003d\"class in java.lang.module\"\u003eFindException\u003c/a\u003e\u003c/code\u003e - If resolution fails for any of the observability-related reasons specified by the static \n\u003ccode\u003eresolve\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/ResolutionException.html\" title\u003d\"class in java.lang.module\"\u003eResolutionException\u003c/a\u003e\u003c/code\u003e - If resolution fails any of the consistency checks specified by the static \n\u003ccode\u003eresolve\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If locating a module is denied by the security manager"
        ],
        "return": [
          "The configuration that is the result of resolving the given root modules"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.module.Configuration",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "before"
          }
        },
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "after"
          }
        },
        {
          "type": {
            "name": "java.util.Collection",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "roots"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "resolveAndBind",
      "comment": "Resolves a collection of root modules, with service binding, and with this configuration as its parent, to create a new configuration. This method works exactly as specified by the static resolveAndBind method when invoked with this configuration as the parent. In other words, if this configuration is cf then this method is equivalent to invoking:  \n     Configuration.resolveAndBind(before, List.of(cf), after, roots);",
      "tagMap": {
        "param": [
          "\u003ccode\u003ebefore\u003c/code\u003e - The \n\u003cem\u003ebefore\u003c/em\u003e module finder to find modules",
          "\u003ccode\u003eafter\u003c/code\u003e - The \n\u003cem\u003eafter\u003c/em\u003e module finder to locate modules when not located by the \n\u003ccode\u003ebefore\u003c/code\u003e module finder or in parent configurations",
          "\u003ccode\u003eroots\u003c/code\u003e - The possibly-empty collection of module names of the modules to resolve"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/FindException.html\" title\u003d\"class in java.lang.module\"\u003eFindException\u003c/a\u003e\u003c/code\u003e - If resolution fails for any of the observability-related reasons specified by the static \n\u003ccode\u003eresolve\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/ResolutionException.html\" title\u003d\"class in java.lang.module\"\u003eResolutionException\u003c/a\u003e\u003c/code\u003e - If resolution fails any of the consistency checks specified by the static \n\u003ccode\u003eresolve\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If locating a module is denied by the security manager"
        ],
        "return": [
          "The configuration that is the result of resolving, with service binding, the given root modules"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.module.Configuration",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "before"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.module.Configuration",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "parents"
          }
        },
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "after"
          }
        },
        {
          "type": {
            "name": "java.util.Collection",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "roots"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "resolve",
      "comment": "Resolves a collection of root modules to create a configuration. Each root module is located using the given before module finder. If a module is not found then it is located in the parent configuration as if by invoking the findModule method on each parent in iteration order. If not found then the module is located using the given after module finder. The same search order is used to locate transitive dependences. Root modules or dependences that are located in a parent configuration are resolved no further and are not included in the resulting configuration. When all modules have been enumerated then a readability graph is computed, and in conjunction with the module exports and service use, checked for consistency. Resolution may fail with FindException for the following observability-related reasons: A root module, or a direct or transitive dependency, is not found. An error occurs when attempting to find a module. Possible errors include I/O errors, errors detected parsing a module descriptor (module-info.class) or two versions of the same module are found in the same directory. Resolution may fail with ResolutionException if any of the following consistency checks fail: A cycle is detected, say where module m1 requires module m2 and m2 requires m1. A module reads two or more modules with the same name. This includes the case where a module reads another with the same name as itself. Two or more modules in the configuration export the same package to a module that reads both. This includes the case where a module M containing package p reads another module that exports p to M. A module M declares that it \"uses p.S\" or \"provides p.S with ...\" but package p is neither in module M nor exported to M by any module that M reads.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ebefore\u003c/code\u003e - The \n\u003cem\u003ebefore\u003c/em\u003e module finder to find modules",
          "\u003ccode\u003eparents\u003c/code\u003e - The list parent configurations in search order",
          "\u003ccode\u003eafter\u003c/code\u003e - The \n\u003cem\u003eafter\u003c/em\u003e module finder to locate modules when not located by the \n\u003ccode\u003ebefore\u003c/code\u003e module finder or in parent configurations",
          "\u003ccode\u003eroots\u003c/code\u003e - The possibly-empty collection of module names of the modules to resolve"
        ],
        "implNote": [
          "In the implementation then observability of modules may depend on referential integrity or other checks that ensure different builds of tightly coupled modules or modules for specific operating systems or architectures are not combined in the same configuration."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/FindException.html\" title\u003d\"class in java.lang.module\"\u003eFindException\u003c/a\u003e\u003c/code\u003e - If resolution fails for any of observability-related reasons specified above",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/ResolutionException.html\" title\u003d\"class in java.lang.module\"\u003eResolutionException\u003c/a\u003e\u003c/code\u003e - If resolution fails for any of the consistency checks specified above",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the list of parents is empty, or the list has two or more parents with modules for different target operating systems, architectures, or versions",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If locating a module is denied by the security manager"
        ],
        "return": [
          "The configuration that is the result of resolving the given root modules"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.module.Configuration",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "before"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.module.Configuration",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "parents"
          }
        },
        {
          "type": {
            "name": "java.lang.module.ModuleFinder",
            "type": "Class"
          },
          "field": {
            "name": "after"
          }
        },
        {
          "type": {
            "name": "java.util.Collection",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "roots"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "resolveAndBind",
      "comment": "Resolves a collection of root modules, with service binding, to create configuration. This method works exactly as specified by resolve except that the graph of resolved modules is augmented with modules induced by the service-use dependence relation. More specifically, the root modules are resolved as if by calling resolve. The resolved modules, and all modules in the parent configurations, with service dependences are then examined. All modules found by the given module finders that provide an implementation of one or more of the service types are added to the module graph and then resolved as if by calling the resolve method. Adding modules to the module graph may introduce new service-use dependences and so the process works iteratively until no more modules are added. As service binding involves resolution then it may fail with FindException or ResolutionException for exactly the same reasons specified in resolve.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ebefore\u003c/code\u003e - The \n\u003cem\u003ebefore\u003c/em\u003e module finder to find modules",
          "\u003ccode\u003eparents\u003c/code\u003e - The list parent configurations in search order",
          "\u003ccode\u003eafter\u003c/code\u003e - The \n\u003cem\u003eafter\u003c/em\u003e module finder to locate modules when not located by the \n\u003ccode\u003ebefore\u003c/code\u003e module finder or in parent configurations",
          "\u003ccode\u003eroots\u003c/code\u003e - The possibly-empty collection of module names of the modules to resolve"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/FindException.html\" title\u003d\"class in java.lang.module\"\u003eFindException\u003c/a\u003e\u003c/code\u003e - If resolution fails for any of the observability-related reasons specified by the static \n\u003ccode\u003eresolve\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/module/ResolutionException.html\" title\u003d\"class in java.lang.module\"\u003eResolutionException\u003c/a\u003e\u003c/code\u003e - If resolution fails any of the consistency checks specified by the static \n\u003ccode\u003eresolve\u003c/code\u003e method",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - If the list of parents is empty, or the list has two or more parents with modules for different target operating systems, architectures, or versions",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - If locating a module is denied by the security manager"
        ],
        "return": [
          "The configuration that is the result of resolving, with service binding, the given root modules"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.module.Configuration",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "empty",
      "comment": "Returns the empty configuration. There are no modules in the empty configuration. It has no parents.",
      "tagMap": {
        "return": [
          "The empty configuration"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "java.lang.module.Configuration",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "parents",
      "comment": "Returns an unmodifiable list of this configuration\u0027s parents, in search order. If this is the empty configuration then an empty list is returned.",
      "tagMap": {
        "return": [
          "A possibly-empty unmodifiable list of this parent configurations"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Set",
        "parameters": [
          {
            "name": "java.lang.module.ResolvedModule",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "modules",
      "comment": "Returns an unmodifiable set of the resolved modules in this configuration.",
      "tagMap": {
        "return": [
          "A possibly-empty unmodifiable set of the resolved modules in this configuration"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "name": "java.lang.module.ResolvedModule",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findModule",
      "comment": "Finds a resolved module in this configuration, or if not in this configuration, the parent configurations. Finding a module in parent configurations is equivalent to invoking findModule on each parent, in search order, until the module is found or all parents have been searched. In a tree of configurations then this is equivalent to a depth-first search.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ename\u003c/code\u003e - The module name of the resolved module to find"
        ],
        "return": [
          "The resolved module with the given name or an empty \n\u003ccode\u003e Optional\u003c/code\u003e if there isn\u0027t a module with this name in this configuration or any parent configurations"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a string describing this configuration.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "A possibly empty string describing this configuration"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.lang.module.Configuration",
  "comment": "A configuration that is the result of \n\u003ca href\u003d\"package-summary.html#resolution\"\u003e resolution\u003c/a\u003e or resolution with \n\u003ca href\u003d\"../../../../java.base/java/lang/module/Configuration.html#service-binding\"\u003eservice binding\u003c/a\u003e. \n\u003cp\u003e A configuration encapsulates the \u003cem\u003ereadability graph\u003c/em\u003e that is the output of resolution. A readability graph is a directed graph whose vertices are of type \u003ca href\u003d\"ResolvedModule.html\" title\u003d\"class in java.lang.module\"\u003e\u003ccode\u003eResolvedModule\u003c/code\u003e\u003c/a\u003e and the edges represent the readability amongst the modules. \u003ccode\u003eConfiguration\u003c/code\u003e defines the \u003ca href\u003d\"#modules()\"\u003e\u003ccode\u003emodules()\u003c/code\u003e\u003c/a\u003e method to get the set of resolved modules in the graph. \u003ccode\u003e ResolvedModule\u003c/code\u003e defines the \u003ca href\u003d\"ResolvedModule.html#reads()\"\u003e\u003ccode\u003ereads()\u003c/code\u003e\u003c/a\u003e method to get the set of modules that a resolved module reads. The modules that are read may be in the same configuration or may be in \u003ca href\u003d\"#parents()\"\u003e\u003ccode\u003eparent\u003c/code\u003e\u003c/a\u003e configurations. \u003c/p\u003e \n\u003cp\u003e Configuration defines the \u003ca href\u003d\"#resolve(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)\"\u003e\u003ccode\u003eresolve\u003c/code\u003e\u003c/a\u003e method to resolve a collection of root modules, and the \u003ca href\u003d\"#resolveAndBind(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)\"\u003e\u003ccode\u003eresolveAndBind\u003c/code\u003e\u003c/a\u003e method to do resolution with service binding. There are instance and static variants of both methods. The instance methods create a configuration with the receiver as the parent configuration. The static methods are for more advanced cases where there can be more than one parent configuration. \u003c/p\u003e \n\u003cp\u003e Each \u003ca href\u003d\"../ModuleLayer.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003elayer\u003c/code\u003e\u003c/a\u003e of modules in the Java virtual machine is created from a configuration. The configuration for the \u003ca href\u003d\"../ModuleLayer.html#boot()\"\u003e\u003ccode\u003eboot\u003c/code\u003e\u003c/a\u003e layer is obtained by invoking \u003ccode\u003e ModuleLayer.boot().configuration()\u003c/code\u003e. The configuration for the boot layer will often be the parent when creating new configurations. \u003c/p\u003e \n\u003ch2\u003e Example \u003c/h2\u003e \n\u003cp\u003e The following example uses the \u003ca href\u003d\"#resolve(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)\"\u003e\u003ccode\u003eresolve\u003c/code\u003e\u003c/a\u003e method to resolve a module named \u003cem\u003emyapp\u003c/em\u003e with the configuration for the boot layer as the parent configuration. It prints the name of each resolved module and the names of the modules that each module reads. \u003c/p\u003e \n\u003cpre\u003e\u003ccode\u003e\n    ModuleFinder finder \u003d ModuleFinder.of(dir1, dir2, dir3);\n\n    Configuration parent \u003d ModuleLayer.boot().configuration();\n\n    Configuration cf \u003d parent.resolve(finder, ModuleFinder.of(), Set.of(\"myapp\"));\n    cf.modules().forEach(m -\u0026gt; {\n        System.out.format(\"%s -\u0026gt; %s%n\",\n            m.name(),\n            m.reads().stream()\n                .map(ResolvedModule::name)\n                .collect(Collectors.joining(\", \")));\n    });\n \u003c/code\u003e\u003c/pre\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ModuleLayer.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eModuleLayer\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "9"
    ]
  }
}