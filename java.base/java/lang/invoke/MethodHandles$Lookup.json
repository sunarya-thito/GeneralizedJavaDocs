{
  "packageName": "java.lang.invoke",
  "simpleName": "Lookup",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "PUBLIC",
      "comment": "A single-bit mask representing public access, which may contribute to the result of lookupModes. The value, 0x01, happens to be the same as the value of the public modifier bit. A Lookup with this lookup mode performs cross-module access check with respect to the lookup class and previous lookup class if present.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandles.Lookup.PUBLIC\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "PRIVATE",
      "comment": "A single-bit mask representing private access, which may contribute to the result of lookupModes. The value, 0x02, happens to be the same as the value of the private modifier bit.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandles.Lookup.PRIVATE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "PROTECTED",
      "comment": "A single-bit mask representing protected access, which may contribute to the result of lookupModes. The value, 0x04, happens to be the same as the value of the protected modifier bit.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandles.Lookup.PROTECTED\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "PACKAGE",
      "comment": "A single-bit mask representing package access (default access), which may contribute to the result of lookupModes. The value is 0x08, which does not correspond meaningfully to any particular modifier bit.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandles.Lookup.PACKAGE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "MODULE",
      "comment": "A single-bit mask representing module access, which may contribute to the result of lookupModes. The value is 0x10, which does not correspond meaningfully to any particular modifier bit. In conjunction with the PUBLIC modifier bit, a Lookup with this lookup mode can access all public types in the module of the lookup class and public types in packages exported by other modules to the module of the lookup class. If this lookup mode is set, the previous lookup class is always null.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandles.Lookup.MODULE\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "UNCONDITIONAL",
      "comment": "A single-bit mask representing unconditional access which may contribute to the result of lookupModes. The value is 0x20, which does not correspond meaningfully to any particular modifier bit. A Lookup with this lookup mode assumes readability. This lookup mode can access all public members of public types of all modules when the type is in a package that is exported unconditionally. If this lookup mode is set, the previous lookup class is always null.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#publicLookup()\"\u003e\u003ccode\u003eMethodHandles.publicLookup()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandles.Lookup.UNCONDITIONAL\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ORIGINAL",
      "comment": "A single-bit mask representing original access which may contribute to the result of lookupModes. The value is 0x40, which does not correspond meaningfully to any particular modifier bit. If this lookup mode is set, the Lookup object must be created by the original lookup class by calling MethodHandles.lookup() method or by a bootstrap method invoked by the VM. The Lookup object with this lookup mode has full privilege access.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandles.Lookup.ORIGINAL\"\u003eConstant Field Values\u003c/a\u003e"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "lookupClass",
      "comment": "Tells which class is performing the lookup. It is this class against which checks are performed for visibility and access permissions. If this lookup object has a previous lookup class, access checks are performed against both the lookup class and the previous lookup class. The class implies a maximum level of access permission, but the permissions may be additionally limited by the bitmask lookupModes, which controls whether non-public members can be accessed.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#cross-module-lookup\"\u003eCross-module lookups\u003c/a\u003e"
        ],
        "return": [
          "the lookup class, on behalf of which this lookup object finds members"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "previousLookupClass",
      "comment": "Reports a lookup class in another module that this lookup object was previously teleported from, or null. A Lookup object produced by the factory methods, such as the lookup() and publicLookup() method, has null previous lookup class. A Lookup object has a non-null previous lookup class when this lookup was teleported from an old lookup class in one module to a new lookup class in another module.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#in(java.lang.Class)\"\u003e\u003ccode\u003ein(Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003eMethodHandles.privateLookupIn(Class, Lookup)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#cross-module-lookup\"\u003eCross-module lookups\u003c/a\u003e"
        ],
        "return": [
          "the lookup class in another module that this lookup object was previously teleported from, or \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "since": [
          "14"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "lookupModes",
      "comment": "Tells which access-protection classes of members this lookup object can produce. The result is a bit-mask of the bits PUBLIC (0x01), PRIVATE (0x02), PROTECTED (0x04), PACKAGE (0x08), MODULE (0x10), UNCONDITIONAL (0x20), and ORIGINAL (0x40). A freshly-created lookup object on the caller\u0027s class has all possible bits set, except UNCONDITIONAL. A lookup object on a new lookup class created from a previous lookup object may have some mode bits set to zero. Mode bits can also be directly cleared. Once cleared, mode bits cannot be restored from the downgraded lookup object. The purpose of this is to restrict access via the new lookup object, so that it can access only names which can be reached by the original lookup object, and also by the new lookup class.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#in(java.lang.Class)\"\u003e\u003ccode\u003ein(java.lang.Class\u0026lt;?\u0026gt;)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#dropLookupMode(int)\"\u003e\u003ccode\u003edropLookupMode(int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the lookup modes, which limit the kinds of access performed by this lookup object"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandles$Lookup",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "requestedLookupClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "in",
      "comment": "Creates a lookup on the specified new lookup class. The resulting object will report the specified class as its own lookupClass. However, the resulting Lookup object is guaranteed to have no more access capabilities than the original. In particular, access capabilities can be lost as follows: If the new lookup class is different from the old lookup class, i.e. ORIGINAL access is lost. If the new lookup class is in a different module from the old one, i.e. MODULE access is lost. If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible, i.e. PROTECTED and PACKAGE access are lost. If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance, i.e. PRIVATE access is lost. (Protected members may continue to be accessible because of package sharing.) If the new lookup class is not accessible to this lookup, then no members, not even public members, will be accessible i.e. all access modes are lost. If the new lookup class, the old lookup class and the previous lookup class are all in different modules i.e. teleporting to a third module, all access modes are lost. The new previous lookup class is chosen as follows: If the new lookup object has UNCONDITIONAL bit, the new previous lookup class is null. If the new lookup class is in the same module as the old lookup class, the new previous lookup class is the old previous lookup class. If the new lookup class is in a different module from the old lookup class, the new previous lookup class is the old lookup class. The resulting lookup\u0027s capabilities for loading classes (used during findClass(java.lang.String) invocations) are determined by the lookup class\u0027 loader, which may change due to this operation.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#accessClass(java.lang.Class)\"\u003e\u003ccode\u003eaccessClass(Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#cross-module-lookup\"\u003eCross-module lookups\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003erequestedLookupClass\u003c/code\u003e - the desired lookup class for the new lookup object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003erequestedLookupClass\u003c/code\u003e is a primitive type or void or array class",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a lookup object which reports the desired lookup class, or the same object if there is no change"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandles$Lookup",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "modeToDrop"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "dropLookupMode",
      "comment": "Creates a lookup on the same lookup class which this lookup object finds members, but with a lookup mode that has lost the given lookup mode. The lookup mode to drop is one of PUBLIC, MODULE, PACKAGE, PROTECTED, PRIVATE, ORIGINAL, or UNCONDITIONAL. If this lookup is a public lookup, this lookup has UNCONDITIONAL mode set and it has no other mode set. When dropping UNCONDITIONAL on a public lookup then the resulting lookup has no access. If this lookup is not a public lookup, then the following applies regardless of its lookup modes. PROTECTED and ORIGINAL are always dropped and so the resulting lookup mode will never have these access capabilities. When dropping PACKAGE then the resulting lookup will not have PACKAGE or PRIVATE access. When dropping MODULE then the resulting lookup will not have MODULE, PACKAGE, or PRIVATE access. When dropping PUBLIC then the resulting lookup has no access.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003eMethodHandles.privateLookupIn(java.lang.Class\u0026lt;?\u0026gt;, java.lang.invoke.MethodHandles.Lookup)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "A lookup with \n\u003ccode\u003ePACKAGE\u003c/code\u003e but not \n\u003ccode\u003ePRIVATE\u003c/code\u003e mode can safely delegate non-public access within the package of the lookup class without conferring \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#privacc\"\u003eprivate access\u003c/a\u003e. A lookup with \n\u003ccode\u003eMODULE\u003c/code\u003e but not \n\u003ccode\u003ePACKAGE\u003c/code\u003e mode can safely delegate \n\u003ccode\u003ePUBLIC\u003c/code\u003e access within the module of the lookup class without conferring package access. A lookup with a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#previousLookupClass()\"\u003eprevious lookup class\u003c/a\u003e (and \n\u003ccode\u003ePUBLIC\u003c/code\u003e but not \n\u003ccode\u003eMODULE\u003c/code\u003e mode) can safely delegate access to public classes accessible to both the module of the lookup class and the module of the previous lookup class."
        ],
        "param": [
          "\u003ccode\u003emodeToDrop\u003c/code\u003e - the lookup mode to drop"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emodeToDrop\u003c/code\u003e is not one of \n\u003ccode\u003ePUBLIC\u003c/code\u003e, \n\u003ccode\u003eMODULE\u003c/code\u003e, \n\u003ccode\u003ePACKAGE\u003c/code\u003e, \n\u003ccode\u003ePROTECTED\u003c/code\u003e, \n\u003ccode\u003ePRIVATE\u003c/code\u003e, \n\u003ccode\u003eORIGINAL\u003c/code\u003e or \n\u003ccode\u003eUNCONDITIONAL\u003c/code\u003e"
        ],
        "return": [
          "a lookup object which lacks the indicated mode, or the same object if there is no change"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "bytes"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "defineClass",
      "comment": "Creates and links a class or interface from bytes with the same class loader and in the same runtime package and protection domain as this lookup\u0027s lookup class as if calling ClassLoader::defineClass. The lookup modes for this lookup must include PACKAGE access as default (package) members will be accessible to the class. The PACKAGE lookup mode serves to authenticate that the lookup object was created by a caller in the runtime package (or derived from a lookup originally created by suitably privileged code to a target class in the runtime package). The bytes parameter is the class bytes of a valid class file (as defined by the The Java Virtual Machine Specification) with a class name in the same package as the lookup class. This method does not run the class initializer. The class initializer may run at a later time, as detailed in section 12.4 of the The Java Language Specification. If there is a security manager and this lookup does not have full privilege access, its checkPermission method is first called to check RuntimePermission(\"defineClass\").",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003eMethodHandles.privateLookupIn(java.lang.Class\u0026lt;?\u0026gt;, java.lang.invoke.MethodHandles.Lookup)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#dropLookupMode(int)\"\u003e\u003ccode\u003edropLookupMode(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassLoader.html#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)\"\u003e\u003ccode\u003eClassLoader.defineClass(String,byte[],int,int,ProtectionDomain)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ebytes\u003c/code\u003e - the class bytes"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if this lookup does not have \n\u003ccode\u003ePACKAGE\u003c/code\u003e access",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassFormatError.html\" title\u003d\"class in java.lang\"\u003eClassFormatError\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e is not a \n\u003ccode\u003eClassFile\u003c/code\u003e structure",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e denotes a class in a different package than the lookup class or \n\u003ccode\u003ebytes\u003c/code\u003e is not a class or interface (\n\u003ccode\u003eACC_MODULE\u003c/code\u003e flag is set in the value of the \n\u003ccode\u003eaccess_flags\u003c/code\u003e item)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/VerifyError.html\" title\u003d\"class in java.lang\"\u003eVerifyError\u003c/a\u003e\u003c/code\u003e - if the newly created class cannot be verified",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LinkageError.html\" title\u003d\"class in java.lang\"\u003eLinkageError\u003c/a\u003e\u003c/code\u003e - if the newly created class cannot be linked for any other reason",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the \n\u003ccode\u003eClass\u003c/code\u003e object for the class"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandles$Lookup",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "bytes"
          }
        },
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "initialize"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandles$Lookup$ClassOption",
            "type": "Class"
          },
          "field": {
            "name": "options"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "defineHiddenClass",
      "comment": "Creates a hidden class or interface from bytes, returning a Lookup on the newly created class or interface. Ordinarily, a class or interface C is created by a class loader, which either defines C directly or delegates to another class loader. A class loader defines C directly by invoking ClassLoader::defineClass, which causes the Java Virtual Machine to derive C from a purported representation in class file format. In situations where use of a class loader is undesirable, a class or interface C can be created by this method instead. This method is capable of defining C, and thereby creating it, without invoking ClassLoader::defineClass. Instead, this method defines C as if by arranging for the Java Virtual Machine to derive a nonarray class or interface C from a purported representation in class file format using the following rules: The lookup modes for this Lookup must include full privilege access. This level of access is needed to create C in the module of the lookup class of this Lookup. The purported representation in bytes must be a ClassFile structure of a supported major and minor version. The major and minor version may differ from the class file version of the lookup class of this Lookup. The value of this_class must be a valid index in the constant_pool table, and the entry at that index must be a valid CONSTANT_Class_info structure. Let N be the binary name encoded in internal form that is specified by this structure. N must denote a class or interface in the same package as the lookup class. Let CN be the string N + \".\" + \u003csuffix\u003e, where \u003csuffix\u003e is an unqualified name. Let newBytes be the ClassFile structure given by bytes with an additional entry in the constant_pool table, indicating a CONSTANT_Utf8_info structure for CN, and where the CONSTANT_Class_info structure indicated by this_class refers to the new CONSTANT_Utf8_info structure. Let L be the defining class loader of the lookup class of this Lookup. C is derived with name CN, class loader L, and purported representation newBytes as if by the rules of JVMS 5.3.5, with the following adjustments: The constant indicated by this_class is permitted to specify a name that includes a single \".\" character, even though this is not a valid binary class or interface name in internal form. The Java Virtual Machine marks L as the defining class loader of C, but no class loader is recorded as an initiating class loader of C. C is considered to have the same runtime package, module and protection domain as the lookup class of this Lookup. Let GN be the binary name obtained by taking N (a binary name encoded in internal form) and replacing ASCII forward slashes with ASCII periods. For the instance of Class representing C: Class.getName() returns the string GN + \"/\" + \u003csuffix\u003e, even though this is not a valid binary class or interface name. Class.descriptorString() returns the string \"L\" + N + \".\" + \u003csuffix\u003e + \";\", even though this is not a valid type descriptor name. Class.describeConstable() returns an empty optional as C cannot be described in nominal form. After C is derived, it is linked by the Java Virtual Machine. Linkage occurs as specified in JVMS 5.4.3, with the following adjustments: During verification, whenever it is necessary to load the class named CN, the attempt succeeds, producing class C. No request is made of any class loader. On any attempt to resolve the entry in the run-time constant pool indicated by this_class, the symbolic reference is considered to be resolved to C and resolution always succeeds immediately. If the initialize parameter is true, then C is initialized by the Java Virtual Machine. The newly created class or interface C serves as the lookup class of the Lookup object returned by this method. C is hidden in the sense that no other class or interface can refer to C via a constant pool entry. That is, a hidden class or interface cannot be named as a supertype, a field type, a method parameter type, or a method return type by any other class. This is because a hidden class or interface does not have a binary name, so there is no internal form available to record in any class\u0027s constant pool. A hidden class or interface is not discoverable by Class.forName(String, boolean, ClassLoader), ClassLoader.loadClass(String, boolean), or findClass(String), and is not modifiable by Java agents or tool agents using the JVM Tool Interface. A class or interface created by a class loader has a strong relationship with that class loader. That is, every Class object contains a reference to the ClassLoader that defined it. This means that a class created by a class loader may be unloaded if and only if its defining loader is not reachable and thus may be reclaimed by a garbage collector (JLS 12.7). By default, however, a hidden class or interface may be unloaded even if the class loader that is marked as its defining loader is reachable. This behavior is useful when a hidden class or interface serves multiple classes defined by arbitrary class loaders. In other cases, a hidden class or interface may be linked to a single class (or a small number of classes) with the same defining loader as the hidden class or interface. In such cases, where the hidden class or interface must be coterminous with a normal class or interface, the STRONG option may be passed in options. This arranges for a hidden class to have the same strong relationship with the class loader marked as its defining loader, as a normal class or interface has with its own defining loader. If STRONG is not used, then the invoker of defineHiddenClass may still prevent a hidden class or interface from being unloaded by ensuring that the Class object is reachable. The unloading characteristics are set for each hidden class when it is defined, and cannot be changed later. An advantage of allowing hidden classes to be unloaded independently of the class loader marked as their defining loader is that a very large number of hidden classes may be created by an application. In contrast, if STRONG is used, then the JVM may run out of memory, just as if normal classes were created by class loaders. Classes and interfaces in a nest are allowed to have mutual access to their private members. The nest relationship is determined by the NestHost attribute (JVMS 4.7.28) and the NestMembers attribute (JVMS 4.7.29) in a class file. By default, a hidden class belongs to a nest consisting only of itself because a hidden class has no binary name. The NESTMATE option can be passed in options to create a hidden class or interface C as a member of a nest. The nest to which C belongs is not based on any NestHost attribute in the ClassFile structure from which C was derived. Instead, the following rules determine the nest host of C: If the nest host of the lookup class of this Lookup has previously been determined, then let H be the nest host of the lookup class. Otherwise, the nest host of the lookup class is determined using the algorithm in JVMS 5.4.4, yielding H. The nest host of C is determined to be H, the nest host of the lookup class. A hidden class or interface may be serializable, but this requires a custom serialization mechanism in order to ensure that instances are properly serialized and deserialized. The default serialization mechanism supports only classes and interfaces that are discoverable by their class name.",
      "tagMap": {
        "See Java Language Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-12.html#jls-12.7\"\u003e12.7 Unloading of Classes and Interfaces\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#isHidden()\"\u003e\u003ccode\u003eClass.isHidden()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ebytes\u003c/code\u003e - the bytes that make up the class data, in the format of a valid \n\u003ccode\u003eclass\u003c/code\u003e file as defined by \n\u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.",
          "\u003ccode\u003einitialize\u003c/code\u003e - if \n\u003ccode\u003etrue\u003c/code\u003e the class will be initialized.",
          "\u003ccode\u003eoptions\u003c/code\u003e - \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.ClassOption.html\" title\u003d\"enum class in java.lang.invoke\"\u003eclass options\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if this \n\u003ccode\u003eLookup\u003c/code\u003e does not have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#hasFullPrivilegeAccess()\"\u003efull privilege\u003c/a\u003e access",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassFormatError.html\" title\u003d\"class in java.lang\"\u003eClassFormatError\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e is not a \n\u003ccode\u003eClassFile\u003c/code\u003e structure",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedClassVersionError.html\" title\u003d\"class in java.lang\"\u003eUnsupportedClassVersionError\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e is not of a supported major or minor version",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e denotes a class in a different package than the lookup class or \n\u003ccode\u003ebytes\u003c/code\u003e is not a class or interface (\n\u003ccode\u003eACC_MODULE\u003c/code\u003e flag is set in the value of the \n\u003ccode\u003eaccess_flags\u003c/code\u003e item)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IncompatibleClassChangeError.html\" title\u003d\"class in java.lang\"\u003eIncompatibleClassChangeError\u003c/a\u003e\u003c/code\u003e - if the class or interface named as the direct superclass of \n\u003ccode\u003eC\u003c/code\u003e is in fact an interface, or if any of the classes or interfaces named as direct superinterfaces of \n\u003ccode\u003eC\u003c/code\u003e are not in fact interfaces",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCircularityError.html\" title\u003d\"class in java.lang\"\u003eClassCircularityError\u003c/a\u003e\u003c/code\u003e - if any of the superclasses or superinterfaces of \n\u003ccode\u003eC\u003c/code\u003e is \n\u003ccode\u003eC\u003c/code\u003e itself",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/VerifyError.html\" title\u003d\"class in java.lang\"\u003eVerifyError\u003c/a\u003e\u003c/code\u003e - if the newly created class cannot be verified",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LinkageError.html\" title\u003d\"class in java.lang\"\u003eLinkageError\u003c/a\u003e\u003c/code\u003e - if the newly created class cannot be linked for any other reason",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any parameter is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.2.1\"\u003e4.2.1 Binary Class and Interface Names\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.2.2\"\u003e4.2.2 Unqualified Names\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.7.28\"\u003e4.7.28 The \u003ccode\u003eNestHost\u003c/code\u003e Attribute\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.7.29\"\u003e4.7.29 The \u003ccode\u003eNestMembers\u003c/code\u003e Attribute\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.3.1\"\u003e5.4.3.1 Class and Interface Resolution\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.4\"\u003e5.4.4 Access Control\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.3.5\"\u003e5.3.5 Deriving a \u003ccode\u003eClass\u003c/code\u003e from a \u003ccode\u003eclass\u003c/code\u003e File Representation\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4\"\u003e5.4 Linking\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.5\"\u003e5.5 Initialization\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "the \n\u003ccode\u003eLookup\u003c/code\u003e object on the hidden class, with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#ORIGINAL\"\u003eoriginal\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#hasFullPrivilegeAccess()\"\u003efull privilege\u003c/a\u003e access"
        ],
        "since": [
          "15"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandles$Lookup",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "bytes"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "classData"
          }
        },
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "initialize"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandles$Lookup$ClassOption",
            "type": "Class"
          },
          "field": {
            "name": "options"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "defineHiddenClassWithClassData",
      "comment": "Creates a hidden class or interface from bytes with associated class data, returning a Lookup on the newly created class or interface. This method is equivalent to calling defineHiddenClass(bytes, initialize, options) as if the hidden class is injected with a private static final unnamed field which is initialized with the given classData at the first instruction of the class initializer. The newly created class is linked by the Java Virtual Machine. The MethodHandles::classData and MethodHandles::classDataAt methods can be used to retrieve the classData.",
      "tagMap": {
        "See Java Language Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-12.html#jls-12.7\"\u003e12.7 Unloading of Classes and Interface\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)\"\u003e\u003ccode\u003edefineHiddenClass(byte[], boolean, ClassOption...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#isHidden()\"\u003e\u003ccode\u003eClass.isHidden()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#classData(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003eMethodHandles.classData(Lookup, String, Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#classDataAt(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.Class,int)\"\u003e\u003ccode\u003eMethodHandles.classDataAt(Lookup, String, Class, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "A framework can create a hidden class with class data with one or more objects and load the class data as dynamically-computed constant(s) via a bootstrap method. \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#classData(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003eClass data\u003c/code\u003e\u003c/a\u003e is accessible only to the lookup object created by the newly defined hidden class but inaccessible to other members in the same nest (unlike private static fields that are accessible to nestmates). Care should be taken w.r.t. mutability for example when passing an array or other mutable structure through the class data. Changing any value stored in the class data at runtime may lead to unpredictable behavior. If the class data is a \n\u003ccode\u003eList\u003c/code\u003e, it is good practice to make it unmodifiable for example via \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/List.html#of()\"\u003e\u003ccode\u003eList::of\u003c/code\u003e\u003c/a\u003e."
        ],
        "param": [
          "\u003ccode\u003ebytes\u003c/code\u003e - the class bytes",
          "\u003ccode\u003eclassData\u003c/code\u003e - pre-initialized class data",
          "\u003ccode\u003einitialize\u003c/code\u003e - if \n\u003ccode\u003etrue\u003c/code\u003e the class will be initialized.",
          "\u003ccode\u003eoptions\u003c/code\u003e - \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.ClassOption.html\" title\u003d\"enum class in java.lang.invoke\"\u003eclass options\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if this \n\u003ccode\u003eLookup\u003c/code\u003e does not have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#hasFullPrivilegeAccess()\"\u003efull privilege\u003c/a\u003e access",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassFormatError.html\" title\u003d\"class in java.lang\"\u003eClassFormatError\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e is not a \n\u003ccode\u003eClassFile\u003c/code\u003e structure",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedClassVersionError.html\" title\u003d\"class in java.lang\"\u003eUnsupportedClassVersionError\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e is not of a supported major or minor version",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ebytes\u003c/code\u003e denotes a class in a different package than the lookup class or \n\u003ccode\u003ebytes\u003c/code\u003e is not a class or interface (\n\u003ccode\u003eACC_MODULE\u003c/code\u003e flag is set in the value of the \n\u003ccode\u003eaccess_flags\u003c/code\u003e item)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IncompatibleClassChangeError.html\" title\u003d\"class in java.lang\"\u003eIncompatibleClassChangeError\u003c/a\u003e\u003c/code\u003e - if the class or interface named as the direct superclass of \n\u003ccode\u003eC\u003c/code\u003e is in fact an interface, or if any of the classes or interfaces named as direct superinterfaces of \n\u003ccode\u003eC\u003c/code\u003e are not in fact interfaces",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCircularityError.html\" title\u003d\"class in java.lang\"\u003eClassCircularityError\u003c/a\u003e\u003c/code\u003e - if any of the superclasses or superinterfaces of \n\u003ccode\u003eC\u003c/code\u003e is \n\u003ccode\u003eC\u003c/code\u003e itself",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/VerifyError.html\" title\u003d\"class in java.lang\"\u003eVerifyError\u003c/a\u003e\u003c/code\u003e - if the newly created class cannot be verified",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LinkageError.html\" title\u003d\"class in java.lang\"\u003eLinkageError\u003c/a\u003e\u003c/code\u003e - if the newly created class cannot be linked for any other reason",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any parameter is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.2.1\"\u003e4.2.1 Binary Class and Interface Names\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.2.2\"\u003e4.2.2 Unqualified Names\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.7.28\"\u003e4.7.28 The \u003ccode\u003eNestHost\u003c/code\u003e Attribute\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.7.29\"\u003e4.7.29 The \u003ccode\u003eNestMembers\u003c/code\u003e Attribute\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.3.1\"\u003e5.4.3.1 Class and Interface Resolution\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.4\"\u003e5.4.4 Access Control\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.3.5\"\u003e5.3.5 Deriving a \u003ccode\u003eClass\u003c/code\u003e from a \u003ccode\u003eclass\u003c/code\u003e File Representation\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4\"\u003e5.4 Linking\u003c/a\u003e\n\u003cbr\u003e\n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.5\"\u003e5.5 Initialization\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "the \n\u003ccode\u003eLookup\u003c/code\u003e object on the hidden class, with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#ORIGINAL\"\u003eoriginal\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#hasFullPrivilegeAccess()\"\u003efull privilege\u003c/a\u003e access"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Displays the name of the class from which lookups are to be made, followed by \"/\" and the name of the previous lookup class if present. (The name is the one reported by Class.getName.) If there are restrictions on the access permitted to this lookup, this is indicated by adding a suffix to the class name, consisting of a slash and a keyword. The keyword represents the strongest allowed access, and is chosen as follows: If no access is allowed, the suffix is \"/noaccess\". If only unconditional access is allowed, the suffix is \"/publicLookup\". If only public access to types in exported packages is allowed, the suffix is \"/public\". If only public and module access are allowed, the suffix is \"/module\". If public and package access are allowed, the suffix is \"/package\". If public, package, and private access are allowed, the suffix is \"/private\". If none of the above cases apply, it is the case that full privilege access (public, module, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from MethodHandles.lookup. Objects created by Lookup.in always have restricted access, and will display a suffix. (It may seem strange that protected access should be stronger than private access. Viewed independently from package access, protected access is the first to be lost, because it requires a direct subclass relationship between caller and callee.)",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#in(java.lang.Class)\"\u003e\u003ccode\u003ein(java.lang.Class\u0026lt;?\u0026gt;)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a string representation of the object."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchMethodException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findStatic",
      "comment": "Produces a method handle for a static method. The type of the method handle will be that of the method. (Since static methods do not take receivers, there is no additional receiver argument inserted into the method handle type, as there would be with findVirtual or findSpecial.) The method and all its argument types must be accessible to the lookup object. The returned method handle will have variable arity if and only if the method\u0027s variable arity modifier bit (0x0080) is set. If the returned method handle is invoked, the method\u0027s class will be initialized, if it has not already been initialized. Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_asList \u003d publicLookup().findStatic(Arrays.class,\n  \"asList\", methodType(List.class, Object[].class));\nassertEquals(\"[x, y]\", MH_asList.invoke(\"x\", \"y\").toString());",
      "tagMap": {
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the name of the method",
          "\u003ccode\u003etype\u003c/code\u003e - the type of the method"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchMethodException.html\" title\u003d\"class in java.lang\"\u003eNoSuchMethodException\u003c/a\u003e\u003c/code\u003e - if the method does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the method is not \n\u003ccode\u003estatic\u003c/code\u003e, or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "the desired method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchMethodException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findVirtual",
      "comment": "Produces a method handle for a virtual method. The type of the method handle will be that of the method, with the receiver type (usually refc) prepended. The method and all its argument types must be accessible to the lookup object. When called, the handle will treat the first argument as a receiver and, for non-private methods, dispatch on the receiver\u0027s type to determine which method implementation to enter. For private methods the named method in refc will be invoked on the receiver. (The dispatching action is identical with that performed by an invokevirtual or invokeinterface instruction.) The first argument will be of type refc if the lookup class has full privileges to access the member. Otherwise the member must be protected and the first argument will be restricted in type to the lookup class. The returned method handle will have variable arity if and only if the method\u0027s variable arity modifier bit (0x0080) is set. Because of the general equivalence between invokevirtual instructions and method handles produced by findVirtual, if the class is MethodHandle and the name string is invokeExact or invoke, the resulting method handle is equivalent to one produced by MethodHandles.exactInvoker or MethodHandles.invoker with the same type argument. If the class is VarHandle and the name string corresponds to the name of a signature-polymorphic access mode method, the resulting method handle is equivalent to one produced by MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType) with the access mode corresponding to the name string and with the same type arguments. Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_concat \u003d publicLookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_hashCode \u003d publicLookup().findVirtual(Object.class,\n  \"hashCode\", methodType(int.class));\nMethodHandle MH_hashCode_String \u003d publicLookup().findVirtual(String.class,\n  \"hashCode\", methodType(int.class));\nassertEquals(\"xy\", (String) MH_concat.invokeExact(\"x\", \"y\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode.invokeExact((Object)\"xy\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode_String.invokeExact(\"xy\"));\n// interface method:\nMethodHandle MH_subSequence \u003d publicLookup().findVirtual(CharSequence.class,\n  \"subSequence\", methodType(CharSequence.class, int.class, int.class));\nassertEquals(\"def\", MH_subSequence.invoke(\"abcdefghi\", 3, 6).toString());\n// constructor \"internal method\" must be accessed differently:\nMethodType MT_newString \u003d methodType(void.class); //()V for new String()\ntry { assertEquals(\"impossible\", lookup()\n        .findVirtual(String.class, \"\u003cinit\u003e\", MT_newString));\n } catch (NoSuchMethodException ex) { } // OK\nMethodHandle MH_newString \u003d publicLookup()\n  .findConstructor(String.class, MT_newString);\nassertEquals(\"\", (String) MH_newString.invokeExact());",
      "tagMap": {
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class or interface from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the name of the method",
          "\u003ccode\u003etype\u003c/code\u003e - the type of the method, with the receiver argument omitted"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchMethodException.html\" title\u003d\"class in java.lang\"\u003eNoSuchMethodException\u003c/a\u003e\u003c/code\u003e - if the method does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the method is \n\u003ccode\u003estatic\u003c/code\u003e, or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "the desired method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchMethodException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findConstructor",
      "comment": "Produces a method handle which creates an object and initializes it, using the constructor of the specified type. The parameter types of the method handle will be those of the constructor, while the return type will be a reference to the constructor\u0027s class. The constructor and all its argument types must be accessible to the lookup object. The requested type must have a return type of void. (This is consistent with the JVM\u0027s treatment of constructor type descriptors.) The returned method handle will have variable arity if and only if the constructor\u0027s variable arity modifier bit (0x0080) is set. If the returned method handle is invoked, the constructor\u0027s class will be initialized, if it has not already been initialized. Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_newArrayList \u003d publicLookup().findConstructor(\n  ArrayList.class, methodType(void.class, Collection.class));\nCollection orig \u003d Arrays.asList(\"x\", \"y\");\nCollection copy \u003d (ArrayList) MH_newArrayList.invokeExact(orig);\nassert(orig !\u003d copy);\nassertEquals(orig, copy);\n// a variable-arity constructor:\nMethodHandle MH_newProcessBuilder \u003d publicLookup().findConstructor(\n  ProcessBuilder.class, methodType(void.class, String[].class));\nProcessBuilder pb \u003d (ProcessBuilder)\n  MH_newProcessBuilder.invoke(\"x\", \"y\", \"z\");\nassertEquals(\"[x, y, z]\", pb.command().toString());",
      "tagMap": {
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class or interface from which the method is accessed",
          "\u003ccode\u003etype\u003c/code\u003e - the type of the method, with the receiver argument omitted, and a void return type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchMethodException.html\" title\u003d\"class in java.lang\"\u003eNoSuchMethodException\u003c/a\u003e\u003c/code\u003e - if the constructor does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "the desired method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.ClassNotFoundException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "targetName"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findClass",
      "comment": "Looks up a class by name from the lookup context defined by this Lookup object, as if resolved by an ldc instruction. Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class, and then determines whether the class is accessible to this lookup object. The lookup context here is determined by the lookup class, its class loader, and the lookup modes.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etargetName\u003c/code\u003e - the fully qualified name of the class to be looked up."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/LinkageError.html\" title\u003d\"class in java.lang\"\u003eLinkageError\u003c/a\u003e\u003c/code\u003e - if the linkage fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassNotFoundException.html\" title\u003d\"class in java.lang\"\u003eClassNotFoundException\u003c/a\u003e\u003c/code\u003e - if the class cannot be loaded by the lookup class\u0027 loader.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if the class is not accessible, using the allowed access modes."
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.3.1\"\u003e5.4.3.1 Class and Interface Resolution\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "the requested class."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "targetClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "ensureInitialized",
      "comment": "Ensures that targetClass has been initialized. The class to be initialized must be accessible to this Lookup object. This method causes targetClass to be initialized if it has not been already initialized, as specified in JVMS 5.5.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etargetClass\u003c/code\u003e - the class to be initialized"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etargetClass\u003c/code\u003e is a primitive type or \n\u003ccode\u003evoid\u003c/code\u003e or array class",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etargetClass\u003c/code\u003e is not \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#accessClass(java.lang.Class)\"\u003eaccessible\u003c/a\u003e to this lookup",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ExceptionInInitializerError.html\" title\u003d\"class in java.lang\"\u003eExceptionInInitializerError\u003c/a\u003e\u003c/code\u003e - if the class initialization provoked by this method fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.5\"\u003e5.5 Initialization\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "\u003ccode\u003etargetClass\u003c/code\u003e that has been initialized"
        ],
        "since": [
          "15"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "targetClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "accessClass",
      "comment": "Determines if a class can be accessed from the lookup context defined by this Lookup object. The static initializer of the class is not run. If the targetClass is in the same module as the lookup class, the lookup class is LC in module M1 and the previous lookup class is in module M0 or null if not present, targetClass is accessible if and only if one of the following is true: If this lookup has PRIVATE access, targetClass is LC or other class in the same nest of LC. If this lookup has PACKAGE access, targetClass is in the same runtime package of LC. If this lookup has MODULE access, targetClass is a public type in M1. If this lookup has PUBLIC access, targetClass is a public type in a package exported by M1 to at least M0 if the previous lookup class is present; otherwise, targetClass is a public type in a package exported by M1 unconditionally. Otherwise, if this lookup has UNCONDITIONAL access, this lookup can access public types in all modules when the type is in a package that is exported unconditionally. Otherwise, the target class is in a different module from lookupClass, and if this lookup does not have PUBLIC access, lookupClass is inaccessible. Otherwise, if this lookup has no previous lookup class, M1 is the module containing lookupClass and M2 is the module containing targetClass, then targetClass is accessible if and only if M1 reads M2, and targetClass is public and in a package exported by M2 at least to M1. Otherwise, if this lookup has a previous lookup class, M1 and M2 are as before, and M0 is the module containing the previous lookup class, then targetClass is accessible if and only if one of the following is true: targetClass is in M0 and M1 reads M0 and the type is in a package that is exported to at least M1. targetClass is in M1 and M0 reads M1 and the type is in a package that is exported to at least M0. targetClass is in a third module M2 and both M0 and M1 reads M2 and the type is in a package that is exported to at least both M0 and M2. Otherwise, targetClass is not accessible.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#cross-module-lookup\"\u003eCross-module lookups\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etargetClass\u003c/code\u003e - the class to be access-checked"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if the class is not accessible from the lookup class and previous lookup class, if present, using the allowed access modes.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e"
        ],
        "return": [
          "the class that has been access-checked"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchMethodException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "specialCaller"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findSpecial",
      "comment": "Produces an early-bound method handle for a virtual method. It will bypass checks for overriding methods on the receiver, as if called from an invokespecial instruction from within the explicitly specified specialCaller. The type of the method handle will be that of the method, with a suitably restricted receiver type prepended. (The receiver type will be specialCaller or a subtype.) The method and all its argument types must be accessible to the lookup object. Before method resolution, if the explicitly specified caller class is not identical with the lookup class, or if this lookup object does not have private access privileges, the access fails. The returned method handle will have variable arity if and only if the method\u0027s variable arity modifier bit (0x0080) is set. (Note: JVM internal methods named \"\u003cinit\u003e\" are not visible to this API, even though the invokespecial instruction can refer to them in special circumstances. Use findConstructor to access instance initialization methods in a safe manner.) Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nstatic class Listie extends ArrayList {\n  public String toString() { return \"[wee Listie]\"; }\n  static Lookup lookup() { return MethodHandles.lookup(); }\n}\n...\n// no access to constructor via invokeSpecial:\nMethodHandle MH_newListie \u003d Listie.lookup()\n  .findConstructor(Listie.class, methodType(void.class));\nListie l \u003d (Listie) MH_newListie.invokeExact();\ntry { assertEquals(\"impossible\", Listie.lookup().findSpecial(\n        Listie.class, \"\u003cinit\u003e\", methodType(void.class), Listie.class));\n } catch (NoSuchMethodException ex) { } // OK\n// access to super and self methods via invokeSpecial:\nMethodHandle MH_super \u003d Listie.lookup().findSpecial(\n  ArrayList.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_this \u003d Listie.lookup().findSpecial(\n  Listie.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_duper \u003d Listie.lookup().findSpecial(\n  Object.class, \"toString\" , methodType(String.class), Listie.class);\nassertEquals(\"[]\", (String) MH_super.invokeExact(l));\nassertEquals(\"\"+l, (String) MH_this.invokeExact(l));\nassertEquals(\"[]\", (String) MH_duper.invokeExact(l)); // ArrayList method\ntry { assertEquals(\"inaccessible\", Listie.lookup().findSpecial(\n        String.class, \"toString\", methodType(String.class), Listie.class));\n } catch (IllegalAccessException ex) { } // OK\nListie subl \u003d new Listie() { public String toString() { return \"[subclass]\"; } };\nassertEquals(\"\"+l, (String) MH_this.invokeExact(subl)); // Listie method",
      "tagMap": {
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class or interface from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the name of the method (which must not be \"\u0026lt;init\u0026gt;\")",
          "\u003ccode\u003etype\u003c/code\u003e - the type of the method, with the receiver argument omitted",
          "\u003ccode\u003especialCaller\u003c/code\u003e - the proposed calling class to perform the \n\u003ccode\u003einvokespecial\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchMethodException.html\" title\u003d\"class in java.lang\"\u003eNoSuchMethodException\u003c/a\u003e\u003c/code\u003e - if the method does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the method is \n\u003ccode\u003estatic\u003c/code\u003e, or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "the desired method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchFieldException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findGetter",
      "comment": "Produces a method handle giving read access to a non-static field. The type of the method handle will have a return type of the field\u0027s value type. The method handle\u0027s single argument will be the instance containing the field. Access checking is performed immediately on behalf of the lookup class.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003efindVarHandle(Class, String, Class)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class or interface from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the field\u0027s name",
          "\u003ccode\u003etype\u003c/code\u003e - the field\u0027s type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchFieldException.html\" title\u003d\"class in java.lang\"\u003eNoSuchFieldException\u003c/a\u003e\u003c/code\u003e - if the field does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the field is \n\u003ccode\u003estatic\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "a method handle which can load values from the field"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchFieldException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findSetter",
      "comment": "Produces a method handle giving write access to a non-static field. The type of the method handle will have a void return type. The method handle will take two arguments, the instance containing the field, and the value to be stored. The second argument will be of the field\u0027s value type. Access checking is performed immediately on behalf of the lookup class.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003efindVarHandle(Class, String, Class)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class or interface from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the field\u0027s name",
          "\u003ccode\u003etype\u003c/code\u003e - the field\u0027s type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchFieldException.html\" title\u003d\"class in java.lang\"\u003eNoSuchFieldException\u003c/a\u003e\u003c/code\u003e - if the field does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the field is \n\u003ccode\u003estatic\u003c/code\u003e or \n\u003ccode\u003efinal\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "a method handle which can store values into the field"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchFieldException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "recv"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findVarHandle",
      "comment": "Produces a VarHandle giving access to a non-static field name of type type declared in a class of type recv. The VarHandle\u0027s variable type is type and it has one coordinate type, recv. Access checking is performed immediately on behalf of the lookup class. Certain access modes of the returned VarHandle are unsupported under the following conditions: if the field is declared final, then the write, atomic update, numeric atomic update, and bitwise atomic update access modes are unsupported. if the field type is anything other than byte, short, char, int, long, float, or double then numeric atomic update access modes are unsupported. if the field type is anything other than boolean, byte, short, char, int or long then bitwise atomic update access modes are unsupported. If the field is declared volatile then the returned VarHandle will override access to the field (effectively ignore the volatile declaration) in accordance to its specified access modes. If the field type is float or double then numeric and atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double), respectively).",
      "tagMap": {
        "apiNote": [
          "Bitwise comparison of \n\u003ccode\u003efloat\u003c/code\u003e values or \n\u003ccode\u003edouble\u003c/code\u003e values, as performed by the numeric and atomic update access modes, differ from the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator and the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eFloat.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eDouble.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e methods, specifically with respect to comparing NaN values or comparing \n\u003ccode\u003e-0.0\u003c/code\u003e with \n\u003ccode\u003e+0.0\u003c/code\u003e. Care should be taken when performing a compare and set or a compare and exchange operation with such values since the operation may unexpectedly fail. There are many possible NaN values that are considered to be \n\u003ccode\u003eNaN\u003c/code\u003e in Java, although no IEEE 754 floating-point operation provided by Java can distinguish between them. Operation failure can occur if the expected or witness value is a NaN value and it is transformed (perhaps in a platform specific manner) into another NaN value, and thus has a different bitwise representation (see \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#intBitsToFloat(int)\"\u003e\u003ccode\u003eFloat.intBitsToFloat(int)\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long)\"\u003e\u003ccode\u003eDouble.longBitsToDouble(long)\u003c/code\u003e\u003c/a\u003e for more details). The values \n\u003ccode\u003e-0.0\u003c/code\u003e and \n\u003ccode\u003e+0.0\u003c/code\u003e have different bitwise representations but are considered equal when using the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator. Operation failure can occur if, for example, a numeric algorithm computes an expected value to be say \n\u003ccode\u003e-0.0\u003c/code\u003e and previously computed the witness value to be say \n\u003ccode\u003e+0.0\u003c/code\u003e."
        ],
        "param": [
          "\u003ccode\u003erecv\u003c/code\u003e - the receiver class, of type \n\u003ccode\u003eR\u003c/code\u003e, that declares the non-static field",
          "\u003ccode\u003ename\u003c/code\u003e - the field\u0027s name",
          "\u003ccode\u003etype\u003c/code\u003e - the field\u0027s type, of type \n\u003ccode\u003eT\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchFieldException.html\" title\u003d\"class in java.lang\"\u003eNoSuchFieldException\u003c/a\u003e\u003c/code\u003e - if the field does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the field is \n\u003ccode\u003estatic\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "a VarHandle giving access to non-static fields."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchFieldException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findStaticGetter",
      "comment": "Produces a method handle giving read access to a static field. The type of the method handle will have a return type of the field\u0027s value type. The method handle will take no arguments. Access checking is performed immediately on behalf of the lookup class. If the returned method handle is invoked, the field\u0027s class will be initialized, if it has not already been initialized.",
      "tagMap": {
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class or interface from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the field\u0027s name",
          "\u003ccode\u003etype\u003c/code\u003e - the field\u0027s type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchFieldException.html\" title\u003d\"class in java.lang\"\u003eNoSuchFieldException\u003c/a\u003e\u003c/code\u003e - if the field does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the field is not \n\u003ccode\u003estatic\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "a method handle which can load values from the field"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchFieldException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "refc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findStaticSetter",
      "comment": "Produces a method handle giving write access to a static field. The type of the method handle will have a void return type. The method handle will take a single argument, of the field\u0027s value type, the value to be stored. Access checking is performed immediately on behalf of the lookup class. If the returned method handle is invoked, the field\u0027s class will be initialized, if it has not already been initialized.",
      "tagMap": {
        "param": [
          "\u003ccode\u003erefc\u003c/code\u003e - the class or interface from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the field\u0027s name",
          "\u003ccode\u003etype\u003c/code\u003e - the field\u0027s type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchFieldException.html\" title\u003d\"class in java.lang\"\u003eNoSuchFieldException\u003c/a\u003e\u003c/code\u003e - if the field does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the field is not \n\u003ccode\u003estatic\u003c/code\u003e or is \n\u003ccode\u003efinal\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "a method handle which can store values into the field"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchFieldException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "decl"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "findStaticVarHandle",
      "comment": "Produces a VarHandle giving access to a static field name of type type declared in a class of type decl. The VarHandle\u0027s variable type is type and it has no coordinate types. Access checking is performed immediately on behalf of the lookup class. If the returned VarHandle is operated on, the declaring class will be initialized, if it has not already been initialized. Certain access modes of the returned VarHandle are unsupported under the following conditions: if the field is declared final, then the write, atomic update, numeric atomic update, and bitwise atomic update access modes are unsupported. if the field type is anything other than byte, short, char, int, long, float, or double, then numeric atomic update access modes are unsupported. if the field type is anything other than boolean, byte, short, char, int or long then bitwise atomic update access modes are unsupported. If the field is declared volatile then the returned VarHandle will override access to the field (effectively ignore the volatile declaration) in accordance to its specified access modes. If the field type is float or double then numeric and atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double), respectively).",
      "tagMap": {
        "apiNote": [
          "Bitwise comparison of \n\u003ccode\u003efloat\u003c/code\u003e values or \n\u003ccode\u003edouble\u003c/code\u003e values, as performed by the numeric and atomic update access modes, differ from the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator and the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eFloat.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eDouble.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e methods, specifically with respect to comparing NaN values or comparing \n\u003ccode\u003e-0.0\u003c/code\u003e with \n\u003ccode\u003e+0.0\u003c/code\u003e. Care should be taken when performing a compare and set or a compare and exchange operation with such values since the operation may unexpectedly fail. There are many possible NaN values that are considered to be \n\u003ccode\u003eNaN\u003c/code\u003e in Java, although no IEEE 754 floating-point operation provided by Java can distinguish between them. Operation failure can occur if the expected or witness value is a NaN value and it is transformed (perhaps in a platform specific manner) into another NaN value, and thus has a different bitwise representation (see \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#intBitsToFloat(int)\"\u003e\u003ccode\u003eFloat.intBitsToFloat(int)\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long)\"\u003e\u003ccode\u003eDouble.longBitsToDouble(long)\u003c/code\u003e\u003c/a\u003e for more details). The values \n\u003ccode\u003e-0.0\u003c/code\u003e and \n\u003ccode\u003e+0.0\u003c/code\u003e have different bitwise representations but are considered equal when using the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator. Operation failure can occur if, for example, a numeric algorithm computes an expected value to be say \n\u003ccode\u003e-0.0\u003c/code\u003e and previously computed the witness value to be say \n\u003ccode\u003e+0.0\u003c/code\u003e."
        ],
        "param": [
          "\u003ccode\u003edecl\u003c/code\u003e - the class that declares the static field",
          "\u003ccode\u003ename\u003c/code\u003e - the field\u0027s name",
          "\u003ccode\u003etype\u003c/code\u003e - the field\u0027s type, of type \n\u003ccode\u003eT\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchFieldException.html\" title\u003d\"class in java.lang\"\u003eNoSuchFieldException\u003c/a\u003e\u003c/code\u003e - if the field does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the field is not \n\u003ccode\u003estatic\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "a VarHandle giving access to a static field"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.NoSuchMethodException",
          "type": "Class"
        },
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "receiver"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "bind",
      "comment": "Produces an early-bound method handle for a non-static method. The receiver must have a supertype defc in which a method of the given name and type is accessible to the lookup class. The method and all its argument types must be accessible to the lookup object. The type of the method handle will be that of the method, without any insertion of an additional receiver parameter. The given receiver will be bound into the method handle, so that every call to the method handle will invoke the requested method on the given receiver. The returned method handle will have variable arity if and only if the method\u0027s variable arity modifier bit (0x0080) is set and the trailing array argument is not the only argument. (If the trailing array argument is the only argument, the given receiver value will be bound to it.) This is almost equivalent to the following code, with some differences noted below: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle mh0 \u003d lookup().findVirtual(defc, name, type);\nMethodHandle mh1 \u003d mh0.bindTo(receiver);\nmh1 \u003d mh1.withVarargs(mh0.isVarargsCollector());\nreturn mh1;\n where defc is either receiver.getClass() or a super type of that class, in which the requested method is accessible to the lookup class. (Unlike bind, bindTo does not preserve variable arity. Also, bindTo may throw a ClassCastException in instances where bind would throw an IllegalAccessException, as in the case where the member is protected and the receiver is restricted by findVirtual to the lookup class.)",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#bindTo(java.lang.Object)\"\u003e\u003ccode\u003eMethodHandle.bindTo(java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003efindVirtual(java.lang.Class\u0026lt;?\u0026gt;, java.lang.String, java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ereceiver\u003c/code\u003e - the object from which the method is accessed",
          "\u003ccode\u003ename\u003c/code\u003e - the name of the method",
          "\u003ccode\u003etype\u003c/code\u003e - the type of the method, with the receiver argument omitted"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchMethodException.html\" title\u003d\"class in java.lang\"\u003eNoSuchMethodException\u003c/a\u003e\u003c/code\u003e - if the method does not exist",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "the desired method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.reflect.Method",
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unreflect",
      "comment": "Makes a direct method handle to m, if the lookup class has permission. If m is non-static, the receiver argument is treated as an initial argument. If m is virtual, overriding is respected on every call. Unlike the Core Reflection API, exceptions are not wrapped. The type of the method handle will be that of the method, with the receiver type prepended (but only if it is non-static). If the method\u0027s accessible flag is not set, access checking is performed immediately on behalf of the lookup class. If m is not public, do not share the resulting handle with untrusted parties. The returned method handle will have variable arity if and only if the method\u0027s variable arity modifier bit (0x0080) is set. If m is static, and if the returned method handle is invoked, the method\u0027s class will be initialized, if it has not already been initialized.",
      "tagMap": {
        "param": [
          "\u003ccode\u003em\u003c/code\u003e - the reflected method"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a method handle which can invoke the reflected method"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.reflect.Method",
            "type": "Class"
          },
          "field": {
            "name": "m"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "specialCaller"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unreflectSpecial",
      "comment": "Produces a method handle for a reflected method. It will bypass checks for overriding methods on the receiver, as if called from an invokespecial instruction from within the explicitly specified specialCaller. The type of the method handle will be that of the method, with a suitably restricted receiver type prepended. (The receiver type will be specialCaller or a subtype.) If the method\u0027s accessible flag is not set, access checking is performed immediately on behalf of the lookup class, as if invokespecial instruction were being linked. Before method resolution, if the explicitly specified caller class is not identical with the lookup class, or if this lookup object does not have private access privileges, the access fails. The returned method handle will have variable arity if and only if the method\u0027s variable arity modifier bit (0x0080) is set.",
      "tagMap": {
        "param": [
          "\u003ccode\u003em\u003c/code\u003e - the reflected method",
          "\u003ccode\u003especialCaller\u003c/code\u003e - the class nominally calling the method"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the method is \n\u003ccode\u003estatic\u003c/code\u003e, or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null"
        ],
        "return": [
          "a method handle which can invoke the reflected method"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.reflect.Constructor",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "c"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unreflectConstructor",
      "comment": "Produces a method handle for a reflected constructor. The type of the method handle will be that of the constructor, with the return type changed to the declaring class. The method handle will perform a newInstance operation, creating a new instance of the constructor\u0027s class on the arguments passed to the method handle. If the constructor\u0027s accessible flag is not set, access checking is performed immediately on behalf of the lookup class. The returned method handle will have variable arity if and only if the constructor\u0027s variable arity modifier bit (0x0080) is set. If the returned method handle is invoked, the constructor\u0027s class will be initialized, if it has not already been initialized.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ec\u003c/code\u003e - the reflected constructor"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails or if the method\u0027s variable arity modifier bit is set and \n\u003ccode\u003easVarargsCollector\u003c/code\u003e fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a method handle which can invoke the reflected constructor"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.reflect.Field",
            "type": "Class"
          },
          "field": {
            "name": "f"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unreflectGetter",
      "comment": "Produces a method handle giving read access to a reflected field. The type of the method handle will have a return type of the field\u0027s value type. If the field is static, the method handle will take no arguments. Otherwise, its single argument will be the instance containing the field. If the Field object\u0027s accessible flag is not set, access checking is performed immediately on behalf of the lookup class. If the field is static, and if the returned method handle is invoked, the field\u0027s class will be initialized, if it has not already been initialized.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ef\u003c/code\u003e - the reflected field"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a method handle which can load values from the reflected field"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.reflect.Field",
            "type": "Class"
          },
          "field": {
            "name": "f"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unreflectSetter",
      "comment": "Produces a method handle giving write access to a reflected field. The type of the method handle will have a void return type. If the field is static, the method handle will take a single argument, of the field\u0027s value type, the value to be stored. Otherwise, the two arguments will be the instance containing the field, and the value to be stored. If the Field object\u0027s accessible flag is not set, access checking is performed immediately on behalf of the lookup class. If the field is final, write access will not be allowed and access checking will fail, except under certain narrow circumstances documented for Field.set. A method handle is returned only if a corresponding call to the Field object\u0027s set method could return normally. In particular, fields which are both static and final may never be set. If the field is static, and if the returned method handle is invoked, the field\u0027s class will be initialized, if it has not already been initialized.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ef\u003c/code\u003e - the reflected field"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails, or if the field is \n\u003ccode\u003efinal\u003c/code\u003e and write access is not enabled on the \n\u003ccode\u003eField\u003c/code\u003e object",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a method handle which can store values into the reflected field"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.reflect.Field",
            "type": "Class"
          },
          "field": {
            "name": "f"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unreflectVarHandle",
      "comment": "Produces a VarHandle giving access to a reflected field f of type T declared in a class of type R. The VarHandle\u0027s variable type is T. If the field is non-static the VarHandle has one coordinate type, R. Otherwise, the field is static, and the VarHandle has no coordinate types. Access checking is performed immediately on behalf of the lookup class, regardless of the value of the field\u0027s accessible flag. If the field is static, and if the returned VarHandle is operated on, the field\u0027s declaring class will be initialized, if it has not already been initialized. Certain access modes of the returned VarHandle are unsupported under the following conditions: if the field is declared final, then the write, atomic update, numeric atomic update, and bitwise atomic update access modes are unsupported. if the field type is anything other than byte, short, char, int, long, float, or double then numeric atomic update access modes are unsupported. if the field type is anything other than boolean, byte, short, char, int or long then bitwise atomic update access modes are unsupported. If the field is declared volatile then the returned VarHandle will override access to the field (effectively ignore the volatile declaration) in accordance to its specified access modes. If the field type is float or double then numeric and atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double), respectively).",
      "tagMap": {
        "apiNote": [
          "Bitwise comparison of \n\u003ccode\u003efloat\u003c/code\u003e values or \n\u003ccode\u003edouble\u003c/code\u003e values, as performed by the numeric and atomic update access modes, differ from the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator and the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eFloat.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eDouble.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e methods, specifically with respect to comparing NaN values or comparing \n\u003ccode\u003e-0.0\u003c/code\u003e with \n\u003ccode\u003e+0.0\u003c/code\u003e. Care should be taken when performing a compare and set or a compare and exchange operation with such values since the operation may unexpectedly fail. There are many possible NaN values that are considered to be \n\u003ccode\u003eNaN\u003c/code\u003e in Java, although no IEEE 754 floating-point operation provided by Java can distinguish between them. Operation failure can occur if the expected or witness value is a NaN value and it is transformed (perhaps in a platform specific manner) into another NaN value, and thus has a different bitwise representation (see \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#intBitsToFloat(int)\"\u003e\u003ccode\u003eFloat.intBitsToFloat(int)\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long)\"\u003e\u003ccode\u003eDouble.longBitsToDouble(long)\u003c/code\u003e\u003c/a\u003e for more details). The values \n\u003ccode\u003e-0.0\u003c/code\u003e and \n\u003ccode\u003e+0.0\u003c/code\u003e have different bitwise representations but are considered equal when using the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator. Operation failure can occur if, for example, a numeric algorithm computes an expected value to be say \n\u003ccode\u003e-0.0\u003c/code\u003e and previously computed the witness value to be say \n\u003ccode\u003e+0.0\u003c/code\u003e."
        ],
        "param": [
          "\u003ccode\u003ef\u003c/code\u003e - the reflected field, with a field of type \n\u003ccode\u003eT\u003c/code\u003e, and a declaring class of type \n\u003ccode\u003eR\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if access checking fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a VarHandle giving access to non-static fields or a static field"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandleInfo",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "revealDirect",
      "comment": "Cracks a direct method handle created by this lookup object or a similar one. Security and access checks are performed to ensure that this lookup object is capable of reproducing the target method handle. This means that the cracking may fail if target is a direct method handle but was created by an unrelated lookup object. This can happen if the method handle is caller sensitive and was created by a lookup object for a different class.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html\" title\u003d\"interface in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandleInfo\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - a direct method handle to crack into symbolic reference components"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager is present and it \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003erefuses access\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the target is not a direct method handle or if access checking fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the target is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "a symbolic reference which can be used to reconstruct this method handle from this lookup object"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasPrivateAccess",
      "comment": "Returns true if this lookup has PRIVATE and MODULE access.",
      "annotations": [
        {
          "type": "Deprecated",
          "values": [
            {
              "name": "since",
              "value": "14"
            }
          ]
        }
      ],
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this lookup has \n\u003ccode\u003ePRIVATE\u003c/code\u003e and \n\u003ccode\u003eMODULE\u003c/code\u003e access."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasFullPrivilegeAccess",
      "comment": "Returns true if this lookup has full privilege access, i.e. PRIVATE and MODULE access. A Lookup object must have full privilege access in order to access all members that are allowed to the lookup class.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#privacc\"\u003eprivate and module access\u003c/a\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this lookup has full privilege access."
        ],
        "since": [
          "14"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.lang.invoke.MethodHandles$Lookup$ClassOption"
  ],
  "memberType": "JavaClass",
  "modifiers": 25,
  "name": "java.lang.invoke.MethodHandles$Lookup",
  "comment": "A \n\u003cem\u003elookup object\u003c/em\u003e is a factory for creating method handles, when the creation requires access checking. Method handles do not perform access checks when they are called, but rather when they are created. Therefore, method handle access restrictions must be enforced when a method handle is created. The caller class against which those restrictions are enforced is known as the \n\u003ca href\u003d\"#lookupClass()\"\u003elookup class\u003c/a\u003e. \n\u003cp\u003e A lookup class which needs to create method handles will call \u003ca href\u003d\"MethodHandles.html#lookup()\"\u003e\u003ccode\u003eMethodHandles.lookup\u003c/code\u003e\u003c/a\u003e to create a factory for itself. When the \u003ccode\u003eLookup\u003c/code\u003e factory object is created, the identity of the lookup class is determined, and securely stored in the \u003ccode\u003eLookup\u003c/code\u003e object. The lookup class (or its delegates) may then use factory methods on the \u003ccode\u003eLookup\u003c/code\u003e object to create method handles for access-checked members. This includes all methods, constructors, and fields which are allowed to the lookup class, even private ones. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"lookups\"\u003e\u003c/a\u003eLookup Factory Methods\u003c/h2\u003e The factory methods on a \n\u003ccode\u003eLookup\u003c/code\u003e object correspond to all major use cases for methods, constructors, and fields. Each method handle created by a factory method is the functional equivalent of a particular \n\u003cem\u003ebytecode behavior\u003c/em\u003e. (Bytecode behaviors are described in section \n\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.3.5\"\u003e5.4.3.5\u003c/a\u003e of the Java Virtual Machine Specification.) Here is a summary of the correspondence between these factory methods and the behavior of the resulting method handles: \n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n  lookup method behaviors\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003e\u003ca id\u003d\"equiv\"\u003e\u003c/a\u003elookup expression\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003emember\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003ebytecode behavior\u003c/th\u003e \n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findGetter(java.lang.Class,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003elookup.findGetter(C.class,\"f\",FT.class)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) this.f;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findStaticGetter(java.lang.Class,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003elookup.findStaticGetter(C.class,\"f\",FT.class)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003estatic\u003c/code\u003e\u003cbr\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(FT) C.f;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findSetter(java.lang.Class,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003elookup.findSetter(C.class,\"f\",FT.class)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003ethis.f \u003d x;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findStaticSetter(java.lang.Class,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003elookup.findStaticSetter(C.class,\"f\",FT.class)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003estatic\u003c/code\u003e\u003cbr\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eC.f \u003d arg;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003elookup.findVirtual(C.class,\"m\",MT)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) this.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003elookup.findStatic(C.class,\"m\",MT)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003estatic\u003c/code\u003e\u003cbr\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) C.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)\"\u003e\u003ccode\u003elookup.findSpecial(C.class,\"m\",MT,this.class)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) super.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findConstructor(java.lang.Class,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003elookup.findConstructor(C.class,MT)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eC(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003enew C(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#unreflectGetter(java.lang.reflect.Field)\"\u003e\u003ccode\u003elookup.unreflectGetter(aField)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e(\u003ccode\u003estatic\u003c/code\u003e)?\u003cbr\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(FT) aField.get(thisOrNull);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#unreflectSetter(java.lang.reflect.Field)\"\u003e\u003ccode\u003elookup.unreflectSetter(aField)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e(\u003ccode\u003estatic\u003c/code\u003e)?\u003cbr\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eaField.set(thisOrNull, arg);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#unreflect(java.lang.reflect.Method)\"\u003e\u003ccode\u003elookup.unreflect(aMethod)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e(\u003ccode\u003estatic\u003c/code\u003e)?\u003cbr\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) aMethod.invoke(thisOrNull, arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#unreflectConstructor(java.lang.reflect.Constructor)\"\u003e\u003ccode\u003elookup.unreflectConstructor(aConstructor)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eC(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(C) aConstructor.newInstance(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#unreflectSpecial(java.lang.reflect.Method,java.lang.Class)\"\u003e\u003ccode\u003elookup.unreflectSpecial(aMethod,this.class)\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) super.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ca href\u003d\"#findClass(java.lang.String)\"\u003e\u003ccode\u003elookup.findClass(\"C\")\u003c/code\u003e\u003c/a\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eclass C { ... }\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eC.class;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e Here, the type \n\u003ccode\u003eC\u003c/code\u003e is the class or interface being searched for a member, documented as a parameter named \n\u003ccode\u003erefc\u003c/code\u003e in the lookup methods. The method type \n\u003ccode\u003eMT\u003c/code\u003e is composed from the return type \n\u003ccode\u003eT\u003c/code\u003e and the sequence of argument types \n\u003ccode\u003eA*\u003c/code\u003e. The constructor also has a sequence of argument types \n\u003ccode\u003eA*\u003c/code\u003e and is deemed to return the newly-created object of type \n\u003ccode\u003eC\u003c/code\u003e. Both \n\u003ccode\u003eMT\u003c/code\u003e and the field type \n\u003ccode\u003eFT\u003c/code\u003e are documented as a parameter named \n\u003ccode\u003etype\u003c/code\u003e. The formal parameter \n\u003ccode\u003ethis\u003c/code\u003e stands for the self-reference of type \n\u003ccode\u003eC\u003c/code\u003e; if it is present, it is always the leading argument to the method handle invocation. (In the case of some \n\u003ccode\u003eprotected\u003c/code\u003e members, \n\u003ccode\u003ethis\u003c/code\u003e may be restricted in type to the lookup class; see below.) The name \n\u003ccode\u003earg\u003c/code\u003e stands for all the other method handle arguments. In the code examples for the Core Reflection API, the name \n\u003ccode\u003ethisOrNull\u003c/code\u003e stands for a null reference if the accessed method or field is static, and \n\u003ccode\u003ethis\u003c/code\u003e otherwise. The names \n\u003ccode\u003eaMethod\u003c/code\u003e, \n\u003ccode\u003eaField\u003c/code\u003e, and \n\u003ccode\u003eaConstructor\u003c/code\u003e stand for reflective objects corresponding to the given members declared in type \n\u003ccode\u003eC\u003c/code\u003e. \n\u003cp\u003e The bytecode behavior for a \u003ccode\u003efindClass\u003c/code\u003e operation is a load of a constant class, as if by \u003ccode\u003eldc CONSTANT_Class\u003c/code\u003e. The behavior is represented, not as a method handle, but directly as a \u003ccode\u003eClass\u003c/code\u003e constant. \u003c/p\u003e\n\u003cp\u003e In cases where the given member is of variable arity (i.e., a method or constructor) the returned method handle will also be of \u003ca href\u003d\"MethodHandle.html#asVarargsCollector(java.lang.Class)\"\u003evariable arity\u003c/a\u003e. In all other cases, the returned method handle will be of fixed arity. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e \u003cem\u003eDiscussion:\u003c/em\u003e The equivalence between looked-up method handles and underlying class members and bytecode behaviors can break down in a few ways: \u003c/p\u003e\n\u003cul style\u003d\"font-size:smaller;\"\u003e \n \u003cli\u003eIf \u003ccode\u003eC\u003c/code\u003e is not symbolically accessible from the lookup class\u0027s loader, the lookup can still succeed, even when there is no equivalent Java expression or bytecoded constant. \u003c/li\u003e\n \u003cli\u003eLikewise, if \u003ccode\u003eT\u003c/code\u003e or \u003ccode\u003eMT\u003c/code\u003e is not symbolically accessible from the lookup class\u0027s loader, the lookup can still succeed. For example, lookups for \u003ccode\u003eMethodHandle.invokeExact\u003c/code\u003e and \u003ccode\u003eMethodHandle.invoke\u003c/code\u003e will always succeed, regardless of requested type. \u003c/li\u003e\n \u003cli\u003eIf there is a security manager installed, it can forbid the lookup on various grounds (\u003ca href\u003d\"MethodHandles.Lookup.html#secmgr\"\u003esee below\u003c/a\u003e). By contrast, the \u003ccode\u003eldc\u003c/code\u003e instruction on a \u003ccode\u003eCONSTANT_MethodHandle\u003c/code\u003e constant is not subject to security manager checks. \u003c/li\u003e\n \u003cli\u003eIf the looked-up method has a \u003ca href\u003d\"MethodHandle.html#maxarity\"\u003every large arity\u003c/a\u003e, the method handle creation may fail with an \u003ccode\u003eIllegalArgumentException\u003c/code\u003e, due to the method handle type having \u003ca href\u003d\"MethodHandle.html#maxarity\"\u003etoo many parameters.\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"access\"\u003e\u003c/a\u003eAccess checking\u003c/h2\u003e Access checks are applied in the factory methods of \n\u003ccode\u003eLookup\u003c/code\u003e, when a method handle is created. This is a key difference from the Core Reflection API, since \n\u003ca href\u003d\"../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)\"\u003e\u003ccode\u003ejava.lang.reflect.Method.invoke\u003c/code\u003e\u003c/a\u003e performs access checking against every caller, on every call. \n\u003cp\u003e All access checks start from a \u003ccode\u003eLookup\u003c/code\u003e object, which compares its recorded lookup class against all requests to create method handles. A single \u003ccode\u003eLookup\u003c/code\u003e object can be used to create any number of access-checked method handles, all checked against a single lookup class. \u003c/p\u003e\n\u003cp\u003e A \u003ccode\u003eLookup\u003c/code\u003e object can be shared with other trusted code, such as a metaobject protocol. A shared \u003ccode\u003eLookup\u003c/code\u003e object delegates the capability to create method handles on private members of the lookup class. Even if privileged code uses the \u003ccode\u003eLookup\u003c/code\u003e object, the access checking is confined to the privileges of the original lookup class. \u003c/p\u003e\n\u003cp\u003e A lookup can fail, because the containing class is not accessible to the lookup class, or because the desired class member is missing, or because the desired class member is not accessible to the lookup class, or because the lookup object is not trusted enough to access the member. In the case of a field setter function on a \u003ccode\u003efinal\u003c/code\u003e field, finality enforcement is treated as a kind of access control, and the lookup will fail, except in special cases of \u003ca href\u003d\"#unreflectSetter(java.lang.reflect.Field)\"\u003e\u003ccode\u003eLookup.unreflectSetter\u003c/code\u003e\u003c/a\u003e. In any of these cases, a \u003ccode\u003eReflectiveOperationException\u003c/code\u003e will be thrown from the attempted lookup. The exact class will be one of the following: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eNoSuchMethodException — if a method is requested but does not exist \u003c/li\u003e\n \u003cli\u003eNoSuchFieldException — if a field is requested but does not exist \u003c/li\u003e\n \u003cli\u003eIllegalAccessException — if the member exists but an access check fails \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e In general, the conditions under which a method handle may be looked up for a method \u003ccode\u003eM\u003c/code\u003e are no more restrictive than the conditions under which the lookup class could have compiled, verified, and resolved a call to \u003ccode\u003eM\u003c/code\u003e. Where the JVM would raise exceptions like \u003ccode\u003eNoSuchMethodError\u003c/code\u003e, a method handle lookup will generally raise a corresponding checked exception, such as \u003ccode\u003eNoSuchMethodException\u003c/code\u003e. And the effect of invoking the method handle resulting from the lookup is \u003ca href\u003d\"MethodHandles.Lookup.html#equiv\"\u003eexactly equivalent\u003c/a\u003e to executing the compiled, verified, and resolved call to \u003ccode\u003eM\u003c/code\u003e. The same point is true of fields and constructors. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e \u003cem\u003eDiscussion:\u003c/em\u003e Access checks only apply to named and reflected methods, constructors, and fields. Other method handle creation methods, such as \u003ca href\u003d\"MethodHandle.html#asType(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandle.asType\u003c/code\u003e\u003c/a\u003e, do not require any access checks, and are used independently of any \u003ccode\u003eLookup\u003c/code\u003e object. \u003c/p\u003e\n\u003cp\u003e If the desired member is \u003ccode\u003eprotected\u003c/code\u003e, the usual JVM rules apply, including the requirement that the lookup class must either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.9.2\"\u003e4.9.2\u003c/a\u003e, \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.3.5\"\u003e5.4.3.5\u003c/a\u003e, and \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html#jls-6.4\"\u003e6.4\u003c/a\u003e.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading \u003ccode\u003ethis\u003c/code\u003e parameter from \u003ccode\u003eC\u003c/code\u003e (which will necessarily be a superclass of the lookup class) to the lookup class itself. \u003c/p\u003e\n\u003cp\u003e The JVM imposes a similar requirement on \u003ccode\u003einvokespecial\u003c/code\u003e instruction, that the receiver argument must match both the resolved method \u003cem\u003eand\u003c/em\u003e the current class. Again, this requirement is enforced by narrowing the type of the leading parameter to the resulting method handle. (See the Java Virtual Machine Specification, section \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.10.1.9\"\u003e4.10.1.9\u003c/a\u003e.) \u003c/p\u003e\n\u003cp\u003e The JVM represents constructors and static initializer blocks as internal methods with special names (\u003ccode\u003e\"\u0026lt;init\u0026gt;\"\u003c/code\u003e and \u003ccode\u003e\"\u0026lt;clinit\u0026gt;\"\u003c/code\u003e). The internal syntax of invocation instructions allows them to refer to such internal methods as if they were normal methods, but the JVM bytecode verifier rejects them. A lookup of such an internal method will produce a \u003ccode\u003eNoSuchMethodException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e If the relationship between nested types is expressed directly through the \u003ccode\u003eNestHost\u003c/code\u003e and \u003ccode\u003eNestMembers\u003c/code\u003e attributes (see the Java Virtual Machine Specification, sections \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.7.28\"\u003e4.7.28\u003c/a\u003e and \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.7.29\"\u003e4.7.29\u003c/a\u003e), then the associated \u003ccode\u003eLookup\u003c/code\u003e object provides direct access to the lookup class and all of its nestmates (see \u003ca href\u003d\"../Class.html#getNestHost()\"\u003e\u003ccode\u003eClass.getNestHost\u003c/code\u003e\u003c/a\u003e). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class \u003ccode\u003eC.D\u003c/code\u003e can access private members within other related classes such as \u003ccode\u003eC\u003c/code\u003e, \u003ccode\u003eC.D.E\u003c/code\u003e, or \u003ccode\u003eC.B\u003c/code\u003e, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a \u003ccode\u003eLookup\u003c/code\u003e object on \u003ccode\u003eC.E\u003c/code\u003e would be unable to access those private members. A workaround for this limitation is the \u003ca href\u003d\"#in(java.lang.Class)\"\u003e\u003ccode\u003eLookup.in\u003c/code\u003e\u003c/a\u003e method, which can transform a lookup on \u003ccode\u003eC.E\u003c/code\u003e into one on any of those other classes, without special elevation of privilege. \u003c/p\u003e\n\u003cp\u003e The accesses permitted to a given lookup object may be limited, according to its set of \u003ca href\u003d\"#lookupModes()\"\u003e\u003ccode\u003elookupModes\u003c/code\u003e\u003c/a\u003e, to a subset of members normally accessible to the lookup class. For example, the \u003ca href\u003d\"MethodHandles.html#publicLookup()\"\u003e\u003ccode\u003epublicLookup\u003c/code\u003e\u003c/a\u003e method produces a lookup object which is only allowed to access public members in public classes of exported packages. The caller sensitive method \u003ca href\u003d\"MethodHandles.html#lookup()\"\u003e\u003ccode\u003elookup\u003c/code\u003e\u003c/a\u003e produces a lookup object with full capabilities relative to its caller class, to emulate all supported bytecode behaviors. Also, the \u003ca href\u003d\"#in(java.lang.Class)\"\u003e\u003ccode\u003eLookup.in\u003c/code\u003e\u003c/a\u003e method may produce a lookup object with fewer access modes than the original lookup object. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e \u003ca id\u003d\"privacc\"\u003e\u003c/a\u003e \u003cem\u003eDiscussion of private and module access:\u003c/em\u003e We say that a lookup has \u003cem\u003eprivate access\u003c/em\u003e if its \u003ca href\u003d\"#lookupModes()\"\u003elookup modes\u003c/a\u003e include the possibility of accessing \u003ccode\u003eprivate\u003c/code\u003e members (which includes the private members of nestmates). As documented in the relevant methods elsewhere, only lookups with private access possess the following capabilities: \u003c/p\u003e\n\u003cul style\u003d\"font-size:smaller;\"\u003e \n \u003cli\u003eaccess private fields, methods, and constructors of the lookup class and its nestmates \u003c/li\u003e\n \u003cli\u003ecreate method handles which \u003ca href\u003d\"#findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)\"\u003e\u003ccode\u003eemulate invokespecial\u003c/code\u003e\u003c/a\u003e instructions \u003c/li\u003e\n \u003cli\u003eavoid \u003ca href\u003d\"MethodHandles.Lookup.html#secmgr\"\u003epackage access checks\u003c/a\u003e for classes accessible to the lookup class \u003c/li\u003e\n \u003cli\u003ecreate \u003ca href\u003d\"#in(java.lang.Class)\"\u003e\u003ccode\u003edelegated lookup objects\u003c/code\u003e\u003c/a\u003e which have private access to other classes within the same package member \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e Similarly, a lookup with module access ensures that the original lookup creator was a member in the same module as the lookup class. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e Private and module access are independently determined modes; a lookup may have either or both or neither. A lookup which possesses both access modes is said to possess \u003ca href\u003d\"#hasFullPrivilegeAccess()\"\u003efull privilege access\u003c/a\u003e. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e A lookup with \u003cem\u003eoriginal access\u003c/em\u003e ensures that this lookup is created by the original lookup class and the bootstrap method invoked by the VM. Such a lookup with original access also has private and module access which has the following additional capability: \u003c/p\u003e\n\u003cul style\u003d\"font-size:smaller;\"\u003e \n \u003cli\u003ecreate method handles which invoke \u003ca href\u003d\"MethodHandles.Lookup.html#callsens\"\u003ecaller sensitive\u003c/a\u003e methods, such as \u003ccode\u003eClass.forName\u003c/code\u003e \u003c/li\u003e\n \u003cli\u003eobtain the \u003ca href\u003d\"MethodHandles.html#classData(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.Class)\"\u003eclass data\u003c/a\u003e associated with the lookup class\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e Each of these permissions is a consequence of the fact that a lookup object with private access can be securely traced back to an originating class, whose \u003ca href\u003d\"MethodHandles.Lookup.html#equiv\"\u003ebytecode behaviors\u003c/a\u003e and Java language access permissions can be reliably determined and emulated by method handles. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"cross-module-lookup\"\u003e\u003c/a\u003eCross-module lookups\u003c/h2\u003e When a lookup class in one module \n\u003ccode\u003eM1\u003c/code\u003e accesses a class in another module \n\u003ccode\u003eM2\u003c/code\u003e, extra access checking is performed beyond the access mode bits. A \n\u003ccode\u003eLookup\u003c/code\u003e with \n\u003ca href\u003d\"#PUBLIC\"\u003e\u003ccode\u003ePUBLIC\u003c/code\u003e\u003c/a\u003e mode and a lookup class in \n\u003ccode\u003eM1\u003c/code\u003e can access public types in \n\u003ccode\u003eM2\u003c/code\u003e when \n\u003ccode\u003eM2\u003c/code\u003e is readable to \n\u003ccode\u003eM1\u003c/code\u003e and when the type is in a package of \n\u003ccode\u003eM2\u003c/code\u003e that is exported to at least \n\u003ccode\u003eM1\u003c/code\u003e. \n\u003cp\u003e A \u003ccode\u003eLookup\u003c/code\u003e on \u003ccode\u003eC\u003c/code\u003e can also \u003cem\u003eteleport\u003c/em\u003e to a target class via \u003ca href\u003d\"#in(java.lang.Class)\"\u003e\u003ccode\u003eLookup.in\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003eMethodHandles.privateLookupIn\u003c/code\u003e\u003c/a\u003e methods. Teleporting across modules will always record the original lookup class as the \u003cem\u003e\u003ca href\u003d\"#previousLookupClass()\"\u003eprevious lookup class\u003c/a\u003e\u003c/em\u003e and drops \u003ca href\u003d\"#MODULE\"\u003e\u003ccode\u003eMODULE\u003c/code\u003e\u003c/a\u003e access. If the target class is in the same module as the lookup class \u003ccode\u003eC\u003c/code\u003e, then the target class becomes the new lookup class and there is no change to the previous lookup class. If the target class is in a different module from \u003ccode\u003eM1\u003c/code\u003e (\u003ccode\u003eC\u003c/code\u003e\u0027s module), \u003ccode\u003eC\u003c/code\u003e becomes the new previous lookup class and the target class becomes the new lookup class. In that case, if there was already a previous lookup class in \u003ccode\u003eM0\u003c/code\u003e, and it differs from \u003ccode\u003eM1\u003c/code\u003e and \u003ccode\u003eM2\u003c/code\u003e, then the resulting lookup drops all privileges. For example, \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e \u003ccode\u003e\n Lookup lookup \u003d MethodHandles.lookup();   // in class C\n Lookup lookup2 \u003d lookup.in(D.class);\n MethodHandle mh \u003d lookup2.findStatic(E.class, \"m\", MT);\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"MethodHandles.html#lookup()\"\u003e\u003ccode\u003eMethodHandles.lookup()\u003c/code\u003e\u003c/a\u003e factory method produces a \u003ccode\u003eLookup\u003c/code\u003e object with \u003ccode\u003enull\u003c/code\u003e previous lookup class. \u003ca href\u003d\"#in(java.lang.Class)\"\u003e\u003ccode\u003elookup.in(D.class)\u003c/code\u003e\u003c/a\u003e transforms the \u003ccode\u003elookup\u003c/code\u003e on class \u003ccode\u003eC\u003c/code\u003e to class \u003ccode\u003eD\u003c/code\u003e without elevation of privileges. If \u003ccode\u003eC\u003c/code\u003e and \u003ccode\u003eD\u003c/code\u003e are in the same module, \u003ccode\u003elookup2\u003c/code\u003e records \u003ccode\u003eD\u003c/code\u003e as the new lookup class and keeps the same previous lookup class as the original \u003ccode\u003elookup\u003c/code\u003e, or \u003ccode\u003enull\u003c/code\u003e if not present. \u003c/p\u003e\n\u003cp\u003e When a \u003ccode\u003eLookup\u003c/code\u003e teleports from a class in one nest to another nest, \u003ccode\u003ePRIVATE\u003c/code\u003e access is dropped. When a \u003ccode\u003eLookup\u003c/code\u003e teleports from a class in one package to another package, \u003ccode\u003ePACKAGE\u003c/code\u003e access is dropped. When a \u003ccode\u003eLookup\u003c/code\u003e teleports from a class in one module to another module, \u003ccode\u003eMODULE\u003c/code\u003e access is dropped. Teleporting across modules drops the ability to access non-exported classes in both the module of the new lookup class and the module of the old lookup class and the resulting \u003ccode\u003eLookup\u003c/code\u003e remains only \u003ccode\u003ePUBLIC\u003c/code\u003e access. A \u003ccode\u003eLookup\u003c/code\u003e can teleport back and forth to a class in the module of the lookup class and the module of the previous class lookup. Teleporting across modules can only decrease access but cannot increase it. Teleporting to some third module drops all accesses. \u003c/p\u003e\n\u003cp\u003e In the above example, if \u003ccode\u003eC\u003c/code\u003e and \u003ccode\u003eD\u003c/code\u003e are in different modules, \u003ccode\u003elookup2\u003c/code\u003e records \u003ccode\u003eD\u003c/code\u003e as its lookup class and \u003ccode\u003eC\u003c/code\u003e as its previous lookup class and \u003ccode\u003elookup2\u003c/code\u003e has only \u003ccode\u003ePUBLIC\u003c/code\u003e access. \u003ccode\u003elookup2\u003c/code\u003e can teleport to other class in \u003ccode\u003eC\u003c/code\u003e\u0027s module and \u003ccode\u003eD\u003c/code\u003e\u0027s module. If class \u003ccode\u003eE\u003c/code\u003e is in a third module, \u003ccode\u003elookup2.in(E.class)\u003c/code\u003e creates a \u003ccode\u003eLookup\u003c/code\u003e on \u003ccode\u003eE\u003c/code\u003e with no access and \u003ccode\u003elookup2\u003c/code\u003e\u0027s lookup class \u003ccode\u003eD\u003c/code\u003e is recorded as its previous lookup class. \u003c/p\u003e\n\u003cp\u003e Teleporting across modules restricts access to the public types that both the lookup class and the previous lookup class can equally access (see below). \u003c/p\u003e\n\u003cp\u003e \u003ca href\u003d\"MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003eMethodHandles.privateLookupIn(T.class, lookup)\u003c/code\u003e\u003c/a\u003e can be used to teleport a \u003ccode\u003elookup\u003c/code\u003e from class \u003ccode\u003eC\u003c/code\u003e to class \u003ccode\u003eT\u003c/code\u003e and create a new \u003ccode\u003eLookup\u003c/code\u003e with \u003ca href\u003d\"#privacc\"\u003eprivate access\u003c/a\u003e if the lookup class is allowed to do \u003cem\u003edeep reflection\u003c/em\u003e on \u003ccode\u003eT\u003c/code\u003e. The \u003ccode\u003elookup\u003c/code\u003e must have \u003ca href\u003d\"#MODULE\"\u003e\u003ccode\u003eMODULE\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#PRIVATE\"\u003e\u003ccode\u003ePRIVATE\u003c/code\u003e\u003c/a\u003e access to call \u003ccode\u003eprivateLookupIn\u003c/code\u003e. A \u003ccode\u003elookup\u003c/code\u003e on \u003ccode\u003eC\u003c/code\u003e in module \u003ccode\u003eM1\u003c/code\u003e is allowed to do deep reflection on all classes in \u003ccode\u003eM1\u003c/code\u003e. If \u003ccode\u003eT\u003c/code\u003e is in \u003ccode\u003eM1\u003c/code\u003e, \u003ccode\u003eprivateLookupIn\u003c/code\u003e produces a new \u003ccode\u003eLookup\u003c/code\u003e on \u003ccode\u003eT\u003c/code\u003e with full capabilities. A \u003ccode\u003elookup\u003c/code\u003e on \u003ccode\u003eC\u003c/code\u003e is also allowed to do deep reflection on \u003ccode\u003eT\u003c/code\u003e in another module \u003ccode\u003eM2\u003c/code\u003e if \u003ccode\u003eM1\u003c/code\u003e reads \u003ccode\u003eM2\u003c/code\u003e and \u003ccode\u003eM2\u003c/code\u003e \u003ca href\u003d\"../Module.html#isOpen(java.lang.String,java.lang.Module)\"\u003e\u003ccode\u003eopens\u003c/code\u003e\u003c/a\u003e the package containing \u003ccode\u003eT\u003c/code\u003e to at least \u003ccode\u003eM1\u003c/code\u003e. \u003ccode\u003eT\u003c/code\u003e becomes the new lookup class and \u003ccode\u003eC\u003c/code\u003e becomes the new previous lookup class and \u003ccode\u003eMODULE\u003c/code\u003e access is dropped from the resulting \u003ccode\u003eLookup\u003c/code\u003e. The resulting \u003ccode\u003eLookup\u003c/code\u003e can be used to do member lookup or teleport to another lookup class by calling \u003ca href\u003d\"#in(java.lang.Class)\"\u003e\u003ccode\u003eLookup::in\u003c/code\u003e\u003c/a\u003e. But it cannot be used to obtain another private \u003ccode\u003eLookup\u003c/code\u003e by calling \u003ca href\u003d\"MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003eprivateLookupIn\u003c/code\u003e\u003c/a\u003e because it has no \u003ccode\u003eMODULE\u003c/code\u003e access. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"module-access-check\"\u003e\u003c/a\u003eCross-module access checks\u003c/h2\u003e A \n\u003ccode\u003eLookup\u003c/code\u003e with \n\u003ca href\u003d\"#PUBLIC\"\u003e\u003ccode\u003ePUBLIC\u003c/code\u003e\u003c/a\u003e or with \n\u003ca href\u003d\"#UNCONDITIONAL\"\u003e\u003ccode\u003eUNCONDITIONAL\u003c/code\u003e\u003c/a\u003e mode allows cross-module access. The access checking is performed with respect to both the lookup class and the previous lookup class if present. \n\u003cp\u003e A \u003ccode\u003eLookup\u003c/code\u003e with \u003ca href\u003d\"#UNCONDITIONAL\"\u003e\u003ccode\u003eUNCONDITIONAL\u003c/code\u003e\u003c/a\u003e mode can access public type in all modules when the type is in a package that is \u003ca href\u003d\"../Module.html#isExported(java.lang.String)\"\u003eexported unconditionally\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e If a \u003ccode\u003eLookup\u003c/code\u003e on \u003ccode\u003eLC\u003c/code\u003e in \u003ccode\u003eM1\u003c/code\u003e has no previous lookup class, the lookup with \u003ca href\u003d\"#PUBLIC\"\u003e\u003ccode\u003ePUBLIC\u003c/code\u003e\u003c/a\u003e mode can access all public types in modules that are readable to \u003ccode\u003eM1\u003c/code\u003e and the type is in a package that is exported at least to \u003ccode\u003eM1\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e If a \u003ccode\u003eLookup\u003c/code\u003e on \u003ccode\u003eLC\u003c/code\u003e in \u003ccode\u003eM1\u003c/code\u003e has a previous lookup class \u003ccode\u003ePLC\u003c/code\u003e on \u003ccode\u003eM0\u003c/code\u003e, the lookup with \u003ca href\u003d\"#PUBLIC\"\u003e\u003ccode\u003ePUBLIC\u003c/code\u003e\u003c/a\u003e mode can access the intersection of all public types that are accessible to \u003ccode\u003eM1\u003c/code\u003e with all public types that are accessible to \u003ccode\u003eM0\u003c/code\u003e. \u003ccode\u003eM0\u003c/code\u003e reads \u003ccode\u003eM1\u003c/code\u003e and hence the set of accessible types includes: \u003c/p\u003e\n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n   Public types in the following packages are accessible to the lookup class and the previous lookup class. \n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003eEqually accessible types to \u003ccode\u003eM0\u003c/code\u003e and \u003ccode\u003eM1\u003c/code\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003eunconditional-exported packages from \u003ccode\u003eM1\u003c/code\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003eunconditional-exported packages from \u003ccode\u003eM0\u003c/code\u003e if \u003ccode\u003eM1\u003c/code\u003e reads \u003ccode\u003eM0\u003c/code\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003eunconditional-exported packages from a third module \u003ccode\u003eM2\u003c/code\u003e if both \u003ccode\u003eM0\u003c/code\u003e and \u003ccode\u003eM1\u003c/code\u003e read \u003ccode\u003eM2\u003c/code\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003equalified-exported packages from \u003ccode\u003eM1\u003c/code\u003e to \u003ccode\u003eM0\u003c/code\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003equalified-exported packages from \u003ccode\u003eM0\u003c/code\u003e to \u003ccode\u003eM1\u003c/code\u003e if \u003ccode\u003eM1\u003c/code\u003e reads \u003ccode\u003eM0\u003c/code\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003equalified-exported packages from a third module \u003ccode\u003eM2\u003c/code\u003e to both \u003ccode\u003eM0\u003c/code\u003e and \u003ccode\u003eM1\u003c/code\u003e if both \u003ccode\u003eM0\u003c/code\u003e and \u003ccode\u003eM1\u003c/code\u003e read \u003ccode\u003eM2\u003c/code\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"access-modes\"\u003e\u003c/a\u003eAccess modes\u003c/h2\u003e The table below shows the access modes of a \n\u003ccode\u003eLookup\u003c/code\u003e produced by any of the following factory or transformation methods: \n\u003cul\u003e \n \u003cli\u003e\u003ca href\u003d\"MethodHandles.html#lookup()\"\u003e\u003ccode\u003eMethodHandles::lookup\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e \n \u003cli\u003e\u003ca href\u003d\"MethodHandles.html#publicLookup()\"\u003e\u003ccode\u003eMethodHandles::publicLookup\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e \n \u003cli\u003e\u003ca href\u003d\"MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003eMethodHandles::privateLookupIn\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e \n \u003cli\u003e\u003ca href\u003d\"#in(java.lang.Class)\"\u003e\u003ccode\u003eLookup::in\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e \n \u003cli\u003e\u003ca href\u003d\"#dropLookupMode(int)\"\u003e\u003ccode\u003eLookup::dropLookupMode\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e \n\u003c/ul\u003e \n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n   Access mode summary \n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003eLookup object\u003c/th\u003e \n   \u003cth style\u003d\"text-align:center\"\u003eoriginal\u003c/th\u003e \n   \u003cth style\u003d\"text-align:center\"\u003eprotected\u003c/th\u003e \n   \u003cth style\u003d\"text-align:center\"\u003eprivate\u003c/th\u003e \n   \u003cth style\u003d\"text-align:center\"\u003epackage\u003c/th\u003e \n   \u003cth style\u003d\"text-align:center\"\u003emodule\u003c/th\u003e \n   \u003cth style\u003d\"text-align:center\"\u003epublic\u003c/th\u003e \n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003e\u003ccode\u003eCL \u003d MethodHandles.lookup()\u003c/code\u003e in \u003ccode\u003eC\u003c/code\u003e\u003c/th\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eORI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRO\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003e\u003ccode\u003eCL.in(C1)\u003c/code\u003e same package\u003c/th\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003e\u003ccode\u003eCL.in(C1)\u003c/code\u003e same module\u003c/th\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\" style\u003d\"text-align:left\"\u003e\u003ccode\u003eCL.in(D)\u003c/code\u003e different module\u003c/th\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eCL.in(D).in(C)\u003c/code\u003e hop back to module\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1 \u003d privateLookupIn(C1,CL)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRO\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1a \u003d privateLookupIn(C,PRI1)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRO\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.in(C1)\u003c/code\u003e same package\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.in(C1)\u003c/code\u003e different package\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.in(D)\u003c/code\u003e different module\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.dropLookupMode(PROTECTED)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.dropLookupMode(PRIVATE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.dropLookupMode(PACKAGE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.dropLookupMode(MODULE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI1.dropLookupMode(PUBLIC)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003enone\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2 \u003d privateLookupIn(D,CL)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRO\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eprivateLookupIn(D,PRI1)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRO\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eprivateLookupIn(C,PRI2)\u003c/code\u003e fails\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eIAE\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.in(D2)\u003c/code\u003e same package\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.in(D2)\u003c/code\u003e different package\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.in(C1)\u003c/code\u003e hop back to module\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.in(E)\u003c/code\u003e hop to third module\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003enone\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.dropLookupMode(PROTECTED)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.dropLookupMode(PRIVATE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.dropLookupMode(PACKAGE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.dropLookupMode(MODULE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e2R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePRI2.dropLookupMode(PUBLIC)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003enone\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eCL.dropLookupMode(PROTECTED)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePRI\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eCL.dropLookupMode(PRIVATE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003ePAC\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eCL.dropLookupMode(PACKAGE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eMOD\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eCL.dropLookupMode(MODULE)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003e1R\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eCL.dropLookupMode(PUBLIC)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003enone\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePUB \u003d publicLookup()\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eU\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePUB.in(D)\u003c/code\u003e different module\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eU\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePUB.in(D).in(E)\u003c/code\u003e third module\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eU\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003ePUB.dropLookupMode(UNCONDITIONAL)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003enone\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eprivateLookupIn(C1,PUB)\u003c/code\u003e fails\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003eIAE\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003ctd\u003e\u003ccode\u003eANY.in(X)\u003c/code\u003e, for inaccessible \u003ccode\u003eX\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003c/td\u003e \n   \u003ctd style\u003d\"text-align:center\"\u003enone\u003c/td\u003e \n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003e Notes: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eClass \u003ccode\u003eC\u003c/code\u003e and class \u003ccode\u003eC1\u003c/code\u003e are in module \u003ccode\u003eM1\u003c/code\u003e, but \u003ccode\u003eD\u003c/code\u003e and \u003ccode\u003eD2\u003c/code\u003e are in module \u003ccode\u003eM2\u003c/code\u003e, and \u003ccode\u003eE\u003c/code\u003e is in module \u003ccode\u003eM3\u003c/code\u003e. \u003ccode\u003eX\u003c/code\u003e stands for class which is inaccessible to the lookup. \u003ccode\u003eANY\u003c/code\u003e stands for any of the example lookups.\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eORI\u003c/code\u003e indicates \u003ca href\u003d\"#ORIGINAL\"\u003e\u003ccode\u003eORIGINAL\u003c/code\u003e\u003c/a\u003e bit set, \u003ccode\u003ePRO\u003c/code\u003e indicates \u003ca href\u003d\"#PROTECTED\"\u003e\u003ccode\u003ePROTECTED\u003c/code\u003e\u003c/a\u003e bit set, \u003ccode\u003ePRI\u003c/code\u003e indicates \u003ca href\u003d\"#PRIVATE\"\u003e\u003ccode\u003ePRIVATE\u003c/code\u003e\u003c/a\u003e bit set, \u003ccode\u003ePAC\u003c/code\u003e indicates \u003ca href\u003d\"#PACKAGE\"\u003e\u003ccode\u003ePACKAGE\u003c/code\u003e\u003c/a\u003e bit set, \u003ccode\u003eMOD\u003c/code\u003e indicates \u003ca href\u003d\"#MODULE\"\u003e\u003ccode\u003eMODULE\u003c/code\u003e\u003c/a\u003e bit set, \u003ccode\u003e1R\u003c/code\u003e and \u003ccode\u003e2R\u003c/code\u003e indicate \u003ca href\u003d\"#PUBLIC\"\u003e\u003ccode\u003ePUBLIC\u003c/code\u003e\u003c/a\u003e bit set, \u003ccode\u003eU\u003c/code\u003e indicates \u003ca href\u003d\"#UNCONDITIONAL\"\u003e\u003ccode\u003eUNCONDITIONAL\u003c/code\u003e\u003c/a\u003e bit set, \u003ccode\u003eIAE\u003c/code\u003e indicates \u003ccode\u003eIllegalAccessException\u003c/code\u003e thrown.\u003c/li\u003e \n \u003cli\u003ePublic access comes in three kinds: \n  \u003cul\u003e \n   \u003cli\u003eunconditional (\u003ccode\u003eU\u003c/code\u003e): the lookup assumes readability. The lookup has \u003ccode\u003enull\u003c/code\u003e previous lookup class. \u003c/li\u003e\n   \u003cli\u003eone-module-reads (\u003ccode\u003e1R\u003c/code\u003e): the module access checking is performed with respect to the lookup class. The lookup has \u003ccode\u003enull\u003c/code\u003e previous lookup class. \u003c/li\u003e\n   \u003cli\u003etwo-module-reads (\u003ccode\u003e2R\u003c/code\u003e): the module access checking is performed with respect to the lookup class and the previous lookup class. The lookup has a non-null previous lookup class which is in a different module from the current lookup class. \u003c/li\u003e\n  \u003c/ul\u003e \u003c/li\u003e\n \u003cli\u003eAny attempt to reach a third module loses all access.\u003c/li\u003e \n \u003cli\u003eIf a target class \u003ccode\u003eX\u003c/code\u003e is not accessible to \u003ccode\u003eLookup::in\u003c/code\u003e all access modes are dropped.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"secmgr\"\u003e\u003c/a\u003eSecurity manager interactions\u003c/h2\u003e Although bytecode instructions can only refer to classes in a related class loader, this API can search for methods in any class, as long as a reference to its \n\u003ccode\u003eClass\u003c/code\u003e object is available. Such cross-loader references are also possible with the Core Reflection API, and are impossible to bytecode instructions such as \n\u003ccode\u003einvokestatic\u003c/code\u003e or \n\u003ccode\u003egetfield\u003c/code\u003e. There is a \n\u003ca href\u003d\"../SecurityManager.html\" title\u003d\"class in java.lang\"\u003esecurity manager API\u003c/a\u003e to allow applications to check such cross-loader references. These checks apply to both the \n\u003ccode\u003eMethodHandles.Lookup\u003c/code\u003e API and the Core Reflection API (as found on \n\u003ca href\u003d\"../Class.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eClass\u003c/code\u003e\u003c/a\u003e). \n\u003cp\u003e If a security manager is present, member and class lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a \u003ca href\u003d\"../SecurityException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eSecurityException\u003c/code\u003e\u003c/a\u003e. Define \u003ccode\u003esmgr\u003c/code\u003e as the security manager, \u003ccode\u003elookc\u003c/code\u003e as the lookup class of the current lookup object, \u003ccode\u003erefc\u003c/code\u003e as the containing class in which the member is being sought, and \u003ccode\u003edefc\u003c/code\u003e as the class in which the member is actually defined. (If a class or other type is being accessed, the \u003ccode\u003erefc\u003c/code\u003e and \u003ccode\u003edefc\u003c/code\u003e values are the class itself.) The value \u003ccode\u003elookc\u003c/code\u003e is defined as \u003cem\u003enot present\u003c/em\u003e if the current lookup object does not have \u003ca href\u003d\"#hasFullPrivilegeAccess()\"\u003efull privilege access\u003c/a\u003e. The calls are made according to the following rules: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003cb\u003eStep 1:\u003c/b\u003e If \u003ccode\u003elookc\u003c/code\u003e is not present, or if its class loader is not the same as or an ancestor of the class loader of \u003ccode\u003erefc\u003c/code\u003e, then \u003ca href\u003d\"../SecurityManager.html#checkPackageAccess(java.lang.String)\"\u003e\u003ccode\u003esmgr.checkPackageAccess(refcPkg)\u003c/code\u003e\u003c/a\u003e is called, where \u003ccode\u003erefcPkg\u003c/code\u003e is the package of \u003ccode\u003erefc\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003e\u003cb\u003eStep 2a:\u003c/b\u003e If the retrieved member is not public and \u003ccode\u003elookc\u003c/code\u003e is not present, then \u003ca href\u003d\"../SecurityManager.html#checkPermission(java.security.Permission)\"\u003e\u003ccode\u003esmgr.checkPermission\u003c/code\u003e\u003c/a\u003e with \u003ccode\u003eRuntimePermission(\"accessDeclaredMembers\")\u003c/code\u003e is called. \u003c/li\u003e\n \u003cli\u003e\u003cb\u003eStep 2b:\u003c/b\u003e If the retrieved class has a \u003ccode\u003enull\u003c/code\u003e class loader, and \u003ccode\u003elookc\u003c/code\u003e is not present, then \u003ca href\u003d\"../SecurityManager.html#checkPermission(java.security.Permission)\"\u003e\u003ccode\u003esmgr.checkPermission\u003c/code\u003e\u003c/a\u003e with \u003ccode\u003eRuntimePermission(\"getClassLoader\")\u003c/code\u003e is called. \u003c/li\u003e\n \u003cli\u003e\u003cb\u003eStep 3:\u003c/b\u003e If the retrieved member is not public, and if \u003ccode\u003elookc\u003c/code\u003e is not present, and if \u003ccode\u003edefc\u003c/code\u003e and \u003ccode\u003erefc\u003c/code\u003e are different, then \u003ca href\u003d\"../SecurityManager.html#checkPackageAccess(java.lang.String)\"\u003e\u003ccode\u003esmgr.checkPackageAccess(defcPkg)\u003c/code\u003e\u003c/a\u003e is called, where \u003ccode\u003edefcPkg\u003c/code\u003e is the package of \u003ccode\u003edefc\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e Security checks are performed after other access checks have passed. Therefore, the above rules presuppose a member or class that is public, or else that is being accessed from a lookup class that has rights to access the member or class. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e If a security manager is present and the current lookup object does not have \u003ca href\u003d\"#hasFullPrivilegeAccess()\"\u003efull privilege access\u003c/a\u003e, then \u003ca href\u003d\"#defineClass(byte%5B%5D)\"\u003e\u003ccode\u003edefineClass\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)\"\u003e\u003ccode\u003edefineHiddenClass\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#defineHiddenClassWithClassData(byte%5B%5D,java.lang.Object,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)\"\u003e\u003ccode\u003edefineHiddenClassWithClassData\u003c/code\u003e\u003c/a\u003e calls \u003ca href\u003d\"../SecurityManager.html#checkPermission(java.security.Permission)\"\u003e\u003ccode\u003esmgr.checkPermission\u003c/code\u003e\u003c/a\u003e with \u003ccode\u003eRuntimePermission(\"defineClass\")\u003c/code\u003e. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"callsens\"\u003e\u003c/a\u003eCaller sensitive methods\u003c/h2\u003e A small number of Java methods have a special property called caller sensitivity. A \n\u003cem\u003ecaller-sensitive\u003c/em\u003e method can behave differently depending on the identity of its immediate caller. \n\u003cp\u003e If a method handle for a caller-sensitive method is requested, the general rules for \u003ca href\u003d\"MethodHandles.Lookup.html#equiv\"\u003ebytecode behaviors\u003c/a\u003e apply, but they take account of the lookup class in a special way. The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class. (By contrast, the invoker of the method handle is disregarded.) Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles. \u003c/p\u003e\n\u003cp\u003e In cases where the lookup object is \u003ca href\u003d\"MethodHandles.html#publicLookup()\"\u003e\u003ccode\u003epublicLookup()\u003c/code\u003e\u003c/a\u003e, or some other lookup object without the \u003ca href\u003d\"#ORIGINAL\"\u003eoriginal access\u003c/a\u003e, the lookup class is disregarded. In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an \u003ccode\u003eIllegalAccessException\u003c/code\u003e. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e \u003cem\u003eDiscussion:\u003c/em\u003e For example, the caller-sensitive method \u003ca href\u003d\"../Class.html#forName(java.lang.String)\"\u003e\u003ccode\u003eClass.forName(x)\u003c/code\u003e\u003c/a\u003e can return varying classes or throw varying exceptions, depending on the class loader of the class that calls it. A public lookup of \u003ccode\u003eClass.forName\u003c/code\u003e will fail, because there is no reasonable way to determine its bytecode behavior. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e If an application caches method handles for broad sharing, it should use \u003ccode\u003epublicLookup()\u003c/code\u003e to create them. If there is a lookup of \u003ccode\u003eClass.forName\u003c/code\u003e, it will fail, and the application must take appropriate action in that case. It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible. \u003c/p\u003e\n\u003cp style\u003d\"font-size:smaller;\"\u003e The function \u003ccode\u003eMethodHandles.lookup\u003c/code\u003e is caller sensitive so that there can be a secure foundation for lookups. Nearly all other methods in the JSR 292 API rely on lookup objects to check access requests.\u003c/p\u003e",
  "tagMap": {}
}