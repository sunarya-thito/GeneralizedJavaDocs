{
  "packageName": "java.lang.invoke",
  "simpleName": "CallSite",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.invoke.MethodType",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "type",
      "comment": "Returns the type of this call site\u0027s target. Although targets may change, any call site\u0027s type is permanent, and can never change to an unequal type. The setTarget method enforces this invariant by refusing any new target that does not have the previous target\u0027s type.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the type of the current target, which is also the type of any future target"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getTarget",
      "comment": "Returns the target method of the call site, according to the behavior defined by this call site\u0027s specific class. The immediate subclasses of CallSite document the class-specific behaviors of this method.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/ConstantCallSite.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eConstantCallSite\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VolatileCallSite.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eVolatileCallSite\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html#setTarget(java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003esetTarget(java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/ConstantCallSite.html#getTarget()\"\u003e\u003ccode\u003eConstantCallSite.getTarget()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MutableCallSite.html#getTarget()\"\u003e\u003ccode\u003eMutableCallSite.getTarget()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VolatileCallSite.html#getTarget()\"\u003e\u003ccode\u003eVolatileCallSite.getTarget()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the current linkage state of the call site, its target method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "name": "newTarget",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setTarget",
      "comment": "Updates the target method of this call site, according to the behavior defined by this call site\u0027s specific class. The immediate subclasses of CallSite document the class-specific behaviors of this method. The type of the new target must be equal to the type of the old target.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html#getTarget()\"\u003e\u003ccode\u003egetTarget()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/ConstantCallSite.html#setTarget(java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003eConstantCallSite.setTarget(java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MutableCallSite.html#setTarget(java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003eMutableCallSite.setTarget(java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VolatileCallSite.html#setTarget(java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003eVolatileCallSite.setTarget(java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003enewTarget\u003c/code\u003e - the new target"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the proposed new target is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the proposed new target has a method type that differs from the previous target"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "dynamicInvoker",
      "comment": "Produces a method handle equivalent to an invokedynamic instruction which has been linked to this call site. This method is equivalent to the following code: \n MethodHandle getTarget, invoker, result;\n getTarget \u003d MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker \u003d MethodHandles.exactInvoker(this.type());\n result \u003d MethodHandles.foldArguments(invoker, getTarget)",
      "annotations": [],
      "tagMap": {
        "return": [
          "a method handle which always invokes this call site\u0027s current target"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.lang.invoke.CallSite",
  "comment": "A \n\u003ccode\u003eCallSite\u003c/code\u003e is a holder for a variable \n\u003ca href\u003d\"MethodHandle.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandle\u003c/code\u003e\u003c/a\u003e, which is called its \n\u003ccode\u003etarget\u003c/code\u003e. An \n\u003ccode\u003einvokedynamic\u003c/code\u003e instruction linked to a \n\u003ccode\u003eCallSite\u003c/code\u003e delegates all calls to the site\u0027s current target. A \n\u003ccode\u003eCallSite\u003c/code\u003e may be associated with several \n\u003ccode\u003einvokedynamic\u003c/code\u003e instructions, or it may be \"free floating\", associated with none. In any case, it may be invoked through an associated method handle called its \n\u003ca href\u003d\"#dynamicInvoker()\"\u003edynamic invoker\u003c/a\u003e. \n\u003cp\u003e \u003ccode\u003eCallSite\u003c/code\u003e is an abstract class which does not allow direct subclassing by users. It has three immediate, concrete subclasses that may be either instantiated or subclassed. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eIf a mutable target is not required, an \u003ccode\u003einvokedynamic\u003c/code\u003e instruction may be permanently bound by means of a \u003ca href\u003d\"ConstantCallSite.html\" title\u003d\"class in java.lang.invoke\"\u003econstant call site\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003eIf a mutable target is required which has volatile variable semantics, because updates to the target must be immediately and reliably witnessed by other threads, a \u003ca href\u003d\"VolatileCallSite.html\" title\u003d\"class in java.lang.invoke\"\u003evolatile call site\u003c/a\u003e may be used. \u003c/li\u003e\n \u003cli\u003eOtherwise, if a mutable target is required, a \u003ca href\u003d\"MutableCallSite.html\" title\u003d\"class in java.lang.invoke\"\u003emutable call site\u003c/a\u003e may be used. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e A non-constant call site may be \u003cem\u003erelinked\u003c/em\u003e by changing its target. The new target must have the same \u003ca href\u003d\"MethodHandle.html#type()\"\u003etype\u003c/a\u003e as the previous target. Thus, though a call site can be relinked to a series of successive targets, it cannot change its type. \u003c/p\u003e\n\u003cp\u003e Here is a sample use of call sites and bootstrap methods which links every dynamic call site to print its arguments: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nstatic void test() throws Throwable {\n    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION\n    InvokeDynamic[#bootstrapDynamic].baz(\"baz arg\", 2, 3.14);\n}\nprivate static void printArgs(Object... args) {\n  System.out.println(java.util.Arrays.deepToString(args));\n}\nprivate static final MethodHandle printArgs;\nstatic {\n  MethodHandles.Lookup lookup \u003d MethodHandles.lookup();\n  Class thisClass \u003d lookup.lookupClass();  // (who am I?)\n  printArgs \u003d lookup.findStatic(thisClass,\n      \"printArgs\", MethodType.methodType(void.class, Object[].class));\n}\nprivate static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {\n  // ignore caller and name, but match the type:\n  return new ConstantCallSite(printArgs.asType(type));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.7"
    ]
  }
}