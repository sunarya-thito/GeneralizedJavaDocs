{
  "packageName": "java.lang.invoke",
  "simpleName": "MethodHandleInfo",
  "moduleName": "java.base",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_getField",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_getField\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_getStatic",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_getStatic\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_putField",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_putField\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_putStatic",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_putStatic\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_invokeVirtual",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_invokeVirtual\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_invokeStatic",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_invokeStatic\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_invokeSpecial",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_invokeSpecial\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_newInvokeSpecial",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_newInvokeSpecial\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 24,
      "name": "REF_invokeInterface",
      "comment": "A direct method handle reference kind, as defined in the table above.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#java.lang.invoke.MethodHandleInfo.REF_invokeInterface\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getReferenceKind",
      "comment": "Returns the reference kind of the cracked method handle, which in turn determines whether the method handle\u0027s underlying member was a constructor, method, or field. See the table above for definitions.",
      "tagMap": {
        "return": [
          "the integer code for the kind of reference used to access the underlying member"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getDeclaringClass",
      "comment": "Returns the class in which the cracked method handle\u0027s underlying member was defined.",
      "tagMap": {
        "return": [
          "the declaring class of the underlying member"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getName",
      "comment": "Returns the name of the cracked method handle\u0027s underlying member. This is \"\u003cinit\u003e\" if the underlying member was a constructor, else it is a simple method name or field name.",
      "tagMap": {
        "return": [
          "the simple name of the underlying member"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodType",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getMethodType",
      "comment": "Returns the nominal type of the cracked symbolic reference, expressed as a method type. If the reference is to a constructor, the return type will be void. If it is to a non-static method, the method type will not mention the this parameter. If it is to a field and the requested access is to read the field, the method type will have no parameters and return the field type. If it is to a field and the requested access is to write the field, the method type will have one parameter of the field type and return void. Note that original direct method handle may include a leading this parameter, or (in the case of a constructor) will replace the void return type with the constructed class. The nominal type does not include any this parameter, and (in the case of a constructor) will return void.",
      "tagMap": {
        "return": [
          "the type of the underlying member, expressed as a method type"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "expected"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandles$Lookup",
            "type": "Class"
          },
          "field": {
            "name": "lookup"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "upperBounds": [
            {
              "name": "java.lang.reflect.Member",
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "reflectAs",
      "comment": "Reflects the underlying member as a method, constructor, or field object. If the underlying member is public, it is reflected as if by getMethod, getConstructor, or getField. Otherwise, it is reflected as if by getDeclaredMethod, getDeclaredConstructor, or getDeclaredField. The underlying member must be accessible to the given lookup object.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the desired type of the result, either \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Member.html\" title\u003d\"interface in java.lang.reflect\"\u003e\u003ccode\u003eMember\u003c/code\u003e\u003c/a\u003e or a subtype"
        ],
        "param": [
          "\u003ccode\u003eexpected\u003c/code\u003e - a class object representing the desired result type \n\u003ccode\u003eT\u003c/code\u003e",
          "\u003ccode\u003elookup\u003c/code\u003e - the lookup object that created this MethodHandleInfo, or one with equivalent access privileges"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the member is not of the expected type",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the underlying member is not accessible to the given lookup object"
        ],
        "return": [
          "a reference to the method, constructor, or field object"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getModifiers",
      "comment": "Returns the access modifiers of the underlying member.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Modifier.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eModifier\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html#reflectAs(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)\"\u003e\u003ccode\u003ereflectAs(java.lang.Class\u0026lt;T\u0026gt;, java.lang.invoke.MethodHandles.Lookup)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the Java language modifiers for underlying member, or -1 if the member cannot be accessed"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": true,
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "isVarArgs",
      "comment": "Determines if the underlying member was a variable arity method or constructor. Such members are represented by method handles that are varargs collectors.",
      "tagMap": {
        "implSpec": [
          "This produces a result equivalent to: \n\u003cpre\u003e\u003ccode\u003e\n     getReferenceKind() \u0026gt;\u003d REF_invokeVirtual \u0026amp;\u0026amp; Modifier.isTransient(getModifiers())\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if and only if the underlying member was declared with variable arity."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "referenceKind"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "referenceKindToString",
      "comment": "Returns the descriptive name of the given reference kind, as defined in the table above. The conventional prefix \"REF_\" is omitted.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ereferenceKind\u003c/code\u003e - an integer code for a kind of reference used to access a class member"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the argument is not a valid \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html#refkinds\"\u003ereference kind number\u003c/a\u003e"
        ],
        "return": [
          "a mixed-case string such as \n\u003ccode\u003e\"getField\"\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "kind"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "defc"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 8,
      "name": "toString",
      "comment": "Returns a string representation for a MethodHandleInfo, given the four parts of its symbolic reference. This is defined to be of the form \"RK C.N:MT\", where RK is the reference kind string for kind, C is the name of defc N is the name, and MT is the type. These four values may be obtained from the reference kind, declaring class, member name, and method type of a MethodHandleInfo object.",
      "tagMap": {
        "implSpec": [
          "This produces a result equivalent to: \n\u003cpre\u003e\u003ccode\u003e\n     String.format(\"%s %s.%s:%s\", referenceKindToString(kind), defc.getName(), name, type)\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003ekind\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html#getReferenceKind()\"\u003ereference kind\u003c/a\u003e part of the symbolic reference",
          "\u003ccode\u003edefc\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html#getDeclaringClass()\"\u003edeclaring class\u003c/a\u003e part of the symbolic reference",
          "\u003ccode\u003ename\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html#getName()\"\u003emember name\u003c/a\u003e part of the symbolic reference",
          "\u003ccode\u003etype\u003c/code\u003e - the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html#getMethodType()\"\u003emethod type\u003c/a\u003e part of the symbolic reference"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the first argument is not a valid \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandleInfo.html#refkinds\"\u003ereference kind number\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any reference argument is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "a string of the form \n\u003ccode\u003e\"RK C.N:MT\"\u003c/code\u003e"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "java.lang.invoke.MethodHandleInfo",
  "comment": "A symbolic reference obtained by cracking a direct method handle into its constituent symbolic parts. To crack a direct method handle, call \n\u003ca href\u003d\"MethodHandles.Lookup.html#revealDirect(java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003eLookup.revealDirect\u003c/code\u003e\u003c/a\u003e. \n\u003ch2\u003e\u003ca id\u003d\"directmh\"\u003e\u003c/a\u003eDirect Method Handles\u003c/h2\u003e A \n\u003cem\u003edirect method handle\u003c/em\u003e represents a method, constructor, or field without any intervening argument bindings or other transformations. The method, constructor, or field referred to by a direct method handle is called its \n\u003cem\u003eunderlying member\u003c/em\u003e. Direct method handles may be obtained in any of these ways: \n\u003cul\u003e \n \u003cli\u003eBy executing an \u003ccode\u003eldc\u003c/code\u003e instruction on a \u003ccode\u003eCONSTANT_MethodHandle\u003c/code\u003e constant. (See the Java Virtual Machine Specification, sections \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.4.8\"\u003e4.4.8\u003c/a\u003e and \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.3\"\u003e5.4.3\u003c/a\u003e.) \u003c/li\u003e\n \u003cli\u003eBy calling one of the \u003ca href\u003d\"MethodHandles.Lookup.html#lookups\"\u003eLookup Factory Methods\u003c/a\u003e, such as \u003ca href\u003d\"MethodHandles.Lookup.html#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eLookup.findVirtual\u003c/code\u003e\u003c/a\u003e, to resolve a symbolic reference into a method handle. A symbolic reference consists of a class, name string, and type. \u003c/li\u003e\n \u003cli\u003eBy calling the factory method \u003ca href\u003d\"MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)\"\u003e\u003ccode\u003eLookup.unreflect\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"MethodHandles.Lookup.html#unreflectSpecial(java.lang.reflect.Method,java.lang.Class)\"\u003e\u003ccode\u003eLookup.unreflectSpecial\u003c/code\u003e\u003c/a\u003e to convert a \u003ca href\u003d\"../reflect/Method.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eMethod\u003c/code\u003e\u003c/a\u003e into a method handle. \u003c/li\u003e\n \u003cli\u003eBy calling the factory method \u003ca href\u003d\"MethodHandles.Lookup.html#unreflectConstructor(java.lang.reflect.Constructor)\"\u003e\u003ccode\u003eLookup.unreflectConstructor\u003c/code\u003e\u003c/a\u003e to convert a \u003ca href\u003d\"../reflect/Constructor.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eConstructor\u003c/code\u003e\u003c/a\u003e into a method handle. \u003c/li\u003e\n \u003cli\u003eBy calling the factory method \u003ca href\u003d\"MethodHandles.Lookup.html#unreflectGetter(java.lang.reflect.Field)\"\u003e\u003ccode\u003eLookup.unreflectGetter\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"MethodHandles.Lookup.html#unreflectSetter(java.lang.reflect.Field)\"\u003e\u003ccode\u003eLookup.unreflectSetter\u003c/code\u003e\u003c/a\u003e to convert a \u003ca href\u003d\"../reflect/Field.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eField\u003c/code\u003e\u003c/a\u003e into a method handle. \u003c/li\u003e\n\u003c/ul\u003e \n\u003ch2\u003eRestrictions on Cracking\u003c/h2\u003e Given a suitable \n\u003ccode\u003eLookup\u003c/code\u003e object, it is possible to crack any direct method handle to recover a symbolic reference for the underlying method, constructor, or field. Cracking must be done via a \n\u003ccode\u003eLookup\u003c/code\u003e object equivalent to that which created the target method handle, or which has enough access permissions to recreate an equivalent method handle. \n\u003cp\u003e If the underlying method is \u003ca href\u003d\"MethodHandles.Lookup.html#callsens\"\u003ecaller sensitive\u003c/a\u003e, the direct method handle will have been \"bound\" to a particular caller class, the \u003ca href\u003d\"MethodHandles.Lookup.html#lookupClass()\"\u003elookup class\u003c/a\u003e of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like \u003ccode\u003eClass.forName\u003c/code\u003e). \u003c/p\u003e\n\u003cp\u003e The requirement of lookup object matching provides a \"fast fail\" behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use \u003ca href\u003d\"MethodHandles.html#reflectAs(java.lang.Class,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003eMethodHandles.reflectAs(java.lang.Class\u0026lt;T\u0026gt;, java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e to override this limitation. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"refkinds\"\u003e\u003c/a\u003eReference kinds\u003c/h2\u003e The \n\u003ca href\u003d\"MethodHandles.Lookup.html#lookups\"\u003eLookup Factory Methods\u003c/a\u003e correspond to all major use cases for methods, constructors, and fields. These use cases may be distinguished using small integers as follows: \n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n  reference kinds\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e\n   \u003cth scope\u003d\"col\"\u003ereference kind\u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003edescriptive name\u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003escope\u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003emember\u003c/th\u003e\n   \u003cth scope\u003d\"col\"\u003ebehavior\u003c/th\u003e\n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e1\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_getField\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) this.f;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e2\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_getStatic\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e or \u003ccode\u003einterface\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003estatic\u003c/code\u003e\u003cbr\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) C.f;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e3\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_putField\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003ethis.f \u003d x;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e4\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_putStatic\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003estatic\u003c/code\u003e\u003cbr\u003e\u003ccode\u003eFT f;\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eC.f \u003d arg;\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e5\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_invokeVirtual\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) this.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e6\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_invokeStatic\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e or \u003ccode\u003einterface\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003estatic\u003c/code\u003e\u003cbr\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) C.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e7\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_invokeSpecial\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e or \u003ccode\u003einterface\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) super.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e8\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_newInvokeSpecial\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003eclass\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eC(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003enew C(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003e9\u003c/code\u003e\u003c/th\u003e\n   \u003ctd\u003e\u003ccode\u003eREF_invokeInterface\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003einterface\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eT m(A*);\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003ccode\u003e(T) this.m(arg*);\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n \u003c/tbody\u003e \n\u003c/table\u003e",
  "tagMap": {
    "since": [
      "1.8"
    ]
  }
}