{
  "packageName": "java.lang.invoke",
  "simpleName": "VarHandle",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "hasInvokeExactBehavior",
      "comment": "Returns true if this VarHandle has invoke-exact behavior.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#withInvokeExactBehavior()\"\u003e\u003ccode\u003ewithInvokeExactBehavior()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#withInvokeBehavior()\"\u003e\u003ccode\u003ewithInvokeBehavior()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this VarHandle has \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#invoke-exact-behavior\"\u003e\u003cem\u003einvoke-exact behavior\u003c/em\u003e\u003c/a\u003e."
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "get",
      "comment": "Returns the value of a variable, with memory semantics of reading as if the variable was declared non-volatile. Commonly referred to as plain read access. The method signature is of the form (CT1 ct1, ..., CTn ctn)T. The symbolic type descriptor at the call site of get must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET) on this VarHandle. This access mode is supported by all VarHandle instances and never throws UnsupportedOperationException.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "set",
      "comment": "Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared non-volatile and non-final. Commonly referred to as plain write access. The method signature is of the form (CT1 ct1, ..., CTn ctn, T newValue)void The symbolic type descriptor at the call site of set must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.SET) on this VarHandle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getVolatile",
      "comment": "Returns the value of a variable, with memory semantics of reading as if the variable was declared volatile. The method signature is of the form (CT1 ct1, ..., CTn ctn)T. The symbolic type descriptor at the call site of getVolatile must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_VOLATILE) on this VarHandle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "setVolatile",
      "comment": "Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared volatile. The method signature is of the form (CT1 ct1, ..., CTn ctn, T newValue)void. The symbolic type descriptor at the call site of setVolatile must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.SET_VOLATILE) on this VarHandle.",
      "tagMap": {
        "apiNote": [
          "Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with \n\u003ccode\u003ememory_order_seq_cst\u003c/code\u003e."
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getOpaque",
      "comment": "Returns the value of a variable, accessed in program order, but with no assurance of memory ordering effects with respect to other threads. The method signature is of the form (CT1 ct1, ..., CTn ctn)T. The symbolic type descriptor at the call site of getOpaque must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_OPAQUE) on this VarHandle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "setOpaque",
      "comment": "Sets the value of a variable to the newValue, in program order, but with no assurance of memory ordering effects with respect to other threads. The method signature is of the form (CT1 ct1, ..., CTn ctn, T newValue)void. The symbolic type descriptor at the call site of setOpaque must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.SET_OPAQUE) on this VarHandle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAcquire",
      "comment": "Returns the value of a variable, and ensures that subsequent loads and stores are not reordered before this access. The method signature is of the form (CT1 ct1, ..., CTn ctn)T. The symbolic type descriptor at the call site of getAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "apiNote": [
          "Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with \n\u003ccode\u003ememory_order_acquire\u003c/code\u003e ordering."
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "setRelease",
      "comment": "Sets the value of a variable to the newValue, and ensures that prior loads and stores are not reordered after this access. The method signature is of the form (CT1 ct1, ..., CTn ctn, T newValue)void. The symbolic type descriptor at the call site of setRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.SET_RELEASE) on this VarHandle.",
      "tagMap": {
        "apiNote": [
          "Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with \n\u003ccode\u003ememory_order_release\u003c/code\u003e ordering."
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "compareAndSet",
      "comment": "Atomically sets the value of a variable to the newValue with the memory semantics of setVolatile(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of getVolatile(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean. The symbolic type descriptor at the call site of compareAndSet must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.COMPARE_AND_SET) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful, otherwise \n\u003ccode\u003efalse\u003c/code\u003e if the witness value was not the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "compareAndExchange",
      "comment": "Atomically sets the value of a variable to the newValue with the memory semantics of setVolatile(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of getVolatile(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T. The symbolic type descriptor at the call site of compareAndExchange must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type is not compatible with the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type is compatible with the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the witness value, which will be the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e if successful , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "compareAndExchangeAcquire",
      "comment": "Atomically sets the value of a variable to the newValue with the memory semantics of set(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of getAcquire(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T. The symbolic type descriptor at the call site of compareAndExchangeAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#set(java.lang.Object...)\"\u003e\u003ccode\u003eset(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAcquire(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the witness value, which will be the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e if successful , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "compareAndExchangeRelease",
      "comment": "Atomically sets the value of a variable to the newValue with the memory semantics of setRelease(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of get(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T. The symbolic type descriptor at the call site of compareAndExchangeRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setRelease(java.lang.Object...)\"\u003e\u003ccode\u003esetRelease(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#get(java.lang.Object...)\"\u003e\u003ccode\u003eget(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the witness value, which will be the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e if successful , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "weakCompareAndSetPlain",
      "comment": "Possibly atomically sets the value of a variable to the newValue with the semantics of set(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of get(java.lang.Object...). This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean. The symbolic type descriptor at the call site of weakCompareAndSetPlain must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#set(java.lang.Object...)\"\u003e\u003ccode\u003eset(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#get(java.lang.Object...)\"\u003e\u003ccode\u003eget(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful, otherwise \n\u003ccode\u003efalse\u003c/code\u003e if the witness value was not the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e or if this operation spuriously failed."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "weakCompareAndSet",
      "comment": "Possibly atomically sets the value of a variable to the newValue with the memory semantics of setVolatile(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of getVolatile(java.lang.Object...). This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean. The symbolic type descriptor at the call site of weakCompareAndSet must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful, otherwise \n\u003ccode\u003efalse\u003c/code\u003e if the witness value was not the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e or if this operation spuriously failed."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "weakCompareAndSetAcquire",
      "comment": "Possibly atomically sets the value of a variable to the newValue with the semantics of set(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of getAcquire(java.lang.Object...). This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean. The symbolic type descriptor at the call site of weakCompareAndSetAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#set(java.lang.Object...)\"\u003e\u003ccode\u003eset(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAcquire(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful, otherwise \n\u003ccode\u003efalse\u003c/code\u003e if the witness value was not the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e or if this operation spuriously failed."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "weakCompareAndSetRelease",
      "comment": "Possibly atomically sets the value of a variable to the newValue with the semantics of setRelease(java.lang.Object...) if the variable\u0027s current value, referred to as the witness value, \u003d\u003d the expectedValue, as accessed with the memory semantics of get(java.lang.Object...). This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. The method signature is of the form (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean. The symbolic type descriptor at the call site of weakCompareAndSetRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setRelease(java.lang.Object...)\"\u003e\u003ccode\u003esetRelease(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#get(java.lang.Object...)\"\u003e\u003ccode\u003eget(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if successful, otherwise \n\u003ccode\u003efalse\u003c/code\u003e if the witness value was not the same as the \n\u003ccode\u003eexpectedValue\u003c/code\u003e or if this operation spuriously failed."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndSet",
      "comment": "Atomically sets the value of a variable to the newValue with the memory semantics of setVolatile(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getVolatile(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T newValue)T. The symbolic type descriptor at the call site of getAndSet must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_SET) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndSetAcquire",
      "comment": "Atomically sets the value of a variable to the newValue with the memory semantics of set(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getAcquire(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T newValue)T. The symbolic type descriptor at the call site of getAndSetAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndSetRelease",
      "comment": "Atomically sets the value of a variable to the newValue with the memory semantics of setRelease(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of get(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T newValue)T. The symbolic type descriptor at the call site of getAndSetRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T newValue)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndAdd",
      "comment": "Atomically adds the value to the current value of a variable with the memory semantics of setVolatile(java.lang.Object...), and returns the variable\u0027s previous value, as accessed with the memory semantics of getVolatile(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T value)T. The symbolic type descriptor at the call site of getAndAdd must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_ADD) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T value)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndAddAcquire",
      "comment": "Atomically adds the value to the current value of a variable with the memory semantics of set(java.lang.Object...), and returns the variable\u0027s previous value, as accessed with the memory semantics of getAcquire(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T value)T. The symbolic type descriptor at the call site of getAndAddAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T value)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndAddRelease",
      "comment": "Atomically adds the value to the current value of a variable with the memory semantics of setRelease(java.lang.Object...), and returns the variable\u0027s previous value, as accessed with the memory semantics of get(java.lang.Object...). The method signature is of the form (CT1 ct1, ..., CTn ctn, T value)T. The symbolic type descriptor at the call site of getAndAddRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T value)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseOr",
      "comment": "Atomically sets the value of a variable to the result of bitwise OR between the variable\u0027s current value and the mask with the memory semantics of setVolatile(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getVolatile(java.lang.Object...). If the variable type is the non-integral boolean type then a logical OR is performed instead of a bitwise OR. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseOr must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseOrAcquire",
      "comment": "Atomically sets the value of a variable to the result of bitwise OR between the variable\u0027s current value and the mask with the memory semantics of set(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getAcquire(java.lang.Object...). If the variable type is the non-integral boolean type then a logical OR is performed instead of a bitwise OR. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseOrAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#set(java.lang.Object...)\"\u003e\u003ccode\u003eset(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAcquire(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseOrRelease",
      "comment": "Atomically sets the value of a variable to the result of bitwise OR between the variable\u0027s current value and the mask with the memory semantics of setRelease(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of get(java.lang.Object...). If the variable type is the non-integral boolean type then a logical OR is performed instead of a bitwise OR. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseOrRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setRelease(java.lang.Object...)\"\u003e\u003ccode\u003esetRelease(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#get(java.lang.Object...)\"\u003e\u003ccode\u003eget(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseAnd",
      "comment": "Atomically sets the value of a variable to the result of bitwise AND between the variable\u0027s current value and the mask with the memory semantics of setVolatile(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getVolatile(java.lang.Object...). If the variable type is the non-integral boolean type then a logical AND is performed instead of a bitwise AND. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseAnd must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseAndAcquire",
      "comment": "Atomically sets the value of a variable to the result of bitwise AND between the variable\u0027s current value and the mask with the memory semantics of set(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getAcquire(java.lang.Object...). If the variable type is the non-integral boolean type then a logical AND is performed instead of a bitwise AND. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseAndAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#set(java.lang.Object...)\"\u003e\u003ccode\u003eset(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAcquire(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseAndRelease",
      "comment": "Atomically sets the value of a variable to the result of bitwise AND between the variable\u0027s current value and the mask with the memory semantics of setRelease(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of get(java.lang.Object...). If the variable type is the non-integral boolean type then a logical AND is performed instead of a bitwise AND. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseAndRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setRelease(java.lang.Object...)\"\u003e\u003ccode\u003esetRelease(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#get(java.lang.Object...)\"\u003e\u003ccode\u003eget(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseXor",
      "comment": "Atomically sets the value of a variable to the result of bitwise XOR between the variable\u0027s current value and the mask with the memory semantics of setVolatile(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getVolatile(java.lang.Object...). If the variable type is the non-integral boolean type then a logical XOR is performed instead of a bitwise XOR. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseXor must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseXorAcquire",
      "comment": "Atomically sets the value of a variable to the result of bitwise XOR between the variable\u0027s current value and the mask with the memory semantics of set(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of getAcquire(java.lang.Object...). If the variable type is the non-integral boolean type then a logical XOR is performed instead of a bitwise XOR. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseXorAcquire must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#set(java.lang.Object...)\"\u003e\u003ccode\u003eset(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#getAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAcquire(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAndBitwiseXorRelease",
      "comment": "Atomically sets the value of a variable to the result of bitwise XOR between the variable\u0027s current value and the mask with the memory semantics of setRelease(java.lang.Object...) and returns the variable\u0027s previous value, as accessed with the memory semantics of get(java.lang.Object...). If the variable type is the non-integral boolean type then a logical XOR is performed instead of a bitwise XOR. The method signature is of the form (CT1 ct1, ..., CTn ctn, T mask)T. The symbolic type descriptor at the call site of getAndBitwiseXorRelease must match the access mode type that is the result of calling accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE) on this VarHandle.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#setRelease(java.lang.Object...)\"\u003e\u003ccode\u003esetRelease(Object...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#get(java.lang.Object...)\"\u003e\u003ccode\u003eget(Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list of the form \n\u003ccode\u003e(CT1 ct1, ..., CTn ctn, T mask)\u003c/code\u003e , statically represented using varargs."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the access mode is unsupported for this VarHandle.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the access mode type does not match the caller\u0027s symbolic type descriptor.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the access mode type matches the caller\u0027s symbolic type descriptor, but a reference cast fails."
        ],
        "return": [
          "the signature-polymorphic result that is the previous value of the variable , statically represented using \n\u003ccode\u003eObject\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "withInvokeExactBehavior",
      "comment": "Returns a VarHandle, with access to the same variable(s) as this VarHandle, but whose invocation behavior of access mode methods is adjusted to invoke-exact behavior. If this VarHandle already has invoke-exact behavior this VarHandle is returned. Invoking hasInvokeExactBehavior() on the returned var handle is guaranteed to return true.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#withInvokeBehavior()\"\u003e\u003ccode\u003ewithInvokeBehavior()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#hasInvokeExactBehavior()\"\u003e\u003ccode\u003ehasInvokeExactBehavior()\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Invoke-exact behavior guarantees that upon invocation of an access mode method the types and arity of the arguments must match the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#accessModeType(java.lang.invoke.VarHandle.AccessMode)\"\u003e\u003ccode\u003eaccess mode type\u003c/code\u003e\u003c/a\u003e, otherwise a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eWrongMethodTypeException\u003c/code\u003e\u003c/a\u003e is thrown."
        ],
        "return": [
          "a VarHandle with invoke-exact behavior"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "withInvokeBehavior",
      "comment": "Returns a VarHandle, with access to the same variable(s) as this VarHandle, but whose invocation behavior of access mode methods is adjusted to invoke behavior. If this VarHandle already has invoke behavior this VarHandle is returned. Invoking hasInvokeExactBehavior() on the returned var handle is guaranteed to return false.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#withInvokeExactBehavior()\"\u003e\u003ccode\u003ewithInvokeExactBehavior()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html#hasInvokeExactBehavior()\"\u003e\u003ccode\u003ehasInvokeExactBehavior()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a VarHandle with invoke behavior"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "toString",
      "comment": "Returns a compact textual description of this VarHandle, including the type of variable described, and a description of its coordinates.",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "A compact textual description of this \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html\" title\u003d\"class in java.lang.invoke\"\u003eVarHandle\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Class",
        "parameters": [
          {
            "type": "Wildcard"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "varType",
      "comment": "Returns the variable type of variables referenced by this VarHandle.",
      "tagMap": {
        "return": [
          "the variable type of variables referenced by this VarHandle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.List",
        "parameters": [
          {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "coordinateTypes",
      "comment": "Returns the coordinate types for this VarHandle.",
      "tagMap": {
        "return": [
          "the coordinate types for this VarHandle. The returned list is unmodifiable"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodType",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle$AccessMode",
            "type": "Class"
          },
          "field": {
            "name": "accessMode"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "accessModeType",
      "comment": "Obtains the access mode type for this VarHandle and a given access mode. The access mode type\u0027s parameter types will consist of a prefix that is the coordinate types of this VarHandle followed by further types as defined by the access mode method. The access mode type\u0027s return type is defined by the return type of the access mode method.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eaccessMode\u003c/code\u003e - the access mode, corresponding to the signature-polymorphic method of the same name"
        ],
        "return": [
          "the access mode type for the given access mode"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle$AccessMode",
            "type": "Class"
          },
          "field": {
            "name": "accessMode"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "isAccessModeSupported",
      "comment": "Returns true if the given access mode is supported, otherwise false. The return of a false value for a given access mode indicates that an UnsupportedOperationException is thrown on invocation of the corresponding access mode method.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eaccessMode\u003c/code\u003e - the access mode, corresponding to the signature-polymorphic method of the same name"
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if the given access mode is supported, otherwise \n\u003ccode\u003efalse\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle$AccessMode",
            "type": "Class"
          },
          "field": {
            "name": "accessMode"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toMethodHandle",
      "comment": "Obtains a method handle bound to this VarHandle and the given access mode.",
      "tagMap": {
        "apiNote": [
          "This method, for a VarHandle \n\u003ccode\u003evh\u003c/code\u003e and access mode \n\u003ccode\u003e{access-mode}\u003c/code\u003e, returns a method handle that is equivalent to method handle \n\u003ccode\u003ebmh\u003c/code\u003e in the following code (though it may be more efficient): \n\u003cpre\u003e\u003ccode\u003e\n MethodHandle mh \u003d MethodHandles.varHandleExactInvoker(\n                       vh.accessModeType(VarHandle.AccessMode.{access-mode}));\n\n MethodHandle bmh \u003d mh.bindTo(vh);\n \u003c/code\u003e\u003c/pre\u003e"
        ],
        "param": [
          "\u003ccode\u003eaccessMode\u003c/code\u003e - the access mode, corresponding to the signature-polymorphic method of the same name"
        ],
        "return": [
          "a method handle bound to this VarHandle and the given access mode"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "name": "java.lang.invoke.VarHandle$VarHandleDesc",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "describeConstable",
      "comment": "Return a nominal descriptor for this instance, if one can be constructed, or an empty Optional if one cannot be.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/constant/Constable.html#describeConstable()\"\u003edescribeConstable\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/constant/Constable.html\" title\u003d\"interface in java.lang.constant\"\u003eConstable\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "An \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Optional.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eOptional\u003c/code\u003e\u003c/a\u003e containing the resulting nominal descriptor, or an empty \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Optional.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eOptional\u003c/code\u003e\u003c/a\u003e if one cannot be constructed."
        ],
        "since": [
          "12"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "fullFence",
      "comment": "Ensures that loads and stores before the fence will not be reordered with loads and stores after the fence.",
      "tagMap": {
        "apiNote": [
          "Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with \n\u003ccode\u003eatomic_thread_fence(memory_order_seq_cst)\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "acquireFence",
      "comment": "Ensures that loads before the fence will not be reordered with loads and stores after the fence.",
      "tagMap": {
        "apiNote": [
          "Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with \n\u003ccode\u003eatomic_thread_fence(memory_order_acquire)\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "releaseFence",
      "comment": "Ensures that loads and stores before the fence will not be reordered with stores after the fence.",
      "tagMap": {
        "apiNote": [
          "Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with \n\u003ccode\u003eatomic_thread_fence(memory_order_release)\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "loadLoadFence",
      "comment": "Ensures that loads before the fence will not be reordered with loads after the fence.",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "storeStoreFence",
      "comment": "Ensures that stores before the fence will not be reordered with stores after the fence.",
      "tagMap": {}
    }
  ],
  "innerClasses": [
    "java.lang.invoke.VarHandle$VarHandleDesc",
    "java.lang.invoke.VarHandle$AccessMode"
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.lang.invoke.VarHandle",
  "comment": "A VarHandle is a dynamically strongly typed reference to a variable, or to a parametrically-defined family of variables, including static fields, non-static fields, array elements, or components of an off-heap data structure. Access to such variables is supported under various \n\u003cem\u003eaccess modes\u003c/em\u003e, including plain read/write access, volatile read/write access, and compare-and-set. \n\u003cp\u003eVarHandles are immutable and have no visible state. VarHandles cannot be subclassed by the user. \u003c/p\u003e\n\u003cp\u003eA VarHandle has: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003ea \u003ca href\u003d\"#varType()\"\u003e\u003ccode\u003evariable type\u003c/code\u003e\u003c/a\u003e T, the type of every variable referenced by this VarHandle; and \u003c/li\u003e\n \u003cli\u003ea list of \u003ca href\u003d\"#coordinateTypes()\"\u003e\u003ccode\u003ecoordinate types\u003c/code\u003e\u003c/a\u003e \u003ccode\u003eCT1, CT2, ..., CTn\u003c/code\u003e, the types of \u003cem\u003ecoordinate expressions\u003c/em\u003e that jointly locate a variable referenced by this VarHandle. \u003c/li\u003e\n\u003c/ul\u003e Variable and coordinate types may be primitive or reference, and are represented by \n\u003ccode\u003eClass\u003c/code\u003e objects. The list of coordinate types may be empty. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eFactory methods that produce or \u003ca href\u003d\"MethodHandles.Lookup.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003elookup\u003c/code\u003e\u003c/a\u003e VarHandle instances document the supported variable type and the list of coordinate types. \u003c/p\u003e\n\u003cp\u003eEach access mode is associated with one \u003cem\u003eaccess mode method\u003c/em\u003e, a \u003ca href\u003d\"MethodHandle.html#sigpoly\"\u003esignature polymorphic\u003c/a\u003e method named for the access mode. When an access mode method is invoked on a VarHandle instance, the initial arguments to the invocation are coordinate expressions that indicate in precisely which object the variable is to be accessed. Trailing arguments to the invocation represent values of importance to the access mode. For example, the various compare-and-set or compare-and-exchange access modes require two trailing arguments for the variable\u0027s expected value and new value. \u003c/p\u003e\n\u003cp\u003eThe arity and types of arguments to the invocation of an access mode method are not checked statically. Instead, each access mode method specifies an \u003ca href\u003d\"#accessModeType(java.lang.invoke.VarHandle.AccessMode)\"\u003e\u003ccode\u003eaccess mode type\u003c/code\u003e\u003c/a\u003e, represented as an instance of \u003ca href\u003d\"MethodType.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodType\u003c/code\u003e\u003c/a\u003e, that serves as a kind of method signature against which the arguments are checked dynamically. An access mode type gives formal parameter types in terms of the coordinate types of a VarHandle instance and the types for values of importance to the access mode. An access mode type also gives a return type, often in terms of the variable type of a VarHandle instance. When an access mode method is invoked on a VarHandle instance, the symbolic type descriptor at the call site, the run time types of arguments to the invocation, and the run time type of the return value, must \u003ca href\u003d\"#invoke\"\u003ematch\u003c/a\u003e the types given in the access mode type. A runtime exception will be thrown if the match fails. For example, the access mode method \u003ca href\u003d\"#compareAndSet(java.lang.Object...)\"\u003e\u003ccode\u003ecompareAndSet(java.lang.Object...)\u003c/code\u003e\u003c/a\u003e specifies that if its receiver is a VarHandle instance with coordinate types \u003ccode\u003eCT1, ..., CTn\u003c/code\u003e and variable type \u003ccode\u003eT\u003c/code\u003e, then its access mode type is \u003ccode\u003e(CT1 c1, ..., CTn cn, T expectedValue, T newValue)boolean\u003c/code\u003e. Suppose that a VarHandle instance can access array elements, and that its coordinate types are \u003ccode\u003eString[]\u003c/code\u003e and \u003ccode\u003eint\u003c/code\u003e while its variable type is \u003ccode\u003eString\u003c/code\u003e. The access mode type for \u003ccode\u003ecompareAndSet\u003c/code\u003e on this VarHandle instance would be \u003ccode\u003e(String[] c1, int c2, String expectedValue, String newValue)boolean\u003c/code\u003e. Such a VarHandle instance may be produced by the \u003ca href\u003d\"MethodHandles.html#arrayElementVarHandle(java.lang.Class)\"\u003e\u003ccode\u003earray factory method\u003c/code\u003e\u003c/a\u003e and access array elements as follows: \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n String[] sa \u003d ...\n VarHandle avh \u003d MethodHandles.arrayElementVarHandle(String[].class);\n boolean r \u003d avh.compareAndSet(sa, 10, \"expected\", \"new\");\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eAccess modes control atomicity and consistency properties. \u003cem\u003ePlain\u003c/em\u003e read (\u003ccode\u003eget\u003c/code\u003e) and write (\u003ccode\u003eset\u003c/code\u003e) accesses are guaranteed to be bitwise atomic only for references and for primitive values of at most 32 bits, and impose no observable ordering constraints with respect to threads other than the executing thread. \u003cem\u003eOpaque\u003c/em\u003e operations are bitwise atomic and coherently ordered with respect to accesses to the same variable. In addition to obeying Opaque properties, \u003cem\u003eAcquire\u003c/em\u003e mode reads and their subsequent accesses are ordered after matching \u003cem\u003eRelease\u003c/em\u003e mode writes and their previous accesses. In addition to obeying Acquire and Release properties, all \u003cem\u003eVolatile\u003c/em\u003e operations are totally ordered with respect to each other. \u003c/p\u003e\n\u003cp\u003eAccess modes are grouped into the following categories: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eread access modes that get the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods \u003ca href\u003d\"#get(java.lang.Object...)\"\u003e\u003ccode\u003eget\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getVolatile(java.lang.Object...)\"\u003e\u003ccode\u003egetVolatile\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getOpaque(java.lang.Object...)\"\u003e\u003ccode\u003egetOpaque\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003ewrite access modes that set the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods \u003ca href\u003d\"#set(java.lang.Object...)\"\u003e\u003ccode\u003eset\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#setVolatile(java.lang.Object...)\"\u003e\u003ccode\u003esetVolatile\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#setRelease(java.lang.Object...)\"\u003e\u003ccode\u003esetRelease\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#setOpaque(java.lang.Object...)\"\u003e\u003ccode\u003esetOpaque\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003eatomic update access modes that, for example, atomically compare and set the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods \u003ca href\u003d\"#compareAndSet(java.lang.Object...)\"\u003e\u003ccode\u003ecompareAndSet\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#weakCompareAndSetPlain(java.lang.Object...)\"\u003e\u003ccode\u003eweakCompareAndSetPlain\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#weakCompareAndSet(java.lang.Object...)\"\u003e\u003ccode\u003eweakCompareAndSet\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#weakCompareAndSetAcquire(java.lang.Object...)\"\u003e\u003ccode\u003eweakCompareAndSetAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#weakCompareAndSetRelease(java.lang.Object...)\"\u003e\u003ccode\u003eweakCompareAndSetRelease\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#compareAndExchangeAcquire(java.lang.Object...)\"\u003e\u003ccode\u003ecompareAndExchangeAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#compareAndExchange(java.lang.Object...)\"\u003e\u003ccode\u003ecompareAndExchange\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#compareAndExchangeRelease(java.lang.Object...)\"\u003e\u003ccode\u003ecompareAndExchangeRelease\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndSet(java.lang.Object...)\"\u003e\u003ccode\u003egetAndSet\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndSetAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAndSetAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndSetRelease(java.lang.Object...)\"\u003e\u003ccode\u003egetAndSetRelease\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003enumeric atomic update access modes that, for example, atomically get and set with addition the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods \u003ca href\u003d\"#getAndAdd(java.lang.Object...)\"\u003e\u003ccode\u003egetAndAdd\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndAddAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAndAddAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndAddRelease(java.lang.Object...)\"\u003e\u003ccode\u003egetAndAddRelease\u003c/code\u003e\u003c/a\u003e, \u003c/li\u003e\n \u003cli\u003ebitwise atomic update access modes that, for example, atomically get and bitwise OR the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods \u003ca href\u003d\"#getAndBitwiseOr(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseOr\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseOrAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseOrAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseOrRelease(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseOrRelease\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseAnd(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseAnd\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseAndAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseAndAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseAndRelease(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseAndRelease\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseXor(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseXor\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseXorAcquire(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseXorAcquire\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#getAndBitwiseXorRelease(java.lang.Object...)\"\u003e\u003ccode\u003egetAndBitwiseXorRelease\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eFactory methods that produce or \u003ca href\u003d\"MethodHandles.Lookup.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003elookup\u003c/code\u003e\u003c/a\u003e VarHandle instances document the set of access modes that are supported, which may also include documenting restrictions based on the variable type and whether a variable is read-only. If an access mode is not supported then the corresponding access mode method will on invocation throw an \u003ccode\u003eUnsupportedOperationException\u003c/code\u003e. Factory methods should document any additional undeclared exceptions that may be thrown by access mode methods. The \u003ca href\u003d\"#get(java.lang.Object...)\"\u003e\u003ccode\u003eget\u003c/code\u003e\u003c/a\u003e access mode is supported for all VarHandle instances and the corresponding method never throws \u003ccode\u003eUnsupportedOperationException\u003c/code\u003e. If a VarHandle references a read-only variable (for example a \u003ccode\u003efinal\u003c/code\u003e field) then write, atomic update, numeric atomic update, and bitwise atomic update access modes are not supported and corresponding methods throw \u003ccode\u003eUnsupportedOperationException\u003c/code\u003e. Read/write access modes (if supported), with the exception of \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e, provide atomic access for reference types and all primitive types. Unless stated otherwise in the documentation of a factory method, the access modes \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e (if supported) provide atomic access for reference types and all primitives types, with the exception of \u003ccode\u003elong\u003c/code\u003e and \u003ccode\u003edouble\u003c/code\u003e on 32-bit platforms. \u003c/p\u003e\n\u003cp\u003eAccess modes will override any memory ordering effects specified at the declaration site of a variable. For example, a VarHandle accessing a field using the \u003ccode\u003eget\u003c/code\u003e access mode will access the field as specified \u003cem\u003eby its access mode\u003c/em\u003e even if that field is declared \u003ccode\u003evolatile\u003c/code\u003e. When mixed access is performed extreme care should be taken since the Java Memory Model may permit surprising results. \u003c/p\u003e\n\u003cp\u003eIn addition to supporting access to variables under various access modes, a set of static methods, referred to as memory fence methods, is also provided for fine-grained control of memory ordering. The Java Language Specification permits other threads to observe operations as if they were executed in orders different than are apparent in program source code, subject to constraints arising, for example, from the use of locks, \u003ccode\u003evolatile\u003c/code\u003e fields or VarHandles. The static methods, \u003ca href\u003d\"#fullFence()\"\u003e\u003ccode\u003efullFence\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#acquireFence()\"\u003e\u003ccode\u003eacquireFence\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#releaseFence()\"\u003e\u003ccode\u003ereleaseFence\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"#loadLoadFence()\"\u003e\u003ccode\u003eloadLoadFence\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#storeStoreFence()\"\u003e\u003ccode\u003estoreStoreFence\u003c/code\u003e\u003c/a\u003e, can also be used to impose constraints. Their specifications, as is the case for certain access modes, are phrased in terms of the lack of \"reorderings\" -- observable ordering effects that might otherwise occur if the fence was not present. More precise phrasing of the specification of access mode methods and memory fence methods may accompany future updates of the Java Language Specification. \u003c/p\u003e\n\u003ch2\u003eCompiling invocation of access mode methods\u003c/h2\u003e A Java method call expression naming an access mode method can invoke a VarHandle from Java source code. From the viewpoint of source code, these methods can take any arguments and their polymorphic result (if expressed) can be cast to any return type. Formally this is accomplished by giving the access mode methods variable arity \n\u003ccode\u003eObject\u003c/code\u003e arguments and \n\u003ccode\u003eObject\u003c/code\u003e return types (if the return type is polymorphic), but they have an additional quality called \n\u003cem\u003esignature polymorphism\u003c/em\u003e which connects this freedom of invocation directly to the JVM execution stack. \n\u003cp\u003e As is usual with virtual methods, source-level calls to access mode methods compile to an \u003ccode\u003einvokevirtual\u003c/code\u003e instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must generate instructions to push them on the stack according to their own unconverted types. The VarHandle object itself will be pushed on the stack before the arguments. The compiler then generates an \u003ccode\u003einvokevirtual\u003c/code\u003e instruction that invokes the access mode method with a symbolic type descriptor which describes the argument and return types. \u003c/p\u003e\n\u003cp\u003e To issue a complete symbolic type descriptor, the compiler must also determine the return type (if polymorphic). This is based on a cast on the method invocation expression, if there is one, or else \u003ccode\u003eObject\u003c/code\u003e if the invocation is an expression, or else \u003ccode\u003evoid\u003c/code\u003e if the invocation is a statement. The cast may be to a primitive type (but not \u003ccode\u003evoid\u003c/code\u003e). \u003c/p\u003e\n\u003cp\u003e As a corner case, an uncasted \u003ccode\u003enull\u003c/code\u003e argument is given a symbolic type descriptor of \u003ccode\u003ejava.lang.Void\u003c/code\u003e. The ambiguity with the type \u003ccode\u003eVoid\u003c/code\u003e is harmless, since there are no references of type \u003ccode\u003eVoid\u003c/code\u003e except the null reference. \u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"invoke\"\u003ePerforming invocation of access mode methods\u003c/a\u003e\u003c/h2\u003e The first time an \n\u003ccode\u003einvokevirtual\u003c/code\u003e instruction is executed it is linked by symbolically resolving the names in the instruction and verifying that the method call is statically legal. This also holds for calls to access mode methods. In this case, the symbolic type descriptor emitted by the compiler is checked for correct syntax, and names it contains are resolved. Thus, an \n\u003ccode\u003einvokevirtual\u003c/code\u003e instruction which invokes an access mode method will always link, as long as the symbolic type descriptor is syntactically well-formed and the types exist. \n\u003cp\u003e When the \u003ccode\u003einvokevirtual\u003c/code\u003e is executed after linking, the receiving VarHandle\u0027s access mode type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the access mode method which the caller is invoking is not present on the individual VarHandle being invoked. \u003c/p\u003e\n\u003cp id\u003d\"invoke-behavior\"\u003e Invocation of an access mode method behaves, by default, as if an invocation of \u003ca href\u003d\"MethodHandle.html#invoke(java.lang.Object...)\"\u003e\u003ccode\u003eMethodHandle.invoke(java.lang.Object...)\u003c/code\u003e\u003c/a\u003e, where the receiving method handle accepts the VarHandle instance as the leading argument. More specifically, the following, where \u003ccode\u003e{access-mode}\u003c/code\u003e corresponds to the access mode method name: \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n VarHandle vh \u003d ..\n R r \u003d (R) vh.{access-mode}(p1, p2, ..., pN);\n \u003c/code\u003e\u003c/pre\u003e behaves as if: \n\u003cpre\u003e \u003ccode\u003e\n VarHandle vh \u003d ..\n VarHandle.AccessMode am \u003d VarHandle.AccessMode.valueFromMethodName(\"{access-mode}\");\n MethodHandle mh \u003d MethodHandles.varHandleExactInvoker(\n                       am,\n                       vh.accessModeType(am));\n\n R r \u003d (R) mh.invoke(vh, p1, p2, ..., pN)\n \u003c/code\u003e\u003c/pre\u003e (modulo access mode methods do not declare throwing of \n\u003ccode\u003eThrowable\u003c/code\u003e). This is equivalent to: \n\u003cpre\u003e \u003ccode\u003e\n MethodHandle mh \u003d MethodHandles.lookup().findVirtual(\n                       VarHandle.class,\n                       \"{access-mode}\",\n                       MethodType.methodType(R, p1, p2, ..., pN));\n\n R r \u003d (R) mh.invokeExact(vh, p1, p2, ..., pN)\n \u003c/code\u003e\u003c/pre\u003e where the desired method type is the symbolic type descriptor and a \n\u003ca href\u003d\"MethodHandle.html#invokeExact(java.lang.Object...)\"\u003e\u003ccode\u003eMethodHandle.invokeExact(java.lang.Object...)\u003c/code\u003e\u003c/a\u003e is performed, since before invocation of the target, the handle will apply reference casts as necessary and box, unbox, or widen primitive values, as if by \n\u003ca href\u003d\"MethodHandle.html#asType(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003easType\u003c/code\u003e\u003c/a\u003e (see also \n\u003ca href\u003d\"MethodHandles.html#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e). More concisely, such behavior is equivalent to: \n\u003cpre\u003e \u003ccode\u003e\n VarHandle vh \u003d ..\n VarHandle.AccessMode am \u003d VarHandle.AccessMode.valueFromMethodName(\"{access-mode}\");\n MethodHandle mh \u003d vh.toMethodHandle(am);\n\n R r \u003d (R) mh.invoke(p1, p2, ..., pN)\n \u003c/code\u003e\u003c/pre\u003e Where, in this case, the method handle is bound to the VarHandle instance. \n\u003cp\u003e\u003c/p\u003e\n\u003cp id\u003d\"invoke-exact-behavior\"\u003e A VarHandle\u0027s invocation behavior can be adjusted (see \u003ca href\u003d\"#withInvokeExactBehavior()\"\u003e\u003ccode\u003ewithInvokeExactBehavior()\u003c/code\u003e\u003c/a\u003e) such that invocation of an access mode method behaves as if invocation of \u003ca href\u003d\"MethodHandle.html#invokeExact(java.lang.Object...)\"\u003e\u003ccode\u003eMethodHandle.invokeExact(java.lang.Object...)\u003c/code\u003e\u003c/a\u003e, where the receiving method handle accepts the VarHandle instance as the leading argument. More specifically, the following, where \u003ccode\u003e{access-mode}\u003c/code\u003e corresponds to the access mode method name: \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n VarHandle vh \u003d ..\n R r \u003d (R) vh.{access-mode}(p1, p2, ..., pN);\n \u003c/code\u003e\u003c/pre\u003e behaves as if: \n\u003cpre\u003e \u003ccode\u003e\n VarHandle vh \u003d ..\n VarHandle.AccessMode am \u003d VarHandle.AccessMode.valueFromMethodName(\"{access-mode}\");\n MethodHandle mh \u003d MethodHandles.varHandleExactInvoker(\n                       am,\n                       vh.accessModeType(am));\n\n R r \u003d (R) mh.invokeExact(vh, p1, p2, ..., pN)\n \u003c/code\u003e\u003c/pre\u003e (modulo access mode methods do not declare throwing of \n\u003ccode\u003eThrowable\u003c/code\u003e). More concisely, such behavior is equivalent to: \n\u003cpre\u003e \u003ccode\u003e\n VarHandle vh \u003d ..\n VarHandle.AccessMode am \u003d VarHandle.AccessMode.valueFromMethodName(\"{access-mode}\");\n MethodHandle mh \u003d vh.toMethodHandle(am);\n\n R r \u003d (R) mh.invokeExact(p1, p2, ..., pN)\n \u003c/code\u003e\u003c/pre\u003e Where, in this case, the method handle is bound to the VarHandle instance. \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eInvocation checking\u003c/h2\u003e In typical programs, VarHandle access mode type matching will usually succeed. But if a match fails, the JVM will throw a \n\u003ca href\u003d\"WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eWrongMethodTypeException\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003e Thus, an access mode type mismatch which might show up as a linkage error in a statically typed program can show up as a dynamic \u003ccode\u003eWrongMethodTypeException\u003c/code\u003e in a program which uses VarHandles. \u003c/p\u003e\n\u003cp\u003e Because access mode types contain \"live\" \u003ccode\u003eClass\u003c/code\u003e objects, method type matching takes into account both type names and class loaders. Thus, even if a VarHandle \u003ccode\u003eVH\u003c/code\u003e is created in one class loader \u003ccode\u003eL1\u003c/code\u003e and used in another \u003ccode\u003eL2\u003c/code\u003e, VarHandle access mode method calls are type-safe, because the caller\u0027s symbolic type descriptor, as resolved in \u003ccode\u003eL2\u003c/code\u003e, is matched against the original callee method\u0027s symbolic type descriptor, as resolved in \u003ccode\u003eL1\u003c/code\u003e. The resolution in \u003ccode\u003eL1\u003c/code\u003e happens when \u003ccode\u003eVH\u003c/code\u003e is created and its access mode types are assigned, while the resolution in \u003ccode\u003eL2\u003c/code\u003e happens when the \u003ccode\u003einvokevirtual\u003c/code\u003e instruction is linked. \u003c/p\u003e\n\u003cp\u003e Apart from type descriptor checks, a VarHandles\u0027s capability to access it\u0027s variables is unrestricted. If a VarHandle is formed on a non-public variable by a class that has access to that variable, the resulting VarHandle can be used in any place by any caller who receives a reference to it. \u003c/p\u003e\n\u003cp\u003e Unlike with the Core Reflection API, where access is checked every time a reflective method is invoked, VarHandle access checking is performed \u003ca href\u003d\"MethodHandles.Lookup.html#access\"\u003ewhen the VarHandle is created\u003c/a\u003e. Thus, VarHandles to non-public variables, or to variables in non-public classes, should generally be kept secret. They should not be passed to untrusted code unless their use from the untrusted code would be harmless. \u003c/p\u003e\n\u003ch2\u003eVarHandle creation\u003c/h2\u003e Java code can create a VarHandle that directly accesses any field that is accessible to that code. This is done via a reflective, capability-based API called \n\u003ca href\u003d\"MethodHandles.Lookup.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandles.Lookup\u003c/code\u003e\u003c/a\u003e. For example, a VarHandle for a non-static field can be obtained from \n\u003ca href\u003d\"MethodHandles.Lookup.html#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003eLookup.findVarHandle\u003c/code\u003e\u003c/a\u003e. There is also a conversion method from Core Reflection API objects, \n\u003ca href\u003d\"MethodHandles.Lookup.html#unreflectVarHandle(java.lang.reflect.Field)\"\u003e\u003ccode\u003eLookup.unreflectVarHandle\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003e Access to protected field members is restricted to receivers only of the accessing class, or one of its subclasses, and the accessing class must in turn be a subclass (or package sibling) of the protected member\u0027s defining class. If a VarHandle refers to a protected non-static field of a declaring class outside the current package, the receiver argument will be narrowed to the type of the accessing class. \u003c/p\u003e\n\u003ch2\u003eInteroperation between VarHandles and the Core Reflection API\u003c/h2\u003e Using factory methods in the \n\u003ca href\u003d\"MethodHandles.Lookup.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eLookup\u003c/code\u003e\u003c/a\u003e API, any field represented by a Core Reflection API object can be converted to a behaviorally equivalent VarHandle. For example, a reflective \n\u003ca href\u003d\"../reflect/Field.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eField\u003c/code\u003e\u003c/a\u003e can be converted to a VarHandle using \n\u003ca href\u003d\"MethodHandles.Lookup.html#unreflectVarHandle(java.lang.reflect.Field)\"\u003e\u003ccode\u003eLookup.unreflectVarHandle\u003c/code\u003e\u003c/a\u003e. The resulting VarHandles generally provide more direct and efficient access to the underlying fields. \n\u003cp\u003e As a special case, when the Core Reflection API is used to view the signature polymorphic access mode methods in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by \u003ca href\u003d\"../Class.html#getDeclaredMethod(java.lang.String,java.lang.Class...)\"\u003e\u003ccode\u003eClass.getDeclaredMethod\u003c/code\u003e\u003c/a\u003e, is unaffected by their special status in this API. For example, \u003ca href\u003d\"../reflect/Method.html#getModifiers()\"\u003e\u003ccode\u003eMethod.getModifiers\u003c/code\u003e\u003c/a\u003e will report exactly those modifier bits required for any similarly declared method, including in this case \u003ccode\u003enative\u003c/code\u003e and \u003ccode\u003evarargs\u003c/code\u003e bits. \u003c/p\u003e\n\u003cp\u003e As with any reflected method, these methods (when reflected) may be invoked directly via \u003ca href\u003d\"../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)\"\u003e\u003ccode\u003ejava.lang.reflect.Method.invoke\u003c/code\u003e\u003c/a\u003e, via JNI, or indirectly via \u003ca href\u003d\"MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)\"\u003e\u003ccode\u003eLookup.unreflect\u003c/code\u003e\u003c/a\u003e. However, such reflective calls do not result in access mode method invocations. Such a call, if passed the required argument (a single one, of type \u003ccode\u003eObject[]\u003c/code\u003e), will ignore the argument and will throw an \u003ccode\u003eUnsupportedOperationException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e Since \u003ccode\u003einvokevirtual\u003c/code\u003e instructions can natively invoke VarHandle access mode methods under any symbolic type descriptor, this reflective view conflicts with the normal presentation of these methods via bytecodes. Thus, these native methods, when reflectively viewed by \u003ccode\u003eClass.getDeclaredMethod\u003c/code\u003e, may be regarded as placeholders only. \u003c/p\u003e\n\u003cp\u003e In order to obtain an invoker method for a particular access mode type, use \u003ca href\u003d\"MethodHandles.html#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandles.varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"MethodHandles.html#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e. The \u003ca href\u003d\"MethodHandles.Lookup.html#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eLookup.findVirtual\u003c/code\u003e\u003c/a\u003e API is also able to return a method handle to call an access mode method for any specified access mode type and is equivalent in behavior to \u003ca href\u003d\"MethodHandles.html#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003ch2\u003eInteroperation between VarHandles and Java generics\u003c/h2\u003e A VarHandle can be obtained for a variable, such as a field, which is declared with Java generic types. As with the Core Reflection API, the VarHandle\u0027s variable type will be constructed from the erasure of the source-level type. When a VarHandle access mode method is invoked, the types of its arguments or the return value cast type may be generic types or type instances. If this occurs, the compiler will replace those types by their erasures when it constructs the symbolic type descriptor for the \n\u003ccode\u003einvokevirtual\u003c/code\u003e instruction.",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandle\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandles\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodType.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodType\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "9"
    ]
  }
}