{
  "packageName": "java.lang.invoke",
  "simpleName": "MethodHandles",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandles$Lookup",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "lookup",
      "comment": "Returns a lookup object with full capabilities to emulate all supported bytecode behaviors of the caller. These capabilities include full privilege access to the caller. Factory methods on the lookup object can create direct method handles for any member that the caller has access to via bytecodes, including protected and private fields and methods. This lookup object is created by the original lookup class and has the ORIGINAL bit set. This lookup object is a capability which may be delegated to trusted agents. Do not store it in place where untrusted code can access it. This method is caller sensitive, which means that it may return different values to different callers.",
      "tagMap": {
        "return": [
          "a lookup object for the caller of this method, with \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#ORIGINAL\"\u003eoriginal\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#hasFullPrivilegeAccess()\"\u003efull privilege access\u003c/a\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandles$Lookup",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "publicLookup",
      "comment": "Returns a lookup object which is trusted minimally. The lookup has the UNCONDITIONAL mode. It can only be used to create method handles to public members of public classes in packages that are exported unconditionally. As a matter of pure convention, the lookup class of this lookup object will be Object.",
      "tagMap": {
        "apiNote": [
          "The use of Object is conventional, and because the lookup modes are limited, there is no special access provided to the internals of Object, its package or its module. This public lookup object or other lookup object with \n\u003ccode\u003eUNCONDITIONAL\u003c/code\u003e mode assumes readability. Consequently, the lookup class is not used to determine the lookup context. \n\u003cp style\u003d\"font-size:smaller;\"\u003e \u003cem\u003eDiscussion:\u003c/em\u003e The lookup class can be changed to any other class \u003ccode\u003eC\u003c/code\u003e using an expression of the form \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#in(java.lang.Class)\"\u003e\u003ccode\u003epublicLookup().in(C.class)\u003c/code\u003e\u003c/a\u003e. A public lookup object is always subject to \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#secmgr\"\u003esecurity manager checks\u003c/a\u003e. Also, it cannot access \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#callsens\"\u003ecaller sensitive methods\u003c/a\u003e.\u003c/p\u003e"
        ],
        "return": [
          "a lookup object which is trusted minimally"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandles$Lookup",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "targetClass"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandles$Lookup",
            "type": "Class"
          },
          "field": {
            "name": "caller"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "privateLookupIn",
      "comment": "Returns a lookup object on a target class to emulate all supported bytecode behaviors, including private access. The returned lookup object can provide access to classes in modules and packages, and members of those classes, outside the normal rules of Java access control, instead conforming to the more permissive rules for modular deep reflection. A caller, specified as a Lookup object, in module M1 is allowed to do deep reflection on module M2 and package of the target class if and only if all of the following conditions are true: If there is a security manager, its checkPermission method is called to check ReflectPermission(\"suppressAccessChecks\") and that must return normally. The caller lookup object must have full privilege access. Specifically: The caller lookup object must have the MODULE lookup mode. (This is because otherwise there would be no way to ensure the original lookup creator was a member of any particular module, and so any subsequent checks for readability and qualified exports would become ineffective.) The caller lookup object must have PRIVATE access. (This is because an application intending to share intra-module access using MODULE alone will inadvertently also share deep reflection to its own module.) The target class must be a proper class, not a primitive or array class. (Thus, M2 is well-defined.) If the caller module M1 differs from the target module M2 then both of the following must be true: M1 reads M2. M2 opens the package containing the target class to at least M1. If any of the above checks is violated, this method fails with an exception. Otherwise, if M1 and M2 are the same module, this method returns a Lookup on targetClass with full privilege access with null previous lookup class. Otherwise, M1 and M2 are two different modules. This method returns a Lookup on targetClass that records the lookup class of the caller as the new previous lookup class with PRIVATE access but no MODULE access. The resulting Lookup object has no ORIGINAL access.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#dropLookupMode(int)\"\u003e\u003ccode\u003eMethodHandles.Lookup.dropLookupMode(int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#cross-module-lookup\"\u003eCross-module lookups\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etargetClass\u003c/code\u003e - the target class",
          "\u003ccode\u003ecaller\u003c/code\u003e - the caller lookup object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etargetClass\u003c/code\u003e is a primitive type or void or array class",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etargetClass\u003c/code\u003e or \n\u003ccode\u003ecaller\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if denied by the security manager",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if any of the other access checks specified above fails"
        ],
        "return": [
          "a lookup object for the target class, with private access"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandles$Lookup",
            "type": "Class"
          },
          "field": {
            "name": "caller"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "classData",
      "comment": "Returns the class data associated with the lookup class of the given caller lookup object, or null. A hidden class with class data can be created by calling Lookup::defineHiddenClassWithClassData. This method will cause the static class initializer of the lookup class of the given caller lookup object be executed if it has not been initialized. A hidden class created by Lookup::defineHiddenClass and non-hidden classes have no class data. null is returned if this method is called on the lookup object on these classes. The lookup modes for this lookup must have original access in order to retrieve the class data.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type to cast the class data object to"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClassWithClassData(byte%5B%5D,java.lang.Object,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)\"\u003e\u003ccode\u003eMethodHandles.Lookup.defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#classDataAt(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.Class,int)\"\u003e\u003ccode\u003eclassDataAt(Lookup, String, Class, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method can be called as a bootstrap method for a dynamically computed constant. A framework can create a hidden class with class data, for example that can be \n\u003ccode\u003eClass\u003c/code\u003e or \n\u003ccode\u003eMethodHandle\u003c/code\u003e object. The class data is accessible only to the lookup object created by the original caller but inaccessible to other members in the same nest. If a framework passes security sensitive objects to a hidden class via class data, it is recommended to load the value of class data as a dynamically computed constant instead of storing the class data in private static field(s) which are accessible to other nestmates."
        ],
        "param": [
          "\u003ccode\u003ecaller\u003c/code\u003e - the lookup context describing the class performing the operation (normally stacked by the JVM)",
          "\u003ccode\u003ename\u003c/code\u003e - must be \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/constant/ConstantDescs.html#DEFAULT_NAME\"\u003e\u003ccode\u003eConstantDescs.DEFAULT_NAME\u003c/code\u003e\u003c/a\u003e (\n\u003ccode\u003e\"_\"\u003c/code\u003e)",
          "\u003ccode\u003etype\u003c/code\u003e - the type of the class data"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if name is not \n\u003ccode\u003e\"_\"\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if the lookup context does not have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#ORIGINAL\"\u003eoriginal\u003c/a\u003e access",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the class data cannot be converted to the given \n\u003ccode\u003etype\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ecaller\u003c/code\u003e or \n\u003ccode\u003etype\u003c/code\u003e argument is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.5\"\u003e5.5 Initialization\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "the value of the class data if present in the lookup class; otherwise \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalAccessException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandles$Lookup",
            "type": "Class"
          },
          "field": {
            "name": "caller"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "name"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "index"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "classDataAt",
      "comment": "Returns the element at the specified index in the class data, if the class data associated with the lookup class of the given caller lookup object is a List. If the class data is not present in this lookup class, this method returns null. A hidden class with class data can be created by calling Lookup::defineHiddenClassWithClassData. This method will cause the static class initializer of the lookup class of the given caller lookup object be executed if it has not been initialized. A hidden class created by Lookup::defineHiddenClass and non-hidden classes have no class data. null is returned if this method is called on the lookup object on these classes. The lookup modes for this lookup must have original access in order to retrieve the class data.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the type to cast the result object to"
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#classData(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.Class)\"\u003e\u003ccode\u003eclassData(Lookup, String, Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClassWithClassData(byte%5B%5D,java.lang.Object,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)\"\u003e\u003ccode\u003eMethodHandles.Lookup.defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This method can be called as a bootstrap method for a dynamically computed constant. A framework can create a hidden class with class data, for example that can be \n\u003ccode\u003eList.of(o1, o2, o3....)\u003c/code\u003e containing more than one object and use this method to load one element at a specific index. The class data is accessible only to the lookup object created by the original caller but inaccessible to other members in the same nest. If a framework passes security sensitive objects to a hidden class via class data, it is recommended to load the value of class data as a dynamically computed constant instead of storing the class data in private static field(s) which are accessible to other nestmates."
        ],
        "param": [
          "\u003ccode\u003ecaller\u003c/code\u003e - the lookup context describing the class performing the operation (normally stacked by the JVM)",
          "\u003ccode\u003ename\u003c/code\u003e - must be \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/constant/ConstantDescs.html#DEFAULT_NAME\"\u003e\u003ccode\u003eConstantDescs.DEFAULT_NAME\u003c/code\u003e\u003c/a\u003e (\n\u003ccode\u003e\"_\"\u003c/code\u003e)",
          "\u003ccode\u003etype\u003c/code\u003e - the type of the element at the given index in the class data",
          "\u003ccode\u003eindex\u003c/code\u003e - index of the element in the class data"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if name is not \n\u003ccode\u003e\"_\"\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalAccessException.html\" title\u003d\"class in java.lang\"\u003eIllegalAccessException\u003c/a\u003e\u003c/code\u003e - if the lookup context does not have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#ORIGINAL\"\u003eoriginal\u003c/a\u003e access",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the class data cannot be converted to \n\u003ccode\u003eList\u003c/code\u003e or the element at the specified index cannot be converted to the given type",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if the index is out of range",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ecaller\u003c/code\u003e or \n\u003ccode\u003etype\u003c/code\u003e argument is \n\u003ccode\u003enull\u003c/code\u003e; or if unboxing operation fails because the element at the given index is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the element at the given index in the class data if the class data is present; otherwise \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "T",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "name": "T",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "expected"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        }
      ],
      "genericParameters": [
        {
          "name": "T",
          "upperBounds": [
            {
              "name": "java.lang.reflect.Member",
              "type": "Class"
            }
          ],
          "type": "Variable"
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "reflectAs",
      "comment": "Performs an unchecked \"crack\" of a direct method handle. The result is as if the user had obtained a lookup object capable enough to crack the target method handle, called Lookup.revealDirect on the target to obtain its symbolic reference, and then called MethodHandleInfo.reflectAs to resolve the symbolic reference to a member. If there is a security manager, its checkPermission method is called with a ReflectPermission(\"suppressAccessChecks\") permission.",
      "tagMap": {
        "Type Parameters:": [
          "\u003ccode\u003eT\u003c/code\u003e - the desired type of the result, either \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Member.html\" title\u003d\"interface in java.lang.reflect\"\u003e\u003ccode\u003eMember\u003c/code\u003e\u003c/a\u003e or a subtype"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - a direct method handle to crack into symbolic reference components",
          "\u003ccode\u003eexpected\u003c/code\u003e - a class object representing the desired result type \n\u003ccode\u003eT\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if the caller is not privileged to call \n\u003ccode\u003esetAccessible\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the target is not a direct method handle",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the member is not of the expected type"
        ],
        "return": [
          "a reference to the method, constructor, or field object"
        ],
        "since": [
          "1.8"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "arrayConstructor",
      "comment": "Produces a method handle constructing arrays of a desired type, as if by the anewarray bytecode. The return type of the method handle will be the array type. The type of its sole argument will be int, which specifies the size of the array. If the returned method handle is invoked with a negative array size, a NegativeArraySizeException will be thrown.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Array.html#newInstance(java.lang.Class,int)\"\u003e\u003ccode\u003eArray.newInstance(Class, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003earrayClass\u003c/code\u003e - an array type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayClass\u003c/code\u003e is not an array type"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html#jls-6.5\"\u003e6.5 \u003ccode\u003eanewarray\u003c/code\u003e Instruction\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "a method handle which can create arrays of the given type"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "arrayLength",
      "comment": "Produces a method handle returning the length of an array, as if by the arraylength bytecode. The type of the method handle will have int as return type, and its sole argument will be the array type. If the returned method handle is invoked with a null array reference, a NullPointerException will be thrown.",
      "tagMap": {
        "param": [
          "\u003ccode\u003earrayClass\u003c/code\u003e - an array type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if arrayClass is not an array type"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html#jls-6.5\"\u003e6.5 \u003ccode\u003earraylength\u003c/code\u003e Instruction\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "a method handle which can retrieve the length of an array of the given array type"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "arrayElementGetter",
      "comment": "Produces a method handle giving read access to elements of an array, as if by the aaload bytecode. The type of the method handle will have a return type of the array\u0027s element type. Its first argument will be the array type, and the second will be int. When the returned method handle is invoked, the array reference and array index are checked. A NullPointerException will be thrown if the array reference is null and an ArrayIndexOutOfBoundsException will be thrown if the index is negative or if it is greater than or equal to the length of the array.",
      "tagMap": {
        "param": [
          "\u003ccode\u003earrayClass\u003c/code\u003e - an array type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if arrayClass is not an array type"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html#jls-6.5\"\u003e6.5 \u003ccode\u003eaaload\u003c/code\u003e Instruction\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "a method handle which can load values from the given array type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "arrayElementSetter",
      "comment": "Produces a method handle giving write access to elements of an array, as if by the astore bytecode. The type of the method handle will have a void return type. Its last argument will be the array\u0027s element type. The first and second arguments will be the array type and int. When the returned method handle is invoked, the array reference and array index are checked. A NullPointerException will be thrown if the array reference is null and an ArrayIndexOutOfBoundsException will be thrown if the index is negative or if it is greater than or equal to the length of the array.",
      "tagMap": {
        "param": [
          "\u003ccode\u003earrayClass\u003c/code\u003e - the class of an array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if arrayClass is not an array type"
        ],
        "See Java Virtual Machine Specification:": [
          "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html#jls-6.5\"\u003e6.5 \u003ccode\u003eaastore\u003c/code\u003e Instruction\u003c/a\u003e\n\u003cbr\u003e"
        ],
        "return": [
          "a method handle which can store values into the array type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayClass"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "arrayElementVarHandle",
      "comment": "Produces a VarHandle giving access to elements of an array of type arrayClass. The VarHandle\u0027s variable type is the component type of arrayClass and the list of coordinate types is (arrayClass, int), where the int coordinate type corresponds to an argument that is an index into an array. Certain access modes of the returned VarHandle are unsupported under the following conditions: if the component type is anything other than byte, short, char, int, long, float, or double then numeric atomic update access modes are unsupported. if the component type is anything other than boolean, byte, short, char, int or long then bitwise atomic update access modes are unsupported. If the component type is float or double then numeric and atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double), respectively). When the returned VarHandle is invoked, the array reference and array index are checked. A NullPointerException will be thrown if the array reference is null and an ArrayIndexOutOfBoundsException will be thrown if the index is negative or if it is greater than or equal to the length of the array.",
      "tagMap": {
        "apiNote": [
          "Bitwise comparison of \n\u003ccode\u003efloat\u003c/code\u003e values or \n\u003ccode\u003edouble\u003c/code\u003e values, as performed by the numeric and atomic update access modes, differ from the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator and the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eFloat.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eDouble.equals(java.lang.Object)\u003c/code\u003e\u003c/a\u003e methods, specifically with respect to comparing NaN values or comparing \n\u003ccode\u003e-0.0\u003c/code\u003e with \n\u003ccode\u003e+0.0\u003c/code\u003e. Care should be taken when performing a compare and set or a compare and exchange operation with such values since the operation may unexpectedly fail. There are many possible NaN values that are considered to be \n\u003ccode\u003eNaN\u003c/code\u003e in Java, although no IEEE 754 floating-point operation provided by Java can distinguish between them. Operation failure can occur if the expected or witness value is a NaN value and it is transformed (perhaps in a platform specific manner) into another NaN value, and thus has a different bitwise representation (see \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Float.html#intBitsToFloat(int)\"\u003e\u003ccode\u003eFloat.intBitsToFloat(int)\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long)\"\u003e\u003ccode\u003eDouble.longBitsToDouble(long)\u003c/code\u003e\u003c/a\u003e for more details). The values \n\u003ccode\u003e-0.0\u003c/code\u003e and \n\u003ccode\u003e+0.0\u003c/code\u003e have different bitwise representations but are considered equal when using the primitive \n\u003ccode\u003e\u003d\u003d\u003c/code\u003e operator. Operation failure can occur if, for example, a numeric algorithm computes an expected value to be say \n\u003ccode\u003e-0.0\u003c/code\u003e and previously computed the witness value to be say \n\u003ccode\u003e+0.0\u003c/code\u003e."
        ],
        "param": [
          "\u003ccode\u003earrayClass\u003c/code\u003e - the class of an array, of type \n\u003ccode\u003eT[]\u003c/code\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the arrayClass is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if arrayClass is not an array type"
        ],
        "return": [
          "a VarHandle giving access to elements of an array"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "viewArrayClass"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "byteOrder"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "byteArrayViewVarHandle",
      "comment": "Produces a VarHandle giving access to elements of a byte[] array viewed as if it were a different primitive array type, such as int[] or long[]. The VarHandle\u0027s variable type is the component type of viewArrayClass and the list of coordinate types is (byte[], int), where the int coordinate type corresponds to an argument that is an index into a byte[] array. The returned VarHandle accesses bytes at an index in a byte[] array, composing bytes to or from a value of the component type of viewArrayClass according to the given endianness. The supported component types (variables types) are short, char, int, long, float and double. Access of bytes at a given index will result in an IndexOutOfBoundsException if the index is less than 0 or greater than the byte[] array length minus the size (in bytes) of T. Access of bytes at an index may be aligned or misaligned for T, with respect to the underlying memory address, A say, associated with the array and index. If access is misaligned then access for anything other than the get and set access modes will result in an IllegalStateException. In such cases atomic access is only guaranteed with respect to the largest power of two that divides the GCD of A and the size (in bytes) of T. If access is aligned then following access modes are supported and are guaranteed to support atomic access: read write access modes for all T, with the exception of access modes get and set for long and double on 32-bit platforms. atomic update access modes for int, long, float or double. (Future major platform releases of the JDK may support additional types for certain currently unsupported access modes.) numeric atomic update access modes for int and long. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) bitwise atomic update access modes for int and long. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) Misaligned access, and therefore atomicity guarantees, may be determined for byte[] arrays without operating on a specific array. Given an index, T and it\u0027s corresponding boxed type, T_BOX, misalignment may be determined as follows: \n int sizeOfT \u003d T_BOX.BYTES;  // size in bytes of T\n int misalignedAtZeroIndex \u003d ByteBuffer.wrap(new byte[0]).\n     alignmentOffset(0, sizeOfT);\n int misalignedAtIndex \u003d (misalignedAtZeroIndex + index) % sizeOfT;\n boolean isMisaligned \u003d misalignedAtIndex !\u003d 0;\n If the variable type is float or double then atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double), respectively).",
      "tagMap": {
        "param": [
          "\u003ccode\u003eviewArrayClass\u003c/code\u003e - the view array class, with a component type of type \n\u003ccode\u003eT\u003c/code\u003e",
          "\u003ccode\u003ebyteOrder\u003c/code\u003e - the endianness of the view array elements, as stored in the underlying \n\u003ccode\u003ebyte\u003c/code\u003e array"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if viewArrayClass or byteOrder is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if viewArrayClass is not an array type",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the component type of viewArrayClass is not supported as a variable type"
        ],
        "return": [
          "a VarHandle giving access to elements of a \n\u003ccode\u003ebyte[]\u003c/code\u003e array viewed as if elements corresponding to the components type of the view array class"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.VarHandle",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.IllegalArgumentException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "viewArrayClass"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteOrder",
            "type": "Class"
          },
          "field": {
            "name": "byteOrder"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "byteBufferViewVarHandle",
      "comment": "Produces a VarHandle giving access to elements of a ByteBuffer viewed as if it were an array of elements of a different primitive component type to that of byte, such as int[] or long[]. The VarHandle\u0027s variable type is the component type of viewArrayClass and the list of coordinate types is (ByteBuffer, int), where the int coordinate type corresponds to an argument that is an index into a byte[] array. The returned VarHandle accesses bytes at an index in a ByteBuffer, composing bytes to or from a value of the component type of viewArrayClass according to the given endianness. The supported component types (variables types) are short, char, int, long, float and double. Access will result in a ReadOnlyBufferException for anything other than the read access modes if the ByteBuffer is read-only. Access of bytes at a given index will result in an IndexOutOfBoundsException if the index is less than 0 or greater than the ByteBuffer limit minus the size (in bytes) of T. Access of bytes at an index may be aligned or misaligned for T, with respect to the underlying memory address, A say, associated with the ByteBuffer and index. If access is misaligned then access for anything other than the get and set access modes will result in an IllegalStateException. In such cases atomic access is only guaranteed with respect to the largest power of two that divides the GCD of A and the size (in bytes) of T. If access is aligned then following access modes are supported and are guaranteed to support atomic access: read write access modes for all T, with the exception of access modes get and set for long and double on 32-bit platforms. atomic update access modes for int, long, float or double. (Future major platform releases of the JDK may support additional types for certain currently unsupported access modes.) numeric atomic update access modes for int and long. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) bitwise atomic update access modes for int and long. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) Misaligned access, and therefore atomicity guarantees, may be determined for a ByteBuffer, bb (direct or otherwise), an index, T and it\u0027s corresponding boxed type, T_BOX, as follows: \n int sizeOfT \u003d T_BOX.BYTES;  // size in bytes of T\n ByteBuffer bb \u003d ...\n int misalignedAtIndex \u003d bb.alignmentOffset(index, sizeOfT);\n boolean isMisaligned \u003d misalignedAtIndex !\u003d 0;\n If the variable type is float or double then atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double), respectively).",
      "tagMap": {
        "param": [
          "\u003ccode\u003eviewArrayClass\u003c/code\u003e - the view array class, with a component type of type \n\u003ccode\u003eT\u003c/code\u003e",
          "\u003ccode\u003ebyteOrder\u003c/code\u003e - the endianness of the view array elements, as stored in the underlying \n\u003ccode\u003eByteBuffer\u003c/code\u003e (Note this overrides the endianness of a \n\u003ccode\u003eByteBuffer\u003c/code\u003e)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if viewArrayClass or byteOrder is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if viewArrayClass is not an array type",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the component type of viewArrayClass is not supported as a variable type"
        ],
        "return": [
          "a VarHandle giving access to elements of a \n\u003ccode\u003eByteBuffer\u003c/code\u003e viewed as if elements corresponding to the components type of the view array class"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "leadingArgCount"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "spreadInvoker",
      "comment": "Produces a method handle which will invoke any method handle of the given type, with a given number of trailing arguments replaced by a single trailing Object[] array. The resulting invoker will be a method handle with the following arguments: a single MethodHandle target zero or more leading values (counted by leadingArgCount) an Object[] array containing trailing arguments The invoker will invoke its target like a call to invoke with the indicated type. That is, if the target is exactly of the given type, it will behave like invokeExact; otherwise it behave as if asType is used to convert the target to the required type. The type of the returned invoker will not be the given type, but rather will have all parameters except the first leadingArgCount replaced by a single array of type Object[], which will be the final parameter. Before invoking its target, the invoker will spread the final array, apply reference casts as necessary, and unbox and widen primitive arguments. If, when the invoker is called, the supplied array argument does not have the correct number of elements, the invoker will throw an IllegalArgumentException instead of invoking the target. This method is equivalent to the following code (though it may be more efficient): \nMethodHandle invoker \u003d MethodHandles.invoker(type);\nint spreadArgCount \u003d type.parameterCount() - leadingArgCount;\ninvoker \u003d invoker.asSpreader(Object[].class, spreadArgCount);\nreturn invoker;\n This method throws no reflective or security exceptions.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the desired target type",
          "\u003ccode\u003eleadingArgCount\u003c/code\u003e - number of fixed arguments, to be passed unchanged to the target"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etype\u003c/code\u003e is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eleadingArgCount\u003c/code\u003e is not in the range from 0 to \n\u003ccode\u003etype.parameterCount()\u003c/code\u003e inclusive, or if the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e"
        ],
        "return": [
          "a method handle suitable for invoking any method handle of the given type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "exactInvoker",
      "comment": "Produces a special invoker method handle which can be used to invoke any method handle of the given type, as if by invokeExact. The resulting invoker will have a type which is exactly equal to the desired type, except that it will accept an additional leading argument of type MethodHandle. This method is equivalent to the following code (though it may be more efficient): publicLookup().findVirtual(MethodHandle.class, \"invokeExact\", type) Discussion: Invoker method handles can be useful when working with variable method handles of unknown types. For example, to emulate an invokeExact call to a variable method handle M, extract its type T, look up the invoker method X for T, and call the invoker method, as X.invoke(T, A...). (It would not work to call X.invokeExact, since the type T is unknown.) If spreading, collecting, or other argument transformations are required, they can be applied once to the invoker X and reused on many M method handle values, as long as they are compatible with the type of X. (Note: The invoker method is not available via the Core Reflection API. An attempt to call java.lang.reflect.Method.invoke on the declared invokeExact or invoke method will raise an UnsupportedOperationException.) This method throws no reflective or security exceptions.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the desired target type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e"
        ],
        "return": [
          "a method handle suitable for invoking any method handle of the given type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "invoker",
      "comment": "Produces a special invoker method handle which can be used to invoke any method handle compatible with the given type, as if by invoke. The resulting invoker will have a type which is exactly equal to the desired type, except that it will accept an additional leading argument of type MethodHandle. Before invoking its target, if the target differs from the expected type, the invoker will apply reference casts as necessary and box, unbox, or widen primitive values, as if by asType. Similarly, the return value will be converted as necessary. If the target is a variable arity method handle, the required arity conversion will be made, again as if by asType. This method is equivalent to the following code (though it may be more efficient): publicLookup().findVirtual(MethodHandle.class, \"invoke\", type) Discussion: A general method type is one which mentions only Object arguments and return values. An invoker for such a type is capable of calling any method handle of the same arity as the general type. (Note: The invoker method is not available via the Core Reflection API. An attempt to call java.lang.reflect.Method.invoke on the declared invokeExact or invoke method will raise an UnsupportedOperationException.) This method throws no reflective or security exceptions.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the desired target type"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e"
        ],
        "return": [
          "a method handle suitable for invoking any method handle convertible to the given type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle$AccessMode",
            "type": "Class"
          },
          "field": {
            "name": "accessMode"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "varHandleExactInvoker",
      "comment": "Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type. The resulting invoker will have a type which is exactly equal to the desired given type, except that it will accept an additional leading argument of type VarHandle.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eaccessMode\u003c/code\u003e - the VarHandle access mode",
          "\u003ccode\u003etype\u003c/code\u003e - the desired target type"
        ],
        "return": [
          "a method handle suitable for invoking an access mode method of any VarHandle whose access mode type is of the given type."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.VarHandle$AccessMode",
            "type": "Class"
          },
          "field": {
            "name": "accessMode"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "varHandleInvoker",
      "comment": "Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type. The resulting invoker will have a type which is exactly equal to the desired given type, except that it will accept an additional leading argument of type VarHandle. Before invoking its target, if the access mode type differs from the desired given type, the invoker will apply reference casts as necessary and box, unbox, or widen primitive values, as if by asType. Similarly, the return value will be converted as necessary. This method is equivalent to the following code (though it may be more efficient): publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)",
      "tagMap": {
        "param": [
          "\u003ccode\u003eaccessMode\u003c/code\u003e - the VarHandle access mode",
          "\u003ccode\u003etype\u003c/code\u003e - the desired target type"
        ],
        "return": [
          "a method handle suitable for invoking an access mode method of any VarHandle whose access mode type is convertible to the given type."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "newType"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "explicitCastArguments",
      "comment": "Produces a method handle which adapts the type of the given method handle to a new type by pairwise argument and return type conversion. The original type and new type must have the same number of arguments. The resulting method handle is guaranteed to report a type which is equal to the desired new type. If the original type and new type are equal, returns target. The same conversions are allowed as for MethodHandle.asType, and some additional conversions are also applied if those conversions fail. Given types T0, T1, one of the following conversions is applied if possible, before or instead of any conversions done by asType: If T0 and T1 are references, and T1 is an interface type, then the value of type T0 is passed as a T1 without a cast. (This treatment of interfaces follows the usage of the bytecode verifier.) If T0 is boolean and T1 is another primitive, the boolean is converted to a byte value, 1 for true, 0 for false. (This treatment follows the usage of the bytecode verifier.) If T1 is boolean and T0 is another primitive, T0 is converted to byte via Java casting conversion (JLS 5.5), and the low order bit of the result is tested, as if by (x \u0026 1) !\u003d 0. If T0 and T1 are primitives other than boolean, then a Java casting conversion (JLS 5.5) is applied. (Specifically, T0 will convert to T1 by widening and/or narrowing.) If T0 is a reference and T1 a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java casting conversion (JLS 5.5) on the primitive value, possibly followed by a conversion from byte to boolean by testing the low-order bit. If T0 is a reference and T1 a primitive, and if the reference is null at runtime, a zero value is introduced.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asType(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandle.asType(java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after arguments are retyped",
          "\u003ccode\u003enewType\u003c/code\u003e - the expected type of the new method handle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the conversion cannot be made"
        ],
        "return": [
          "a method handle which delegates to the target after performing any necessary argument conversions, and arranges for any necessary return value conversions"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "newType"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "reorder"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "permuteArguments",
      "comment": "Produces a method handle which adapts the calling sequence of the given method handle to a new type, by reordering the arguments. The resulting method handle is guaranteed to report a type which is equal to the desired new type. The given array controls the reordering. Call #I the number of incoming parameters (the value newType.parameterCount(), and call #O the number of outgoing parameters (the value target.type().parameterCount()). Then the length of the reordering array must be #O, and each element must be a non-negative number less than #I. For every N less than #O, the N-th outgoing argument will be taken from the I-th incoming argument, where I is reorder[N]. No argument or return value conversions are applied. The type of each incoming argument, as determined by newType, must be identical to the type of the corresponding outgoing parameter or parameters in the target method handle. The return type of newType must be identical to the return type of the original target. The reordering array need not specify an actual permutation. An incoming argument will be duplicated if its index appears more than once in the array, and an incoming argument will be dropped if its index does not appear in the array. As in the case of dropArguments, incoming arguments which are not mentioned in the reordering array may be of any type, as determined only by newType. \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodType intfn1 \u003d methodType(int.class, int.class);\nMethodType intfn2 \u003d methodType(int.class, int.class, int.class);\nMethodHandle sub \u003d ... (int x, int y) -\u003e (x-y) ...;\nassert(sub.type().equals(intfn2));\nMethodHandle sub1 \u003d permuteArguments(sub, intfn2, 0, 1);\nMethodHandle rsub \u003d permuteArguments(sub, intfn2, 1, 0);\nassert((int)rsub.invokeExact(1, 100) \u003d\u003d 99);\nMethodHandle add \u003d ... (int x, int y) -\u003e (x+y) ...;\nassert(add.type().equals(intfn2));\nMethodHandle twice \u003d permuteArguments(add, intfn1, 0, 0);\nassert(twice.type().equals(intfn1));\nassert((int)twice.invokeExact(21) \u003d\u003d 42);\n Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after arguments are reordered",
          "\u003ccode\u003enewType\u003c/code\u003e - the expected type of the new method handle",
          "\u003ccode\u003ereorder\u003c/code\u003e - an index array which controls the reordering"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the index array length is not equal to the arity of the target, or if any index array element not a valid index for a parameter of \n\u003ccode\u003enewType\u003c/code\u003e, or if two corresponding parameter types in \n\u003ccode\u003etarget.type()\u003c/code\u003e and \n\u003ccode\u003enewType\u003c/code\u003e are not identical,"
        ],
        "return": [
          "a method handle which delegates to the target after it drops unused arguments and moves and/or duplicates the other arguments"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "constant",
      "comment": "Produces a method handle of the requested return type which returns the given constant value every time it is invoked. Before the method handle is returned, the passed-in value is converted to the requested type. If the requested type is primitive, widening primitive conversions are attempted, else reference conversions are attempted. The returned method handle is equivalent to identity(type).bindTo(value).",
      "tagMap": {
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the return type of the desired method handle",
          "\u003ccode\u003evalue\u003c/code\u003e - the value to return"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003etype\u003c/code\u003e argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the value cannot be converted to the required return type",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given type is \n\u003ccode\u003evoid.class\u003c/code\u003e"
        ],
        "return": [
          "a method handle of the given return type and no arguments, which always returns the given value"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "identity",
      "comment": "Produces a method handle which returns its sole argument when invoked.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the type of the sole parameter and return value of the desired method handle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given type is \n\u003ccode\u003evoid.class\u003c/code\u003e"
        ],
        "return": [
          "a unary method handle which accepts and returns the given type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "zero",
      "comment": "Produces a constant method handle of the requested return type which returns the default value for that type every time it is invoked. The resulting constant method handle will have no side effects. The returned method handle is equivalent to empty(methodType(type)). It is also equivalent to explicitCastArguments(constant(Object.class, null), methodType(type)), since explicitCastArguments converts null to default values.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#constant(java.lang.Class,java.lang.Object)\"\u003e\u003ccode\u003econstant(java.lang.Class\u0026lt;?\u0026gt;, java.lang.Object)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#empty(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eempty(java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#explicitCastArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eexplicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the expected return type of the desired method handle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a constant method handle that takes no arguments and returns the default value of the given type (or void, if the type is void)"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "empty",
      "comment": "Produces a method handle of the requested type which ignores any arguments, does nothing, and returns a suitable default depending on the return type. That is, it returns a zero primitive value, a null, or void. The returned method handle is equivalent to dropArguments(zero(type.returnType()), 0, type.parameterList()).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#zero(java.lang.Class)\"\u003e\u003ccode\u003ezero(java.lang.Class\u0026lt;?\u0026gt;)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#constant(java.lang.Class,java.lang.Object)\"\u003e\u003ccode\u003econstant(java.lang.Class\u0026lt;?\u0026gt;, java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Given a predicate and target, a useful \"if-then\" construct can be produced as \n\u003ccode\u003eguardWithTest(pred, target, empty(target.type())\u003c/code\u003e."
        ],
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the type of the desired method handle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the argument is null"
        ],
        "return": [
          "a constant method handle of the given type, which returns a default value of the given return type"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "values"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "insertArguments",
      "comment": "Provides a target method handle with one or more bound arguments in advance of the method handle\u0027s invocation. The formal parameters to the target corresponding to the bound arguments are called bound parameters. Returns a new method handle which saves away the bound arguments. When it is invoked, it receives arguments for any non-bound parameters, binds the saved arguments to their corresponding parameters, and calls the original target. The type of the new method handle will drop the types for the bound parameters from the original target type, since the new method handle will no longer require those arguments to be supplied by its callers. Each given argument object must match the corresponding bound parameter type. If a bound parameter type is a primitive, the argument object must be a wrapper, and will be unboxed to produce the primitive value. The pos argument selects which parameters are to be bound. It may range between zero and N-L (inclusively), where N is the arity of the target method handle and L is the length of the values array. Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#bindTo(java.lang.Object)\"\u003e\u003ccode\u003eMethodHandle.bindTo(java.lang.Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after the argument is inserted",
          "\u003ccode\u003epos\u003c/code\u003e - where to insert the argument (zero for the first)",
          "\u003ccode\u003evalues\u003c/code\u003e - the series of arguments to insert"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the target or the \n\u003ccode\u003evalues\u003c/code\u003e array is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if (@code pos) is less than \n\u003ccode\u003e0\u003c/code\u003e or greater than \n\u003ccode\u003eN - L\u003c/code\u003e where \n\u003ccode\u003eN\u003c/code\u003e is the arity of the target method handle and \n\u003ccode\u003eL\u003c/code\u003e is the length of the values array.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if an argument does not match the corresponding bound parameter type."
        ],
        "return": [
          "a method handle which inserts an additional argument, before calling the original method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.Class",
                "parameters": [
                  {
                    "type": "Wildcard"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "valueTypes"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "dropArguments",
      "comment": "Produces a method handle which will discard some dummy arguments before calling some other specified target method handle. The type of the new method handle will be the same as the target\u0027s type, except it will also include the dummy argument types, at some given position. The pos argument may range between zero and N, where N is the arity of the target. If pos is zero, the dummy arguments will precede the target\u0027s real arguments; if pos is N they will come after. Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodType bigType \u003d cat.type().insertParameterTypes(0, int.class, String.class);\nMethodHandle d0 \u003d dropArguments(cat, 0, bigType.parameterList().subList(0,2));\nassertEquals(bigType, d0.type());\nassertEquals(\"yz\", (String) d0.invokeExact(123, \"x\", \"y\", \"z\"));\n This method is also equivalent to the following code:  dropArguments(target, pos, valueTypes.toArray(new Class[0]))",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after the arguments are dropped",
          "\u003ccode\u003epos\u003c/code\u003e - position of first argument to drop (zero for the leftmost)",
          "\u003ccode\u003evalueTypes\u003c/code\u003e - the type(s) of the argument(s) to drop"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the target is null, or if the \n\u003ccode\u003evalueTypes\u003c/code\u003e list or any of its elements is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any element of \n\u003ccode\u003evalueTypes\u003c/code\u003e is \n\u003ccode\u003evoid.class\u003c/code\u003e, or if \n\u003ccode\u003epos\u003c/code\u003e is negative or greater than the arity of the target, or if the new method handle\u0027s type would have too many parameters"
        ],
        "return": [
          "a method handle which drops arguments of the given types, before calling the original method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "valueTypes"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "dropArguments",
      "comment": "Produces a method handle which will discard some dummy arguments before calling some other specified target method handle. The type of the new method handle will be the same as the target\u0027s type, except it will also include the dummy argument types, at some given position. The pos argument may range between zero and N, where N is the arity of the target. If pos is zero, the dummy arguments will precede the target\u0027s real arguments; if pos is N they will come after.",
      "tagMap": {
        "apiNote": [
          "\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle d0 \u003d dropArguments(cat, 0, String.class);\nassertEquals(\"yz\", (String) d0.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d1 \u003d dropArguments(cat, 1, String.class);\nassertEquals(\"xz\", (String) d1.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d2 \u003d dropArguments(cat, 2, String.class);\nassertEquals(\"xy\", (String) d2.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d12 \u003d dropArguments(cat, 1, int.class, boolean.class);\nassertEquals(\"xz\", (String) d12.invokeExact(\"x\", 12, true, \"z\"));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e This method is also equivalent to the following code: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)\"\u003e\u003ccode\u003edropArguments\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(target, pos, Arrays.asList(valueTypes))\u003c/code\u003e\n \u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after the arguments are dropped",
          "\u003ccode\u003epos\u003c/code\u003e - position of first argument to drop (zero for the leftmost)",
          "\u003ccode\u003evalueTypes\u003c/code\u003e - the type(s) of the argument(s) to drop"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the target is null, or if the \n\u003ccode\u003evalueTypes\u003c/code\u003e array or any of its elements is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any element of \n\u003ccode\u003evalueTypes\u003c/code\u003e is \n\u003ccode\u003evoid.class\u003c/code\u003e, or if \n\u003ccode\u003epos\u003c/code\u003e is negative or greater than the arity of the target, or if the new method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e"
        ],
        "return": [
          "a method handle which drops arguments of the given types, before calling the original method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "skip"
          }
        },
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.Class",
                "parameters": [
                  {
                    "type": "Wildcard"
                  }
                ],
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "newTypes"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "dropArgumentsToMatch",
      "comment": "Adapts a target method handle to match the given parameter type list. If necessary, adds dummy arguments. Some leading parameters can be skipped before matching begins. The remaining types in the target\u0027s parameter type list must be a sub-list of the newTypes type list at the starting position pos. The resulting handle will have the target handle\u0027s parameter type list, with any non-matching parameter types (before or after the matching sub-list) inserted in corresponding positions of the target\u0027s original parameters, as if by dropArguments(MethodHandle, int, Class[]). The resulting handle will have the same return type as the target handle. In more formal terms, assume these two type lists: The target handle has the parameter type list S..., M..., with as many types in S as indicated by skip. The M types are those that are supposed to match part of the given type list, newTypes. The newTypes list contains types P..., M..., A..., with as many types in P as indicated by pos. The M types are precisely those that the M types in the target handle\u0027s parameter type list are supposed to match. The types in A are additional types found after the matching sub-list. Given these assumptions, the result of an invocation of dropArgumentsToMatch will have the parameter type list S..., P..., M..., A..., with the P and A types inserted as if by dropArguments(MethodHandle, int, Class[]).",
      "tagMap": {
        "apiNote": [
          "Two method handles whose argument lists are \"effectively identical\" (i.e., identical in a common prefix) may be mutually converted to a common type by two calls to \n\u003ccode\u003edropArgumentsToMatch\u003c/code\u003e, as follows: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\n...\nMethodHandle h0 \u003d constant(boolean.class, true);\nMethodHandle h1 \u003d lookup().findVirtual(String.class, \"concat\", methodType(String.class, String.class));\nMethodType bigType \u003d h1.type().insertParameterTypes(1, String.class, int.class);\nMethodHandle h2 \u003d dropArguments(h1, 0, bigType.parameterList());\nif (h1.type().parameterCount() \u0026lt; h2.type().parameterCount())\n    h1 \u003d dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1\nelse\n    h2 \u003d dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2\nMethodHandle h3 \u003d guardWithTest(h0, h1, h2);\nassertEquals(\"xy\", h3.invoke(\"x\", \"y\", 1, \"a\", \"b\", \"c\"));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to adapt",
          "\u003ccode\u003eskip\u003c/code\u003e - number of targets parameters to disregard (they will be unchanged)",
          "\u003ccode\u003enewTypes\u003c/code\u003e - the list of types to match \n\u003ccode\u003etarget\u003c/code\u003e\u0027s parameter type list to",
          "\u003ccode\u003epos\u003c/code\u003e - place in \n\u003ccode\u003enewTypes\u003c/code\u003e where the non-skipped target parameters must occur"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any element of \n\u003ccode\u003enewTypes\u003c/code\u003e is \n\u003ccode\u003evoid.class\u003c/code\u003e, or if \n\u003ccode\u003eskip\u003c/code\u003e is negative or greater than the arity of the target, or if \n\u003ccode\u003epos\u003c/code\u003e is negative or greater than the newTypes list size, or if \n\u003ccode\u003enewTypes\u003c/code\u003e does not contain the \n\u003ccode\u003etarget\u003c/code\u003e\u0027s non-skipped parameter types at position \n\u003ccode\u003epos\u003c/code\u003e."
        ],
        "return": [
          "a possibly adapted method handle"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "dropReturn",
      "comment": "Drop the return value of the target handle (if any). The returned method handle will have a void return type.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to adapt"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etarget\u003c/code\u003e is null"
        ],
        "return": [
          "a possibly adapted method handle"
        ],
        "since": [
          "16"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "filters"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "filterArguments",
      "comment": "Adapts a target method handle by pre-processing one or more of its arguments, each with its own unary filter function, and then calling the target with each pre-processed argument replaced by the result of its corresponding filter function. The pre-processing is performed by one or more method handles, specified in the elements of the filters array. The first element of the filter array corresponds to the pos argument of the target, and so on in sequence. The filter functions are invoked in left to right order. Null arguments in the array are treated as identity functions, and the corresponding arguments left unchanged. (If there are no non-null elements in the array, the original target is returned.) Each filter is applied to the corresponding argument of the adapter. If a filter F applies to the Nth argument of the target, then F must be a method handle which takes exactly one argument. The type of F\u0027s sole argument replaces the corresponding argument type of the target in the resulting adapted method handle. The return type of F must be identical to the corresponding parameter type of the target. It is an error if there are elements of filters (null or not) which do not correspond to argument positions in the target. Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle upcase \u003d lookup().findVirtual(String.class,\n  \"toUpperCase\", methodType(String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle f0 \u003d filterArguments(cat, 0, upcase);\nassertEquals(\"Xy\", (String) f0.invokeExact(\"x\", \"y\")); // Xy\nMethodHandle f1 \u003d filterArguments(cat, 1, upcase);\nassertEquals(\"xY\", (String) f1.invokeExact(\"x\", \"y\")); // xY\nMethodHandle f2 \u003d filterArguments(cat, 0, upcase, upcase);\nassertEquals(\"XY\", (String) f2.invokeExact(\"x\", \"y\")); // XY\n Here is pseudocode for the resulting adapter. In the code, T denotes the return type of both the target and resulting adapter. P/p and B/b represent the types and values of the parameters and arguments that precede and follow the filter position pos, respectively. A[i]/a[i] stand for the types and values of the filtered parameters and arguments; they also represent the return types of the filter[i] handles. The latter accept arguments v[i] of type V[i], which also appear in the signature of the resulting adapter. \n T target(P... p, A[i]... a[i], B... b);\n A[i] filter[i](V[i]);\n T adapter(P... p, V[i]... v[i], B... b) {\n   return target(p..., filter[i](v[i])..., b...);\n }\n Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after arguments are filtered",
          "\u003ccode\u003epos\u003c/code\u003e - the position of the first argument to filter",
          "\u003ccode\u003efilters\u003c/code\u003e - method handles to call initially on filtered arguments"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the target is null or if the \n\u003ccode\u003efilters\u003c/code\u003e array is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if a non-null element of \n\u003ccode\u003efilters\u003c/code\u003e does not match a corresponding argument type of target as described above, or if the \n\u003ccode\u003epos+filters.length\u003c/code\u003e is greater than \n\u003ccode\u003etarget.type().parameterCount()\u003c/code\u003e, or if the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e"
        ],
        "return": [
          "method handle which incorporates the specified argument filtering logic"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "filter"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "collectArguments",
      "comment": "Adapts a target method handle by pre-processing a sub-sequence of its arguments with a filter (another method handle). The pre-processed arguments are replaced by the result (if any) of the filter function. The target is then called on the modified (usually shortened) argument list. If the filter returns a value, the target must accept that value as its argument in position pos, preceded and/or followed by any arguments not passed to the filter. If the filter returns void, the target must accept all arguments not passed to the filter. No arguments are reordered, and a result returned from the filter replaces (in order) the whole subsequence of arguments originally passed to the adapter. The argument types (if any) of the filter replace zero or one argument types of the target, at position pos, in the resulting adapted method handle. The return type of the filter (if any) must be identical to the argument type of the target at position pos, and that target argument is supplied by the return value of the filter. In all cases, pos must be greater than or equal to zero, and pos must also be less than or equal to the target\u0027s arity. Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle deepToString \u003d publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\n\nMethodHandle ts1 \u003d deepToString.asCollector(String[].class, 1);\nassertEquals(\"[strange]\", (String) ts1.invokeExact(\"strange\"));\n\nMethodHandle ts2 \u003d deepToString.asCollector(String[].class, 2);\nassertEquals(\"[up, down]\", (String) ts2.invokeExact(\"up\", \"down\"));\n\nMethodHandle ts3 \u003d deepToString.asCollector(String[].class, 3);\nMethodHandle ts3_ts2 \u003d collectArguments(ts3, 1, ts2);\nassertEquals(\"[top, [up, down], strange]\",\n             (String) ts3_ts2.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts1 \u003d collectArguments(ts3_ts2, 3, ts1);\nassertEquals(\"[top, [up, down], [strange]]\",\n             (String) ts3_ts2_ts1.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts3 \u003d collectArguments(ts3_ts2, 1, ts3);\nassertEquals(\"[top, [[up, down, strange], charm], bottom]\",\n             (String) ts3_ts2_ts3.invokeExact(\"top\", \"up\", \"down\", \"strange\", \"charm\", \"bottom\"));\n Here is pseudocode for the resulting adapter. In the code, T represents the return type of the target and resulting adapter. V/v stand for the return type and value of the filter, which are also found in the signature and arguments of the target, respectively, unless V is void. A/a and C/c represent the parameter types and values preceding and following the collection position, pos, in the target\u0027s signature. They also turn up in the resulting adapter\u0027s signature and arguments, where they surround B/b, which represent the parameter types and arguments to the filter (if any). \n T target(A...,V,C...);\n V filter(B...);\n T adapter(A... a,B... b,C... c) {\n   V v \u003d filter(b...);\n   return target(a...,v,c...);\n }\n // and if the filter has no arguments:\n T target2(A...,V,C...);\n V filter2();\n T adapter2(A... a,C... c) {\n   V v \u003d filter2();\n   return target2(a...,v,c...);\n }\n // and if the filter has a void return:\n T target3(A...,C...);\n void filter3(B...);\n T adapter3(A... a,B... b,C... c) {\n   filter3(b...);\n   return target3(a...,c...);\n }\n A collection adapter collectArguments(mh, 0, coll) is equivalent to one which first \"folds\" the affected arguments, and then drops them, in separate steps as follows: \n mh \u003d MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2\n mh \u003d MethodHandles.foldArguments(mh, coll); //step 1\n If the target method handle consumes no arguments besides than the result (if any) of the filter coll, then collectArguments(mh, 0, coll) is equivalent to filterReturnValue(coll, mh). If the filter method handle coll consumes one argument and produces a non-void result, then collectArguments(mh, N, coll) is equivalent to filterArguments(mh, N, coll). Other equivalences are possible but would require argument permutation. Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003efoldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)\"\u003e\u003ccode\u003efilterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003efilterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after filtering the subsequence of arguments",
          "\u003ccode\u003epos\u003c/code\u003e - the position of the first adapter argument to pass to the filter, and/or the target argument which receives the result of the filter",
          "\u003ccode\u003efilter\u003c/code\u003e - method handle to call on the subsequence of arguments"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the return type of \n\u003ccode\u003efilter\u003c/code\u003e is non-void and is not the same as the \n\u003ccode\u003epos\u003c/code\u003e argument of the target, or if \n\u003ccode\u003epos\u003c/code\u003e is not between 0 and the target\u0027s arity, inclusive, or if the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e"
        ],
        "return": [
          "method handle which incorporates the specified argument subsequence filtering logic"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "filter"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "filterReturnValue",
      "comment": "Adapts a target method handle by post-processing its return value (if any) with a filter (another method handle). The result of the filter is returned from the adapter. If the target returns a value, the filter must accept that value as its only argument. If the target returns void, the filter must accept no arguments. The return type of the filter replaces the return type of the target in the resulting adapted method handle. The argument type of the filter (if any) must be identical to the return type of the target. Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle length \u003d lookup().findVirtual(String.class,\n  \"length\", methodType(int.class));\nSystem.out.println((String) cat.invokeExact(\"x\", \"y\")); // xy\nMethodHandle f0 \u003d filterReturnValue(cat, length);\nSystem.out.println((int) f0.invokeExact(\"x\", \"y\")); // 2\n Here is pseudocode for the resulting adapter. In the code, T/t represent the result type and value of the target; V, the result type of the filter; and A/a, the types and values of the parameters and arguments of the target as well as the resulting adapter. \n T target(A...);\n V filter(T);\n V adapter(A... a) {\n   T t \u003d target(a...);\n   return filter(t);\n }\n // and if the target has a void return:\n void target2(A...);\n V filter2();\n V adapter2(A... a) {\n   target2(a...);\n   return filter2();\n }\n // and if the filter has a void return:\n T target3(A...);\n void filter3(V);\n void adapter3(A... a) {\n   T t \u003d target3(a...);\n   filter3(t);\n }\n Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke before filtering the return value",
          "\u003ccode\u003efilter\u003c/code\u003e - method handle to call on the return value"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the argument list of \n\u003ccode\u003efilter\u003c/code\u003e does not match the return type of target as described above"
        ],
        "return": [
          "method handle which incorporates the specified return value filtering logic"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "combiner"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "foldArguments",
      "comment": "Adapts a target method handle by pre-processing some of its arguments, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments. The pre-processing is performed by combiner, a second method handle. Of the arguments passed to the adapter, the first N arguments are copied to the combiner, which is then called. (Here, N is defined as the parameter count of the combiner.) After this, control passes to the target, with any result from the combiner inserted before the original N incoming arguments. If the combiner returns a value, the first parameter type of the target must be identical with the return type of the combiner, and the next N parameter types of the target must exactly match the parameters of the combiner. If the combiner has a void return, no result will be inserted, and the first N parameter types of the target must exactly match the parameters of the combiner. The resulting adapter is the same type as the target, except that the first parameter type is dropped, if it corresponds to the result of the combiner. (Note that dropArguments can be used to remove any arguments that either the combiner or the target does not wish to receive. If some of the incoming arguments are destined only for the combiner, consider using asCollector instead, since those arguments will not need to be live on the stack on entry to the target.) Example: \nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle trace \u003d publicLookup().findVirtual(java.io.PrintStream.class,\n  \"println\", methodType(void.class, String.class))\n    .bindTo(System.out);\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\"));\nMethodHandle catTrace \u003d foldArguments(cat, trace);\n// also prints \"boo\":\nassertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\"));\n Here is pseudocode for the resulting adapter. In the code, T represents the result type of the target and resulting adapter. V/v represent the type and value of the parameter and argument of target that precedes the folding position; V also is the result type of the combiner. A/a denote the types and values of the N parameters and arguments at the folding position. B/b represent the types and values of the target parameters and arguments that follow the folded parameters and arguments. \n // there are N arguments in A...\n T target(V, A[N]..., B...);\n V combiner(A...);\n T adapter(A... a, B... b) {\n   V v \u003d combiner(a...);\n   return target(v, a..., b...);\n }\n // and if the combiner has a void return:\n T target2(A[N]..., B...);\n void combiner2(A...);\n T adapter2(A... a, B... b) {\n   combiner2(a...);\n   return target2(a..., b...);\n }\n Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after arguments are combined",
          "\u003ccode\u003ecombiner\u003c/code\u003e - method handle to call initially on the incoming arguments"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ecombiner\u003c/code\u003e\u0027s return type is non-void and not the same as the first argument type of the target, or if the initial \n\u003ccode\u003eN\u003c/code\u003e argument types of the target (skipping one matching the \n\u003ccode\u003ecombiner\u003c/code\u003e\u0027s return type) are not identical with the argument types of \n\u003ccode\u003ecombiner\u003c/code\u003e"
        ],
        "return": [
          "method handle which incorporates the specified argument folding logic"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "pos"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "combiner"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "foldArguments",
      "comment": "Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments just before the folded arguments. This method is closely related to foldArguments(MethodHandle, MethodHandle), but allows to control the position in the parameter list at which folding takes place. The argument controlling this, pos, is a zero-based index. The aforementioned method foldArguments(MethodHandle, MethodHandle) assumes position 0.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003efoldArguments(MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Example: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n    import static java.lang.invoke.MethodHandles.*;\n    import static java.lang.invoke.MethodType.*;\n    ...\n    MethodHandle trace \u003d publicLookup().findVirtual(java.io.PrintStream.class,\n    \"println\", methodType(void.class, String.class))\n    .bindTo(System.out);\n    MethodHandle cat \u003d lookup().findVirtual(String.class,\n    \"concat\", methodType(String.class, String.class));\n    assertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\"));\n    MethodHandle catTrace \u003d foldArguments(cat, 1, trace);\n    // also prints \"jum\":\n    assertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\"));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003eHere is pseudocode for the resulting adapter. In the code, \u003ccode\u003eT\u003c/code\u003e represents the result type of the \u003ccode\u003etarget\u003c/code\u003e and resulting adapter. \u003ccode\u003eV\u003c/code\u003e/\u003ccode\u003ev\u003c/code\u003e represent the type and value of the parameter and argument of \u003ccode\u003etarget\u003c/code\u003e that precedes the folding position; \u003ccode\u003eV\u003c/code\u003e also is the result type of the \u003ccode\u003ecombiner\u003c/code\u003e. \u003ccode\u003eA\u003c/code\u003e/\u003ccode\u003ea\u003c/code\u003e denote the types and values of the \u003ccode\u003eN\u003c/code\u003e parameters and arguments at the folding position. \u003ccode\u003eZ\u003c/code\u003e/\u003ccode\u003ez\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e/\u003ccode\u003eb\u003c/code\u003e represent the types and values of the \u003ccode\u003etarget\u003c/code\u003e parameters and arguments that precede and follow the folded parameters and arguments starting at \u003ccode\u003epos\u003c/code\u003e, respectively. \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // there are N arguments in A...\n T target(Z..., V, A[N]..., B...);\n V combiner(A...);\n T adapter(Z... z, A... a, B... b) {\n   V v \u003d combiner(a...);\n   return target(z..., v, a..., b...);\n }\n // and if the combiner has a void return:\n T target2(Z..., A[N]..., B...);\n void combiner2(A...);\n T adapter2(Z... z, A... a, B... b) {\n   combiner2(a...);\n   return target2(z..., a..., b...);\n }\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003cem\u003eNote:\u003c/em\u003e The resulting adapter is never a \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asVarargsCollector(java.lang.Class)\"\u003evariable-arity method handle\u003c/a\u003e, even if the original target method handle was.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle to invoke after arguments are combined",
          "\u003ccode\u003epos\u003c/code\u003e - the position at which to start folding and at which to insert the folding result; if this is \n\u003ccode\u003e 0\u003c/code\u003e, the effect is the same as for \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003efoldArguments(MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e.",
          "\u003ccode\u003ecombiner\u003c/code\u003e - method handle to call initially on the incoming arguments"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if either of the following two conditions holds: (1) \n\u003ccode\u003ecombiner\u003c/code\u003e\u0027s return type is non-\n\u003ccode\u003evoid\u003c/code\u003e and not the same as the argument type at position \n\u003ccode\u003epos\u003c/code\u003e of the target signature; (2) the \n\u003ccode\u003eN\u003c/code\u003e argument types at position \n\u003ccode\u003epos\u003c/code\u003e of the target signature (skipping one matching the \n\u003ccode\u003ecombiner\u003c/code\u003e\u0027s return type) are not identical with the argument types of \n\u003ccode\u003ecombiner\u003c/code\u003e."
        ],
        "return": [
          "method handle which incorporates the specified argument folding logic"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "test"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "fallback"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "guardWithTest",
      "comment": "Makes a method handle which adapts a target method handle, by guarding it with a test, a boolean-valued method handle. If the guard fails, a fallback handle is called instead. All three method handles must have the same corresponding argument and return types, except that the return type of the test must be boolean, and the test is allowed to have fewer arguments than the other two method handles. Here is pseudocode for the resulting adapter. In the code, T represents the uniform result type of the three involved handles; A/a, the types and values of the target parameters and arguments that are consumed by the test; and B/b, those types and values of the target parameters and arguments that are not consumed by the test. \n boolean test(A...);\n T target(A...,B...);\n T fallback(A...,B...);\n T adapter(A... a,B... b) {\n   if (test(a...))\n     return target(a..., b...);\n   else\n     return fallback(a..., b...);\n }\n Note that the test arguments (a... in the pseudocode) cannot be modified by execution of the test, and so are passed unchanged from the caller to the target or fallback as appropriate.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etest\u003c/code\u003e - method handle used for test, must return boolean",
          "\u003ccode\u003etarget\u003c/code\u003e - method handle to call if test passes",
          "\u003ccode\u003efallback\u003c/code\u003e - method handle to call if test fails"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etest\u003c/code\u003e does not return boolean, or if all three method types do not match (with the return type of \n\u003ccode\u003etest\u003c/code\u003e changed to match that of the target)."
        ],
        "return": [
          "method handle which incorporates the specified if/then/else logic"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "java.lang.Throwable",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "exType"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "handler"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "catchException",
      "comment": "Makes a method handle which adapts a target method handle, by running it inside an exception handler. If the target returns normally, the adapter returns that value. If an exception matching the specified type is thrown, the fallback handle is called instead on the exception, plus the original arguments. The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in guardWithTest). Also, the handler must have an extra leading parameter of exType or a supertype. Here is pseudocode for the resulting adapter. In the code, T represents the return type of the target and handler, and correspondingly that of the resulting adapter; A/a, the types and values of arguments to the resulting handle consumed by handler; and B/b, those of arguments to the resulting handle discarded by handler. \n T target(A..., B...);\n T handler(ExType, A...);\n T adapter(A... a, B... b) {\n   try {\n     return target(a..., b...);\n   } catch (ExType ex) {\n     return handler(ex, a...);\n   }\n }\n Note that the saved arguments (a... in the pseudocode) cannot be modified by execution of the target, and so are passed unchanged from the caller to the handler, if the handler is invoked. The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a finally clause). To create such a throwing handler, compose the handler creation logic with throwException, in order to create a method handle of the correct return type.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#tryFinally(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003etryFinally(MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - method handle to call",
          "\u003ccode\u003eexType\u003c/code\u003e - the type of exception which the handler will catch",
          "\u003ccode\u003ehandler\u003c/code\u003e - method handle to call if a matching exception is thrown"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ehandler\u003c/code\u003e does not accept the given exception type, or if the method handle types do not match in their return types and their corresponding parameters"
        ],
        "return": [
          "method handle which incorporates the specified try/catch logic"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "returnType"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "upperBounds": [
                  {
                    "name": "java.lang.Throwable",
                    "type": "Class"
                  }
                ],
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "exType"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "throwException",
      "comment": "Produces a method handle which will throw exceptions of the given exType. The method handle will accept a single argument of exType, and immediately throw it as an exception. The method type will nominally specify a return of returnType. The return type may be anything convenient: It doesn\u0027t matter to the method handle\u0027s behavior, since it will never return normally.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ereturnType\u003c/code\u003e - the return type of the desired method handle",
          "\u003ccode\u003eexType\u003c/code\u003e - the parameter type of the desired method handle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either argument is null"
        ],
        "return": [
          "method handle which can throw the given exceptions"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "clauses"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "loop",
      "comment": "Constructs a method handle representing a loop with several loop variables that are updated and checked upon each iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and delivers the loop\u0027s result, which is the return value of the resulting handle. Intuitively, every loop is formed by one or more \"clauses\", each specifying a local iteration variable and/or a loop exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in terms of method handles, each clause will specify up to four independent actions: init: Before the loop executes, the initialization of an iteration variable v of type V. step: When a clause executes, an update step for the iteration variable v. pred: When a clause executes, a predicate execution to test for loop exit. fini: If a clause causes a loop exit, a finalizer execution to compute the loop\u0027s return value. The full sequence of all iteration variable types, in clause order, will be notated as (V...). The values themselves will be (v...). When we speak of \"parameter lists\", we will usually be referring to types, but in some contexts (describing execution) the lists will be of actual values. Some of these clause parts may be omitted according to certain rules, and useful default behavior is provided in this case. See below for a detailed description. Parameters optional everywhere: Each clause function is allowed but not required to accept a parameter for each iteration variable v. As an exception, the init functions cannot take any v parameters, because those values are not yet computed when the init functions are executed. Any clause function may neglect to take any trailing subsequence of parameters it is entitled to take. In fact, any clause function may take no arguments at all. Loop parameters: A clause function may take all the iteration variable values it is entitled to, in which case it may also take more trailing parameters. Such extra values are called loop parameters, with their types and values notated as (A...) and (a...). These become the parameters of the resulting loop handle, to be supplied whenever the loop is executed. (Since init functions do not accept iteration variables v, any parameter to an init function is automatically a loop parameter a.) As with iteration variables, clause functions are allowed but not required to accept loop parameters. These loop parameters act as loop-invariant values visible across the whole loop. Parameters visible everywhere: Each non-init clause function is permitted to observe the entire loop state, because it can be passed the full list (v... a...) of current iteration variable values and incoming loop parameters. The init functions can observe initial pre-loop state, in the form (a...). Most clause functions will not need all of this information, but they will be formally connected to it as if by dropArguments(java.lang.invoke.MethodHandle, int, java.util.List\u003cjava.lang.Class\u003c?\u003e\u003e). More specifically, we shall use the notation (V*) to express an arbitrary prefix of a full sequence (V...) (and likewise for (v*), (A*), (a*)). In that notation, the general form of an init function parameter list is (A*), and the general form of a non-init function parameter list is (V*) or (V... A*). Checking clause structure: Given a set of clauses, there is a number of checks and adjustments performed to connect all the parts of the loop. They are spelled out in detail in the steps below. In these steps, every occurrence of the word \"must\" corresponds to a place where IllegalArgumentException will be thrown if the required constraint is not met by the inputs to the loop combinator. Effectively identical sequences: A parameter list A is defined to be effectively identical to another parameter list B if A and B are identical, or if A is shorter and is identical with a proper prefix of B. When speaking of an unordered set of parameter lists, we say they the set is \"effectively identical\" as a whole if the set contains a longest list, and all members of the set are effectively identical to that longest list. For example, any set of type sequences of the form (V*) is effectively identical, and the same is true if more sequences of the form (V... A*) are added. Step 0: Determine clause structure. The clause array (of type MethodHandle[][]) must be non-null and contain at least one element. The clause array may not contain nulls or sub-arrays longer than four elements. Clauses shorter than four elements are treated as if they were padded by null elements to length four. Padding takes place by appending elements to the array. Clauses with all nulls are disregarded. Each clause is treated as a four-tuple of functions, called \"init\", \"step\", \"pred\", and \"fini\". Step 1A: Determine iteration variable types (V...). The iteration variable type for each clause is determined using the clause\u0027s init and step return types. If both functions are omitted, there is no iteration variable for the corresponding clause (void is used as the type to indicate that). If one of them is omitted, the other\u0027s return type defines the clause\u0027s iteration variable type. If both are given, the common return type (they must be identical) defines the clause\u0027s iteration variable type. Form the list of return types (in clause order), omitting all occurrences of void. This list of types is called the \"iteration variable types\" ((V...)). Step 1B: Determine loop parameters (A...). Examine and collect init function parameter lists (which are of the form (A*)). Examine and collect the suffixes of the step, pred, and fini parameter lists, after removing the iteration variable types. (They must have the form (V... A*); collect the (A*) parts only.) Do not collect suffixes from step, pred, and fini parameter lists that do not begin with all the iteration variable types. (These types will be checked in step 2, along with all the clause function types.) Omitted clause functions are ignored. (Equivalently, they are deemed to have empty parameter lists.) All of the collected parameter lists must be effectively identical. The longest parameter list (which is necessarily unique) is called the \"external parameter list\" ((A...)). If there is no such parameter list, the external parameter list is taken to be the empty sequence. The combined list consisting of iteration variable types followed by the external parameter types is called the \"internal parameter list\". Step 1C: Determine loop return type. Examine fini function return types, disregarding omitted fini functions. If there are no fini functions, the loop return type is void. Otherwise, the common return type R of the fini functions (their return types must be identical) defines the loop return type. Step 1D: Check other types. There must be at least one non-omitted pred function. Every non-omitted pred function must have a boolean return type. Step 2: Determine parameter lists. The parameter list for the resulting loop handle will be the external parameter list (A...). The parameter list for init functions will be adjusted to the external parameter list. (Note that their parameter lists are already effectively identical to this list.) The parameter list for every non-omitted, non-init (step, pred, and fini) function must be effectively identical to the internal parameter list (V... A...). Step 3: Fill in omitted functions. If an init function is omitted, use a default value for the clause\u0027s iteration variable type. If a step function is omitted, use an identity function of the clause\u0027s iteration variable type; insert dropped argument parameters before the identity function parameter for the non-void iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.) If a pred function is omitted, use a constant true function. (This will keep the loop going, as far as this clause is concerned. Note that in such cases the corresponding fini function is unreachable.) If a fini function is omitted, use a default value for the loop return type. Step 4: Fill in missing parameter types. At this point, every init function parameter list is effectively identical to the external parameter list (A...), but some lists may be shorter. For every init function with a short parameter list, pad out the end of the list. At this point, every non-init function parameter list is effectively identical to the internal parameter list (V... A...), but some lists may be shorter. For every non-init function with a short parameter list, pad out the end of the list. Argument lists are padded out by dropping unused trailing arguments. Final observations. After these steps, all clauses have been adjusted by supplying omitted functions and arguments. All init functions have a common parameter type list (A...), which the final loop handle will also have. All fini functions have a common return type R, which the final loop handle will also have. All non-init functions have a common parameter type list (V... A...), of (non-void) iteration variables V followed by loop parameters. Each pair of init and step functions agrees in their return type V. Each non-init function will be able to observe the current values (v...) of all iteration variables. Every function will be able to observe the incoming values (a...) of all loop parameters. Example. As a consequence of step 1A above, the loop combinator has the following property: Given N clauses Cn \u003d {null, Sn, Pn} with n \u003d 1..N. Suppose predicate handles Pn are either null or have no parameters. (Only one Pn has to be non-null.) Suppose step handles Sn have signatures (B1..BX)Rn, for some constant X\u003e\u003dN. Suppose Q is the count of non-void types Rn, and (V1...VQ) is the sequence of those types. It must be that Vn \u003d\u003d Bn for n \u003d 1..min(X,Q). The parameter types Vn will be interpreted as loop-local state elements (V...). Any remaining types BQ+1..BX (if Q\u003cX) will determine the resulting loop handle\u0027s parameter types (A...). In this example, the loop handle parameters (A...) were derived from the step functions, which is natural if most of the loop computation happens in the steps. For some loops, the burden of computation might be heaviest in the pred functions, and so the pred functions might need to accept the loop parameter values. For loops with complex exit logic, the fini functions might need to accept loop parameters, and likewise for loops with complex entry logic, where the init functions will need the extra parameters. For such reasons, the rules for determining these parameters are as symmetric as possible, across all clause parts. In general, the loop parameters function as common invariant values across the whole loop, while the iteration variables function as common variant values, or (if there is no step function) as internal loop invariant temporaries. Loop execution. When the loop is called, the loop input values are saved in locals, to be passed to every clause function. These locals are loop invariant. Each init function is executed in clause order (passing the external arguments (a...)) and the non-void values are saved (as the iteration variables (v...)) into locals. These locals will be loop varying (unless their steps behave as identity functions, as noted above). All function executions (except init functions) will be passed the internal parameter list, consisting of the non-void iteration values (v...) (in clause order) and then the loop inputs (a...) (in argument order). The step and pred functions are then executed, in clause order (step before pred), until a pred function returns false. The non-void result from a step function call is used to update the corresponding value in the sequence (v...) of loop variables. The updated value is immediately visible to all subsequent function calls. If a pred function returns false, the corresponding fini function is called, and the resulting value (of type R) is returned from the loop as a whole. If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit except by throwing an exception. Usage tips. Although each step function will receive the current values of all the loop variables, sometimes a step function only needs to observe the current value of its own variable. In that case, the step function may need to explicitly drop all preceding loop variables. This will require mentioning their types, in an expression like dropArguments(step, 0, V0.class, ...). Loop variables are not required to vary; they can be loop invariant. A clause can create a loop invariant by a suitable init function with no step, pred, or fini function. This may be useful to \"wire\" an incoming loop argument into the step or pred function of an adjacent loop variable. If some of the clause functions are virtual methods on an instance, the instance itself can be conveniently placed in an initial invariant loop \"variable\", using an initial clause like new MethodHandle[]{identity(ObjType.class)}. In that case, the instance reference will be the first iteration variable value, and it will be easy to use virtual methods as clause parts, since all of them will take a leading instance reference matching that value. Here is pseudocode for the resulting loop handle. As above, V and v represent the types and values of loop variables; A and a represent arguments passed to the whole loop; and R is the common result type of all finalizers as well as of the resulting loop. \n V... init...(A...);\n boolean pred...(V..., A...);\n V... step...(V..., A...);\n R fini...(V..., A...);\n R loop(A... a) {\n   V... v... \u003d init...(a...);\n   for (;;) {\n     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {\n       v \u003d s(v..., a...);\n       if (!p(v..., a...)) {\n         return f(v..., a...);\n       }\n     }\n   }\n }\n Note that the parameter type lists (V...) and (A...) have been expanded to their full length, even though individual clause functions may neglect to take them all. As noted above, missing parameters are filled in as if by dropArgumentsToMatch(MethodHandle, int, List, int).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#whileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003ewhileLoop(MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#doWhileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003edoWhileLoop(MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003ecountedLoop(MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#iteratedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003eiteratedLoop(MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Example: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // iterative implementation of the factorial function as a loop handle\n static int one(int k) { return 1; }\n static int inc(int i, int acc, int k) { return i + 1; }\n static int mult(int i, int acc, int k) { return i * acc; }\n static boolean pred(int i, int acc, int k) { return i \u0026lt; k; }\n static int fin(int i, int acc, int k) { return acc; }\n // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods\n // null initializer for counter, should initialize to 0\n MethodHandle[] counterClause \u003d new MethodHandle[]{null, MH_inc};\n MethodHandle[] accumulatorClause \u003d new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};\n MethodHandle loop \u003d MethodHandles.loop(counterClause, accumulatorClause);\n assertEquals(120, loop.invoke(5));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e The same example, dropping arguments and using combinators: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // simplified implementation of the factorial function as a loop handle\n static int inc(int i) { return i + 1; } // drop acc, k\n static int mult(int i, int acc) { return i * acc; } //drop k\n static boolean cmp(int i, int k) { return i \u0026lt; k; }\n // assume MH_inc, MH_mult, and MH_cmp are handles to the above methods\n // null initializer for counter, should initialize to 0\n MethodHandle MH_one \u003d MethodHandles.constant(int.class, 1);\n MethodHandle MH_pred \u003d MethodHandles.dropArguments(MH_cmp, 1, int.class); // drop acc\n MethodHandle MH_fin \u003d MethodHandles.dropArguments(MethodHandles.identity(int.class), 0, int.class); // drop i\n MethodHandle[] counterClause \u003d new MethodHandle[]{null, MH_inc};\n MethodHandle[] accumulatorClause \u003d new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};\n MethodHandle loop \u003d MethodHandles.loop(counterClause, accumulatorClause);\n assertEquals(720, loop.invoke(6));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e A similar example, using a helper object to hold a loop parameter: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // instance-based implementation of the factorial function as a loop handle\n static class FacLoop {\n   final int k;\n   FacLoop(int k) { this.k \u003d k; }\n   int inc(int i) { return i + 1; }\n   int mult(int i, int acc) { return i * acc; }\n   boolean pred(int i) { return i \u0026lt; k; }\n   int fin(int i, int acc) { return acc; }\n }\n // assume MH_FacLoop is a handle to the constructor\n // assume MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods\n // null initializer for counter, should initialize to 0\n MethodHandle MH_one \u003d MethodHandles.constant(int.class, 1);\n MethodHandle[] instanceClause \u003d new MethodHandle[]{MH_FacLoop};\n MethodHandle[] counterClause \u003d new MethodHandle[]{null, MH_inc};\n MethodHandle[] accumulatorClause \u003d new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};\n MethodHandle loop \u003d MethodHandles.loop(instanceClause, counterClause, accumulatorClause);\n assertEquals(5040, loop.invoke(7));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003eclauses\u003c/code\u003e - an array of arrays (4-tuples) of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandle\u003c/code\u003e\u003c/a\u003es adhering to the rules described above."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - in case any of the constraints described above is violated."
        ],
        "return": [
          "a method handle embodying the looping behavior as defined by the arguments."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "init"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "pred"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "body"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "whileLoop",
      "comment": "Constructs a while loop from an initializer, a body, and a predicate. This is a convenience wrapper for the generic loop combinator. The pred handle describes the loop condition; and body, its body. The loop resulting from this method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate evaluates to true). The loop will terminate once the predicate evaluates to false (the body will not be executed in this case). The init handle describes the initial value of an additional optional loop-local variable. In each iteration, this loop-local variable, if present, will be passed to the body and updated with the value returned from its invocation. The result of loop execution will be the final value of the additional loop-local variable (if present). The following rules hold for these argument handles: The body handle must not be null; its type must be of the form (V A...)V, where V is non-void, or else (A...)void. (In the void case, we assign the type void to the name V, and we will write (V A...)V with the understanding that a void type V is quietly dropped from the parameter list, leaving (A...)V.) The parameter list (V A...) of the body is called the internal parameter list. It will constrain the parameter lists of the other loop parts. If the iteration variable type V is dropped from the internal parameter list, the resulting shorter list (A...) is called the external parameter list. The body return type V, if non-void, determines the type of an additional state variable of the loop. The body must both accept and return a value of this type V. If init is non-null, it must have return type V. Its parameter list (of some form (A*)) must be effectively identical to the external parameter list (A...). If init is null, the loop variable will be initialized to its default value. The pred handle must not be null. It must have boolean as its return type. Its parameter list (either empty or of the form (V A*)) must be effectively identical to the internal parameter list. The resulting loop handle\u0027s result type and parameter signature are determined as follows: The loop handle\u0027s result type is the result type V of the body. The loop handle\u0027s parameter types are the types (A...), from the external parameter list. Here is pseudocode for the resulting loop handle. In the code, V/v represent the type / value of the sole loop variable as well as the result type of the loop; and A/a, that of the argument passed to the loop. \n V init(A...);\n boolean pred(V, A...);\n V body(V, A...);\n V whileLoop(A... a...) {\n   V v \u003d init(a...);\n   while (pred(v, a...)) {\n     v \u003d body(v, a...);\n   }\n   return v;\n }",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#loop(java.lang.invoke.MethodHandle%5B%5D...)\"\u003e\u003ccode\u003eloop(MethodHandle[][])\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#doWhileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003edoWhileLoop(MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Example: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // implement the zip function for lists as a loop handle\n static List\u0026lt;String\u0026gt; initZip(Iterator\u0026lt;String\u0026gt; a, Iterator\u0026lt;String\u0026gt; b) { return new ArrayList\u0026lt;\u0026gt;(); }\n static boolean zipPred(List\u0026lt;String\u0026gt; zip, Iterator\u0026lt;String\u0026gt; a, Iterator\u0026lt;String\u0026gt; b) { return a.hasNext() \u0026amp;\u0026amp; b.hasNext(); }\n static List\u0026lt;String\u0026gt; zipStep(List\u0026lt;String\u0026gt; zip, Iterator\u0026lt;String\u0026gt; a, Iterator\u0026lt;String\u0026gt; b) {\n   zip.add(a.next());\n   zip.add(b.next());\n   return zip;\n }\n // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods\n MethodHandle loop \u003d MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);\n List\u0026lt;String\u0026gt; a \u003d Arrays.asList(\"a\", \"b\", \"c\", \"d\");\n List\u0026lt;String\u0026gt; b \u003d Arrays.asList(\"e\", \"f\", \"g\", \"h\");\n List\u0026lt;String\u0026gt; zipped \u003d Arrays.asList(\"a\", \"e\", \"b\", \"f\", \"c\", \"g\", \"d\", \"h\");\n assertEquals(zipped, (List\u0026lt;String\u0026gt;) loop.invoke(a.iterator(), b.iterator()));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e, The implementation of this method can be expressed as follows: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {\n     MethodHandle fini \u003d (body.type().returnType() \u003d\u003d void.class\n                         ? null : identity(body.type().returnType()));\n     MethodHandle[]\n         checkExit \u003d { null, null, pred, fini },\n         varBody   \u003d { init, body };\n     return loop(checkExit, varBody);\n }\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003einit\u003c/code\u003e - optional initializer, providing the initial value of the loop variable. May be \n\u003ccode\u003enull\u003c/code\u003e, implying a default initial value. See above for other constraints.",
          "\u003ccode\u003epred\u003c/code\u003e - condition for the loop, which may not be \n\u003ccode\u003enull\u003c/code\u003e. Its result type must be \n\u003ccode\u003eboolean\u003c/code\u003e. See above for other constraints.",
          "\u003ccode\u003ebody\u003c/code\u003e - body of the loop, which may not be \n\u003ccode\u003enull\u003c/code\u003e. It controls the loop parameters and result type. See above for other constraints."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the rules for the arguments are violated.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epred\u003c/code\u003e or \n\u003ccode\u003ebody\u003c/code\u003e are \n\u003ccode\u003enull\u003c/code\u003e."
        ],
        "return": [
          "a method handle implementing the \n\u003ccode\u003ewhile\u003c/code\u003e loop as described by the arguments."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "init"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "body"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "pred"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "doWhileLoop",
      "comment": "Constructs a do-while loop from an initializer, a body, and a predicate. This is a convenience wrapper for the generic loop combinator. The pred handle describes the loop condition; and body, its body. The loop resulting from this method will, in each iteration, first execute its body and then evaluate the predicate. The loop will terminate once the predicate evaluates to false after an execution of the body. The init handle describes the initial value of an additional optional loop-local variable. In each iteration, this loop-local variable, if present, will be passed to the body and updated with the value returned from its invocation. The result of loop execution will be the final value of the additional loop-local variable (if present). The following rules hold for these argument handles: The body handle must not be null; its type must be of the form (V A...)V, where V is non-void, or else (A...)void. (In the void case, we assign the type void to the name V, and we will write (V A...)V with the understanding that a void type V is quietly dropped from the parameter list, leaving (A...)V.) The parameter list (V A...) of the body is called the internal parameter list. It will constrain the parameter lists of the other loop parts. If the iteration variable type V is dropped from the internal parameter list, the resulting shorter list (A...) is called the external parameter list. The body return type V, if non-void, determines the type of an additional state variable of the loop. The body must both accept and return a value of this type V. If init is non-null, it must have return type V. Its parameter list (of some form (A*)) must be effectively identical to the external parameter list (A...). If init is null, the loop variable will be initialized to its default value. The pred handle must not be null. It must have boolean as its return type. Its parameter list (either empty or of the form (V A*)) must be effectively identical to the internal parameter list. The resulting loop handle\u0027s result type and parameter signature are determined as follows: The loop handle\u0027s result type is the result type V of the body. The loop handle\u0027s parameter types are the types (A...), from the external parameter list. Here is pseudocode for the resulting loop handle. In the code, V/v represent the type / value of the sole loop variable as well as the result type of the loop; and A/a, that of the argument passed to the loop. \n V init(A...);\n boolean pred(V, A...);\n V body(V, A...);\n V doWhileLoop(A... a...) {\n   V v \u003d init(a...);\n   do {\n     v \u003d body(v, a...);\n   } while (pred(v, a...));\n   return v;\n }",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#loop(java.lang.invoke.MethodHandle%5B%5D...)\"\u003e\u003ccode\u003eloop(MethodHandle[][])\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#whileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003ewhileLoop(MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Example: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // int i \u003d 0; while (i \u0026lt; limit) { ++i; } return i; \u003d\u0026gt; limit\n static int zero(int limit) { return 0; }\n static int step(int i, int limit) { return i + 1; }\n static boolean pred(int i, int limit) { return i \u0026lt; limit; }\n // assume MH_zero, MH_step, and MH_pred are handles to the above methods\n MethodHandle loop \u003d MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);\n assertEquals(23, loop.invoke(23));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e, The implementation of this method can be expressed as follows: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {\n     MethodHandle fini \u003d (body.type().returnType() \u003d\u003d void.class\n                         ? null : identity(body.type().returnType()));\n     MethodHandle[] clause \u003d { init, body, pred, fini };\n     return loop(clause);\n }\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003einit\u003c/code\u003e - optional initializer, providing the initial value of the loop variable. May be \n\u003ccode\u003enull\u003c/code\u003e, implying a default initial value. See above for other constraints.",
          "\u003ccode\u003ebody\u003c/code\u003e - body of the loop, which may not be \n\u003ccode\u003enull\u003c/code\u003e. It controls the loop parameters and result type. See above for other constraints.",
          "\u003ccode\u003epred\u003c/code\u003e - condition for the loop, which may not be \n\u003ccode\u003enull\u003c/code\u003e. Its result type must be \n\u003ccode\u003eboolean\u003c/code\u003e. See above for other constraints."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the rules for the arguments are violated.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003epred\u003c/code\u003e or \n\u003ccode\u003ebody\u003c/code\u003e are \n\u003ccode\u003enull\u003c/code\u003e."
        ],
        "return": [
          "a method handle implementing the \n\u003ccode\u003ewhile\u003c/code\u003e loop as described by the arguments."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "iterations"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "init"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "body"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "countedLoop",
      "comment": "Constructs a loop that runs a given number of iterations. This is a convenience wrapper for the generic loop combinator. The number of iterations is determined by the iterations handle evaluation result. The loop counter i is an extra loop iteration variable of type int. It will be initialized to 0 and incremented by 1 in each iteration. If the body handle returns a non-void type V, a leading loop iteration variable of that type is also present. This variable is initialized using the optional init handle, or to the default value of type V if that handle is null. In each iteration, the iteration variables are passed to an invocation of the body handle. A non-void value returned from the body (of type V) updates the leading iteration variable. The result of the loop handle execution will be the final V value of that variable (or void if there is no V variable). The following rules hold for the argument handles: The iterations handle must not be null, and must return the type int, referred to here as I in parameter type lists. The body handle must not be null; its type must be of the form (V I A...)V, where V is non-void, or else (I A...)void. (In the void case, we assign the type void to the name V, and we will write (V I A...)V with the understanding that a void type V is quietly dropped from the parameter list, leaving (I A...)V.) The parameter list (V I A...) of the body contributes to a list of types called the internal parameter list. It will constrain the parameter lists of the other loop parts. As a special case, if the body contributes only V and I types, with no additional A types, then the internal parameter list is extended by the argument types A... of the iterations handle. If the iteration variable types (V I) are dropped from the internal parameter list, the resulting shorter list (A...) is called the external parameter list. The body return type V, if non-void, determines the type of an additional state variable of the loop. The body must both accept a leading parameter and return a value of this type V. If init is non-null, it must have return type V. Its parameter list (of some form (A*)) must be effectively identical to the external parameter list (A...). If init is null, the loop variable will be initialized to its default value. The parameter list of iterations (of some form (A*)) must be effectively identical to the external parameter list (A...). The resulting loop handle\u0027s result type and parameter signature are determined as follows: The loop handle\u0027s result type is the result type V of the body. The loop handle\u0027s parameter types are the types (A...), from the external parameter list. Here is pseudocode for the resulting loop handle. In the code, V/v represent the type / value of the second loop variable as well as the result type of the loop; and A.../a... represent arguments passed to the loop. \n int iterations(A...);\n V init(A...);\n V body(V, int, A...);\n V countedLoop(A... a...) {\n   int end \u003d iterations(a...);\n   V v \u003d init(a...);\n   for (int i \u003d 0; i \u003c end; ++i) {\n     v \u003d body(v, i, a...);\n   }\n   return v;\n }",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003ecountedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Example with a fully conformant body method: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // String s \u003d \"Lambdaman!\"; for (int i \u003d 0; i \u0026lt; 13; ++i) { s \u003d \"na \" + s; } return s;\n // \u003d\u0026gt; a variation on a well known theme\n static String step(String v, int counter, String init) { return \"na \" + v; }\n // assume MH_step is a handle to the method above\n MethodHandle fit13 \u003d MethodHandles.constant(int.class, 13);\n MethodHandle start \u003d MethodHandles.identity(String.class);\n MethodHandle loop \u003d MethodHandles.countedLoop(fit13, start, MH_step);\n assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(\"Lambdaman!\"));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e, Example with the simplest possible body method type, and passing the number of iterations to the loop invocation: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // String s \u003d \"Lambdaman!\"; for (int i \u003d 0; i \u0026lt; 13; ++i) { s \u003d \"na \" + s; } return s;\n // \u003d\u0026gt; a variation on a well known theme\n static String step(String v, int counter ) { return \"na \" + v; }\n // assume MH_step is a handle to the method above\n MethodHandle count \u003d MethodHandles.dropArguments(MethodHandles.identity(int.class), 1, String.class);\n MethodHandle start \u003d MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class);\n MethodHandle loop \u003d MethodHandles.countedLoop(count, start, MH_step);  // (v, i) -\u0026gt; \"na \" + v\n assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(13, \"Lambdaman!\"));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e, Example that treats the number of iterations, string to append to, and string to append as loop parameters: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // String s \u003d \"Lambdaman!\", t \u003d \"na\"; for (int i \u003d 0; i \u0026lt; 13; ++i) { s \u003d t + \" \" + s; } return s;\n // \u003d\u0026gt; a variation on a well known theme\n static String step(String v, int counter, int iterations_, String pre, String start_) { return pre + \" \" + v; }\n // assume MH_step is a handle to the method above\n MethodHandle count \u003d MethodHandles.identity(int.class);\n MethodHandle start \u003d MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class, String.class);\n MethodHandle loop \u003d MethodHandles.countedLoop(count, start, MH_step);  // (v, i, _, pre, _) -\u0026gt; pre + \" \" + v\n assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(13, \"na\", \"Lambdaman!\"));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e, Example that illustrates the usage of \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)\"\u003e\u003ccode\u003edropArgumentsToMatch(MethodHandle, int, List, int)\u003c/code\u003e\u003c/a\u003e to enforce a loop type: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // String s \u003d \"Lambdaman!\", t \u003d \"na\"; for (int i \u003d 0; i \u0026lt; 13; ++i) { s \u003d t + \" \" + s; } return s;\n // \u003d\u0026gt; a variation on a well known theme\n static String step(String v, int counter, String pre) { return pre + \" \" + v; }\n // assume MH_step is a handle to the method above\n MethodType loopType \u003d methodType(String.class, String.class, int.class, String.class);\n MethodHandle count \u003d MethodHandles.dropArgumentsToMatch(MethodHandles.identity(int.class),    0, loopType.parameterList(), 1);\n MethodHandle start \u003d MethodHandles.dropArgumentsToMatch(MethodHandles.identity(String.class), 0, loopType.parameterList(), 2);\n MethodHandle body  \u003d MethodHandles.dropArgumentsToMatch(MH_step,                              2, loopType.parameterList(), 0);\n MethodHandle loop \u003d MethodHandles.countedLoop(count, start, body);  // (v, i, pre, _, _) -\u0026gt; pre + \" \" + v\n assertEquals(\"na na na na na na na na na na na na na Lambdaman!\", loop.invoke(\"na\", 13, \"Lambdaman!\"));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e, The implementation of this method can be expressed as follows: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {\n     return countedLoop(empty(iterations.type()), iterations, init, body);\n }\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003eiterations\u003c/code\u003e - a non-\n\u003ccode\u003enull\u003c/code\u003e handle to return the number of iterations this loop should run. The handle\u0027s result type must be \n\u003ccode\u003eint\u003c/code\u003e. See above for other constraints.",
          "\u003ccode\u003einit\u003c/code\u003e - optional initializer, providing the initial value of the loop variable. May be \n\u003ccode\u003enull\u003c/code\u003e, implying a default initial value. See above for other constraints.",
          "\u003ccode\u003ebody\u003c/code\u003e - body of the loop, which may not be \n\u003ccode\u003enull\u003c/code\u003e. It controls the loop parameters and result type in the standard case (see above for details). It must accept its own return type (if non-void) plus an \n\u003ccode\u003eint\u003c/code\u003e parameter (for the counter), and may accept any number of additional types. See above for other constraints."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either of the \n\u003ccode\u003eiterations\u003c/code\u003e or \n\u003ccode\u003ebody\u003c/code\u003e handles is \n\u003ccode\u003enull\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any argument violates the rules formulated above."
        ],
        "return": [
          "a method handle representing the loop."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "start"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "end"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "init"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "body"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "countedLoop",
      "comment": "Constructs a loop that counts over a range of numbers. This is a convenience wrapper for the generic loop combinator. The loop counter i is a loop iteration variable of type int. The start and end handles determine the start (inclusive) and end (exclusive) values of the loop counter. The loop counter will be initialized to the int value returned from the evaluation of the start handle and run to the value returned from end (exclusively) with a step width of 1. If the body handle returns a non-void type V, a leading loop iteration variable of that type is also present. This variable is initialized using the optional init handle, or to the default value of type V if that handle is null. In each iteration, the iteration variables are passed to an invocation of the body handle. A non-void value returned from the body (of type V) updates the leading iteration variable. The result of the loop handle execution will be the final V value of that variable (or void if there is no V variable). The following rules hold for the argument handles: The start and end handles must not be null, and must both return the common type int, referred to here as I in parameter type lists. The body handle must not be null; its type must be of the form (V I A...)V, where V is non-void, or else (I A...)void. (In the void case, we assign the type void to the name V, and we will write (V I A...)V with the understanding that a void type V is quietly dropped from the parameter list, leaving (I A...)V.) The parameter list (V I A...) of the body contributes to a list of types called the internal parameter list. It will constrain the parameter lists of the other loop parts. As a special case, if the body contributes only V and I types, with no additional A types, then the internal parameter list is extended by the argument types A... of the end handle. If the iteration variable types (V I) are dropped from the internal parameter list, the resulting shorter list (A...) is called the external parameter list. The body return type V, if non-void, determines the type of an additional state variable of the loop. The body must both accept a leading parameter and return a value of this type V. If init is non-null, it must have return type V. Its parameter list (of some form (A*)) must be effectively identical to the external parameter list (A...). If init is null, the loop variable will be initialized to its default value. The parameter list of start (of some form (A*)) must be effectively identical to the external parameter list (A...). Likewise, the parameter list of end must be effectively identical to the external parameter list. The resulting loop handle\u0027s result type and parameter signature are determined as follows: The loop handle\u0027s result type is the result type V of the body. The loop handle\u0027s parameter types are the types (A...), from the external parameter list. Here is pseudocode for the resulting loop handle. In the code, V/v represent the type / value of the second loop variable as well as the result type of the loop; and A.../a... represent arguments passed to the loop. \n int start(A...);\n int end(A...);\n V init(A...);\n V body(V, int, A...);\n V countedLoop(A... a...) {\n   int e \u003d end(a...);\n   int s \u003d start(a...);\n   V v \u003d init(a...);\n   for (int i \u003d s; i \u003c e; ++i) {\n     v \u003d body(v, i, a...);\n   }\n   return v;\n }",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003ecountedLoop(MethodHandle, MethodHandle, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "The implementation of this method can be expressed as follows: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {\n     MethodHandle returnVar \u003d dropArguments(identity(init.type().returnType()), 0, int.class, int.class);\n     // assume MH_increment and MH_predicate are handles to implementation-internal methods with\n     // the following semantics:\n     // MH_increment: (int limit, int counter) -\u0026gt; counter + 1\n     // MH_predicate: (int limit, int counter) -\u0026gt; counter \u0026lt; limit\n     Class\u0026lt;?\u0026gt; counterType \u003d start.type().returnType();  // int\n     Class\u0026lt;?\u0026gt; returnType \u003d body.type().returnType();\n     MethodHandle incr \u003d MH_increment, pred \u003d MH_predicate, retv \u003d null;\n     if (returnType !\u003d void.class) {  // ignore the V variable\n         incr \u003d dropArguments(incr, 1, returnType);  // (limit, v, i) \u003d\u0026gt; (limit, i)\n         pred \u003d dropArguments(pred, 1, returnType);  // ditto\n         retv \u003d dropArguments(identity(returnType), 0, counterType); // ignore limit\n     }\n     body \u003d dropArguments(body, 0, counterType);  // ignore the limit variable\n     MethodHandle[]\n         loopLimit  \u003d { end, null, pred, retv }, // limit \u003d end(); i \u0026lt; limit || return v\n         bodyClause \u003d { init, body },            // v \u003d init(); v \u003d body(v, i)\n         indexVar   \u003d { start, incr };           // i \u003d start(); i \u003d i + 1\n     return loop(loopLimit, bodyClause, indexVar);\n }\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003estart\u003c/code\u003e - a non-\n\u003ccode\u003enull\u003c/code\u003e handle to return the start value of the loop counter, which must be \n\u003ccode\u003eint\u003c/code\u003e. See above for other constraints.",
          "\u003ccode\u003eend\u003c/code\u003e - a non-\n\u003ccode\u003enull\u003c/code\u003e handle to return the end value of the loop counter (the loop will run to \n\u003ccode\u003eend-1\u003c/code\u003e). The result type must be \n\u003ccode\u003eint\u003c/code\u003e. See above for other constraints.",
          "\u003ccode\u003einit\u003c/code\u003e - optional initializer, providing the initial value of the loop variable. May be \n\u003ccode\u003enull\u003c/code\u003e, implying a default initial value. See above for other constraints.",
          "\u003ccode\u003ebody\u003c/code\u003e - body of the loop, which may not be \n\u003ccode\u003enull\u003c/code\u003e. It controls the loop parameters and result type in the standard case (see above for details). It must accept its own return type (if non-void) plus an \n\u003ccode\u003eint\u003c/code\u003e parameter (for the counter), and may accept any number of additional types. See above for other constraints."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any of the \n\u003ccode\u003estart\u003c/code\u003e, \n\u003ccode\u003eend\u003c/code\u003e, or \n\u003ccode\u003ebody\u003c/code\u003e handles is \n\u003ccode\u003enull\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any argument violates the rules formulated above."
        ],
        "return": [
          "a method handle representing the loop."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "iterator"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "init"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "body"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "iteratedLoop",
      "comment": "Constructs a loop that ranges over the values produced by an Iterator\u003cT\u003e. This is a convenience wrapper for the generic loop combinator. The iterator itself will be determined by the evaluation of the iterator handle. Each value it produces will be stored in a loop iteration variable of type T. If the body handle returns a non-void type V, a leading loop iteration variable of that type is also present. This variable is initialized using the optional init handle, or to the default value of type V if that handle is null. In each iteration, the iteration variables are passed to an invocation of the body handle. A non-void value returned from the body (of type V) updates the leading iteration variable. The result of the loop handle execution will be the final V value of that variable (or void if there is no V variable). The following rules hold for the argument handles: The body handle must not be null; its type must be of the form (V T A...)V, where V is non-void, or else (T A...)void. (In the void case, we assign the type void to the name V, and we will write (V T A...)V with the understanding that a void type V is quietly dropped from the parameter list, leaving (T A...)V.) The parameter list (V T A...) of the body contributes to a list of types called the internal parameter list. It will constrain the parameter lists of the other loop parts. As a special case, if the body contributes only V and T types, with no additional A types, then the internal parameter list is extended by the argument types A... of the iterator handle; if it is null the single type Iterable is added and constitutes the A... list. If the iteration variable types (V T) are dropped from the internal parameter list, the resulting shorter list (A...) is called the external parameter list. The body return type V, if non-void, determines the type of an additional state variable of the loop. The body must both accept a leading parameter and return a value of this type V. If init is non-null, it must have return type V. Its parameter list (of some form (A*)) must be effectively identical to the external parameter list (A...). If init is null, the loop variable will be initialized to its default value. If the iterator handle is non-null, it must have the return type java.util.Iterator or a subtype thereof. The iterator it produces when the loop is executed will be assumed to yield values which can be converted to type T. The parameter list of an iterator that is non-null (of some form (A*)) must be effectively identical to the external parameter list (A...). If iterator is null it defaults to a method handle which behaves like Iterable.iterator(). In that case, the internal parameter list (V T A...) must have at least one A type, and the default iterator handle parameter is adjusted to accept the leading A type, as if by the asType conversion method. The leading A type must be Iterable or a subtype thereof. This conversion step, done at loop construction time, must not throw a WrongMethodTypeException. The type T may be either a primitive or reference. Since type Iterator\u003cT\u003e is erased in the method handle representation to the raw type Iterator, the iteratedLoop combinator adjusts the leading argument type for body to Object as if by the asType conversion method. Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur as the result of dynamic conversions performed by MethodHandle.asType(MethodType). The resulting loop handle\u0027s result type and parameter signature are determined as follows: The loop handle\u0027s result type is the result type V of the body. The loop handle\u0027s parameter types are the types (A...), from the external parameter list. Here is pseudocode for the resulting loop handle. In the code, V/v represent the type / value of the loop variable as well as the result type of the loop; T/t, that of the elements of the structure the loop iterates over, and A.../a... represent arguments passed to the loop. \n Iterator\u003cT\u003e iterator(A...);  // defaults to Iterable::iterator\n V init(A...);\n V body(V,T,A...);\n V iteratedLoop(A... a...) {\n   Iterator\u003cT\u003e it \u003d iterator(a...);\n   V v \u003d init(a...);\n   while (it.hasNext()) {\n     T t \u003d it.next();\n     v \u003d body(v, t, a...);\n   }\n   return v;\n }",
      "tagMap": {
        "apiNote": [
          "Example: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // get an iterator from a list\n static List\u0026lt;String\u0026gt; reverseStep(List\u0026lt;String\u0026gt; r, String e) {\n   r.add(0, e);\n   return r;\n }\n static List\u0026lt;String\u0026gt; newArrayList() { return new ArrayList\u0026lt;\u0026gt;(); }\n // assume MH_reverseStep and MH_newArrayList are handles to the above methods\n MethodHandle loop \u003d MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);\n List\u0026lt;String\u0026gt; list \u003d Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\n List\u0026lt;String\u0026gt; reversedList \u003d Arrays.asList(\"e\", \"d\", \"c\", \"b\", \"a\");\n assertEquals(reversedList, (List\u0026lt;String\u0026gt;) loop.invoke(list));\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e, The implementation of this method can be expressed approximately as follows: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {\n     // assume MH_next, MH_hasNext, MH_startIter are handles to methods of Iterator/Iterable\n     Class\u0026lt;?\u0026gt; returnType \u003d body.type().returnType();\n     Class\u0026lt;?\u0026gt; ttype \u003d body.type().parameterType(returnType \u003d\u003d void.class ? 0 : 1);\n     MethodHandle nextVal \u003d MH_next.asType(MH_next.type().changeReturnType(ttype));\n     MethodHandle retv \u003d null, step \u003d body, startIter \u003d iterator;\n     if (returnType !\u003d void.class) {\n         // the simple thing first:  in (I V A...), drop the I to get V\n         retv \u003d dropArguments(identity(returnType), 0, Iterator.class);\n         // body type signature (V T A...), internal loop types (I V A...)\n         step \u003d swapArguments(body, 0, 1);  // swap V \u0026lt;-\u0026gt; T\n     }\n     if (startIter \u003d\u003d null)  startIter \u003d MH_getIter;\n     MethodHandle[]\n         iterVar    \u003d { startIter, null, MH_hasNext, retv }, // it \u003d iterator; while (it.hasNext())\n         bodyClause \u003d { init, filterArguments(step, 0, nextVal) };  // v \u003d body(v, t, a)\n     return loop(iterVar, bodyClause);\n }\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003eiterator\u003c/code\u003e - an optional handle to return the iterator to start the loop. If non-\n\u003ccode\u003enull\u003c/code\u003e, the handle must return \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Iterator.html\" title\u003d\"interface in java.util\"\u003e\u003ccode\u003eIterator\u003c/code\u003e\u003c/a\u003e or a subtype. See above for other constraints.",
          "\u003ccode\u003einit\u003c/code\u003e - optional initializer, providing the initial value of the loop variable. May be \n\u003ccode\u003enull\u003c/code\u003e, implying a default initial value. See above for other constraints.",
          "\u003ccode\u003ebody\u003c/code\u003e - body of the loop, which may not be \n\u003ccode\u003enull\u003c/code\u003e. It controls the loop parameters and result type in the standard case (see above for details). It must accept its own return type (if non-void) plus a \n\u003ccode\u003eT\u003c/code\u003e parameter (for the iterated values), and may accept any number of additional types. See above for other constraints."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003ebody\u003c/code\u003e handle is \n\u003ccode\u003enull\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if any argument violates the above requirements."
        ],
        "return": [
          "a method handle embodying the iteration loop functionality."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        },
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "cleanup"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "tryFinally",
      "comment": "Makes a method handle that adapts a target method handle by wrapping it in a try-finally block. Another method handle, cleanup, represents the functionality of the finally block. Any exception thrown during the execution of the target handle will be passed to the cleanup handle. The exception will be rethrown, unless cleanup handle throws an exception first. The value returned from the cleanup handle\u0027s execution will be the result of the execution of the try-finally handle. The cleanup handle will be passed one or two additional leading arguments. The first is the exception thrown during the execution of the target handle, or null if no exception was thrown. The second is the result of the execution of the target handle, or, if it throws an exception, a null, zero, or false value of the required type is supplied as a placeholder. The second argument is not present if the target handle has a void return type. (Note that, except for argument type conversions, combinators represent void values in parameter lists by omitting the corresponding paradoxical arguments, not by inserting null or zero values.) The target and cleanup handles must have the same corresponding argument and return types, except that the cleanup handle may omit trailing arguments. Also, the cleanup handle must have one or two extra leading parameters: a Throwable, which will carry the exception thrown by the target handle (if any); and a parameter of the same type as the return type of both target and cleanup, which will carry the result from the execution of the target handle. This parameter is not present if the target returns void. The pseudocode for the resulting adapter looks as follows. In the code, V represents the result type of the try/finally construct; A/a, the types and values of arguments to the resulting handle consumed by the cleanup; and B/b, those of arguments to the resulting handle discarded by the cleanup. \n V target(A..., B...);\n V cleanup(Throwable, V, A...);\n V adapter(A... a, B... b) {\n   V result \u003d (zero value for V);\n   Throwable throwable \u003d null;\n   try {\n     result \u003d target(a..., b...);\n   } catch (Throwable t) {\n     throwable \u003d t;\n     throw t;\n   } finally {\n     result \u003d cleanup(throwable, result, a...);\n   }\n   return result;\n }\n Note that the saved arguments (a... in the pseudocode) cannot be modified by execution of the target, and so are passed unchanged from the caller to the cleanup, if it is invoked. The target and cleanup must return the same type, even if the cleanup always throws. To create such a throwing cleanup, compose the cleanup logic with throwException, in order to create a method handle of the correct return type. Note that tryFinally never converts exceptions into normal returns. In rare cases where exceptions must be converted in that way, first wrap the target with catchException(MethodHandle, Class, MethodHandle) to capture an outgoing exception, and then wrap with tryFinally. It is recommended that the first parameter type of cleanup be declared Throwable rather than a narrower subtype. This ensures cleanup will always be invoked with whatever exception that target throws. Declaring a narrower type may result in a ClassCastException being thrown by the try-finally handle if the type of the exception thrown by target is not assignable to the first parameter type of cleanup. Note that various exception types of VirtualMachineError, LinkageError, and RuntimeException can in principle be thrown by almost any kind of Java code, and a finally clause that catches (say) only IOException would mask any of the others behind a ClassCastException.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003ecatchException(MethodHandle, Class, MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the handle whose execution is to be wrapped in a \n\u003ccode\u003etry\u003c/code\u003e block.",
          "\u003ccode\u003ecleanup\u003c/code\u003e - the handle that is invoked in the finally block."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if any argument is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ecleanup\u003c/code\u003e does not accept the required leading arguments, or if the method handle types do not match in their return types and their corresponding trailing parameters"
        ],
        "return": [
          "a method handle embodying the \n\u003ccode\u003etry-finally\u003c/code\u003e block composed of the two arguments."
        ],
        "since": [
          "9"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.lang.invoke.MethodHandles$Lookup"
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.lang.invoke.MethodHandles",
  "comment": "This class consists exclusively of static methods that operate on or return method handles. They fall into several categories: \n\u003cul\u003e \n \u003cli\u003eLookup methods which help create method handles for methods and fields. \u003c/li\u003e\n \u003cli\u003eCombinator methods, which combine or transform pre-existing method handles into new ones. \u003c/li\u003e\n \u003cli\u003eOther factory methods to create method handles that emulate other common JVM operations or control flow patterns. \u003c/li\u003e\n\u003c/ul\u003e A lookup, combinator, or factory method will fail and throw an \n\u003ccode\u003eIllegalArgumentException\u003c/code\u003e if the created method handle\u0027s type would have \n\u003ca href\u003d\"MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e.",
  "tagMap": {
    "since": [
      "1.7"
    ]
  }
}