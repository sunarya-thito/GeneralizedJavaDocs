{
  "packageName": "java.lang.invoke",
  "simpleName": "MethodHandle",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.invoke.MethodType",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "type",
      "comment": "Reports the type of this method handle. Every invocation of this method handle via invokeExact must exactly match this type.",
      "tagMap": {
        "return": [
          "the method handle type"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.Throwable",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "invokeExact",
      "comment": "Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match. The symbolic type descriptor at the call site of invokeExact must exactly match this method handle\u0027s type. No conversions are allowed on arguments or return values. When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via java.lang.reflect.Method.invoke, via JNI, or indirectly via Lookup.unreflect, it will throw an UnsupportedOperationException.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list, statically represented using varargs"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the target\u0027s type is not identical with the caller\u0027s symbolic type descriptor",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Throwable.html\" title\u003d\"class in java.lang\"\u003eThrowable\u003c/a\u003e\u003c/code\u003e - anything thrown by the underlying method propagates unchanged through the method handle call"
        ],
        "return": [
          "the signature-polymorphic result, statically represented using \n\u003ccode\u003eObject\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.Throwable",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "args"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "invoke",
      "comment": "Invokes the method handle, allowing any caller type descriptor, and optionally performing conversions on arguments and return values. If the call site\u0027s symbolic type descriptor exactly matches this method handle\u0027s type, the call proceeds as if by invokeExact. Otherwise, the call proceeds as if this method handle were first adjusted by calling asType to adjust this method handle to the required type, and then the call proceeds as if by invokeExact on the adjusted method handle. There is no guarantee that the asType call is actually made. If the JVM can predict the results of making the call, it may perform adaptations directly on the caller\u0027s arguments, and call the target method handle according to its own exact type. The resolved type descriptor at the call site of invoke must be a valid argument to the receivers asType method. In particular, the caller must specify the same argument arity as the callee\u0027s type, if the callee is not a variable arity collector. When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via java.lang.reflect.Method.invoke, via JNI, or indirectly via Lookup.unreflect, it will throw an UnsupportedOperationException.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eargs\u003c/code\u003e - the signature-polymorphic parameter list, statically represented using varargs"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the target\u0027s type cannot be adjusted to the caller\u0027s symbolic type descriptor",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if the target\u0027s type can be adjusted to the caller, but a reference cast fails",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Throwable.html\" title\u003d\"class in java.lang\"\u003eThrowable\u003c/a\u003e\u003c/code\u003e - anything thrown by the underlying method propagates unchanged through the method handle call"
        ],
        "return": [
          "the signature-polymorphic result, statically represented using \n\u003ccode\u003eObject\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.Throwable",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "arguments"
          },
          "varArgs": {}
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "invokeWithArguments",
      "comment": "Performs a variable arity invocation, passing the arguments in the given array to the method handle, as if via an inexact invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument array. Specifically, execution proceeds as if by the following steps, although the methods are not guaranteed to be called if the JVM can predict their effects. Determine the length of the argument array as N. For a null reference, N\u003d0. Collect the N elements of the array as a logical argument list, each argument statically typed as an Object. Determine, as M, the parameter count of the type of this method handle. Determine the general type TN of N arguments or M arguments, if smaller than N, as TN\u003dMethodType.genericMethodType(Math.min(N, M)). If N is greater than M, perform the following checks and actions to shorten the logical argument list: Check that this method handle has variable arity with a trailing parameter of some array type A[]. If not, fail with a WrongMethodTypeException. Collect the trailing elements (there are N-M+1 of them) from the logical argument list into a single array of type A[], using asType conversions to convert each trailing argument to type A. If any of these conversions proves impossible, fail with either a ClassCastException if any trailing element cannot be cast to A or a NullPointerException if any trailing element is null and A is not a reference type. Replace the logical arguments gathered into the array of type A[] with the array itself, thus shortening the argument list to length M. This final argument retains the static type A[]. Adjust the type TN by changing the Nth parameter type from Object to A[]. Force the original target method handle MH0 to the required type, as MH1 \u003d MH0.asType(TN). Spread the argument list into N separate arguments A0, .... Invoke the type-adjusted method handle on the unpacked arguments: MH1.invokeExact(A0, ...). Take the return value as an Object reference. If the target method handle has variable arity, and the argument list is longer than that arity, the excess arguments, starting at the position of the trailing array argument, will be gathered (if possible, as if by asType conversions) into an array of the appropriate type, and invocation will proceed on the shortened argument list. In this way, jumbo argument lists which would spread into more than 254 slots can still be processed uniformly. Unlike the generic invocation mode, which can \"recycle\" an array argument, passing it directly to the target method, this invocation mode always creates a new array parameter, even if the original array passed to invokeWithArguments would have been acceptable as a direct argument to the target method. Even if the number M of actual arguments is the arity N, and the last argument is dynamically a suitable array of type A[], it will still be boxed into a new one-element array, since the call site statically types the argument as Object, not an array type. This is not a special rule for this method, but rather a regular effect of the rules for variable-arity invocation. Because of the action of the asType step, the following argument conversions are applied as necessary: reference casting unboxing widening primitive conversions variable arity conversion The result returned by the call is boxed if it is a primitive, or forced to null if the return type is void. Unlike the signature polymorphic methods invokeExact and invoke, invokeWithArguments can be accessed normally via the Core Reflection API and JNI. It can therefore be used as a bridge between native or reflective code and method handles.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#spreadInvoker(java.lang.invoke.MethodType,int)\"\u003e\u003ccode\u003eMethodHandles.spreadInvoker(java.lang.invoke.MethodType, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "This call is approximately equivalent to the following code: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n // for jumbo argument lists, adapt varargs explicitly:\n int N \u003d (arguments \u003d\u003d null? 0: arguments.length);\n int M \u003d this.type.parameterCount();\n int MAX_SAFE \u003d 127;  // 127 longs require 254 slots, which is OK\n if (N \u0026gt; MAX_SAFE \u0026amp;\u0026amp; N \u0026gt; M \u0026amp;\u0026amp; this.isVarargsCollector()) {\n   Class\u0026lt;?\u0026gt; arrayType \u003d this.type().lastParameterType();\n   Class\u0026lt;?\u0026gt; elemType \u003d arrayType.getComponentType();\n   if (elemType !\u003d null) {\n     Object args2 \u003d Array.newInstance(elemType, M);\n     MethodHandle arraySetter \u003d MethodHandles.arrayElementSetter(arrayType);\n     for (int i \u003d 0; i \u0026lt; M; i++) {\n       arraySetter.invoke(args2, i, arguments[M-1 + i]);\n     }\n     arguments \u003d Arrays.copyOf(arguments, M);\n     arguments[M-1] \u003d args2;\n     return this.asFixedArity().invokeWithArguments(arguments);\n   }\n } // done with explicit varargs processing\n\n // Handle fixed arity and non-jumbo variable arity invocation.\n MethodHandle invoker \u003d MethodHandles.spreadInvoker(this.type(), 0);\n Object result \u003d invoker.invokeExact(this, arguments);\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003earguments\u003c/code\u003e - the arguments to pass to the target"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if an argument cannot be converted by reference casting",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the target\u0027s type cannot be adjusted to take the given number of \n\u003ccode\u003eObject\u003c/code\u003e arguments",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Throwable.html\" title\u003d\"class in java.lang\"\u003eThrowable\u003c/a\u003e\u003c/code\u003e - anything thrown by the target method invocation"
        ],
        "return": [
          "the result returned by the target"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.Throwable",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.util.List",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arguments"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "invokeWithArguments",
      "comment": "Performs a variable arity invocation, passing the arguments in the given list to the method handle, as if via an inexact invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument list. This method is also equivalent to the following code: \n   invokeWithArguments(arguments.toArray())\n Jumbo-sized lists are acceptable if this method handle has variable arity. See invokeWithArguments(Object[]) for details.",
      "tagMap": {
        "param": [
          "\u003ccode\u003earguments\u003c/code\u003e - the arguments to pass to the target"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earguments\u003c/code\u003e is a null reference",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if an argument cannot be converted by reference casting",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the target\u0027s type cannot be adjusted to take the given number of \n\u003ccode\u003eObject\u003c/code\u003e arguments",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Throwable.html\" title\u003d\"class in java.lang\"\u003eThrowable\u003c/a\u003e\u003c/code\u003e - anything thrown by the target method invocation"
        ],
        "return": [
          "the result returned by the target"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "newType"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "asType",
      "comment": "Produces an adapter method handle which adapts the type of the current method handle to a new type. The resulting method handle is guaranteed to report a type which is equal to the desired new type. If the original type and new type are equal, returns this. The new method handle, when invoked, will perform the following steps: Convert the incoming argument list to match the original method handle\u0027s argument list. Invoke the original method handle on the converted argument list. Convert any result returned by the original method handle to the return type of new method handle. This method provides the crucial behavioral difference between invokeExact and plain, inexact invoke. The two methods perform the same steps when the caller\u0027s type descriptor exactly matches the callee\u0027s, but when the types differ, plain invoke also calls asType (or some internal equivalent) in order to match up the caller\u0027s and callee\u0027s types. If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as described elsewhere. In every other case, all conversions are applied pairwise, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the corresponding component types of the old and new method handle types. Let T0 and T1 be corresponding new and old parameter types, or old and new return types. Specifically, for some valid index i, let T0\u003dnewType.parameterType(i) and T1\u003dthis.type().parameterType(i). Or else, going the other way for return values, let T0\u003dthis.type().returnType() and T1\u003dnewType.returnType(). If the types are the same, the new method handle makes no change to the corresponding argument or return value (if any). Otherwise, one of the following conversions is applied if possible: If T0 and T1 are references, then a cast to T1 is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.) If T0 and T1 are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, T0 must convert to T1 by a widening primitive conversion.) If T0 is a primitive and T1 a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from T0 to its wrapper class, which is then widened as needed to T1.) If T0 is a reference and T1 a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) T0 must be a wrapper class or a supertype of one. (In the case where T0 is Object, these are the conversions allowed by java.lang.reflect.Method.invoke.) The unboxing conversion must have a possibility of success, which means that if T0 is not itself a wrapper class, there must exist at least one wrapper class TW which is a subtype of T0 and whose unboxed primitive value can be widened to T1. If the return type T1 is marked as void, any returned value is discarded If the return type T0 is void and T1 a reference, a null value is introduced. If the return type T0 is void and T1 a primitive, a zero value is introduced. (Note: Both T0 and T1 may be regarded as static types, because neither corresponds specifically to the dynamic type of any actual argument or return value.) The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made. At runtime, the conversions applied to reference arguments or return values may require additional runtime checks which can fail. An unboxing operation may fail because the original reference is null, causing a NullPointerException. An unboxing operation or a reference cast may also fail on a reference to an object of the wrong type, causing a ClassCastException. Although an unboxing operation may accept several kinds of wrappers, if none are available, a ClassCastException will be thrown.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#explicitCastArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandles.explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003enewType\u003c/code\u003e - the expected type of the new method handle"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003enewType\u003c/code\u003e is a null reference",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the conversion cannot be made"
        ],
        "return": [
          "a method handle which delegates to \n\u003ccode\u003ethis\u003c/code\u003e after performing any necessary argument conversions, and arranges for any necessary return value conversions"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayType"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "arrayLength"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "asSpreader",
      "comment": "Makes an array-spreading method handle, which accepts a trailing array argument and spreads its elements as positional arguments. The new method handle adapts, as its target, the current method handle. The type of the adapter will be the same as the type of the target, except that the final arrayLength parameters of the target\u0027s type are replaced by a single array parameter of type arrayType. If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to asType. When called, the adapter replaces a trailing array argument by the array\u0027s elements, each as its own argument to the target. (The order of the arguments is preserved.) They are converted pairwise by casting and/or unboxing to the types of the trailing parameters of the target. Finally the target is called. What the target eventually returns is returned unchanged by the adapter. Before calling the target, the adapter verifies that the array contains exactly enough elements to provide a correct argument count to the target method handle. (The array may also be null when zero elements are required.) When the adapter is called, the length of the supplied array argument is queried as if by array.length or arraylength bytecode. If the adapter accepts a zero-length trailing array argument, the supplied array argument can either be a zero-length array or null; otherwise, the adapter will throw a NullPointerException if the array is null and throw an IllegalArgumentException if the array does not have the correct number of elements. Here are some simple examples of array-spreading method handles: \nMethodHandle equals \u003d publicLookup()\n  .findVirtual(String.class, \"equals\", methodType(boolean.class, Object.class));\nassert( (boolean) equals.invokeExact(\"me\", (Object)\"me\"));\nassert(!(boolean) equals.invokeExact(\"me\", (Object)\"thee\"));\n// spread both arguments from a 2-array:\nMethodHandle eq2 \u003d equals.asSpreader(Object[].class, 2);\nassert( (boolean) eq2.invokeExact(new Object[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2.invokeExact(new Object[]{ \"me\", \"thee\" }));\n// try to spread from anything but a 2-array:\nfor (int n \u003d 0; n \u003c\u003d 10; n++) {\n  Object[] badArityArgs \u003d (n \u003d\u003d 2 ? new Object[0] : new Object[n]);\n  try { assert((boolean) eq2.invokeExact(badArityArgs) \u0026\u0026 false); }\n  catch (IllegalArgumentException ex) { } // OK\n}\n// spread both arguments from a String array:\nMethodHandle eq2s \u003d equals.asSpreader(String[].class, 2);\nassert( (boolean) eq2s.invokeExact(new String[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2s.invokeExact(new String[]{ \"me\", \"thee\" }));\n// spread second arguments from a 1-array:\nMethodHandle eq1 \u003d equals.asSpreader(Object[].class, 1);\nassert( (boolean) eq1.invokeExact(\"me\", new Object[]{ \"me\" }));\nassert(!(boolean) eq1.invokeExact(\"me\", new Object[]{ \"thee\" }));\n// spread no arguments from a 0-array or null:\nMethodHandle eq0 \u003d equals.asSpreader(Object[].class, 0);\nassert( (boolean) eq0.invokeExact(\"me\", (Object)\"me\", new Object[0]));\nassert(!(boolean) eq0.invokeExact(\"me\", (Object)\"thee\", (Object[])null));\n// asSpreader and asCollector are approximate inverses:\nfor (int n \u003d 0; n \u003c\u003d 2; n++) {\n    for (Class\u003c?\u003e a : new Class\u003c?\u003e[]{Object[].class, String[].class, CharSequence[].class}) {\n        MethodHandle equals2 \u003d equals.asSpreader(a, n).asCollector(a, n);\n        assert( (boolean) equals2.invokeWithArguments(\"me\", \"me\"));\n        assert(!(boolean) equals2.invokeWithArguments(\"me\", \"thee\"));\n    }\n}\nMethodHandle caToString \u003d publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, char[].class));\nassertEquals(\"[A, B, C]\", (String) caToString.invokeExact(\"ABC\".toCharArray()));\nMethodHandle caString3 \u003d caToString.asCollector(char[].class, 3);\nassertEquals(\"[A, B, C]\", (String) caString3.invokeExact(\u0027A\u0027, \u0027B\u0027, \u0027C\u0027));\nMethodHandle caToString2 \u003d caString3.asSpreader(char[].class, 2);\nassertEquals(\"[A, B, C]\", (String) caToString2.invokeExact(\u0027A\u0027, \"BC\".toCharArray()));",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asCollector(java.lang.Class,int)\"\u003e\u003ccode\u003easCollector(java.lang.Class\u0026lt;?\u0026gt;, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003earrayType\u003c/code\u003e - usually \n\u003ccode\u003eObject[]\u003c/code\u003e, the type of the array argument from which to extract the spread arguments",
          "\u003ccode\u003earrayLength\u003c/code\u003e - the number of arguments to spread from an incoming array argument"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is a null reference",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is not an array type, or if target does not have at least \n\u003ccode\u003earrayLength\u003c/code\u003e parameter types, or if \n\u003ccode\u003earrayLength\u003c/code\u003e is negative, or if the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the implied \n\u003ccode\u003easType\u003c/code\u003e call fails"
        ],
        "return": [
          "a new method handle which spreads its final array argument, before calling the original method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "spreadArgPos"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayType"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "arrayLength"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "asSpreader",
      "comment": "Makes an array-spreading method handle, which accepts an array argument at a given position and spreads its elements as positional arguments in place of the array. The new method handle adapts, as its target, the current method handle. The type of the adapter will be the same as the type of the target, except that the arrayLength parameters of the target\u0027s type, starting at the zero-based position spreadArgPos, are replaced by a single array parameter of type arrayType. This method behaves very much like asSpreader(Class, int), but accepts an additional spreadArgPos argument to indicate at which position in the parameter list the spreading should take place.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asSpreader(java.lang.Class,int)\"\u003e\u003ccode\u003easSpreader(Class, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Example: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n    MethodHandle compare \u003d LOOKUP.findStatic(Objects.class, \"compare\", methodType(int.class, Object.class, Object.class, Comparator.class));\n    MethodHandle compare2FromArray \u003d compare.asSpreader(0, Object[].class, 2);\n    Object[] ints \u003d new Object[]{3, 9, 7, 7};\n    Comparator\u0026lt;Integer\u0026gt; cmp \u003d (a, b) -\u0026gt; a - b;\n    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 0, 2), cmp) \u0026lt; 0);\n    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 1, 3), cmp) \u0026gt; 0);\n    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 2, 4), cmp) \u003d\u003d 0);\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e"
        ],
        "param": [
          "\u003ccode\u003espreadArgPos\u003c/code\u003e - the position (zero-based index) in the argument list at which spreading should start.",
          "\u003ccode\u003earrayType\u003c/code\u003e - usually \n\u003ccode\u003eObject[]\u003c/code\u003e, the type of the array argument from which to extract the spread arguments",
          "\u003ccode\u003earrayLength\u003c/code\u003e - the number of arguments to spread from an incoming array argument"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is a null reference",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is not an array type, or if target does not have at least \n\u003ccode\u003earrayLength\u003c/code\u003e parameter types, or if \n\u003ccode\u003earrayLength\u003c/code\u003e is negative, or if \n\u003ccode\u003espreadArgPos\u003c/code\u003e has an illegal value (negative, or together with arrayLength exceeding the number of arguments), or if the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the implied \n\u003ccode\u003easType\u003c/code\u003e call fails"
        ],
        "return": [
          "a new method handle which spreads an array argument at a given position, before calling the original method handle"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "makeVarargs"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "withVarargs",
      "comment": "Adapts this method handle to be variable arity if the boolean flag is true, else fixed arity. If the method handle is already of the proper arity mode, it is returned unchanged.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asVarargsCollector(java.lang.Class)\"\u003e\u003ccode\u003easVarargsCollector(java.lang.Class\u0026lt;?\u0026gt;)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asFixedArity()\"\u003e\u003ccode\u003easFixedArity()\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "\u003cp\u003eThis method is sometimes useful when adapting a method handle that may be variable arity, to ensure that the resulting adapter is also variable arity if and only if the original handle was. For example, this code changes the first argument of a handle \u003ccode\u003emh\u003c/code\u003e to \u003ccode\u003eint\u003c/code\u003e without disturbing its variable arity property: \u003ccode\u003emh.asType(mh.type().changeParameterType(0,int.class)) .withVarargs(mh.isVarargsCollector())\u003c/code\u003e \u003c/p\u003e\n\u003cp\u003e This call is approximately equivalent to the following code: \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n if (makeVarargs \u003d\u003d isVarargsCollector())\n   return this;\n else if (makeVarargs)\n   return asVarargsCollector(type().lastParameterType());\n else\n   return asFixedArity();\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003emakeVarargs\u003c/code\u003e - true if the return method handle should have variable arity behavior"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003emakeVarargs\u003c/code\u003e is true and this method handle does not have a trailing array parameter"
        ],
        "return": [
          "a method handle of the same type, with possibly adjusted variable arity behavior"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayType"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "arrayLength"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "asCollector",
      "comment": "Makes an array-collecting method handle, which accepts a given number of trailing positional arguments and collects them into an array argument. The new method handle adapts, as its target, the current method handle. The type of the adapter will be the same as the type of the target, except that a single trailing parameter (usually of type arrayType) is replaced by arrayLength parameters whose type is element type of arrayType. If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to asType. When called, the adapter replaces its trailing arrayLength arguments by a single new array of type arrayType, whose elements comprise (in order) the replaced arguments. Finally the target is called. What the target eventually returns is returned unchanged by the adapter. (The array may also be a shared constant when arrayLength is zero.) (Note: The arrayType is often identical to the last parameter type of the original target. It is an explicit argument for symmetry with asSpreader, and also to allow the target to use a simple Object as its last parameter type.) In order to create a collecting adapter which is not restricted to a particular number of collected arguments, use asVarargsCollector or withVarargs instead. Here are some examples of array-collecting method handles: \nMethodHandle deepToString \u003d publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nassertEquals(\"[won]\",   (String) deepToString.invokeExact(new Object[]{\"won\"}));\nMethodHandle ts1 \u003d deepToString.asCollector(Object[].class, 1);\nassertEquals(methodType(String.class, Object.class), ts1.type());\n//assertEquals(\"[won]\", (String) ts1.invokeExact(         new Object[]{\"won\"})); //FAIL\nassertEquals(\"[[won]]\", (String) ts1.invokeExact((Object) new Object[]{\"won\"}));\n// arrayType can be a subtype of Object[]\nMethodHandle ts2 \u003d deepToString.asCollector(String[].class, 2);\nassertEquals(methodType(String.class, String.class, String.class), ts2.type());\nassertEquals(\"[two, too]\", (String) ts2.invokeExact(\"two\", \"too\"));\nMethodHandle ts0 \u003d deepToString.asCollector(Object[].class, 0);\nassertEquals(\"[]\", (String) ts0.invokeExact());\n// collectors can be nested, Lisp-style\nMethodHandle ts22 \u003d deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);\nassertEquals(\"[A, B, [C, D]]\", ((String) ts22.invokeExact((Object)\u0027A\u0027, (Object)\"B\", \"C\", \"D\")));\n// arrayType can be any primitive array type\nMethodHandle bytesToString \u003d publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, byte[].class))\n  .asCollector(byte[].class, 3);\nassertEquals(\"[1, 2, 3]\", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));\nMethodHandle longsToString \u003d publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, long[].class))\n  .asCollector(long[].class, 1);\nassertEquals(\"[123]\", (String) longsToString.invokeExact((long)123));\n Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asSpreader(java.lang.Class,int)\"\u003e\u003ccode\u003easSpreader(java.lang.Class\u0026lt;?\u0026gt;, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asVarargsCollector(java.lang.Class)\"\u003e\u003ccode\u003easVarargsCollector(java.lang.Class\u0026lt;?\u0026gt;)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003earrayType\u003c/code\u003e - often \n\u003ccode\u003eObject[]\u003c/code\u003e, the type of the array argument which will collect the arguments",
          "\u003ccode\u003earrayLength\u003c/code\u003e - the number of arguments to collect into a new array argument"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is a null reference",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is not an array type or \n\u003ccode\u003earrayType\u003c/code\u003e is not assignable to this method handle\u0027s trailing parameter type, or \n\u003ccode\u003earrayLength\u003c/code\u003e is not a legal array size, or the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the implied \n\u003ccode\u003easType\u003c/code\u003e call fails"
        ],
        "return": [
          "a new method handle which collects some trailing argument into an array, before calling the original method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "collectArgPos"
          }
        },
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayType"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "arrayLength"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "asCollector",
      "comment": "Makes an array-collecting method handle, which accepts a given number of positional arguments starting at a given position, and collects them into an array argument. The new method handle adapts, as its target, the current method handle. The type of the adapter will be the same as the type of the target, except that the parameter at the position indicated by collectArgPos (usually of type arrayType) is replaced by arrayLength parameters whose type is element type of arrayType. This method behaves very much like asCollector(Class, int), but differs in that its collectArgPos argument indicates at which position in the parameter list arguments should be collected. This index is zero-based.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asCollector(java.lang.Class,int)\"\u003e\u003ccode\u003easCollector(Class, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "Examples: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\n    StringWriter swr \u003d new StringWriter();\n    MethodHandle swWrite \u003d LOOKUP.findVirtual(StringWriter.class, \"write\", methodType(void.class, char[].class, int.class, int.class)).bindTo(swr);\n    MethodHandle swWrite4 \u003d swWrite.asCollector(0, char[].class, 4);\n    swWrite4.invoke(\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, 1, 2);\n    assertEquals(\"BC\", swr.toString());\n    swWrite4.invoke(\u0027P\u0027, \u0027Q\u0027, \u0027R\u0027, \u0027S\u0027, 0, 4);\n    assertEquals(\"BCPQRS\", swr.toString());\n    swWrite4.invoke(\u0027W\u0027, \u0027X\u0027, \u0027Y\u0027, \u0027Z\u0027, 3, 1);\n    assertEquals(\"BCPQRSZ\", swr.toString());\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e \u003cem\u003eNote:\u003c/em\u003e The resulting adapter is never a \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asVarargsCollector(java.lang.Class)\"\u003evariable-arity method handle\u003c/a\u003e, even if the original target method handle was.\u003c/p\u003e"
        ],
        "param": [
          "\u003ccode\u003ecollectArgPos\u003c/code\u003e - the zero-based position in the parameter list at which to start collecting.",
          "\u003ccode\u003earrayType\u003c/code\u003e - often \n\u003ccode\u003eObject[]\u003c/code\u003e, the type of the array argument which will collect the arguments",
          "\u003ccode\u003earrayLength\u003c/code\u003e - the number of arguments to collect into a new array argument"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is a null reference",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is not an array type or \n\u003ccode\u003earrayType\u003c/code\u003e is not assignable to this method handle\u0027s array parameter type, or \n\u003ccode\u003earrayLength\u003c/code\u003e is not a legal array size, or \n\u003ccode\u003ecollectArgPos\u003c/code\u003e has an illegal value (negative, or greater than the number of arguments), or the resulting method handle\u0027s type would have \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#maxarity\"\u003etoo many parameters\u003c/a\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the implied \n\u003ccode\u003easType\u003c/code\u003e call fails"
        ],
        "return": [
          "a new method handle which collects some arguments into an array, before calling the original method handle"
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "arrayType"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "asVarargsCollector",
      "comment": "Makes a variable arity adapter which is able to accept any number of trailing positional arguments and collect them into an array argument. The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain invoke and asType requests can lead to trailing positional arguments being collected into target\u0027s trailing parameter. Also, the last parameter type of the adapter will be arrayType, even if the target has a different last parameter type. This transformation may return this if the method handle is already of variable arity and its trailing parameter type is identical to arrayType. When called with invokeExact, the adapter invokes the target with no argument changes. (Note: This behavior is different from a fixed arity collector, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.) When called with plain, inexact invoke, if the caller type is the same as the adapter, the adapter invokes the target as with invokeExact. (This is the normal behavior for invoke when types match.) Otherwise, if the caller and adapter arity are the same, and the trailing parameter type of the caller is a reference type identical to or assignable to the trailing parameter type of the adapter, the arguments and return values are converted pairwise, as if by asType on a fixed arity method handle. Otherwise, the arities differ, or the adapter\u0027s trailing parameter type is not assignable from the corresponding caller type. In this case, the adapter replaces all trailing arguments from the original trailing argument position onward, by a new array of type arrayType, whose elements comprise (in order) the replaced arguments. The caller type must provides as least enough arguments, and of the correct type, to satisfy the target\u0027s requirement for positional arguments before the trailing array argument. Thus, the caller must supply, at a minimum, N-1 arguments, where N is the arity of the target. Also, there must exist conversions from the incoming arguments to the target\u0027s arguments. As with other uses of plain invoke, if these basic requirements are not fulfilled, a WrongMethodTypeException may be thrown. In all cases, what the target eventually returns is returned unchanged by the adapter. In the final case, it is exactly as if the target method handle were temporarily adapted with a fixed arity collector to the arity required by the caller type. (As with asCollector, if the array length is zero, a shared constant may be used instead of a new array. If the implied call to asCollector would throw an IllegalArgumentException or WrongMethodTypeException, the call to the variable arity adapter must throw WrongMethodTypeException.) The behavior of asType is also specialized for variable arity adapters, to maintain the invariant that plain, inexact invoke is always equivalent to an asType call to adjust the target type, followed by invokeExact. Therefore, a variable arity adapter responds to an asType request by building a fixed arity collector, if and only if the adapter and requested type differ either in arity or trailing argument type. The resulting fixed arity collector has its type further adjusted (if necessary) to the requested type by pairwise conversion, as if by another application of asType. When a method handle is obtained by executing an ldc instruction of a CONSTANT_MethodHandle constant, and the target method is marked as a variable arity method (with the modifier bit 0x0080), the method handle will accept multiple arities, as if the method handle constant were created by means of a call to asVarargsCollector. In order to create a collecting adapter which collects a predetermined number of arguments, and whose type reflects this predetermined number, use asCollector instead. No method handle transformations produce new method handles with variable arity, unless they are documented as doing so. Therefore, besides asVarargsCollector and withVarargs, all methods in MethodHandle and MethodHandles will return a method handle with fixed arity, except in the cases where they are specified to return their original operand (e.g., asType of the method handle\u0027s own type). Calling asVarargsCollector on a method handle which is already of variable arity will produce a method handle with the same type and behavior. It may (or may not) return the original variable arity method handle. Here is an example, of a list-making variable arity method handle: \nMethodHandle deepToString \u003d publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nMethodHandle ts1 \u003d deepToString.asVarargsCollector(Object[].class);\nassertEquals(\"[won]\",   (String) ts1.invokeExact(    new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(         new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(                      \"won\" ));\nassertEquals(\"[[won]]\", (String) ts1.invoke((Object) new Object[]{\"won\"}));\n// findStatic of Arrays.asList(...) produces a variable arity method handle:\nMethodHandle asList \u003d publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class));\nassertEquals(methodType(List.class, Object[].class), asList.type());\nassert(asList.isVarargsCollector());\nassertEquals(\"[]\", asList.invoke().toString());\nassertEquals(\"[1]\", asList.invoke(1).toString());\nassertEquals(\"[two, too]\", asList.invoke(\"two\", \"too\").toString());\nString[] argv \u003d { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asList.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asList.invoke((Object[])argv).toString());\nList ls \u003d (List) asList.invoke((Object)argv);\nassertEquals(1, ls.size());\nassertEquals(\"[three, thee, tee]\", Arrays.toString((Object[])ls.get(0)));\n Discussion: These rules are designed as a dynamically-typed variation of the Java rules for variable arity methods. In both cases, callers to a variable arity method or method handle can either pass zero or more positional arguments, or else pass pre-collected arrays of any length. Users should be aware of the special role of the final argument, and of the effect of a type match on that final argument, which determines whether or not a single trailing argument is interpreted as a whole array or a single element of an array to be collected. Note that the dynamic type of the trailing argument has no effect on this decision, only a comparison between the symbolic type descriptor of the call site and the type descriptor of the method handle.)",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asCollector(java.lang.Class,int)\"\u003e\u003ccode\u003easCollector(java.lang.Class\u0026lt;?\u0026gt;, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#isVarargsCollector()\"\u003e\u003ccode\u003eisVarargsCollector()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#withVarargs(boolean)\"\u003e\u003ccode\u003ewithVarargs(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asFixedArity()\"\u003e\u003ccode\u003easFixedArity()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003earrayType\u003c/code\u003e - often \n\u003ccode\u003eObject[]\u003c/code\u003e, the type of the array argument which will collect the arguments"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is a null reference",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003earrayType\u003c/code\u003e is not an array type or \n\u003ccode\u003earrayType\u003c/code\u003e is not assignable to this method handle\u0027s trailing parameter type"
        ],
        "return": [
          "a new method handle which can collect any number of trailing arguments into an array, before calling the original method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "isVarargsCollector",
      "comment": "Determines if this method handle supports variable arity calls. Such method handles arise from the following sources: a call to asVarargsCollector a call to a lookup method which resolves to a variable arity Java method or constructor an ldc instruction of a CONSTANT_MethodHandle which resolves to a variable arity Java method or constructor",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asVarargsCollector(java.lang.Class)\"\u003e\u003ccode\u003easVarargsCollector(java.lang.Class\u0026lt;?\u0026gt;)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asFixedArity()\"\u003e\u003ccode\u003easFixedArity()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if this method handle accepts more than one arity of plain, inexact \n\u003ccode\u003einvoke\u003c/code\u003e calls"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "asFixedArity",
      "comment": "Makes a fixed arity method handle which is otherwise equivalent to the current method handle. If the current method handle is not of variable arity, the current method handle is returned. This is true even if the current method handle could not be a valid input to asVarargsCollector. Otherwise, the resulting fixed-arity method handle has the same type and behavior of the current method handle, except that isVarargsCollector will be false. The fixed-arity method handle may (or may not) be the a previous argument to asVarargsCollector. Here is an example, of a list-making variable arity method handle: \nMethodHandle asListVar \u003d publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class))\n  .asVarargsCollector(Object[].class);\nMethodHandle asListFix \u003d asListVar.asFixedArity();\nassertEquals(\"[1]\", asListVar.invoke(1).toString());\nException caught \u003d null;\ntry { asListFix.invoke((Object)1); }\ncatch (Exception ex) { caught \u003d ex; }\nassert(caught instanceof ClassCastException);\nassertEquals(\"[two, too]\", asListVar.invoke(\"two\", \"too\").toString());\ntry { asListFix.invoke(\"two\", \"too\"); }\ncatch (Exception ex) { caught \u003d ex; }\nassert(caught instanceof WrongMethodTypeException);\nObject[] argv \u003d { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asListVar.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke(argv).toString());\nassertEquals(1, ((List) asListVar.invoke((Object)argv)).size());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke((Object)argv).toString());",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#asVarargsCollector(java.lang.Class)\"\u003e\u003ccode\u003easVarargsCollector(java.lang.Class\u0026lt;?\u0026gt;)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#isVarargsCollector()\"\u003e\u003ccode\u003eisVarargsCollector()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandle.html#withVarargs(boolean)\"\u003e\u003ccode\u003ewithVarargs(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "a new method handle which accepts only a fixed number of arguments"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "x"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "bindTo",
      "comment": "Binds a value x to the first argument of a method handle, without invoking it. The new method handle adapts, as its target, the current method handle by binding it to the given argument. The type of the bound handle will be the same as the type of the target, except that a single leading reference parameter will be omitted. When called, the bound handle inserts the given value x as a new leading argument to the target. The other arguments are also passed unchanged. What the target eventually returns is returned unchanged by the bound handle. The reference x must be convertible to the first parameter type of the target. Note: Because method handles are immutable, the target method handle retains its original type and behavior. Note: The resulting adapter is never a variable-arity method handle, even if the original target method handle was.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html#insertArguments(java.lang.invoke.MethodHandle,int,java.lang.Object...)\"\u003e\u003ccode\u003eMethodHandles.insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ex\u003c/code\u003e - the value to bind to the first argument of the target"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the target does not have a leading parameter type that is a reference type",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassCastException.html\" title\u003d\"class in java.lang\"\u003eClassCastException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ex\u003c/code\u003e cannot be converted to the leading parameter type of the target"
        ],
        "return": [
          "a new method handle which prepends the given value to the incoming argument list, before calling the original method handle"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.Optional",
        "parameters": [
          {
            "name": "java.lang.constant.MethodHandleDesc",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "describeConstable",
      "comment": "Return a nominal descriptor for this instance, if one can be constructed, or an empty Optional if one cannot be.",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/constant/Constable.html#describeConstable()\"\u003edescribeConstable\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/constant/Constable.html\" title\u003d\"interface in java.lang.constant\"\u003eConstable\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "An \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Optional.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eOptional\u003c/code\u003e\u003c/a\u003e containing the resulting nominal descriptor, or an empty \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Optional.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003eOptional\u003c/code\u003e\u003c/a\u003e if one cannot be constructed."
        ],
        "since": [
          "12"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a string representation of the method handle, starting with the string \"MethodHandle\" and ending with the string representation of the method handle\u0027s type. In other words, this method returns a string equal to the value of: \n \"MethodHandle\" + type().toString()\n (Note: Future releases of this API may add further information to the string representation. Therefore, the present syntax should not be parsed by applications.)",
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a string representation of the method handle"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.lang.invoke.MethodHandle",
  "comment": "A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values. These transformations are quite general, and include such patterns as \n\u003ca href\u003d\"#asType(java.lang.invoke.MethodType)\"\u003econversion\u003c/a\u003e, \n\u003ca href\u003d\"#bindTo(java.lang.Object)\"\u003einsertion\u003c/a\u003e, \n\u003ca href\u003d\"MethodHandles.html#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)\"\u003edeletion\u003c/a\u003e, and \n\u003ca href\u003d\"MethodHandles.html#filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)\"\u003esubstitution\u003c/a\u003e. \n\u003ch2\u003eMethod handle contents\u003c/h2\u003e Method handles are dynamically and strongly typed according to their parameter and return types. They are not distinguished by the name or the defining class of their underlying methods. A method handle must be invoked using a symbolic type descriptor which matches the method handle\u0027s own \n\u003ca href\u003d\"#type()\"\u003etype descriptor\u003c/a\u003e. \n\u003cp\u003e Every method handle reports its type descriptor via the \u003ca href\u003d\"#type()\"\u003e\u003ccode\u003etype\u003c/code\u003e\u003c/a\u003e accessor. This type descriptor is a \u003ca href\u003d\"MethodType.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodType\u003c/code\u003e\u003c/a\u003e object, whose structure is a series of classes, one of which is the return type of the method (or \u003ccode\u003evoid.class\u003c/code\u003e if none). \u003c/p\u003e\n\u003cp\u003e A method handle\u0027s type controls the types of invocations it accepts, and the kinds of transformations that apply to it. \u003c/p\u003e\n\u003cp\u003e A method handle contains a pair of special invoker methods called \u003ca href\u003d\"#invokeExact(java.lang.Object...)\"\u003e\u003ccode\u003einvokeExact\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#invoke(java.lang.Object...)\"\u003e\u003ccode\u003einvoke\u003c/code\u003e\u003c/a\u003e. Both invoker methods provide direct access to the method handle\u0027s underlying method, constructor, field, or other operation, as modified by transformations of arguments and return values. Both invokers accept calls which exactly match the method handle\u0027s own type. The plain, inexact invoker also accepts a range of other call types. \u003c/p\u003e\n\u003cp\u003e Method handles are immutable and have no visible state. Of course, they can be bound to underlying methods or data which exhibit state. With respect to the Java Memory Model, any method handle will behave as if all of its (internal) fields are final variables. This means that any method handle made visible to the application will always be fully formed. This is true even if the method handle is published through a shared variable in a data race. \u003c/p\u003e\n\u003cp\u003e Method handles cannot be subclassed by the user. Implementations may (or may not) create internal subclasses of \u003ccode\u003eMethodHandle\u003c/code\u003e which may be visible via the \u003ca href\u003d\"../Object.html#getClass()\"\u003e\u003ccode\u003eObject.getClass\u003c/code\u003e\u003c/a\u003e operation. The programmer should not draw conclusions about a method handle from its specific class, as the method handle class hierarchy (if any) may change from time to time or across implementations from different vendors. \u003c/p\u003e\n\u003ch2\u003eMethod handle compilation\u003c/h2\u003e A Java method call expression naming \n\u003ccode\u003einvokeExact\u003c/code\u003e or \n\u003ccode\u003einvoke\u003c/code\u003e can invoke a method handle from Java source code. From the viewpoint of source code, these methods can take any arguments and their result can be cast to any return type. Formally this is accomplished by giving the invoker methods \n\u003ccode\u003eObject\u003c/code\u003e return types and variable arity \n\u003ccode\u003eObject\u003c/code\u003e arguments, but they have an additional quality called \n\u003cem\u003esignature polymorphism\u003c/em\u003e which connects this freedom of invocation directly to the JVM execution stack. \n\u003cp\u003e As is usual with virtual methods, source-level calls to \u003ccode\u003einvokeExact\u003c/code\u003e and \u003ccode\u003einvoke\u003c/code\u003e compile to an \u003ccode\u003einvokevirtual\u003c/code\u003e instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must generate instructions that push them on the stack according to their own unconverted types. The method handle object itself is pushed on the stack before the arguments. The compiler then generates an \u003ccode\u003einvokevirtual\u003c/code\u003e instruction that invokes the method handle with a symbolic type descriptor which describes the argument and return types. \u003c/p\u003e\n\u003cp\u003e To issue a complete symbolic type descriptor, the compiler must also determine the return type. This is based on a cast on the method invocation expression, if there is one, or else \u003ccode\u003eObject\u003c/code\u003e if the invocation is an expression, or else \u003ccode\u003evoid\u003c/code\u003e if the invocation is a statement. The cast may be to a primitive type (but not \u003ccode\u003evoid\u003c/code\u003e). \u003c/p\u003e\n\u003cp\u003e As a corner case, an uncasted \u003ccode\u003enull\u003c/code\u003e argument is given a symbolic type descriptor of \u003ccode\u003ejava.lang.Void\u003c/code\u003e. The ambiguity with the type \u003ccode\u003eVoid\u003c/code\u003e is harmless, since there are no references of type \u003ccode\u003eVoid\u003c/code\u003e except the null reference. \u003c/p\u003e\n\u003ch2\u003eMethod handle invocation\u003c/h2\u003e The first time an \n\u003ccode\u003einvokevirtual\u003c/code\u003e instruction is executed it is linked by symbolically resolving the names in the instruction and verifying that the method call is statically legal. This also holds for calls to \n\u003ccode\u003einvokeExact\u003c/code\u003e and \n\u003ccode\u003einvoke\u003c/code\u003e. In this case, the symbolic type descriptor emitted by the compiler is checked for correct syntax, and names it contains are resolved. Thus, an \n\u003ccode\u003einvokevirtual\u003c/code\u003e instruction which invokes a method handle will always link, as long as the symbolic type descriptor is syntactically well-formed and the types exist. \n\u003cp\u003e When the \u003ccode\u003einvokevirtual\u003c/code\u003e is executed after linking, the receiving method handle\u0027s type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the method which the caller is invoking is not present on the individual method handle being invoked. \u003c/p\u003e\n\u003cp\u003e In the case of \u003ccode\u003einvokeExact\u003c/code\u003e, the type descriptor of the invocation (after resolving symbolic type names) must exactly match the method type of the receiving method handle. In the case of plain, inexact \u003ccode\u003einvoke\u003c/code\u003e, the resolved type descriptor must be a valid argument to the receiver\u0027s \u003ca href\u003d\"#asType(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003easType\u003c/code\u003e\u003c/a\u003e method. Thus, plain \u003ccode\u003einvoke\u003c/code\u003e is more permissive than \u003ccode\u003einvokeExact\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e After type matching, a call to \u003ccode\u003einvokeExact\u003c/code\u003e directly and immediately invoke the method handle\u0027s underlying method (or other behavior, as the case may be). \u003c/p\u003e\n\u003cp\u003e A call to plain \u003ccode\u003einvoke\u003c/code\u003e works the same as a call to \u003ccode\u003einvokeExact\u003c/code\u003e, if the symbolic type descriptor specified by the caller exactly matches the method handle\u0027s own type. If there is a type mismatch, \u003ccode\u003einvoke\u003c/code\u003e attempts to adjust the type of the receiving method handle, as if by a call to \u003ca href\u003d\"#asType(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003easType\u003c/code\u003e\u003c/a\u003e, to obtain an exactly invokable method handle \u003ccode\u003eM2\u003c/code\u003e. This allows a more powerful negotiation of method type between caller and callee. \u003c/p\u003e\n\u003cp\u003e (\u003cem\u003eNote:\u003c/em\u003e The adjusted method handle \u003ccode\u003eM2\u003c/code\u003e is not directly observable, and implementations are therefore not required to materialize it.) \u003c/p\u003e\n\u003ch2\u003eInvocation checking\u003c/h2\u003e In typical programs, method handle type matching will usually succeed. But if a match fails, the JVM will throw a \n\u003ca href\u003d\"WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eWrongMethodTypeException\u003c/code\u003e\u003c/a\u003e, either directly (in the case of \n\u003ccode\u003einvokeExact\u003c/code\u003e) or indirectly as if by a failed call to \n\u003ccode\u003easType\u003c/code\u003e (in the case of \n\u003ccode\u003einvoke\u003c/code\u003e). \n\u003cp\u003e Thus, a method type mismatch which might show up as a linkage error in a statically typed program can show up as a dynamic \u003ccode\u003eWrongMethodTypeException\u003c/code\u003e in a program which uses method handles. \u003c/p\u003e\n\u003cp\u003e Because method types contain \"live\" \u003ccode\u003eClass\u003c/code\u003e objects, method type matching takes into account both type names and class loaders. Thus, even if a method handle \u003ccode\u003eM\u003c/code\u003e is created in one class loader \u003ccode\u003eL1\u003c/code\u003e and used in another \u003ccode\u003eL2\u003c/code\u003e, method handle calls are type-safe, because the caller\u0027s symbolic type descriptor, as resolved in \u003ccode\u003eL2\u003c/code\u003e, is matched against the original callee method\u0027s symbolic type descriptor, as resolved in \u003ccode\u003eL1\u003c/code\u003e. The resolution in \u003ccode\u003eL1\u003c/code\u003e happens when \u003ccode\u003eM\u003c/code\u003e is created and its type is assigned, while the resolution in \u003ccode\u003eL2\u003c/code\u003e happens when the \u003ccode\u003einvokevirtual\u003c/code\u003e instruction is linked. \u003c/p\u003e\n\u003cp\u003e Apart from type descriptor checks, a method handle\u0027s capability to call its underlying method is unrestricted. If a method handle is formed on a non-public method by a class that has access to that method, the resulting handle can be used in any place by any caller who receives a reference to it. \u003c/p\u003e\n\u003cp\u003e Unlike with the Core Reflection API, where access is checked every time a reflective method is invoked, method handle access checking is performed \u003ca href\u003d\"MethodHandles.Lookup.html#access\"\u003ewhen the method handle is created\u003c/a\u003e. In the case of \u003ccode\u003eldc\u003c/code\u003e (see below), access checking is performed as part of linking the constant pool entry underlying the constant method handle. \u003c/p\u003e\n\u003cp\u003e Thus, handles to non-public methods, or to methods in non-public classes, should generally be kept secret. They should not be passed to untrusted code unless their use from the untrusted code would be harmless. \u003c/p\u003e\n\u003ch2\u003eMethod handle creation\u003c/h2\u003e Java code can create a method handle that directly accesses any method, constructor, or field that is accessible to that code. This is done via a reflective, capability-based API called \n\u003ca href\u003d\"MethodHandles.Lookup.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandles.Lookup\u003c/code\u003e\u003c/a\u003e. For example, a static method handle can be obtained from \n\u003ca href\u003d\"MethodHandles.Lookup.html#findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eLookup.findStatic\u003c/code\u003e\u003c/a\u003e. There are also conversion methods from Core Reflection API objects, such as \n\u003ca href\u003d\"MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)\"\u003e\u003ccode\u003eLookup.unreflect\u003c/code\u003e\u003c/a\u003e. \n\u003cp\u003e Like classes and strings, method handles that correspond to accessible fields, methods, and constructors can also be represented directly in a class file\u0027s constant pool as constants to be loaded by \u003ccode\u003eldc\u003c/code\u003e bytecodes. A new type of constant pool entry, \u003ccode\u003eCONSTANT_MethodHandle\u003c/code\u003e, refers directly to an associated \u003ccode\u003eCONSTANT_Methodref\u003c/code\u003e, \u003ccode\u003eCONSTANT_InterfaceMethodref\u003c/code\u003e, or \u003ccode\u003eCONSTANT_Fieldref\u003c/code\u003e constant pool entry. (For full details on method handle constants, see sections \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jls-4.4.8\"\u003e4.4.8\u003c/a\u003e and \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-5.html#jls-5.4.3.5\"\u003e5.4.3.5\u003c/a\u003e of the Java Virtual Machine Specification.) \u003c/p\u003e\n\u003cp\u003e Method handles produced by lookups or constant loads from methods or constructors with the variable arity modifier bit (\u003ccode\u003e0x0080\u003c/code\u003e) have a corresponding variable arity, as if they were defined with the help of \u003ca href\u003d\"#asVarargsCollector(java.lang.Class)\"\u003e\u003ccode\u003easVarargsCollector\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"#withVarargs(boolean)\"\u003e\u003ccode\u003ewithVarargs\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003cp\u003e A method reference may refer either to a static or non-static method. In the non-static case, the method handle type includes an explicit receiver argument, prepended before any other arguments. In the method handle\u0027s type, the initial receiver argument is typed according to the class under which the method was initially requested. (E.g., if a non-static method handle is obtained via \u003ccode\u003eldc\u003c/code\u003e, the type of the receiver is the class named in the constant pool entry.) \u003c/p\u003e\n\u003cp\u003e Method handle constants are subject to the same link-time access checks their corresponding bytecode instructions, and the \u003ccode\u003eldc\u003c/code\u003e instruction will throw corresponding linkage errors if the bytecode behaviors would throw such errors. \u003c/p\u003e\n\u003cp\u003e As a corollary of this, access to protected members is restricted to receivers only of the accessing class, or one of its subclasses, and the accessing class must in turn be a subclass (or package sibling) of the protected member\u0027s defining class. If a method reference refers to a protected non-static method or field of a class outside the current package, the receiver argument will be narrowed to the type of the accessing class. \u003c/p\u003e\n\u003cp\u003e When a method handle to a virtual method is invoked, the method is always looked up in the receiver (that is, the first argument). \u003c/p\u003e\n\u003cp\u003e A non-virtual method handle to a specific virtual method implementation can also be created. These do not perform virtual lookup based on receiver type. Such a method handle simulates the effect of an \u003ccode\u003einvokespecial\u003c/code\u003e instruction to the same method. A non-virtual method handle can also be created to simulate the effect of an \u003ccode\u003einvokevirtual\u003c/code\u003e or \u003ccode\u003einvokeinterface\u003c/code\u003e instruction on a private method (as applicable). \u003c/p\u003e\n\u003ch2\u003eUsage examples\u003c/h2\u003e Here are some examples of usage: \n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nObject x, y; String s; int i;\nMethodType mt; MethodHandle mh;\nMethodHandles.Lookup lookup \u003d MethodHandles.lookup();\n// mt is (char,char)String\nmt \u003d MethodType.methodType(String.class, char.class, char.class);\nmh \u003d lookup.findVirtual(String.class, \"replace\", mt);\ns \u003d (String) mh.invokeExact(\"daddy\",\u0027d\u0027,\u0027n\u0027);\n// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;\nassertEquals(s, \"nanny\");\n// weakly typed invocation (using MHs.invoke)\ns \u003d (String) mh.invokeWithArguments(\"sappy\", \u0027p\u0027, \u0027v\u0027);\nassertEquals(s, \"savvy\");\n// mt is (Object[])List\nmt \u003d MethodType.methodType(java.util.List.class, Object[].class);\nmh \u003d lookup.findStatic(java.util.Arrays.class, \"asList\", mt);\nassert(mh.isVarargsCollector());\nx \u003d mh.invoke(\"one\", \"two\");\n// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(\"one\",\"two\"));\n// mt is (Object,Object,Object)Object\nmt \u003d MethodType.genericMethodType(3);\nmh \u003d mh.asType(mt);\nx \u003d mh.invokeExact((Object)1, (Object)2, (Object)3);\n// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(1,2,3));\n// mt is ()int\nmt \u003d MethodType.methodType(int.class);\nmh \u003d lookup.findVirtual(java.util.List.class, \"size\", mt);\ni \u003d (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));\n// invokeExact(Ljava/util/List;)I\nassert(i \u003d\u003d 3);\nmt \u003d MethodType.methodType(void.class, String.class);\nmh \u003d lookup.findVirtual(java.io.PrintStream.class, \"println\", mt);\nmh.invokeExact(System.out, \"Hello, world.\");\n// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e Each of the above calls to \n\u003ccode\u003einvokeExact\u003c/code\u003e or plain \n\u003ccode\u003einvoke\u003c/code\u003e generates a single invokevirtual instruction with the symbolic type descriptor indicated in the following comment. In these examples, the helper method \n\u003ccode\u003eassertEquals\u003c/code\u003e is assumed to be a method which calls \n\u003ca href\u003d\"../../util/Objects.html#equals(java.lang.Object,java.lang.Object)\"\u003e\u003ccode\u003eObjects.equals\u003c/code\u003e\u003c/a\u003e on its arguments, and asserts that the result is true. \n\u003ch2\u003eExceptions\u003c/h2\u003e The methods \n\u003ccode\u003einvokeExact\u003c/code\u003e and \n\u003ccode\u003einvoke\u003c/code\u003e are declared to throw \n\u003ca href\u003d\"../Throwable.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eThrowable\u003c/code\u003e\u003c/a\u003e, which is to say that there is no static restriction on what a method handle can throw. Since the JVM does not distinguish between checked and unchecked exceptions (other than by their class, of course), there is no particular effect on bytecode shape from ascribing checked exceptions to method handle invocations. But in Java source code, methods which perform method handle calls must either explicitly throw \n\u003ccode\u003eThrowable\u003c/code\u003e, or else must catch all throwables locally, rethrowing only those which are legal in the context, and wrapping ones which are illegal. \n\u003ch2\u003e\u003ca id\u003d\"sigpoly\"\u003e\u003c/a\u003eSignature polymorphism\u003c/h2\u003e The unusual compilation and linkage behavior of \n\u003ccode\u003einvokeExact\u003c/code\u003e and plain \n\u003ccode\u003einvoke\u003c/code\u003e is referenced by the term \n\u003cem\u003esignature polymorphism\u003c/em\u003e. As defined in the Java Language Specification, a signature polymorphic method is one which can operate with any of a wide range of call signatures and return types. \n\u003cp\u003e In source code, a call to a signature polymorphic method will compile, regardless of the requested symbolic type descriptor. As usual, the Java compiler emits an \u003ccode\u003einvokevirtual\u003c/code\u003e instruction with the given symbolic type descriptor against the named method. The unusual part is that the symbolic type descriptor is derived from the actual argument and return types, not from the method declaration. \u003c/p\u003e\n\u003cp\u003e When the JVM processes bytecode containing signature polymorphic calls, it will successfully link any such call, regardless of its symbolic type descriptor. (In order to retain type safety, the JVM will guard such calls with suitable dynamic type checks, as described elsewhere.) \u003c/p\u003e\n\u003cp\u003e Bytecode generators, including the compiler back end, are required to emit untransformed symbolic type descriptors for these methods. Tools which determine symbolic linkage are required to accept such untransformed descriptors, without reporting linkage errors. \u003c/p\u003e\n\u003ch2\u003eInteroperation between method handles and the Core Reflection API\u003c/h2\u003e Using factory methods in the \n\u003ca href\u003d\"MethodHandles.Lookup.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eLookup\u003c/code\u003e\u003c/a\u003e API, any class member represented by a Core Reflection API object can be converted to a behaviorally equivalent method handle. For example, a reflective \n\u003ca href\u003d\"../reflect/Method.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eMethod\u003c/code\u003e\u003c/a\u003e can be converted to a method handle using \n\u003ca href\u003d\"MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)\"\u003e\u003ccode\u003eLookup.unreflect\u003c/code\u003e\u003c/a\u003e. The resulting method handles generally provide more direct and efficient access to the underlying class members. \n\u003cp\u003e As a special case, when the Core Reflection API is used to view the signature polymorphic methods \u003ccode\u003einvokeExact\u003c/code\u003e or plain \u003ccode\u003einvoke\u003c/code\u003e in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by \u003ca href\u003d\"../Class.html#getDeclaredMethod(java.lang.String,java.lang.Class...)\"\u003e\u003ccode\u003eClass.getDeclaredMethod\u003c/code\u003e\u003c/a\u003e, is unaffected by their special status in this API. For example, \u003ca href\u003d\"../reflect/Method.html#getModifiers()\"\u003e\u003ccode\u003eMethod.getModifiers\u003c/code\u003e\u003c/a\u003e will report exactly those modifier bits required for any similarly declared method, including in this case \u003ccode\u003enative\u003c/code\u003e and \u003ccode\u003evarargs\u003c/code\u003e bits. \u003c/p\u003e\n\u003cp\u003e As with any reflected method, these methods (when reflected) may be invoked via \u003ca href\u003d\"../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)\"\u003e\u003ccode\u003ejava.lang.reflect.Method.invoke\u003c/code\u003e\u003c/a\u003e. However, such reflective calls do not result in method handle invocations. Such a call, if passed the required argument (a single one, of type \u003ccode\u003eObject[]\u003c/code\u003e), will ignore the argument and will throw an \u003ccode\u003eUnsupportedOperationException\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003e Since \u003ccode\u003einvokevirtual\u003c/code\u003e instructions can natively invoke method handles under any symbolic type descriptor, this reflective view conflicts with the normal presentation of these methods via bytecodes. Thus, these two native methods, when reflectively viewed by \u003ccode\u003eClass.getDeclaredMethod\u003c/code\u003e, may be regarded as placeholders only. \u003c/p\u003e\n\u003cp\u003e In order to obtain an invoker method for a particular type descriptor, use \u003ca href\u003d\"MethodHandles.html#exactInvoker(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandles.exactInvoker\u003c/code\u003e\u003c/a\u003e, or \u003ca href\u003d\"MethodHandles.html#invoker(java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eMethodHandles.invoker\u003c/code\u003e\u003c/a\u003e. The \u003ca href\u003d\"MethodHandles.Lookup.html#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)\"\u003e\u003ccode\u003eLookup.findVirtual\u003c/code\u003e\u003c/a\u003e API is also able to return a method handle to call \u003ccode\u003einvokeExact\u003c/code\u003e or plain \u003ccode\u003einvoke\u003c/code\u003e, for any specified type descriptor . \u003c/p\u003e\n\u003ch2\u003eInteroperation between method handles and Java generics\u003c/h2\u003e A method handle can be obtained on a method, constructor, or field which is declared with Java generic types. As with the Core Reflection API, the type of the method handle will be constructed from the erasure of the source-level type. When a method handle is invoked, the types of its arguments or the return value cast type may be generic types or type instances. If this occurs, the compiler will replace those types by their erasures when it constructs the symbolic type descriptor for the \n\u003ccode\u003einvokevirtual\u003c/code\u003e instruction. \n\u003cp\u003e Method handles do not represent their function-like types in terms of Java parameterized (generic) types, because there are three mismatches between function-like types and parameterized Java types. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eMethod types range over all possible arities, from no arguments to up to the \u003ca href\u003d\"MethodHandle.html#maxarity\"\u003emaximum number\u003c/a\u003e of allowed arguments. Generics are not variadic, and so cannot represent this.\u003c/li\u003e \n \u003cli\u003eMethod types can specify arguments of primitive types, which Java generic types cannot range over.\u003c/li\u003e \n \u003cli\u003eHigher order functions over method handles (combinators) are often generic across a wide range of function types, including those of multiple arities. It is impossible to represent such genericity with a Java type parameter.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca id\u003d\"maxarity\"\u003e\u003c/a\u003eArity limits\u003c/h2\u003e The JVM imposes on all methods and constructors of any kind an absolute limit of 255 stacked arguments. This limit can appear more restrictive in certain cases: \n\u003cul\u003e \n \u003cli\u003eA \u003ccode\u003elong\u003c/code\u003e or \u003ccode\u003edouble\u003c/code\u003e argument counts (for purposes of arity limits) as two argument slots. \u003c/li\u003e\n \u003cli\u003eA non-static method consumes an extra argument for the object on which the method is called. \u003c/li\u003e\n \u003cli\u003eA constructor consumes an extra argument for the object which is being constructed. \u003c/li\u003e\n \u003cli\u003eSince a method handles \u003ccode\u003einvoke\u003c/code\u003e method (or other signature-polymorphic method) is non-virtual, it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object. \u003c/li\u003e\n\u003c/ul\u003e These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments. For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it. Attempts to create method handles with impossible method types lead to an \n\u003ca href\u003d\"../IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eIllegalArgumentException\u003c/code\u003e\u003c/a\u003e. In particular, a method handles type must not have an arity of the exact maximum 255.",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodType.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodType\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eMethodHandles\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.7"
    ]
  }
}