{
  "packageName": "java.lang.invoke",
  "simpleName": "SerializedLambda",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCapturingClass",
      "comment": "Get the name of the class that captured this lambda.",
      "tagMap": {
        "return": [
          "the name of the class that captured this lambda"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFunctionalInterfaceClass",
      "comment": "Get the name of the invoked type to which this lambda has been converted",
      "tagMap": {
        "return": [
          "the name of the functional interface class to which this lambda has been converted"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFunctionalInterfaceMethodName",
      "comment": "Get the name of the primary method for the functional interface to which this lambda has been converted.",
      "tagMap": {
        "return": [
          "the name of the primary methods of the functional interface"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getFunctionalInterfaceMethodSignature",
      "comment": "Get the signature of the primary method for the functional interface to which this lambda has been converted.",
      "tagMap": {
        "return": [
          "the signature of the primary method of the functional interface"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getImplClass",
      "comment": "Get the name of the class containing the implementation method.",
      "tagMap": {
        "return": [
          "the name of the class containing the implementation method"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getImplMethodName",
      "comment": "Get the name of the implementation method.",
      "tagMap": {
        "return": [
          "the name of the implementation method"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getImplMethodSignature",
      "comment": "Get the signature of the implementation method.",
      "tagMap": {
        "return": [
          "the signature of the implementation method"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getImplMethodKind",
      "comment": "Get the method handle kind (see MethodHandleInfo) of the implementation method.",
      "tagMap": {
        "return": [
          "the method handle kind of the implementation method"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getInstantiatedMethodType",
      "comment": "Get the signature of the primary functional interface method after type variables are substituted with their instantiation from the capture site.",
      "tagMap": {
        "return": [
          "the signature of the primary functional interface method after type variable processing"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCapturedArgCount",
      "comment": "Get the count of dynamic arguments to the lambda capture site.",
      "tagMap": {
        "return": [
          "the count of dynamic arguments to the lambda capture site"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "i"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCapturedArg",
      "comment": "Get a dynamic argument to the lambda capture site.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ei\u003c/code\u003e - the argument to capture"
        ],
        "return": [
          "a dynamic argument to the lambda capture site"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.Class",
            "parameters": [
              {
                "type": "Wildcard"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "capturingClass"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "functionalInterfaceClass"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "functionalInterfaceMethodName"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "functionalInterfaceMethodSignature"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "implMethodKind"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "implClass"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "implMethodName"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "implMethodSignature"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "instantiatedMethodType"
          }
        },
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "capturedArgs"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Create a SerializedLambda from the low-level information present at the lambda factory site.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ecapturingClass\u003c/code\u003e - The class in which the lambda expression appears",
          "\u003ccode\u003efunctionalInterfaceClass\u003c/code\u003e - Name, in slash-delimited form, of static type of the returned lambda object",
          "\u003ccode\u003efunctionalInterfaceMethodName\u003c/code\u003e - Name of the functional interface method for the present at the lambda factory site",
          "\u003ccode\u003efunctionalInterfaceMethodSignature\u003c/code\u003e - Signature of the functional interface method present at the lambda factory site",
          "\u003ccode\u003eimplMethodKind\u003c/code\u003e - Method handle kind for the implementation method",
          "\u003ccode\u003eimplClass\u003c/code\u003e - Name, in slash-delimited form, for the class holding the implementation method",
          "\u003ccode\u003eimplMethodName\u003c/code\u003e - Name of the implementation method",
          "\u003ccode\u003eimplMethodSignature\u003c/code\u003e - Signature of the implementation method",
          "\u003ccode\u003einstantiatedMethodType\u003c/code\u003e - The signature of the primary functional interface method after type variables are substituted with their instantiation from the capture site",
          "\u003ccode\u003ecapturedArgs\u003c/code\u003e - The dynamic arguments to the lambda factory site, which represent variables captured by the lambda"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.lang.invoke.SerializedLambda",
  "comment": "Serialized form of a lambda expression. The properties of this class represent the information that is present at the lambda factory site, including static metafactory arguments such as the identity of the primary functional interface method and the identity of the implementation method, as well as dynamic metafactory arguments such as values captured from the lexical scope at the time of lambda capture. \n\u003cp\u003eImplementors of serializable lambdas, such as compilers or language runtime libraries, are expected to ensure that instances deserialize properly. One means to do so is to ensure that the \u003ccode\u003ewriteReplace\u003c/code\u003e method returns an instance of \u003ccode\u003eSerializedLambda\u003c/code\u003e, rather than allowing default serialization to proceed. \u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSerializedLambda\u003c/code\u003e has a \u003ccode\u003ereadResolve\u003c/code\u003e method that looks for a (possibly private) static method called \u003ccode\u003e$deserializeLambda$(SerializedLambda)\u003c/code\u003e in the capturing class, invokes that with itself as the first argument, and returns the result. Lambda classes implementing \u003ccode\u003e$deserializeLambda$\u003c/code\u003e are responsible for validating that the properties of the \u003ccode\u003eSerializedLambda\u003c/code\u003e are consistent with a lambda actually captured by that class. \u003c/p\u003e\n\u003cp\u003eThe identity of a function object produced by deserializing the serialized form is unpredictable, and therefore identity-sensitive operations (such as reference equality, object locking, and \u003ccode\u003eSystem.identityHashCode()\u003c/code\u003e may produce different results in different implementations, or even upon different deserializations in the same implementation.\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/LambdaMetafactory.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eLambdaMetafactory\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#java.lang.invoke.SerializedLambda\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "since": [
      "1.8"
    ]
  }
}