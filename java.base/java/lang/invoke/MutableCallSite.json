{
  "packageName": "java.lang.invoke",
  "simpleName": "MutableCallSite",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.invoke.CallSite",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getTarget",
      "comment": "Returns the target method of the call site, which behaves like a normal field of the MutableCallSite. The interactions of getTarget with memory are the same as of a read from an ordinary variable, such as an array element or a non-volatile, non-final field. In particular, the current thread may choose to reuse the result of a previous read of the target from memory, and may fail to see a recent update to the target by another thread.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MutableCallSite.html#setTarget(java.lang.invoke.MethodHandle)\"\u003e\u003ccode\u003esetTarget(java.lang.invoke.MethodHandle)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html#getTarget()\"\u003egetTarget\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html\" title\u003d\"class in java.lang.invoke\"\u003eCallSite\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "the linkage state of this call site, a method handle which can change over time"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "newTarget"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setTarget",
      "comment": "Updates the target method of this call site, as a normal variable. The type of the new target must agree with the type of the old target. The interactions with memory are the same as of a write to an ordinary variable, such as an array element or a non-volatile, non-final field. In particular, unrelated threads may fail to see the updated target until they perform a read from memory. Stronger guarantees can be created by putting appropriate operations into the bootstrap method and/or the target methods used at any given call site.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MutableCallSite.html#getTarget()\"\u003e\u003ccode\u003egetTarget()\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html#setTarget(java.lang.invoke.MethodHandle)\"\u003esetTarget\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html\" title\u003d\"class in java.lang.invoke\"\u003eCallSite\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003enewTarget\u003c/code\u003e - the new target"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the proposed new target is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html\" title\u003d\"class in java.lang.invoke\"\u003eWrongMethodTypeException\u003c/a\u003e\u003c/code\u003e - if the proposed new target has a method type that differs from the previous target"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.invoke.MethodHandle",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "dynamicInvoker",
      "comment": "Produces a method handle equivalent to an invokedynamic instruction which has been linked to this call site. This method is equivalent to the following code: \n MethodHandle getTarget, invoker, result;\n getTarget \u003d MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker \u003d MethodHandles.exactInvoker(this.type());\n result \u003d MethodHandles.foldArguments(invoker, getTarget)",
      "tagMap": {
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html#dynamicInvoker()\"\u003edynamicInvoker\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/CallSite.html\" title\u003d\"class in java.lang.invoke\"\u003eCallSite\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a method handle which always invokes this call site\u0027s current target"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MutableCallSite",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "sites"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "syncAll",
      "comment": "Performs a synchronization operation on each call site in the given array, forcing all other threads to throw away any cached values previously loaded from the target of any of the call sites. This operation does not reverse any calls that have already started on an old target value. (Java supports forward time travel only.) The overall effect is to force all future readers of each call site\u0027s target to accept the most recently stored value. (\"Most recently\" is reckoned relative to the syncAll itself.) Conversely, the syncAll call may block until all readers have (somehow) decached all previous versions of each call site\u0027s target. To avoid race conditions, calls to setTarget and syncAll should generally be performed under some sort of mutual exclusion. Note that reader threads may observe an updated target as early as the setTarget call that install the value (and before the syncAll that confirms the value). On the other hand, reader threads may observe previous versions of the target until the syncAll call returns (and after the setTarget that attempts to convey the updated version). This operation is likely to be expensive and should be used sparingly. If possible, it should be buffered for batch processing on sets of call sites. If sites contains a null element, a NullPointerException will be raised. In this case, some non-null elements in the array may be processed before the method returns abnormally. Which elements these are (if any) is implementation-dependent. Java Memory Model details In terms of the Java Memory Model, this operation performs a synchronization action which is comparable in effect to the writing of a volatile variable by the current thread, and an eventual volatile read by every other thread that may access one of the affected call sites. The following effects are apparent, for each individual call site S: A new volatile variable V is created, and written by the current thread. As defined by the JMM, this write is a global synchronization event. As is normal with thread-local ordering of write events, every action already performed by the current thread is taken to happen before the volatile write to V. (In some implementations, this means that the current thread performs a global release operation.) Specifically, the write to the current target of S is taken to happen before the volatile write to V. The volatile write to V is placed (in an implementation specific manner) in the global synchronization order. Consider an arbitrary thread T (other than the current thread). If T executes a synchronization action A after the volatile write to V (in the global synchronization order), it is therefore required to see either the current target of S, or a later write to that target, if it executes a read on the target of S. (This constraint is called \"synchronization-order consistency\".) The JMM specifically allows optimizing compilers to elide reads or writes of variables that are known to be useless. Such elided reads and writes have no effect on the happens-before relation. Regardless of this fact, the volatile V will not be elided, even though its written value is indeterminate and its read value is not used. Because of the last point, the implementation behaves as if a volatile read of V were performed by T immediately after its action A. In the local ordering of actions in T, this read happens before any future read of the target of S. It is as if the implementation arbitrarily picked a read of S\u0027s target by T, and forced a read of V to precede it, thereby ensuring communication of the new target value. As long as the constraints of the Java Memory Model are obeyed, implementations may delay the completion of a syncAll operation while other threads (T above) continue to use previous values of S\u0027s target. However, implementations are (as always) encouraged to avoid livelock, and to eventually require all threads to take account of the updated target. Discussion: For performance reasons, syncAll is not a virtual method on a single call site, but rather applies to a set of call sites. Some implementations may incur a large fixed overhead cost for processing one or more synchronization operations, but a small incremental cost for each additional call site. In any case, this operation is likely to be costly, since other threads may have to be somehow interrupted in order to make them notice the updated target value. However, it may be observed that a single call to synchronize several sites has the same formal effect as many calls, each on just one of the sites. Implementation Note: Simple implementations of MutableCallSite may use a volatile variable for the target of a mutable call site. In such an implementation, the syncAll method can be a no-op, and yet it will conform to the JMM behavior documented above.",
      "tagMap": {
        "param": [
          "\u003ccode\u003esites\u003c/code\u003e - an array of call sites to be synchronized"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003esites\u003c/code\u003e array reference is null or the array contains a null"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodType",
            "type": "Class"
          },
          "field": {
            "name": "type"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a blank call site object with the given method type. The initial target is set to a method handle of the given type which will throw an IllegalStateException if called. The type of the call site is permanently set to the given type. Before this CallSite object is returned from a bootstrap method, or invoked in some other manner, it is usually provided with a more useful target method, via a call to setTarget.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etype\u003c/code\u003e - the method type that this call site will have"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the proposed type is null"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.invoke.MethodHandle",
            "type": "Class"
          },
          "field": {
            "name": "target"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Creates a call site object with an initial target method handle. The type of the call site is permanently set to the initial target\u0027s type.",
      "tagMap": {
        "param": [
          "\u003ccode\u003etarget\u003c/code\u003e - the method handle that will be the initial target of the call site"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the proposed target is null"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "java.lang.invoke.MutableCallSite",
  "comment": "A \n\u003ccode\u003eMutableCallSite\u003c/code\u003e is a \n\u003ca href\u003d\"CallSite.html\" title\u003d\"class in java.lang.invoke\"\u003e\u003ccode\u003eCallSite\u003c/code\u003e\u003c/a\u003e whose target variable behaves like an ordinary field. An \n\u003ccode\u003einvokedynamic\u003c/code\u003e instruction linked to a \n\u003ccode\u003eMutableCallSite\u003c/code\u003e delegates all calls to the site\u0027s current target. The \n\u003ca href\u003d\"CallSite.html#dynamicInvoker()\"\u003edynamic invoker\u003c/a\u003e of a mutable call site also delegates each call to the site\u0027s current target. \n\u003cp\u003e Here is an example of a mutable call site which introduces a state variable into a method handle chain. \n \u003c!-- JavaDocExamplesTest.testMutableCallSite --\u003e \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nMutableCallSite name \u003d new MutableCallSite(MethodType.methodType(String.class));\nMethodHandle MH_name \u003d name.dynamicInvoker();\nMethodType MT_str1 \u003d MethodType.methodType(String.class);\nMethodHandle MH_upcase \u003d MethodHandles.lookup()\n    .findVirtual(String.class, \"toUpperCase\", MT_str1);\nMethodHandle worker1 \u003d MethodHandles.filterReturnValue(MH_name, MH_upcase);\nname.setTarget(MethodHandles.constant(String.class, \"Rocky\"));\nassertEquals(\"ROCKY\", (String) worker1.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Fred\"));\nassertEquals(\"FRED\", (String) worker1.invokeExact());\n// (mutation can be continued indefinitely)\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The same call site may be used in several places at once. \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e\u003ccode\u003e\nMethodType MT_str2 \u003d MethodType.methodType(String.class, String.class);\nMethodHandle MH_cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_dear \u003d MethodHandles.insertArguments(MH_cat, 1, \", dear?\");\nMethodHandle worker2 \u003d MethodHandles.filterReturnValue(MH_name, MH_dear);\nassertEquals(\"Fred, dear?\", (String) worker2.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Wilma\"));\nassertEquals(\"WILMA\", (String) worker1.invokeExact());\nassertEquals(\"Wilma, dear?\", (String) worker2.invokeExact());\n \u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003cem\u003eNon-synchronization of target values:\u003c/em\u003e A write to a mutable call site\u0027s target does not force other threads to become aware of the updated value. Threads which do not perform suitable synchronization actions relative to the updated call site may cache the old target value and delay their use of the new target value indefinitely. (This is a normal consequence of the Java Memory Model as applied to object fields.) \u003c/p\u003e\n\u003cp\u003e The \u003ca href\u003d\"#syncAll(java.lang.invoke.MutableCallSite%5B%5D)\"\u003e\u003ccode\u003esyncAll\u003c/code\u003e\u003c/a\u003e operation provides a way to force threads to accept a new target value, even if there is no other synchronization. \u003c/p\u003e\n\u003cp\u003e For target values which will be frequently updated, consider using a \u003ca href\u003d\"VolatileCallSite.html\" title\u003d\"class in java.lang.invoke\"\u003evolatile call site\u003c/a\u003e instead.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.7"
    ]
  }
}