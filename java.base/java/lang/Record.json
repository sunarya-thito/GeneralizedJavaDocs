{
  "packageName": "java.lang",
  "simpleName": "Record",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "obj"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "equals",
      "comment": "Indicates whether some other object is \"equal to\" this one. In addition to the general contract of Object.equals, record classes must further obey the invariant that when a record instance is \"copied\" by passing the result of the record component accessor methods to the canonical constructor, as follows:      R copy \u003d new R(r.c1(), r.c2(), ..., r.cn());\n then it must be the case that r.equals(copy).",
      "tagMap": {
        "implSpec": [
          "The implicitly provided implementation returns \n\u003ccode\u003etrue\u003c/code\u003e if and only if the argument is an instance of the same record class as this record, and each component of this record is equal to the corresponding component of the argument; otherwise, \n\u003ccode\u003e false\u003c/code\u003e is returned. Equality of a component \n\u003ccode\u003ec\u003c/code\u003e is determined as follows: \n\u003cul\u003e \n \u003cli\u003e If the component is of a reference type, the component is considered equal if and only if \u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#equals(java.lang.Object,java.lang.Object)\"\u003e\u003ccode\u003eObjects.equals(this.c, r.c\u003c/code\u003e\u003c/a\u003e would return \u003ccode\u003etrue\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003e If the component is of a primitive type, using the corresponding primitive wrapper class \u003ccode\u003ePW\u003c/code\u003e (the corresponding wrapper class for \u003ccode\u003eint\u003c/code\u003e is \u003ccode\u003e java.lang.Integer\u003c/code\u003e, and so on), the component is considered equal if and only if \u003ccode\u003e PW.compare(this.c, r.c)\u003c/code\u003e would return \u003ccode\u003e0\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e Apart from the semantics described above, the precise algorithm used in the implicitly provided implementation is unspecified and is subject to change. The implementation may or may not use calls to the particular methods listed, and may or may not perform comparisons in the order of component declaration."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#equals(java.lang.Object,java.lang.Object)\"\u003e\u003ccode\u003eObjects.equals(Object,Object)\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\"\u003eequals\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the reference object with which to compare."
        ],
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if this record is equal to the argument; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "hashCode",
      "comment": "Returns a hash code value for the record. Obeys the general contract of Object.hashCode. For records, hashing behavior is constrained by the refined contract of Record.equals, so that any two records created from the same components must have the same hash code.",
      "tagMap": {
        "implSpec": [
          "The implicitly provided implementation returns a hash code value derived by combining appropriate hashes from each component. The precise algorithm used in the implicitly provided implementation is unspecified and is subject to change within the above limits. The resulting integer need not remain consistent from one execution of an application to another execution of the same application, even if the hashes of the component values were to remain consistent in this way. Also, a component of primitive type may contribute its bits to the hash code differently than the \n\u003ccode\u003ehashCode\u003c/code\u003e of its primitive wrapper class."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()\"\u003ehashCode\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a hash code value for this record."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "toString",
      "comment": "Returns a string representation of the record. In accordance with the general contract of Object.toString(), the toString method returns a string that \"textually represents\" this record. The result should be a concise but informative representation that is easy for a person to read. In addition to this general contract, record classes must further participate in the invariant that any two records which are equal must produce equal strings. This invariant is necessarily relaxed in the rare case where corresponding equal component values might fail to produce equal strings for themselves.",
      "tagMap": {
        "implSpec": [
          "The implicitly provided implementation returns a string which contains the name of the record class, the names of components of the record, and string representations of component values, so as to fulfill the contract of this method. The precise format produced by this implicitly provided implementation is subject to change, so the present syntax should not be parsed by applications to recover record component values."
        ],
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003e\u003ccode\u003eObject.toString()\u003c/code\u003e\u003c/a\u003e"
        ],
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "return": [
          "a string representation of the object."
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Constructor for record classes to call.",
      "tagMap": {}
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "java.lang.Record",
  "comment": "This is the common base class of all Java language record classes. \n\u003cp\u003eMore information about records, including descriptions of the implicitly declared methods synthesized by the compiler, can be found in section 8.10 of \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e. \u003c/p\u003e\n\u003cp\u003eA \u003cem\u003erecord class\u003c/em\u003e is a shallowly immutable, transparent carrier for a fixed set of values, called the \u003cem\u003erecord components\u003c/em\u003e. The Java language provides concise syntax for declaring record classes, whereby the record components are declared in the record header. The list of record components declared in the record header form the \u003cem\u003erecord descriptor\u003c/em\u003e. \u003c/p\u003e\n\u003cp\u003eA record class has the following mandated members: a \u003cem\u003ecanonical constructor\u003c/em\u003e, which must provide at least as much access as the record class and whose descriptor is the same as the record descriptor; a private final field corresponding to each component, whose name and type are the same as that of the component; a public accessor method corresponding to each component, whose name and return type are the same as that of the component. If not explicitly declared in the body of the record, implicit implementations for these members are provided. \u003c/p\u003e\n\u003cp\u003eThe implicit declaration of the canonical constructor has the same accessibility as the record class and initializes the component fields from the corresponding constructor arguments. The implicit declaration of the accessor methods returns the value of the corresponding component field. The implicit declaration of the \u003ca href\u003d\"Object.html#equals(java.lang.Object)\"\u003e\u003ccode\u003eObject.equals(Object)\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"Object.html#hashCode()\"\u003e\u003ccode\u003eObject.hashCode()\u003c/code\u003e\u003c/a\u003e, and \u003ca href\u003d\"Object.html#toString()\"\u003e\u003ccode\u003eObject.toString()\u003c/code\u003e\u003c/a\u003e methods are derived from all of the component fields. \u003c/p\u003e\n\u003cp\u003eThe primary reasons to provide an explicit declaration for the canonical constructor or accessor methods are to validate constructor arguments, perform defensive copies on mutable components, or normalize groups of components (such as reducing a rational number to lowest terms.) \u003c/p\u003e\n\u003cp\u003eFor all record classes, the following invariant must hold: if a record R\u0027s components are \u003ccode\u003ec1, c2, ... cn\u003c/code\u003e, then if a record instance is copied as follows: \u003c/p\u003e\n\u003cpre\u003e     R copy \u003d new R(r.c1(), r.c2(), ..., r.cn());\n \u003c/pre\u003e then it must be the case that \n\u003ccode\u003er.equals(copy)\u003c/code\u003e.\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "See Java Language Specification:": [
      "\u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10\"\u003e8.10 Record Types\u003c/a\u003e\n\u003cbr\u003e"
    ],
    "apiNote": [
      "A record class that \n\u003ccode\u003eimplements\u003c/code\u003e \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/Serializable.html\" title\u003d\"interface in java.io\"\u003e\u003ccode\u003eSerializable\u003c/code\u003e\u003c/a\u003e is said to be a \n\u003ci\u003eserializable record\u003c/i\u003e. Serializable records are serialized and deserialized differently than ordinary serializable objects. During deserialization the record\u0027s canonical constructor is invoked to construct the record object. Certain serialization-related methods, such as readObject and writeObject, are ignored for serializable records. More information about serializable records can be found in the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/serial-arch.html#serialization-of-records\"\u003e \u003ccite\u003eJava Object Serialization Specification,\u003c/cite\u003e Section 1.13, \"Serialization of Records\"\u003c/a\u003e."
    ],
    "since": [
      "16"
    ]
  }
}