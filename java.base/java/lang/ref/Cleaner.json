{
  "packageName": "java.lang.ref",
  "simpleName": "Cleaner",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.ref.Cleaner",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "create",
      "comment": "Returns a new Cleaner. The cleaner creates a daemon thread to process the phantom reachable objects and to invoke cleaning actions. The context class loader of the thread is set to the system class loader. The thread has no permissions, enforced only if a SecurityManager is set. The cleaner terminates when it is phantom reachable and all of the registered cleaning actions are complete.",
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if the current thread is not allowed to create or start the thread."
        ],
        "return": [
          "a new \n\u003ccode\u003eCleaner\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ref.Cleaner",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.concurrent.ThreadFactory",
            "type": "Class"
          },
          "field": {
            "name": "threadFactory"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 9,
      "name": "create",
      "comment": "Returns a new Cleaner using a Thread from the ThreadFactory. A thread from the thread factory\u0027s newThread method is set to be a daemon thread and started to process phantom reachable objects and invoke cleaning actions. On each call the thread factory must provide a Thread that is suitable for performing the cleaning actions. The cleaner terminates when it is phantom reachable and all of the registered cleaning actions are complete.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ethreadFactory\u003c/code\u003e - a \n\u003ccode\u003eThreadFactory\u003c/code\u003e to return a new \n\u003ccode\u003eThread\u003c/code\u003e to process cleaning actions"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalThreadStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalThreadStateException\u003c/a\u003e\u003c/code\u003e - if the thread from the thread factory was \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Thread.State.html#NEW\"\u003e\u003ccode\u003enot a new thread\u003c/code\u003e\u003c/a\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if the current thread is not allowed to create or start the thread."
        ],
        "return": [
          "a new \n\u003ccode\u003eCleaner\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.ref.Cleaner$Cleanable",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "field": {
            "name": "obj"
          }
        },
        {
          "type": {
            "name": "java.lang.Runnable",
            "type": "Class"
          },
          "field": {
            "name": "action"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "register",
      "comment": "Registers an object and a cleaning action to run when the object becomes phantom reachable. Refer to the API Note above for cautions about the behavior of cleaning actions.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eobj\u003c/code\u003e - the object to monitor",
          "\u003ccode\u003eaction\u003c/code\u003e - a \n\u003ccode\u003eRunnable\u003c/code\u003e to invoke when the object becomes phantom reachable"
        ],
        "return": [
          "a \n\u003ccode\u003eCleanable\u003c/code\u003e instance"
        ]
      }
    }
  ],
  "innerClasses": [
    "java.lang.ref.Cleaner$Cleanable"
  ],
  "memberType": "JavaClass",
  "modifiers": 17,
  "name": "java.lang.ref.Cleaner",
  "comment": "\u003ccode\u003eCleaner\u003c/code\u003e manages a set of object references and corresponding cleaning actions. \n\u003cp\u003e Cleaning actions are \u003ca href\u003d\"#register(java.lang.Object,java.lang.Runnable)\"\u003e\u003ccode\u003eregistered\u003c/code\u003e\u003c/a\u003e to run after the cleaner is notified that the object has become phantom reachable. The cleaner uses \u003ca href\u003d\"PhantomReference.html\" title\u003d\"class in java.lang.ref\"\u003e\u003ccode\u003ePhantomReference\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"ReferenceQueue.html\" title\u003d\"class in java.lang.ref\"\u003e\u003ccode\u003eReferenceQueue\u003c/code\u003e\u003c/a\u003e to be notified when the \u003ca href\u003d\"package-summary.html#reachability\"\u003ereachability\u003c/a\u003e changes. \u003c/p\u003e\n\u003cp\u003e Each cleaner operates independently, managing the pending cleaning actions and handling threading and termination when the cleaner is no longer in use. Registering an object reference and corresponding cleaning action returns a \u003ca href\u003d\"Cleaner.Cleanable.html\" title\u003d\"interface in java.lang.ref\"\u003e\u003ccode\u003eCleanable\u003c/code\u003e\u003c/a\u003e. The most efficient use is to explicitly invoke the \u003ca href\u003d\"Cleaner.Cleanable.html#clean()\"\u003e\u003ccode\u003eclean\u003c/code\u003e\u003c/a\u003e method when the object is closed or no longer needed. The cleaning action is a \u003ca href\u003d\"../Runnable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eRunnable\u003c/code\u003e\u003c/a\u003e to be invoked at most once when the object has become phantom reachable unless it has already been explicitly cleaned. Note that the cleaning action must not refer to the object being registered. If so, the object will not become phantom reachable and the cleaning action will not be invoked automatically. \u003c/p\u003e\n\u003cp\u003e The execution of the cleaning action is performed by a thread associated with the cleaner. All exceptions thrown by the cleaning action are ignored. The cleaner and other cleaning actions are not affected by exceptions in a cleaning action. The thread runs until all registered cleaning actions have completed and the cleaner itself is reclaimed by the garbage collector. \u003c/p\u003e\n\u003cp\u003e The behavior of cleaners during \u003ca href\u003d\"../System.html#exit(int)\"\u003e\u003ccode\u003eSystem.exit\u003c/code\u003e\u003c/a\u003e is implementation specific. No guarantees are made relating to whether cleaning actions are invoked or not. \u003c/p\u003e\n\u003cp\u003e Unless otherwise noted, passing a \u003ccode\u003enull\u003c/code\u003e argument to a constructor or method in this class will cause a \u003ca href\u003d\"../NullPointerException.html\" title\u003d\"class in java.lang\"\u003e\u003ccode\u003eNullPointerException\u003c/code\u003e\u003c/a\u003e to be thrown.\u003c/p\u003e",
  "tagMap": {
    "apiNote": [
      "The cleaning action is invoked only after the associated object becomes phantom reachable, so it is important that the object implementing the cleaning action does not hold references to the object. In this example, a static class encapsulates the cleaning state and action. An \"inner\" class, anonymous or not, must not be used because it implicitly contains a reference to the outer instance, preventing it from becoming phantom reachable. The choice of a new cleaner or sharing an existing cleaner is determined by the use case. \n\u003cp\u003e If the CleaningExample is used in a try-finally block then the \u003ccode\u003eclose\u003c/code\u003e method calls the cleaning action. If the \u003ccode\u003eclose\u003c/code\u003e method is not called, the cleaning action is called by the Cleaner when the CleaningExample instance has become phantom reachable. \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n public class CleaningExample implements AutoCloseable {\n        // A cleaner, preferably one shared within a library\n        private static final Cleaner cleaner \u003d \u0026lt;cleaner\u0026gt;;\n\n        static class State implements Runnable {\n\n            State(...) {\n                // initialize State needed for cleaning action\n            }\n\n            public void run() {\n                // cleanup action accessing State, executed at most once\n            }\n        }\n\n        private final State state;\n        private final Cleaner.Cleanable cleanable;\n\n        public CleaningExample() {\n            this.state \u003d new State(...);\n            this.cleanable \u003d cleaner.register(this, state);\n        }\n\n        public void close() {\n            cleanable.clean();\n        }\n    }\n \u003c/code\u003e\u003c/pre\u003e The cleaning action could be a lambda but all too easily will capture the object reference, by referring to fields of the object being cleaned, preventing the object from becoming phantom reachable. Using a static nested class, as above, will avoid accidentally retaining the object reference. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e \u003ca id\u003d\"compatible-cleaners\" href\u003d\"\"\u003e\u003c/a\u003e Cleaning actions should be prepared to be invoked concurrently with other cleaning actions. Typically the cleaning actions should be very quick to execute and not block. If the cleaning action blocks, it may delay processing other cleaning actions registered to the same cleaner. All cleaning actions registered to a cleaner should be mutually compatible.\u003c/p\u003e"
    ],
    "since": [
      "9"
    ]
  }
}