{
  "packageName": "javax.crypto",
  "simpleName": "SealedObject",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "memberType": "JavaField",
      "modifiers": 4,
      "name": "encodedParams",
      "comment": "The cryptographic parameters used by the sealing Cipher, encoded in the default format. That is, cipher.getParameters().getEncoded().",
      "tagMap": {}
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAlgorithm",
      "comment": "Returns the algorithm that was used to seal this object.",
      "tagMap": {
        "return": [
          "the algorithm that was used to seal this object."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "java.lang.ClassNotFoundException",
          "type": "Class"
        },
        {
          "name": "java.security.NoSuchAlgorithmException",
          "type": "Class"
        },
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.security.Key",
            "type": "Class"
          },
          "field": {
            "name": "key"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getObject",
      "comment": "Retrieves the original (encapsulated) object. This method creates a cipher for the algorithm that had been used in the sealing operation. If the default provider package provides an implementation of that algorithm, an instance of Cipher containing that implementation is used. If the algorithm is not available in the default package, other packages are searched. The Cipher object is initialized for decryption, using the given key and the parameters (if any) that had been used in the sealing operation. The encapsulated object is unsealed and de-serialized, before it is returned.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ekey\u003c/code\u003e - the key used to unseal the object."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an error occurs during de-serialiazation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassNotFoundException.html\" title\u003d\"class in java.lang\"\u003eClassNotFoundException\u003c/a\u003e\u003c/code\u003e - if an error occurs during de-serialiazation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if the algorithm to unseal the object is not available.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key cannot be used to unseal the object (e.g., it has the wrong algorithm).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ekey\u003c/code\u003e is null."
        ],
        "return": [
          "the original object."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "java.lang.ClassNotFoundException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.IllegalBlockSizeException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.BadPaddingException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "javax.crypto.Cipher",
            "type": "Class"
          },
          "field": {
            "name": "c"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getObject",
      "comment": "Retrieves the original (encapsulated) object. The encapsulated object is unsealed (using the given Cipher, assuming that the Cipher is already properly initialized) and de-serialized, before it is returned.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ec\u003c/code\u003e - the cipher used to unseal the object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the given cipher is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an error occurs during de-serialiazation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassNotFoundException.html\" title\u003d\"class in java.lang\"\u003eClassNotFoundException\u003c/a\u003e\u003c/code\u003e - if an error occurs during de-serialiazation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if the given cipher is a block cipher, no padding has been requested, and the total input length is not a multiple of the cipher\u0027s block size",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if the given cipher has been initialized for decryption, and padding has been specified, but the input data does not have proper expected padding bytes"
        ],
        "return": [
          "the original object."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "java.lang.ClassNotFoundException",
          "type": "Class"
        },
        {
          "name": "java.security.NoSuchAlgorithmException",
          "type": "Class"
        },
        {
          "name": "java.security.NoSuchProviderException",
          "type": "Class"
        },
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.security.Key",
            "type": "Class"
          },
          "field": {
            "name": "key"
          }
        },
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "provider"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getObject",
      "comment": "Retrieves the original (encapsulated) object. This method creates a cipher for the algorithm that had been used in the sealing operation, using an implementation of that algorithm from the given provider. The Cipher object is initialized for decryption, using the given key and the parameters (if any) that had been used in the sealing operation. The encapsulated object is unsealed and de-serialized, before it is returned.",
      "tagMap": {
        "param": [
          "\u003ccode\u003ekey\u003c/code\u003e - the key used to unseal the object.",
          "\u003ccode\u003eprovider\u003c/code\u003e - the name of the provider of the algorithm to unseal the object."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the given provider is null or empty.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an error occurs during de-serialiazation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/ClassNotFoundException.html\" title\u003d\"class in java.lang\"\u003eClassNotFoundException\u003c/a\u003e\u003c/code\u003e - if an error occurs during de-serialiazation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if the algorithm to unseal the object is not available.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchProviderException.html\" title\u003d\"class in java.security\"\u003eNoSuchProviderException\u003c/a\u003e\u003c/code\u003e - if the given provider is not configured.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key cannot be used to unseal the object (e.g., it has the wrong algorithm).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ekey\u003c/code\u003e is null."
        ],
        "return": [
          "the original object."
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.IllegalBlockSizeException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.io.Serializable",
            "type": "Class"
          },
          "field": {
            "name": "object"
          }
        },
        {
          "type": {
            "name": "javax.crypto.Cipher",
            "type": "Class"
          },
          "field": {
            "name": "c"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructs a SealedObject from any Serializable object. The given object is serialized, and its serialized contents are encrypted using the given Cipher, which must be fully initialized. Any algorithm parameters that may be used in the encryption operation are stored inside of the new SealedObject.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eobject\u003c/code\u003e - the object to be sealed; can be null.",
          "\u003ccode\u003ec\u003c/code\u003e - the cipher used to seal the object."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the given cipher is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an error occurs during serialization",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if the given cipher is a block cipher, no padding has been requested, and the total input length (i.e., the length of the serialized object contents) is not a multiple of the cipher\u0027s block size"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "javax.crypto.SealedObject",
            "type": "Class"
          },
          "field": {
            "name": "so"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Constructs a SealedObject object from the passed-in SealedObject.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eso\u003c/code\u003e - a SealedObject object"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if the given sealed object is null."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.crypto.SealedObject",
  "comment": "This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm. \n\u003cp\u003e Given any Serializable object, one can create a SealedObject that encapsulates the original object, in serialized format (i.e., a \"deep copy\"), and seals (encrypts) its serialized contents, using a cryptographic algorithm such as AES, to protect its confidentiality. The encrypted content can later be decrypted (with the corresponding algorithm using the correct decryption key) and de-serialized, yielding the original object. \u003c/p\u003e\n\u003cp\u003e Note that the Cipher object must be fully initialized with the correct algorithm, key, padding scheme, etc., before being applied to a SealedObject. \u003c/p\u003e\n\u003cp\u003e The original object that was sealed can be recovered in two different ways: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eby using the \u003ca href\u003d\"#getObject(javax.crypto.Cipher)\"\u003e\u003ccode\u003egetObject\u003c/code\u003e\u003c/a\u003e method that takes a \u003ccode\u003eCipher\u003c/code\u003e object. \u003cp\u003e This method requires a fully initialized \u003ccode\u003eCipher\u003c/code\u003e object, initialized with the exact same algorithm, key, padding scheme, etc., that were used to seal the object. \u003c/p\u003e\u003cp\u003e This approach has the advantage that the party who unseals the sealed object does not require knowledge of the decryption key. For example, after one party has initialized the cipher object with the required decryption key, it could hand over the cipher object to another party who then unseals the sealed object. \u003c/p\u003e\u003c/li\u003e\n \u003cli\u003eby using one of the \u003ca href\u003d\"#getObject(java.security.Key)\"\u003e\u003ccode\u003egetObject\u003c/code\u003e\u003c/a\u003e methods that take a \u003ccode\u003eKey\u003c/code\u003e object. \u003cp\u003e In this approach, the \u003ccode\u003egetObject\u003c/code\u003e method creates a cipher object for the appropriate decryption algorithm and initializes it with the given decryption key and the algorithm parameters (if any) that were stored in the sealed object. \u003c/p\u003e\u003cp\u003e This approach has the advantage that the party who unseals the object does not need to keep track of the parameters (e.g., an IV) that were used to seal the object. \u003c/p\u003e\u003c/li\u003e\n \u003cp\u003e\u003c/p\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/Cipher.html\" title\u003d\"class in javax.crypto\"\u003e\u003ccode\u003eCipher\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/serialized-form.html#javax.crypto.SealedObject\"\u003eSerialized Form\u003c/a\u003e"
    ],
    "since": [
      "1.4"
    ]
  }
}