{
  "packageName": "javax.crypto",
  "simpleName": "Cipher",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "ENCRYPT_MODE",
      "comment": "Constant used to initialize cipher to encryption mode.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.crypto.Cipher.ENCRYPT_MODE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "DECRYPT_MODE",
      "comment": "Constant used to initialize cipher to decryption mode.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.crypto.Cipher.DECRYPT_MODE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "WRAP_MODE",
      "comment": "Constant used to initialize cipher to key-wrapping mode.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.crypto.Cipher.WRAP_MODE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "UNWRAP_MODE",
      "comment": "Constant used to initialize cipher to key-unwrapping mode.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.crypto.Cipher.UNWRAP_MODE\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "PUBLIC_KEY",
      "comment": "Constant used to indicate the to-be-unwrapped key is a \"public key\".",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.crypto.Cipher.PUBLIC_KEY\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "PRIVATE_KEY",
      "comment": "Constant used to indicate the to-be-unwrapped key is a \"private key\".",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.crypto.Cipher.PRIVATE_KEY\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "type": {
        "name": "int",
        "type": "Class"
      },
      "memberType": "JavaField",
      "modifiers": 25,
      "name": "SECRET_KEY",
      "comment": "Constant used to indicate the to-be-unwrapped key is a \"secret key\".",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/constant-values.html#javax.crypto.Cipher.SECRET_KEY\"\u003eConstant Field Values\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.crypto.Cipher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "getInstance",
      "comment": "Returns a Cipher object that implements the specified transformation. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new Cipher object encapsulating the CipherSpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the Security.getProviders() method.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/Provider.html\" title\u003d\"class in java.security\"\u003e\u003ccode\u003eProvider\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application."
        ],
        "param": [
          "\u003ccode\u003etransformation\u003c/code\u003e - the name of the transformation, e.g., \n\u003ci\u003eAES/CBC/PKCS5Padding\u003c/i\u003e. See the Cipher section in the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/specs/security/standard-names.html#cipher-algorithm-names\"\u003e Java Security Standard Algorithm Names Specification\u003c/a\u003e for information about standard transformation names."
        ],
        "implNote": [
          "The JDK Reference Implementation additionally uses the \n\u003ccode\u003ejdk.security.provider.preferred\u003c/code\u003e \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/Security.html#getProperty(java.lang.String)\"\u003e\u003ccode\u003eSecurity\u003c/code\u003e\u003c/a\u003e property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/Security.html#getProviders()\"\u003e\u003ccode\u003eSecurity.getProviders()\u003c/code\u003e\u003c/a\u003e. See also the Cipher Transformations section of the \n\u003ca href\u003d\"https://docs.oracle.com/pls/topic/lookup?ctx\u003djavase16\u0026amp;id\u003dsecurity_guide_jdk_providers\"\u003eJDK Providers\u003c/a\u003e document for information on the transformation defaults used by JDK providers."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e, empty, in an invalid format, or if no \n\u003ccode\u003eProvider\u003c/code\u003e supports a \n\u003ccode\u003eCipherSpi\u003c/code\u003e implementation for the specified algorithm",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/NoSuchPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eNoSuchPaddingException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e contains a padding scheme that is not available"
        ],
        "return": [
          "a cipher that implements the requested transformation"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.crypto.Cipher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "getInstance",
      "comment": "Returns a Cipher object that implements the specified transformation. A new Cipher object encapsulating the CipherSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the Security.getProviders() method.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/Provider.html\" title\u003d\"class in java.security\"\u003e\u003ccode\u003eProvider\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application."
        ],
        "param": [
          "\u003ccode\u003etransformation\u003c/code\u003e - the name of the transformation, e.g., \n\u003ci\u003eAES/CBC/PKCS5Padding\u003c/i\u003e. See the Cipher section in the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/specs/security/standard-names.html#cipher-algorithm-names\"\u003e Java Security Standard Algorithm Names Specification\u003c/a\u003e for information about standard transformation names.",
          "\u003ccode\u003eprovider\u003c/code\u003e - the name of the provider."
        ],
        "implNote": [
          "See the Cipher Transformations section of the \n\u003ca href\u003d\"https://docs.oracle.com/pls/topic/lookup?ctx\u003djavase16\u0026amp;id\u003dsecurity_guide_jdk_providers\"\u003eJDK Providers\u003c/a\u003e document for information on the transformation defaults used by JDK providers."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003eprovider\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e or empty",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e, empty, in an invalid format, or if a \n\u003ccode\u003eCipherSpi\u003c/code\u003e implementation for the specified algorithm is not available from the specified provider",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/NoSuchPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eNoSuchPaddingException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e contains a padding scheme that is not available",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchProviderException.html\" title\u003d\"class in java.security\"\u003eNoSuchProviderException\u003c/a\u003e\u003c/code\u003e - if the specified provider is not registered in the security provider list"
        ],
        "return": [
          "a cipher that implements the requested transformation"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.crypto.Cipher",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "getInstance",
      "comment": "Returns a Cipher object that implements the specified transformation. A new Cipher object encapsulating the CipherSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/Provider.html\" title\u003d\"class in java.security\"\u003e\u003ccode\u003eProvider\u003c/code\u003e\u003c/a\u003e"
        ],
        "apiNote": [
          "It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application."
        ],
        "param": [
          "\u003ccode\u003etransformation\u003c/code\u003e - the name of the transformation, e.g., \n\u003ci\u003eAES/CBC/PKCS5Padding\u003c/i\u003e. See the Cipher section in the \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/specs/security/standard-names.html#cipher-algorithm-names\"\u003e Java Security Standard Algorithm Names Specification\u003c/a\u003e for information about standard transformation names.",
          "\u003ccode\u003eprovider\u003c/code\u003e - the provider."
        ],
        "implNote": [
          "See the Cipher Transformations section of the \n\u003ca href\u003d\"https://docs.oracle.com/pls/topic/lookup?ctx\u003djavase16\u0026amp;id\u003dsecurity_guide_jdk_providers\"\u003eJDK Providers\u003c/a\u003e document for information on the transformation defaults used by JDK providers."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003eprovider\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e, empty, in an invalid format, or if a \n\u003ccode\u003eCipherSpi\u003c/code\u003e implementation for the specified algorithm is not available from the specified \n\u003ccode\u003eProvider\u003c/code\u003e object",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/NoSuchPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eNoSuchPaddingException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e contains a padding scheme that is not available"
        ],
        "return": [
          "a cipher that implements the requested transformation"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.security.Provider",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getProvider",
      "comment": "Returns the provider of this Cipher object.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the provider of this \n\u003ccode\u003eCipher\u003c/code\u003e object"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getAlgorithm",
      "comment": "Returns the algorithm name of this Cipher object. This is the same name that was specified in one of the getInstance calls that created this Cipher object..",
      "annotations": [],
      "tagMap": {
        "return": [
          "the algorithm name of this \n\u003ccode\u003eCipher\u003c/code\u003e object."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getBlockSize",
      "comment": "Returns the block size (in bytes).",
      "annotations": [],
      "tagMap": {
        "return": [
          "the block size (in bytes), or 0 if the underlying algorithm is not a block cipher"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getOutputSize",
      "comment": "Returns the length in bytes that an output buffer would need to be in order to hold the result of the next update or doFinal operation, given the input length inputLen (in bytes). This call takes into account any unprocessed (buffered) data from a previous update call, padding, and AEAD tagging. The actual output length of the next update or doFinal call may be smaller than the length returned by this method.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length (in bytes)"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not yet been initialized)"
        ],
        "return": [
          "the required output buffer size (in bytes)"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getIV",
      "comment": "Returns the initialization vector (IV) in a new buffer. This is useful in the case where a random IV was created, or in the context of password-based encryption or decryption, where the IV is derived from a user-supplied password.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the initialization vector in a new buffer, or null if the underlying algorithm does not use an IV, or if the IV has not yet been set."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.security.AlgorithmParameters",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getParameters",
      "comment": "Returns the parameters used with this cipher. The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the parameters used with this cipher, or null if this cipher does not use any parameters."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.crypto.ExemptionMechanism",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "getExemptionMechanism",
      "comment": "Returns the exemption mechanism object used with this cipher.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the exemption mechanism object used with this cipher, or null if this cipher does not use any exemption mechanism."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with a key. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters that cannot be derived from the given key, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidKeyException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the SecureRandom implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the key"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with a key and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters that cannot be derived from the given key, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidKeyException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003erandom\u003c/code\u003e - the source of randomness"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with a key and a set of algorithm parameters. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the SecureRandom implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003eparams\u003c/code\u003e - the algorithm parameters"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidAlgorithmParameterException.html\" title\u003d\"class in java.security\"\u003eInvalidAlgorithmParameterException\u003c/a\u003e\u003c/code\u003e - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and \n\u003ccode\u003eparams\u003c/code\u003e is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003eparams\u003c/code\u003e - the algorithm parameters",
          "\u003ccode\u003erandom\u003c/code\u003e - the source of randomness"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidAlgorithmParameterException.html\" title\u003d\"class in java.security\"\u003eInvalidAlgorithmParameterException\u003c/a\u003e\u003c/code\u003e - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and \n\u003ccode\u003eparams\u003c/code\u003e is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with a key and a set of algorithm parameters. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the SecureRandom implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003eparams\u003c/code\u003e - the algorithm parameters"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidAlgorithmParameterException.html\" title\u003d\"class in java.security\"\u003eInvalidAlgorithmParameterException\u003c/a\u003e\u003c/code\u003e - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and \n\u003ccode\u003eparams\u003c/code\u003e is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003eparams\u003c/code\u003e - the algorithm parameters",
          "\u003ccode\u003erandom\u003c/code\u003e - the source of randomness"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidAlgorithmParameterException.html\" title\u003d\"class in java.security\"\u003eInvalidAlgorithmParameterException\u003c/a\u003e\u003c/code\u003e - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and \n\u003ccode\u003eparams\u003c/code\u003e is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with the public key from the given certificate. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If the certificate is of type X.509 and has a key usage extension field marked as critical, and the value of the key usage extension field implies that the public key in the certificate and its corresponding private key are not supposed to be used for the operation represented by the value of opmode, an InvalidKeyException is thrown. If this cipher requires any algorithm parameters that cannot be derived from the public key in the given certificate, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidKeyException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the SecureRandom implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ecertificate\u003c/code\u003e - the certificate"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the public key in the given certificate is inappropriate for initializing this cipher, or this cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "init",
      "comment": "Initializes this cipher with the public key from the given certificate and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If the certificate is of type X.509 and has a key usage extension field marked as critical, and the value of the key usage extension field implies that the public key in the certificate and its corresponding private key are not supposed to be used for the operation represented by the value of opmode, an InvalidKeyException is thrown. If this cipher requires any algorithm parameters that cannot be derived from the public key in the given certificate, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidKeyException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using getParameters or getIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ecertificate\u003c/code\u003e - the certificate",
          "\u003ccode\u003erandom\u003c/code\u003e - the source of randomness"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the public key in the given certificate is inappropriate for initializing this cipher, or this cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e but the mode is not implemented by the underlying \n\u003ccode\u003eCipherSpi\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "update",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The bytes in the input buffer are processed, and the result is stored in a new buffer. If input has a length of zero, this method returns null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)"
        ],
        "return": [
          "the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block."
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "update",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in a new buffer. If inputLen is zero, this method returns null.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)"
        ],
        "return": [
          "the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "update",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in the output buffer. If the output buffer is too small to hold the result, a ShortBufferException is thrown. In this case, repeat this call with a larger output buffer. Use getOutputSize to determine how big the output buffer should be. If inputLen is zero, this method returns a length of zero. Note: this method should be copy-safe, which means the input and output buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length",
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the result"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if the given output buffer is too small to hold the result"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "update",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown. In this case, repeat this call with a larger output buffer. Use getOutputSize to determine how big the output buffer should be. If inputLen is zero, this method returns a length of zero. Note: this method should be copy-safe, which means the input and output buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length",
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the result",
          "\u003ccode\u003eoutputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003eoutput\u003c/code\u003e where the result is stored"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if the given output buffer is too small to hold the result"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "update",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. All input.remaining() bytes starting at input.position() are processed. The result is stored in the output buffer. Upon return, the input buffer\u0027s position will be equal to its limit; its limit will not have changed. The output buffer\u0027s position will have advanced by n, where n is the value returned by this method; the output buffer\u0027s limit will not have changed. If output.remaining() bytes are insufficient to hold the result, a ShortBufferException is thrown. In this case, repeat this call with a larger output buffer. Use getOutputSize to determine how big the output buffer should be. Note: this method should be copy-safe, which means the input and output buffers can reference the same block of memory and no unprocessed input data is overwritten when the result is copied into the output buffer.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input ByteBuffer",
          "\u003ccode\u003eoutput\u003c/code\u003e - the output ByteByffer"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if input and output are the same object",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the output buffer is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if there is insufficient space in the output buffer"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "doFinal",
      "comment": "Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized. Input data that may have been buffered during a previous update operation is processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to init. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.",
      "annotations": [],
      "tagMap": {
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the new buffer with the result"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "doFinal",
      "comment": "Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized. Input data that may have been buffered during a previous update operation is processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown. In this case, repeat this call with a larger output buffer. Use getOutputSize to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to init. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the result",
          "\u003ccode\u003eoutputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003eoutput\u003c/code\u003e where the result is stored"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if the given output buffer is too small to hold the result",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "doFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The bytes in the input buffer, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to init. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the new buffer with the result"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "doFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to init. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the new buffer with the result"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "doFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer. If the output buffer is too small to hold the result, a ShortBufferException is thrown. In this case, repeat this call with a larger output buffer. Use getOutputSize to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to init. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the input and output buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length",
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the result"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if the given output buffer is too small to hold the result",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "doFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown. In this case, repeat this call with a larger output buffer. Use getOutputSize to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to init. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the input and output buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length",
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the result",
          "\u003ccode\u003eoutputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003eoutput\u003c/code\u003e where the result is stored"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if the given output buffer is too small to hold the result",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "doFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. All input.remaining() bytes starting at input.position() are processed. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer. Upon return, the input buffer\u0027s position will be equal to its limit; its limit will not have changed. The output buffer\u0027s position will have advanced by n, where n is the value returned by this method; the output buffer\u0027s limit will not have changed. If output.remaining() bytes are insufficient to hold the result, a ShortBufferException is thrown. In this case, repeat this call with a larger output buffer. Use getOutputSize to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to init. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the input and output buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input ByteBuffer",
          "\u003ccode\u003eoutput\u003c/code\u003e - the output ByteBuffer"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized)",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if input and output are the same object",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the output buffer is read-only",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if there is insufficient space in the output buffer",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "wrap",
      "comment": "Wrap a key.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ekey\u003c/code\u003e - the key to be wrapped."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested, and the length of the encoding of the key to be wrapped is not a multiple of the block size.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if it is impossible or unsafe to wrap the key with this cipher (e.g., a hardware protected key is being passed to a software-only cipher).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the corresponding method in the \n\u003ccode\u003eCipherSpi\u003c/code\u003e is not supported."
        ],
        "return": [
          "the wrapped key."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.security.Key",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "unwrap",
      "comment": "Unwrap a previously wrapped key.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ewrappedKey\u003c/code\u003e - the key to be unwrapped.",
          "\u003ccode\u003ewrappedKeyAlgorithm\u003c/code\u003e - the algorithm associated with the wrapped key.",
          "\u003ccode\u003ewrappedKeyType\u003c/code\u003e - the type of the wrapped key. This must be one of \n\u003ccode\u003eSECRET_KEY\u003c/code\u003e, \n\u003ccode\u003ePRIVATE_KEY\u003c/code\u003e, or \n\u003ccode\u003ePUBLIC_KEY\u003c/code\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if no installed providers can create keys of type \n\u003ccode\u003ewrappedKeyType\u003c/code\u003e for the \n\u003ccode\u003ewrappedKeyAlgorithm\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ewrappedKey\u003c/code\u003e does not represent a wrapped key of type \n\u003ccode\u003ewrappedKeyType\u003c/code\u003e for the \n\u003ccode\u003ewrappedKeyAlgorithm\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the corresponding method in the \n\u003ccode\u003eCipherSpi\u003c/code\u003e is not supported."
        ],
        "return": [
          "the unwrapped key."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "getMaxAllowedKeyLength",
      "comment": "Returns the maximum key length for the specified transformation according to the installed JCE jurisdiction policy files. If JCE unlimited strength jurisdiction policy files are installed, Integer.MAX_VALUE will be returned. For more information on the default key sizes and the JCE jurisdiction policy files, please see the Cryptographic defaults and limitations in the JDK Providers Documentation.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etransformation\u003c/code\u003e - the cipher transformation."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e is not a valid transformation, i.e. in the form of \"algorithm\" or \"algorithm/mode/padding\"."
        ],
        "return": [
          "the maximum key length in bits or Integer.MAX_VALUE."
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.security.spec.AlgorithmParameterSpec",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 25,
      "name": "getMaxAllowedParameterSpec",
      "comment": "Returns an AlgorithmParameterSpec object which contains the maximum cipher parameter value according to the jurisdiction policy file. If JCE unlimited strength jurisdiction policy files are installed or there is no maximum limit on the parameters for the specified transformation in the policy file, null will be returned.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003etransformation\u003c/code\u003e - the cipher transformation."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003etransformation\u003c/code\u003e is not a valid transformation, i.e. in the form of \"algorithm\" or \"algorithm/mode/padding\"."
        ],
        "return": [
          "an AlgorithmParameterSpec which holds the maximum value or null."
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "updateAAD",
      "comment": "Continues a multi-part update of the Additional Authentication Data (AAD). Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods).",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - the buffer containing the Additional Authentication Data"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003esrc\u003c/code\u003e byte array is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the \n\u003ccode\u003eupdate\u003c/code\u003e methods has already been called for the active encryption/decryption operation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the corresponding method in the \n\u003ccode\u003eCipherSpi\u003c/code\u003e has not been overridden by an implementation"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "updateAAD",
      "comment": "Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer. Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods).",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - the buffer containing the AAD",
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset in \n\u003ccode\u003esrc\u003c/code\u003e where the AAD input starts",
          "\u003ccode\u003elen\u003c/code\u003e - the number of AAD bytes"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003esrc\u003c/code\u003e byte array is null, or the \n\u003ccode\u003eoffset\u003c/code\u003e or \n\u003ccode\u003elength\u003c/code\u003e is less than 0, or the sum of the \n\u003ccode\u003eoffset\u003c/code\u003e and \n\u003ccode\u003elen\u003c/code\u003e is greater than the length of the \n\u003ccode\u003esrc\u003c/code\u003e byte array",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the \n\u003ccode\u003eupdate\u003c/code\u003e methods has already been called for the active encryption/decryption operation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the corresponding method in the \n\u003ccode\u003eCipherSpi\u003c/code\u003e has not been overridden by an implementation"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 17,
      "name": "updateAAD",
      "comment": "Continues a multi-part update of the Additional Authentication Data (AAD). Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods). All src.remaining() bytes starting at src.position() are processed. Upon return, the input buffer\u0027s position will be equal to its limit; its limit will not have changed.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - the buffer containing the AAD"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003esrc ByteBuffer\u003c/code\u003e is null",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the \n\u003ccode\u003eupdate\u003c/code\u003e methods has already been called for the active encryption/decryption operation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the corresponding method in the \n\u003ccode\u003eCipherSpi\u003c/code\u003e has not been overridden by an implementation"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "toString",
      "comment": "Returns a String representation of this Cipher.",
      "annotations": [],
      "tagMap": {
        "Overrides:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()\"\u003etoString\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in class\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html\" title\u003d\"class in java.lang\"\u003eObject\u003c/a\u003e\u003c/code\u003e"
        ],
        "implNote": [
          "This implementation returns a String containing the transformation, mode, and provider of this Cipher. The exact format of the String is unspecified and is subject to change."
        ],
        "return": [
          "a String describing this Cipher"
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.crypto.CipherSpi",
            "type": "Class"
          },
          "name": "cipherSpi",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.Provider",
            "type": "Class"
          },
          "name": "provider",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "name": "transformation",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Creates a Cipher object.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ecipherSpi\u003c/code\u003e - the delegate",
          "\u003ccode\u003eprovider\u003c/code\u003e - the provider",
          "\u003ccode\u003etransformation\u003c/code\u003e - the transformation"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eprovider\u003c/code\u003e is \n\u003ccode\u003enull\u003c/code\u003e",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the supplied arguments are deemed invalid for constructing the Cipher object"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.crypto.Cipher",
  "comment": "This class provides the functionality of a cryptographic cipher for encryption and decryption. It forms the core of the Java Cryptographic Extension (JCE) framework. \n\u003cp\u003eIn order to create a Cipher object, the application calls the Cipher\u0027s \u003ccode\u003egetInstance\u003c/code\u003e method, and passes the name of the requested \u003ci\u003etransformation\u003c/i\u003e to it. Optionally, the name of a provider may be specified. \u003c/p\u003e\n\u003cp\u003eA \u003ci\u003etransformation\u003c/i\u003e is a string that describes the operation (or set of operations) to be performed on the given input, to produce some output. A transformation always includes the name of a cryptographic algorithm (e.g., \u003ci\u003eAES\u003c/i\u003e), and may be followed by a feedback mode and padding scheme. \u003c/p\u003e\n\u003cp\u003e A transformation is of the form: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\"\u003ci\u003ealgorithm/mode/padding\u003c/i\u003e\" or \u003c/li\u003e\n \u003cli\u003e\"\u003ci\u003ealgorithm\u003c/i\u003e\" \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e (in the latter case, provider-specific default values for the mode and padding scheme are used). For example, the following is a valid transformation: \u003c/p\u003e\n\u003cpre\u003e     Cipher c \u003d Cipher.getInstance(\"\u003ci\u003eAES/CBC/PKCS5Padding\u003c/i\u003e\");\n \u003c/pre\u003e Using modes such as \n\u003ccode\u003eCFB\u003c/code\u003e and \n\u003ccode\u003eOFB\u003c/code\u003e, block ciphers can encrypt data in units smaller than the cipher\u0027s actual block size. When requesting such a mode, you may optionally specify the number of bits to be processed at a time by appending this number to the mode name as shown in the \"\n\u003ccode\u003eAES/CFB8/NoPadding\u003c/code\u003e\" and \"\n\u003ccode\u003eAES/OFB32/PKCS5Padding\u003c/code\u003e\" transformations. If no such number is specified, a provider-specific default is used. (See the \n\u003ca href\u003d\"https://docs.oracle.com/pls/topic/lookup?ctx\u003djavase16\u0026amp;id\u003dsecurity_guide_jdk_providers\"\u003eJDK Providers Documentation\u003c/a\u003e for the JDK Providers default values.) Thus, block ciphers can be turned into byte-oriented stream ciphers by using an 8 bit mode such as CFB8 or OFB8. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Modes such as Authenticated Encryption with Associated Data (AEAD) provide authenticity assurances for both confidential data and Additional Associated Data (AAD) that is not encrypted. (Please see \u003ca href\u003d\"http://www.ietf.org/rfc/rfc5116.txt\"\u003e RFC 5116 \u003c/a\u003e for more information on AEAD and AAD algorithms such as GCM/CCM.) Both confidential and AAD data can be used when calculating the authentication tag (similar to a \u003ca href\u003d\"Mac.html\" title\u003d\"class in javax.crypto\"\u003e\u003ccode\u003eMac\u003c/code\u003e\u003c/a\u003e). This tag is appended to the ciphertext during encryption, and is verified on decryption. \u003c/p\u003e\n\u003cp\u003e AEAD modes such as GCM/CCM perform all AAD authenticity calculations before starting the ciphertext authenticity calculations. To avoid implementations having to internally buffer ciphertext, all AAD data must be supplied to GCM/CCM implementations (via the \u003ccode\u003eupdateAAD\u003c/code\u003e methods) \u003cb\u003ebefore\u003c/b\u003e the ciphertext is processed (via the \u003ccode\u003eupdate\u003c/code\u003e and \u003ccode\u003edoFinal\u003c/code\u003e methods). \u003c/p\u003e\n\u003cp\u003e Note that GCM mode has a uniqueness requirement on IVs used in encryption with a given key. When IVs are repeated for GCM encryption, such usages are subject to forgery attacks. Thus, after each encryption operation using GCM mode, callers should re-initialize the cipher objects with GCM parameters which have a different IV value. \u003c/p\u003e\n\u003cpre\u003e     GCMParameterSpec s \u003d ...;\n     cipher.init(..., s);\n\n     // If the GCM parameters were generated by the provider, it can\n     // be retrieved by:\n     // cipher.getParameters().getParameterSpec(GCMParameterSpec.class);\n\n     cipher.updateAAD(...);  // AAD\n     cipher.update(...);     // Multi-part update\n     cipher.doFinal(...);    // conclusion of operation\n\n     // Use a different IV value for every encryption\n     byte[] newIv \u003d ...;\n     s \u003d new GCMParameterSpec(s.getTLen(), newIv);\n     cipher.init(..., s);\n     ...\n\n \u003c/pre\u003e The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement for unique nonces with a given key. After each encryption or decryption operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305 ciphers with parameters that specify a different nonce value. Please see \n\u003ca href\u003d\"https://tools.ietf.org/html/rfc7539\"\u003eRFC 7539\u003c/a\u003e for more information on the ChaCha20 and ChaCha20-Poly1305 algorithms. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Every implementation of the Java platform is required to support the following standard \u003ccode\u003eCipher\u003c/code\u003e transformations with the keysizes in parentheses: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ccode\u003eAES/CBC/NoPadding\u003c/code\u003e (128)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eAES/CBC/PKCS5Padding\u003c/code\u003e (128)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eAES/ECB/NoPadding\u003c/code\u003e (128)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eAES/ECB/PKCS5Padding\u003c/code\u003e (128)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eAES/GCM/NoPadding\u003c/code\u003e (128)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eDESede/CBC/NoPadding\u003c/code\u003e (168)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eDESede/CBC/PKCS5Padding\u003c/code\u003e (168)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eDESede/ECB/NoPadding\u003c/code\u003e (168)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eDESede/ECB/PKCS5Padding\u003c/code\u003e (168)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eRSA/ECB/PKCS1Padding\u003c/code\u003e (1024, 2048)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eRSA/ECB/OAEPWithSHA-1AndMGF1Padding\u003c/code\u003e (1024, 2048)\u003c/li\u003e \n \u003cli\u003e\u003ccode\u003eRSA/ECB/OAEPWithSHA-256AndMGF1Padding\u003c/code\u003e (1024, 2048)\u003c/li\u003e \n\u003c/ul\u003e These transformations are described in the \n\u003ca href\u003d\"../../../../specs/security/standard-names.html#cipher-algorithm-names\"\u003e Cipher section\u003c/a\u003e of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other transformations are supported.\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/KeyGenerator.html\" title\u003d\"class in javax.crypto\"\u003e\u003ccode\u003eKeyGenerator\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/SecretKey.html\" title\u003d\"interface in javax.crypto\"\u003e\u003ccode\u003eSecretKey\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.4"
    ]
  }
}