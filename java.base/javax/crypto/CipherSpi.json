{
  "packageName": "javax.crypto",
  "simpleName": "CipherSpi",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.security.NoSuchAlgorithmException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "name": "mode",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineSetMode",
      "comment": "Sets the mode of this cipher.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003emode\u003c/code\u003e - the cipher mode"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if the requested cipher mode does not exist"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.crypto.NoSuchPaddingException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "name": "padding",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineSetPadding",
      "comment": "Sets the padding mechanism of this cipher.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003epadding\u003c/code\u003e - the padding mechanism"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/NoSuchPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eNoSuchPaddingException\u003c/a\u003e\u003c/code\u003e - if the requested padding mechanism does not exist"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineGetBlockSize",
      "comment": "Returns the block size (in bytes).",
      "annotations": [],
      "tagMap": {
        "return": [
          "the block size (in bytes), or 0 if the underlying algorithm is not a block cipher"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputLen",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineGetOutputSize",
      "comment": "Returns the length in bytes that an output buffer would need to be in order to hold the result of the next update or doFinal operation, given the input length inputLen (in bytes). This call takes into account any unprocessed (buffered) data from a previous update call, padding, and AEAD tagging. The actual output length of the next update or doFinal call may be smaller than the length returned by this method.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length (in bytes)"
        ],
        "return": [
          "the required output buffer size (in bytes)"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineGetIV",
      "comment": "Returns the initialization vector (IV) in a new buffer. This is useful in the context of password-based encryption or decryption, where the IV is derived from a user-provided passphrase.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the initialization vector in a new buffer, or null if the underlying algorithm does not use an IV, or if the IV has not yet been set."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.security.AlgorithmParameters",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineGetParameters",
      "comment": "Returns the parameters used with this cipher. The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the parameters used with this cipher, or null if this cipher does not use any parameters."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "opmode",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.Key",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.SecureRandom",
            "type": "Class"
          },
          "name": "random",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineInit",
      "comment": "Initializes this cipher with a key and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters that cannot be derived from the given key, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidKeyException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using engineGetParameters or engineGetIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003erandom\u003c/code\u003e - the source of randomness"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e is not implemented by the cipher."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        },
        {
          "name": "java.security.InvalidAlgorithmParameterException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "opmode",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.Key",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.spec.AlgorithmParameterSpec",
            "type": "Class"
          },
          "name": "params",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.SecureRandom",
            "type": "Class"
          },
          "name": "random",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineInit",
      "comment": "Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using engineGetParameters or engineGetIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003eparams\u003c/code\u003e - the algorithm parameters",
          "\u003ccode\u003erandom\u003c/code\u003e - the source of randomness"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidAlgorithmParameterException.html\" title\u003d\"class in java.security\"\u003eInvalidAlgorithmParameterException\u003c/a\u003e\u003c/code\u003e - if the given algorithm parameters are inappropriate for this cipher, or if this cipher requires algorithm parameters and \n\u003ccode\u003eparams\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e is not implemented by the cipher."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        },
        {
          "name": "java.security.InvalidAlgorithmParameterException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "opmode",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.Key",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.AlgorithmParameters",
            "type": "Class"
          },
          "name": "params",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.security.SecureRandom",
            "type": "Class"
          },
          "name": "random",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineInit",
      "comment": "Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using engineGetParameters or engineGetIV (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003eopmode\u003c/code\u003e - the operation mode of this cipher (this is one of the following: \n\u003ccode\u003eENCRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eDECRYPT_MODE\u003c/code\u003e, \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e)",
          "\u003ccode\u003ekey\u003c/code\u003e - the encryption key",
          "\u003ccode\u003eparams\u003c/code\u003e - the algorithm parameters",
          "\u003ccode\u003erandom\u003c/code\u003e - the source of randomness"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if the given key is inappropriate for initializing this cipher",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidAlgorithmParameterException.html\" title\u003d\"class in java.security\"\u003eInvalidAlgorithmParameterException\u003c/a\u003e\u003c/code\u003e - if the given algorithm parameters are inappropriate for this cipher, or if this cipher requires algorithm parameters and \n\u003ccode\u003eparams\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eopmode\u003c/code\u003e is \n\u003ccode\u003eWRAP_MODE\u003c/code\u003e or \n\u003ccode\u003eUNWRAP_MODE\u003c/code\u003e is not implemented by the cipher."
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "input",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputOffset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputLen",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineUpdate",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in a new buffer.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length"
        ],
        "return": [
          "the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.crypto.ShortBufferException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "input",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputOffset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputLen",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "output",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "outputOffset",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineUpdate",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length",
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the result",
          "\u003ccode\u003eoutputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003eoutput\u003c/code\u003e where the result is stored"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if the given output buffer is too small to hold the result"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.crypto.ShortBufferException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "input",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "output",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "engineUpdate",
      "comment": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. All input.remaining() bytes starting at input.position() are processed. The result is stored in the output buffer. Upon return, the input buffer\u0027s position will be equal to its limit; its limit will not have changed. The output buffer\u0027s position will have advanced by n, where n is the value returned by this method; the output buffer\u0027s limit will not have changed. If output.remaining() bytes are insufficient to hold the result, a ShortBufferException is thrown. Subclasses should consider overriding this method if they can process ByteBuffers more efficiently than byte arrays.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input ByteBuffer",
          "\u003ccode\u003eoutput\u003c/code\u003e - the output ByteByffer"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if there is insufficient space in the output buffer",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either parameter is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "throwsClasses": [
        {
          "name": "javax.crypto.IllegalBlockSizeException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.BadPaddingException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "input",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputOffset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputLen",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineDoFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the new buffer with the result"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.crypto.ShortBufferException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.IllegalBlockSizeException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.BadPaddingException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "input",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputOffset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "inputLen",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "output",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "outputOffset",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1028,
      "name": "engineDoFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input buffer",
          "\u003ccode\u003einputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003einput\u003c/code\u003e where the input starts",
          "\u003ccode\u003einputLen\u003c/code\u003e - the input length",
          "\u003ccode\u003eoutput\u003c/code\u003e - the buffer for the result",
          "\u003ccode\u003eoutputOffset\u003c/code\u003e - the offset in \n\u003ccode\u003eoutput\u003c/code\u003e where the result is stored"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if the given output buffer is too small to hold the result",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.crypto.ShortBufferException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.IllegalBlockSizeException",
          "type": "Class"
        },
        {
          "name": "javax.crypto.BadPaddingException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "input",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "output",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "engineDoFinal",
      "comment": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. All input.remaining() bytes starting at input.position() are processed. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer. Upon return, the input buffer\u0027s position will be equal to its limit; its limit will not have changed. The output buffer\u0027s position will have advanced by n, where n is the value returned by this method; the output buffer\u0027s limit will not have changed. If output.remaining() bytes are insufficient to hold the result, a ShortBufferException is thrown. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Subclasses should consider overriding this method if they can process ByteBuffers more efficiently than byte arrays.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003einput\u003c/code\u003e - the input ByteBuffer",
          "\u003ccode\u003eoutput\u003c/code\u003e - the output ByteByffer"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/ShortBufferException.html\" title\u003d\"class in javax.crypto\"\u003eShortBufferException\u003c/a\u003e\u003c/code\u003e - if there is insufficient space in the output buffer",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/BadPaddingException.html\" title\u003d\"class in javax.crypto\"\u003eBadPaddingException\u003c/a\u003e\u003c/code\u003e - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/AEADBadTagException.html\" title\u003d\"class in javax.crypto\"\u003eAEADBadTagException\u003c/a\u003e\u003c/code\u003e - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if either parameter is \n\u003ccode\u003enull\u003c/code\u003e"
        ],
        "return": [
          "the number of bytes stored in \n\u003ccode\u003eoutput\u003c/code\u003e"
        ],
        "since": [
          "1.5"
        ]
      }
    },
    {
      "returnType": {
        "name": "byte",
        "type": "Class",
        "arrayDimensions": 1
      },
      "throwsClasses": [
        {
          "name": "javax.crypto.IllegalBlockSizeException",
          "type": "Class"
        },
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.security.Key",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "engineWrap",
      "comment": "Wrap a key. This concrete method has been added to this previously-defined abstract class. (For backwards compatibility, it cannot be abstract.) It may be overridden by a provider to wrap a key. Such an override is expected to throw an IllegalBlockSizeException or InvalidKeyException (under the specified circumstances), if the given key cannot be wrapped. If this method is not overridden, it always throws an UnsupportedOperationException.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ekey\u003c/code\u003e - the key to be wrapped."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/IllegalBlockSizeException.html\" title\u003d\"class in javax.crypto\"\u003eIllegalBlockSizeException\u003c/a\u003e\u003c/code\u003e - if this cipher is a block cipher, no padding has been requested, and the length of the encoding of the key to be wrapped is not a multiple of the block size.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if it is impossible or unsafe to wrap the key with this cipher (e.g., a hardware protected key is being passed to a software-only cipher).",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this method is not supported."
        ],
        "return": [
          "the wrapped key."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.security.Key",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        },
        {
          "name": "java.security.NoSuchAlgorithmException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "wrappedKey",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "name": "wrappedKeyAlgorithm",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "wrappedKeyType",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "engineUnwrap",
      "comment": "Unwrap a previously wrapped key. This concrete method has been added to this previously-defined abstract class. (For backwards compatibility, it cannot be abstract.) It may be overridden by a provider to unwrap a previously wrapped key. Such an override is expected to throw an InvalidKeyException if the given wrapped key cannot be unwrapped. If this method is not overridden, it always throws an UnsupportedOperationException.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ewrappedKey\u003c/code\u003e - the key to be unwrapped.",
          "\u003ccode\u003ewrappedKeyAlgorithm\u003c/code\u003e - the algorithm associated with the wrapped key.",
          "\u003ccode\u003ewrappedKeyType\u003c/code\u003e - the type of the wrapped key. This is one of \n\u003ccode\u003eSECRET_KEY\u003c/code\u003e, \n\u003ccode\u003ePRIVATE_KEY\u003c/code\u003e, or \n\u003ccode\u003ePUBLIC_KEY\u003c/code\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/NoSuchAlgorithmException.html\" title\u003d\"class in java.security\"\u003eNoSuchAlgorithmException\u003c/a\u003e\u003c/code\u003e - if no installed providers can create keys of type \n\u003ccode\u003ewrappedKeyType\u003c/code\u003e for the \n\u003ccode\u003ewrappedKeyAlgorithm\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ewrappedKey\u003c/code\u003e does not represent a wrapped key of type \n\u003ccode\u003ewrappedKeyType\u003c/code\u003e for the \n\u003ccode\u003ewrappedKeyAlgorithm\u003c/code\u003e.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this method is not supported."
        ],
        "return": [
          "the unwrapped key."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.security.InvalidKeyException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.security.Key",
            "type": "Class"
          },
          "name": "key",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "engineGetKeySize",
      "comment": "Returns the key size of the given key object in bits. This concrete method has been added to this previously-defined abstract class. It throws an UnsupportedOperationException if it is not overridden by the provider.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ekey\u003c/code\u003e - the key object."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/security/InvalidKeyException.html\" title\u003d\"class in java.security\"\u003eInvalidKeyException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ekey\u003c/code\u003e is invalid."
        ],
        "return": [
          "the key size of the given key object."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "byte",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "src",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "offset",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "int",
            "type": "Class"
          },
          "name": "len",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "engineUpdateAAD",
      "comment": "Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer. Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods).",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - the buffer containing the AAD",
          "\u003ccode\u003eoffset\u003c/code\u003e - the offset in \n\u003ccode\u003esrc\u003c/code\u003e where the AAD input starts",
          "\u003ccode\u003elen\u003c/code\u003e - the number of AAD bytes"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the \n\u003ccode\u003eupdate\u003c/code\u003e methods has already been called for the active encryption/decryption operation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this method has not been overridden by an implementation"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "name": "src",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 4,
      "name": "engineUpdateAAD",
      "comment": "Continues a multi-part update of the Additional Authentication Data (AAD). Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods). All src.remaining() bytes starting at src.position() are processed. Upon return, the input buffer\u0027s position will be equal to its limit; its limit will not have changed.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - the buffer containing the AAD"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the \n\u003ccode\u003eupdate\u003c/code\u003e methods has already been called for the active encryption/decryption operation",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if this method has not been overridden by an implementation"
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Constructor for subclasses to call.",
      "annotations": [],
      "tagMap": {}
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "javax.crypto.CipherSpi",
  "comment": "This class defines the \n\u003ci\u003eService Provider Interface\u003c/i\u003e (\n\u003cb\u003eSPI\u003c/b\u003e) for the \n\u003ccode\u003eCipher\u003c/code\u003e class. All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular cipher algorithm. \n\u003cp\u003eIn order to create an instance of \u003ccode\u003eCipher\u003c/code\u003e, which encapsulates an instance of this \u003ccode\u003eCipherSpi\u003c/code\u003e class, an application calls one of the \u003ca href\u003d\"Cipher.html#getInstance(java.lang.String)\"\u003e\u003ccode\u003egetInstance\u003c/code\u003e\u003c/a\u003e factory methods of the \u003ca href\u003d\"Cipher.html\" title\u003d\"class in javax.crypto\"\u003e\u003ccode\u003eCipher\u003c/code\u003e\u003c/a\u003e engine class and specifies the requested \u003ci\u003etransformation\u003c/i\u003e. Optionally, the application may also specify the name of a provider. \u003c/p\u003e\n\u003cp\u003eA \u003ci\u003etransformation\u003c/i\u003e is a string that describes the operation (or set of operations) to be performed on the given input, to produce some output. A transformation always includes the name of a cryptographic algorithm (e.g., \u003ci\u003eAES\u003c/i\u003e), and may be followed by a feedback mode and padding scheme. \u003c/p\u003e\n\u003cp\u003e A transformation is of the form: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\"\u003ci\u003ealgorithm/mode/padding\u003c/i\u003e\" or \u003c/li\u003e\n \u003cli\u003e\"\u003ci\u003ealgorithm\u003c/i\u003e\" \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e (in the latter case, provider-specific default values for the mode and padding scheme are used). For example, the following is a valid transformation: \u003c/p\u003e\n\u003cpre\u003e     Cipher c \u003d Cipher.getInstance(\"\u003ci\u003eAES/CBC/PKCS5Padding\u003c/i\u003e\");\n \u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eA provider may supply a separate class for each combination of \u003ci\u003ealgorithm/mode/padding\u003c/i\u003e, or may decide to provide more generic classes representing sub-transformations corresponding to \u003ci\u003ealgorithm\u003c/i\u003e or \u003ci\u003ealgorithm/mode\u003c/i\u003e or \u003ci\u003ealgorithm//padding\u003c/i\u003e (note the double slashes), in which case the requested mode and/or padding are set automatically by the \u003ccode\u003egetInstance\u003c/code\u003e methods of \u003ccode\u003eCipher\u003c/code\u003e, which invoke the \u003ca href\u003d\"#engineSetMode(java.lang.String)\"\u003e\u003ccode\u003eengineSetMode\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"#engineSetPadding(java.lang.String)\"\u003e\u003ccode\u003eengineSetPadding\u003c/code\u003e\u003c/a\u003e methods of the provider\u0027s subclass of \u003ccode\u003eCipherSpi\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eCipher\u003c/code\u003e property in a provider master class may have one of the following formats: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cpre\u003e     // provider\u0027s subclass of \"CipherSpi\" implements \"algName\" with\n     // pluggable mode and padding\n     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003ealgName\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003e \u003cpre\u003e     // provider\u0027s subclass of \"CipherSpi\" implements \"algName\" in the\n     // specified \"mode\", with pluggable padding\n     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003ealgName/mode\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003e \u003cpre\u003e     // provider\u0027s subclass of \"CipherSpi\" implements \"algName\" with the\n     // specified \"padding\", with pluggable mode\n     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003ealgName//padding\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003e \u003cpre\u003e     // provider\u0027s subclass of \"CipherSpi\" implements \"algName\" with the\n     // specified \"mode\" and \"padding\"\n     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003ealgName/mode/padding\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eFor example, a provider may supply a subclass of \u003ccode\u003eCipherSpi\u003c/code\u003e that implements \u003ci\u003eAES/ECB/PKCS5Padding\u003c/i\u003e, one that implements \u003ci\u003eAES/CBC/PKCS5Padding\u003c/i\u003e, one that implements \u003ci\u003eAES/CFB/PKCS5Padding\u003c/i\u003e, and yet another one that implements \u003ci\u003eAES/OFB/PKCS5Padding\u003c/i\u003e. That provider would have the following \u003ccode\u003eCipher\u003c/code\u003e properties in its master class: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cpre\u003e     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003eAES/ECB/PKCS5Padding\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003e \u003cpre\u003e     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003eAES/CBC/PKCS5Padding\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003e \u003cpre\u003e     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003eAES/CFB/PKCS5Padding\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n \u003cli\u003e \u003cpre\u003e     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003eAES/OFB/PKCS5Padding\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eAnother provider may implement a class for each of the above modes (i.e., one class for \u003ci\u003eECB\u003c/i\u003e, one for \u003ci\u003eCBC\u003c/i\u003e, one for \u003ci\u003eCFB\u003c/i\u003e, and one for \u003ci\u003eOFB\u003c/i\u003e), one class for \u003ci\u003ePKCS5Padding\u003c/i\u003e, and a generic \u003ci\u003eAES\u003c/i\u003e class that subclasses from \u003ccode\u003eCipherSpi\u003c/code\u003e. That provider would have the following \u003ccode\u003eCipher\u003c/code\u003e properties in its master class: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cpre\u003e     \u003ccode\u003eCipher.\u003c/code\u003e\u003ci\u003eAES\u003c/i\u003e\n \u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egetInstance\u003c/code\u003e factory method of the \u003ccode\u003eCipher\u003c/code\u003e engine class follows these rules in order to instantiate a provider\u0027s implementation of \u003ccode\u003eCipherSpi\u003c/code\u003e for a transformation of the form \"\u003ci\u003ealgorithm\u003c/i\u003e\": \u003c/p\u003e\n\u003col\u003e \n \u003cli\u003e Check if the provider has registered a subclass of \u003ccode\u003eCipherSpi\u003c/code\u003e for the specified \"\u003ci\u003ealgorithm\u003c/i\u003e\". \u003cp\u003eIf the answer is YES, instantiate this class, for whose mode and padding scheme default values (as supplied by the provider) are used. \u003c/p\u003e\u003cp\u003eIf the answer is NO, throw a \u003ccode\u003eNoSuchAlgorithmException\u003c/code\u003e exception. \u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egetInstance\u003c/code\u003e factory method of the \u003ccode\u003eCipher\u003c/code\u003e engine class follows these rules in order to instantiate a provider\u0027s implementation of \u003ccode\u003eCipherSpi\u003c/code\u003e for a transformation of the form \"\u003ci\u003ealgorithm/mode/padding\u003c/i\u003e\": \u003c/p\u003e\n\u003col\u003e \n \u003cli\u003e Check if the provider has registered a subclass of \u003ccode\u003eCipherSpi\u003c/code\u003e for the specified \"\u003ci\u003ealgorithm/mode/padding\u003c/i\u003e\" transformation. \u003cp\u003eIf the answer is YES, instantiate it. \u003c/p\u003e\u003cp\u003eIf the answer is NO, go to the next step. \u003c/p\u003e\u003c/li\u003e\n \u003cli\u003e Check if the provider has registered a subclass of \u003ccode\u003eCipherSpi\u003c/code\u003e for the sub-transformation \"\u003ci\u003ealgorithm/mode\u003c/i\u003e\". \u003cp\u003eIf the answer is YES, instantiate it, and call \u003ccode\u003eengineSetPadding(\u003ci\u003epadding\u003c/i\u003e)\u003c/code\u003e on the new instance. \u003c/p\u003e\u003cp\u003eIf the answer is NO, go to the next step. \u003c/p\u003e\u003c/li\u003e\n \u003cli\u003e Check if the provider has registered a subclass of \u003ccode\u003eCipherSpi\u003c/code\u003e for the sub-transformation \"\u003ci\u003ealgorithm//padding\u003c/i\u003e\" (note the double slashes). \u003cp\u003eIf the answer is YES, instantiate it, and call \u003ccode\u003eengineSetMode(\u003ci\u003emode\u003c/i\u003e)\u003c/code\u003e on the new instance. \u003c/p\u003e\u003cp\u003eIf the answer is NO, go to the next step. \u003c/p\u003e\u003c/li\u003e\n \u003cli\u003e Check if the provider has registered a subclass of \u003ccode\u003eCipherSpi\u003c/code\u003e for the sub-transformation \"\u003ci\u003ealgorithm\u003c/i\u003e\". \u003cp\u003eIf the answer is YES, instantiate it, and call \u003ccode\u003eengineSetMode(\u003ci\u003emode\u003c/i\u003e)\u003c/code\u003e and \u003ccode\u003eengineSetPadding(\u003ci\u003epadding\u003c/i\u003e)\u003c/code\u003e on the new instance. \u003c/p\u003e\u003cp\u003eIf the answer is NO, throw a \u003ccode\u003eNoSuchAlgorithmException\u003c/code\u003e exception. \u003c/p\u003e\u003c/li\u003e\n \u003cp\u003e\u003c/p\u003e\n \u003cp\u003e\u003c/p\u003e\n \u003cp\u003e\u003c/p\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/KeyGenerator.html\" title\u003d\"class in javax.crypto\"\u003e\u003ccode\u003eKeyGenerator\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/crypto/SecretKey.html\" title\u003d\"interface in javax.crypto\"\u003e\u003ccode\u003eSecretKey\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.4"
    ]
  }
}