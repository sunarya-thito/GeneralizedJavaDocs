{
  "packageName": "javax.net.ssl",
  "simpleName": "SSLSocket",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.net.Socket",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getSupportedCipherSuites",
      "comment": "Returns the names of the cipher suites which could be enabled for use on this connection. Normally, only a subset of these will actually be enabled by default, since this list may include cipher suites which do not meet quality of service requirements for those defaults. Such cipher suites might be useful in specialized applications. The returned array includes cipher suites from the list of standard cipher suite names in the JSSE Cipher Suite Names section of the Java Cryptography Architecture Standard Algorithm Name Documentation, and may also include other cipher suites that the provider supports.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()\"\u003e\u003ccode\u003egetEnabledCipherSuites()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetEnabledCipherSuites(String [])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an array of cipher suite names"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getEnabledCipherSuites",
      "comment": "Returns the names of the SSL cipher suites which are currently enabled for use on this connection. When an SSLSocket is first created, all enabled cipher suites support a minimum quality of service. Thus, in some environments this value might be empty. Note that even if a suite is enabled, it may never be used. This can occur if the peer does not support it, or its use is restricted, or the requisite certificates (and private keys) for the suite are not available, or an anonymous suite is enabled but authentication is required. The returned array includes cipher suites from the list of standard cipher suite names in the JSSE Cipher Suite Names section of the Java Cryptography Architecture Standard Algorithm Name Documentation, and may also include other cipher suites that the provider supports.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()\"\u003e\u003ccode\u003egetSupportedCipherSuites()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetEnabledCipherSuites(String [])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an array of cipher suite names"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "suites"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setEnabledCipherSuites",
      "comment": "Sets the cipher suites enabled for use on this connection. Each cipher suite in the suites parameter must have been listed by getSupportedCipherSuites(), or the method will fail. Following a successful call to this method, only suites listed in the suites parameter are enabled for use. Note that the standard list of cipher suite names may be found in the JSSE Cipher Suite Names section of the Java Cryptography Architecture Standard Algorithm Name Documentation. Providers may support cipher suite names not found in this list or might not use the recommended name for a certain cipher suite. See getEnabledCipherSuites() for more information on why a specific ciphersuite may never be used on a connection.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()\"\u003e\u003ccode\u003egetSupportedCipherSuites()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()\"\u003e\u003ccode\u003egetEnabledCipherSuites()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esuites\u003c/code\u003e - Names of all the cipher suites to enable"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - when one or more of the ciphers named by the parameter is not supported, or when the parameter is null."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getSupportedProtocols",
      "comment": "Returns the names of the protocols which could be enabled for use on an SSL connection.",
      "tagMap": {
        "return": [
          "an array of protocols supported"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getEnabledProtocols",
      "comment": "Returns the names of the protocol versions which are currently enabled for use on this connection. Note that even if a protocol is enabled, it may never be used. This can occur if the peer does not support the protocol, or its use is restricted, or there are no enabled cipher suites supported by the protocol.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetEnabledProtocols(String [])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an array of protocols"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "protocols"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setEnabledProtocols",
      "comment": "Sets the protocol versions enabled for use on this connection. The protocols must have been listed by getSupportedProtocols() as being supported. Following a successful call to this method, only protocols listed in the protocols parameter are enabled for use.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getEnabledProtocols()\"\u003e\u003ccode\u003egetEnabledProtocols()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eprotocols\u003c/code\u003e - Names of all the protocols to enable."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - when one or more of the protocols named by the parameter is not supported or when the protocols parameter is null."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLSession",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getSession",
      "comment": "Returns the SSL Session in use by this connection. These can be long lived, and frequently correspond to an entire login session for some user. The session specifies a particular cipher suite which is being actively used by all connections in that session, as well as the identities of the session\u0027s client and server. This method will initiate the initial handshake if necessary and then block until the handshake has been established. If an error occurs during the initial handshake, this method returns an invalid session object which reports an invalid cipher suite of \"SSL_NULL_WITH_NULL_NULL\".",
      "tagMap": {
        "return": [
          "the \n\u003ccode\u003eSSLSession\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLSession",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getHandshakeSession",
      "comment": "Returns the SSLSession being constructed during a SSL/TLS handshake. TLS protocols may negotiate parameters that are needed when using an instance of this class, but before the SSLSession has been completely initialized and made available via getSession. For example, the list of valid signature algorithms may restrict the type of certificates that can be used during TrustManager decisions, or the maximum TLS fragment packet sizes can be resized to better support the network environment. This method provides early access to the SSLSession being constructed. Depending on how far the handshake has progressed, some data may not yet be available for use. For example, if a remote server will be sending a Certificate chain, but that chain has yet not been processed, the getPeerCertificates method of SSLSession will throw a SSLPeerUnverifiedException. Once that chain has been processed, getPeerCertificates will return the proper value. Unlike getSession(), this method does not initiate the initial handshake and does not block until handshaking is complete.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLEngine\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSession.html\" title\u003d\"interface in javax.net.ssl\"\u003e\u003ccode\u003eSSLSession\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eExtendedSSLSession\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/X509ExtendedKeyManager.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eX509ExtendedKeyManager\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/X509ExtendedTrustManager.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eX509ExtendedTrustManager\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "null if this instance is not currently handshaking, or if the current handshake has not progressed far enough to create a basic SSLSession. Otherwise, this method returns the \n\u003ccode\u003eSSLSession\u003c/code\u003e currently being negotiated."
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "javax.net.ssl.HandshakeCompletedListener",
            "type": "Class"
          },
          "field": {
            "name": "listener"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "addHandshakeCompletedListener",
      "comment": "Registers an event listener to receive notifications that an SSL handshake has completed on this connection.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#startHandshake()\"\u003e\u003ccode\u003estartHandshake()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)\"\u003e\u003ccode\u003eremoveHandshakeCompletedListener(HandshakeCompletedListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - the HandShake Completed event listener"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the argument is null."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "javax.net.ssl.HandshakeCompletedListener",
            "type": "Class"
          },
          "field": {
            "name": "listener"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "removeHandshakeCompletedListener",
      "comment": "Removes a previously registered handshake completion listener.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)\"\u003e\u003ccode\u003eaddHandshakeCompletedListener(HandshakeCompletedListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003elistener\u003c/code\u003e - the HandShake Completed event listener"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the listener is not registered, or the argument is null."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "startHandshake",
      "comment": "Starts an SSL handshake on this connection. Common reasons include a need to use new encryption keys, to change cipher suites, or to initiate a new session. To force complete reauthentication, the current session could be invalidated before starting this handshake. If data has already been sent on the connection, it continues to flow during this handshake. When the handshake completes, this will be signaled with an event. This method is synchronous for the initial handshake on a connection and returns when the negotiated handshake is complete. Some protocols may not support multiple handshakes on an existing socket and may throw an IOException.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)\"\u003e\u003ccode\u003eaddHandshakeCompletedListener(HandshakeCompletedListener)\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - on a network level error"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "mode"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setUseClientMode",
      "comment": "Configures the socket to use client (or server) mode when handshaking. This method must be called before any handshaking occurs. Once handshaking has begun, the mode can not be reset for the life of this socket. Servers normally authenticate themselves, and clients are not required to do so.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getUseClientMode()\"\u003e\u003ccode\u003egetUseClientMode()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emode\u003c/code\u003e - true if the socket should start its handshaking in \"client\" mode"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if a mode change is attempted after the initial handshake has begun."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getUseClientMode",
      "comment": "Returns true if the socket is set to use client mode when handshaking.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if the socket should do handshaking in \"client\" mode"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "need"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setNeedClientAuth",
      "comment": "Configures the socket to require client authentication. This option is only useful for sockets in the server mode. A socket\u0027s client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike setWantClientAuth(boolean), if this option is set and the client chooses not to provide authentication information about itself, the negotiations will stop and the connection will be dropped. Calling this method overrides any previous setting made by this method or setWantClientAuth(boolean).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getNeedClientAuth()\"\u003e\u003ccode\u003egetNeedClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)\"\u003e\u003ccode\u003esetWantClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getWantClientAuth()\"\u003e\u003ccode\u003egetWantClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eneed\u003c/code\u003e - set to true if client authentication is required, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getNeedClientAuth",
      "comment": "Returns true if the socket will require client authentication. This option is only useful to sockets in the server mode.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)\"\u003e\u003ccode\u003esetNeedClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)\"\u003e\u003ccode\u003esetWantClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getWantClientAuth()\"\u003e\u003ccode\u003egetWantClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if client authentication is required, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "want"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setWantClientAuth",
      "comment": "Configures the socket to request client authentication. This option is only useful for sockets in the server mode. A socket\u0027s client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike setNeedClientAuth(boolean), if this option is set and the client chooses not to provide authentication information about itself, the negotiations will continue. Calling this method overrides any previous setting made by this method or setNeedClientAuth(boolean).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getWantClientAuth()\"\u003e\u003ccode\u003egetWantClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)\"\u003e\u003ccode\u003esetNeedClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getNeedClientAuth()\"\u003e\u003ccode\u003egetNeedClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ewant\u003c/code\u003e - set to true if client authentication is requested, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getWantClientAuth",
      "comment": "Returns true if the socket will request client authentication. This option is only useful for sockets in the server mode.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)\"\u003e\u003ccode\u003esetNeedClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getNeedClientAuth()\"\u003e\u003ccode\u003egetNeedClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)\"\u003e\u003ccode\u003esetWantClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if client authentication is requested, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "flag"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setEnableSessionCreation",
      "comment": "Controls whether new SSL sessions may be established by this socket. If session creations are not allowed, and there are no existing sessions to resume, there will be no successful handshaking.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#getEnableSessionCreation()\"\u003e\u003ccode\u003egetEnableSessionCreation()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eflag\u003c/code\u003e - true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getEnableSessionCreation",
      "comment": "Returns true if new SSL sessions may be established by this socket.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html#setEnableSessionCreation(boolean)\"\u003e\u003ccode\u003esetEnableSessionCreation(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLParameters",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getSSLParameters",
      "comment": "Returns the SSLParameters in effect for this SSLSocket. The ciphersuites and protocols of the returned SSLParameters are always non-null.",
      "tagMap": {
        "return": [
          "the SSLParameters in effect for this SSLSocket."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "javax.net.ssl.SSLParameters",
            "type": "Class"
          },
          "field": {
            "name": "params"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setSSLParameters",
      "comment": "Applies SSLParameters to this socket. This means: If params.getCipherSuites() is non-null, setEnabledCipherSuites() is called with that value. If params.getProtocols() is non-null, setEnabledProtocols() is called with that value. If params.getNeedClientAuth() or params.getWantClientAuth() return true, setNeedClientAuth(true) and setWantClientAuth(true) are called, respectively; otherwise setWantClientAuth(false) is called. If params.getServerNames() is non-null, the socket will configure its server names with that value. If params.getSNIMatchers() is non-null, the socket will configure its SNI matchers with that value.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eparams\u003c/code\u003e - the parameters"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the setEnabledCipherSuites() or the setEnabledProtocols() call fails"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getApplicationProtocol",
      "comment": "Returns the most recent application protocol value negotiated for this connection. If supported by the underlying SSL/TLS/DTLS implementation, application name negotiation mechanisms such as RFC 7301 , the Application-Layer Protocol Negotiation (ALPN), can negotiate application-level values between peers.",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "null if it has not yet been determined if application protocols might be used for this connection, an empty \n\u003ccode\u003eString\u003c/code\u003e if application protocols values will not be used, or a non-empty application protocol \n\u003ccode\u003eString\u003c/code\u003e if a value was successfully negotiated."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getHandshakeApplicationProtocol",
      "comment": "Returns the application protocol value negotiated on a SSL/TLS handshake currently in progress. Like getHandshakeSession(), a connection may be in the middle of a handshake. The application protocol may or may not yet be available.",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "null if it has not yet been determined if application protocols might be used for this handshake, an empty \n\u003ccode\u003eString\u003c/code\u003e if application protocols values will not be used, or a non-empty application protocol \n\u003ccode\u003eString\u003c/code\u003e if a value was successfully negotiated."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.BiFunction",
            "parameters": [
              {
                "name": "javax.net.ssl.SSLSocket",
                "type": "Class"
              },
              {
                "name": "java.util.List",
                "parameters": [
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  }
                ],
                "type": "Class"
              },
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "selector"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setHandshakeApplicationProtocolSelector",
      "comment": "Registers a callback function that selects an application protocol value for a SSL/TLS/DTLS handshake. The function overrides any values supplied using SSLParameters.setApplicationProtocols and it supports the following type parameters: SSLSocket The function\u0027s first argument allows the current SSLSocket to be inspected, including the handshake session and configuration settings. List\u003cString\u003e The function\u0027s second argument lists the application protocol names advertised by the TLS peer. String The function\u0027s result is an application protocol name, or null to indicate that none of the advertised names are acceptable. If the return value is an empty String then application protocol indications will not be used. If the return value is null (no value chosen) or is a value that was not advertised by the peer, the underlying protocol will determine what action to take. (For example, ALPN will send a \"no_application_protocol\" alert and terminate the connection.) For example, the following call registers a callback function that examines the TLS handshake parameters and selects an application protocol name: \n     serverSocket.setHandshakeApplicationProtocolSelector(\n         (serverSocket, clientProtocols) -\u003e {\n             SSLSession session \u003d serverSocket.getHandshakeSession();\n             return chooseApplicationProtocol(\n                 serverSocket,\n                 clientProtocols,\n                 session.getProtocol(),\n                 session.getCipherSuite());\n         });",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "apiNote": [
          "This method should be called by TLS server applications before the TLS handshake begins. Also, this \n\u003ccode\u003eSSLSocket\u003c/code\u003e should be configured with parameters that are compatible with the application protocol selected by the callback function. For example, enabling a poor choice of cipher suites could result in no suitable application protocol. See \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLParameters.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLParameters\u003c/code\u003e\u003c/a\u003e."
        ],
        "param": [
          "\u003ccode\u003eselector\u003c/code\u003e - the callback function, or null to de-register."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.function.BiFunction",
        "parameters": [
          {
            "name": "javax.net.ssl.SSLSocket",
            "type": "Class"
          },
          {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getHandshakeApplicationProtocolSelector",
      "comment": "Retrieves the callback function that selects an application protocol value during a SSL/TLS/DTLS handshake. See setHandshakeApplicationProtocolSelector for the function\u0027s type parameters.",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "the callback function, or null if none has been set."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Used only by subclasses. Constructs an uninitialized, unconnected TCP socket.",
      "tagMap": {}
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "java.net.UnknownHostException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "host"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "port"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Used only by subclasses. Constructs a TCP connection to a named host at a specified port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkConnect(java.lang.String,int)\"\u003e\u003ccode\u003eSecurityManager.checkConnect(java.lang.String, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ehost\u003c/code\u003e - name of the host with which to connect, or \n\u003ccode\u003enull\u003c/code\u003e for the loopback address.",
          "\u003ccode\u003eport\u003c/code\u003e - number of the server\u0027s port"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs when creating the socket",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and its \n\u003ccode\u003echeckConnect\u003c/code\u003e method doesn\u0027t allow the operation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/UnknownHostException.html\" title\u003d\"class in java.net\"\u003eUnknownHostException\u003c/a\u003e\u003c/code\u003e - if the host is not known",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.net.InetAddress",
            "type": "Class"
          },
          "field": {
            "name": "address"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "port"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Used only by subclasses. Constructs a TCP connection to a server at a specified address and port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkConnect(java.lang.String,int)\"\u003e\u003ccode\u003eSecurityManager.checkConnect(java.lang.String, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eaddress\u003c/code\u003e - the server\u0027s host",
          "\u003ccode\u003eport\u003c/code\u003e - its port"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs when creating the socket",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and its \n\u003ccode\u003echeckConnect\u003c/code\u003e method doesn\u0027t allow the operation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaddress\u003c/code\u003e is null."
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        },
        {
          "name": "java.net.UnknownHostException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "host"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "port"
          }
        },
        {
          "type": {
            "name": "java.net.InetAddress",
            "type": "Class"
          },
          "field": {
            "name": "clientAddress"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "clientPort"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Used only by subclasses. Constructs an SSL connection to a named host at a specified port, binding the client side of the connection a given address and port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkConnect(java.lang.String,int)\"\u003e\u003ccode\u003eSecurityManager.checkConnect(java.lang.String, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ehost\u003c/code\u003e - name of the host with which to connect, or \n\u003ccode\u003enull\u003c/code\u003e for the loopback address.",
          "\u003ccode\u003eport\u003c/code\u003e - number of the server\u0027s port",
          "\u003ccode\u003eclientAddress\u003c/code\u003e - the client\u0027s address the socket is bound to, or \n\u003ccode\u003enull\u003c/code\u003e for the \n\u003ccode\u003eanyLocal\u003c/code\u003e address.",
          "\u003ccode\u003eclientPort\u003c/code\u003e - the client\u0027s port the socket is bound to, or \n\u003ccode\u003ezero\u003c/code\u003e for a system selected free port."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs when creating the socket",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and its \n\u003ccode\u003echeckConnect\u003c/code\u003e method doesn\u0027t allow the operation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/UnknownHostException.html\" title\u003d\"class in java.net\"\u003eUnknownHostException\u003c/a\u003e\u003c/code\u003e - if the host is not known",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the port parameter or clientPort parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."
        ]
      }
    },
    {
      "throwsClasses": [
        {
          "name": "java.io.IOException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.net.InetAddress",
            "type": "Class"
          },
          "field": {
            "name": "address"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "port"
          }
        },
        {
          "type": {
            "name": "java.net.InetAddress",
            "type": "Class"
          },
          "field": {
            "name": "clientAddress"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "clientPort"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Used only by subclasses. Constructs an SSL connection to a server at a specified address and TCP port, binding the client side of the connection a given address and port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html#checkConnect(java.lang.String,int)\"\u003e\u003ccode\u003eSecurityManager.checkConnect(java.lang.String, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eaddress\u003c/code\u003e - the server\u0027s host",
          "\u003ccode\u003eport\u003c/code\u003e - its port",
          "\u003ccode\u003eclientAddress\u003c/code\u003e - the client\u0027s address the socket is bound to, or \n\u003ccode\u003enull\u003c/code\u003e for the \n\u003ccode\u003eanyLocal\u003c/code\u003e address.",
          "\u003ccode\u003eclientPort\u003c/code\u003e - the client\u0027s port the socket is bound to, or \n\u003ccode\u003ezero\u003c/code\u003e for a system selected free port."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/IOException.html\" title\u003d\"class in java.io\"\u003eIOException\u003c/a\u003e\u003c/code\u003e - if an I/O error occurs when creating the socket",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and its \n\u003ccode\u003echeckConnect\u003c/code\u003e method doesn\u0027t allow the operation.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the port parameter or clientPort parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NullPointerException.html\" title\u003d\"class in java.lang\"\u003eNullPointerException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003eaddress\u003c/code\u003e is null."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "javax.net.ssl.SSLSocket",
  "comment": "This class extends \n\u003ccode\u003eSocket\u003c/code\u003e and provides secure sockets using protocols such as the \"Secure Sockets Layer\" (SSL) or IETF \"Transport Layer Security\" (TLS) protocols. \n\u003cp\u003e Such sockets are normal stream sockets, but they add a layer of security protections over the underlying network transport protocol, such as TCP. Those protections include: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cem\u003eIntegrity Protection\u003c/em\u003e. SSL protects against modification of messages by an active wiretapper. \u003c/li\u003e\n \u003cli\u003e \u003cem\u003eAuthentication\u003c/em\u003e. In most modes, SSL provides peer authentication. Servers are usually authenticated, and clients may be authenticated as requested by servers. \u003c/li\u003e\n \u003cli\u003e \u003cem\u003eConfidentiality (Privacy Protection)\u003c/em\u003e. In most modes, SSL encrypts data being sent between client and server. This protects the confidentiality of data, so that passive wiretappers won\u0027t see sensitive data such as financial information or personal information of many kinds. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThese kinds of protection are specified by a \"cipher suite\", which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a ciphersuite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged. \u003c/p\u003e\n\u003cp\u003e The cipher suite used is established by a negotiation process called \"handshaking\". The goal of this process is to create or rejoin a \"session\", which may protect many connections over time. After handshaking has completed, you can access session attributes by using the \u003cem\u003egetSession\u003c/em\u003e method. The initial handshake on this connection can be initiated in one of three ways: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e calling \u003ccode\u003estartHandshake\u003c/code\u003e which explicitly begins handshakes, or \u003c/li\u003e\n \u003cli\u003e any attempt to read or write application data on this socket causes an implicit handshake, or \u003c/li\u003e\n \u003cli\u003e a call to \u003ccode\u003egetSession\u003c/code\u003e tries to set up a session if there is no currently valid session, and an implicit handshake is done. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eIf handshaking fails for any reason, the \u003ccode\u003eSSLSocket\u003c/code\u003e is closed, and no further communications can be done. \u003c/p\u003e\n\u003cp\u003eThere are two groups of cipher suites which you will need to know about when managing cipher suites: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cem\u003eSupported\u003c/em\u003e cipher suites: all the suites which are supported by the SSL implementation. This list is reported using \u003cem\u003egetSupportedCipherSuites\u003c/em\u003e. \u003c/li\u003e\n \u003cli\u003e \u003cem\u003eEnabled\u003c/em\u003e cipher suites, which may be fewer than the full set of supported suites. This group is set using the \u003cem\u003esetEnabledCipherSuites\u003c/em\u003e method, and queried using the \u003cem\u003egetEnabledCipherSuites\u003c/em\u003e method. Initially, a default set of cipher suites will be enabled on a new socket that represents the minimum suggested configuration. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a ciphersuite be selected. \u003c/p\u003e\n\u003cp\u003eWhen an \u003ccode\u003eSSLSocket\u003c/code\u003e is first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection. \u003c/p\u003e\n\u003cp\u003e You may register to receive event notification of handshake completion. This involves the use of two additional classes. \u003cem\u003eHandshakeCompletedEvent\u003c/em\u003e objects are passed to \u003cem\u003eHandshakeCompletedListener\u003c/em\u003e instances, which are registered by users of this API. An \u003ccode\u003eSSLSocket\u003c/code\u003e is created by \u003ccode\u003eSSLSocketFactory\u003c/code\u003e, or by \u003ccode\u003eaccept\u003c/code\u003eing a connection from a \u003ccode\u003eSSLServerSocket\u003c/code\u003e. \u003c/p\u003e\n\u003cp\u003eA SSL socket must choose to operate in the client or server mode. This will determine who begins the handshaking process, as well as which messages should be sent by each party. Each connection must have one client and one server, or handshaking will not progress properly. Once the initial handshaking has started, a socket can not switch between client and server modes, even when performing renegotiations. \u003c/p\u003e\n\u003cp\u003e The ApplicationProtocol \u003ccode\u003eString\u003c/code\u003e values returned by the methods in this class are in the network byte representation sent by the peer. The bytes could be directly compared, or converted to its Unicode {code String} format for comparison. \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e     String networkString \u003d sslSocket.getHandshakeApplicationProtocol();\n     byte[] bytes \u003d networkString.getBytes(StandardCharsets.ISO_8859_1);\n\n     //\n     // Match using bytes:\n     //\n     //   \"http/1.1\"                       (7-bit ASCII values same in UTF-8)\n     //   MEETEI MAYEK LETTERS \"HUK UN I\"  (Unicode 0xabcd-\u0026gt;0xabcf)\n     //\n     String HTTP1_1 \u003d \"http/1.1\";\n     byte[] HTTP1_1_BYTES \u003d HTTP1_1.getBytes(StandardCharsets.UTF_8);\n\n     byte[] HUK_UN_I_BYTES \u003d new byte[] {\n         (byte) 0xab, (byte) 0xcd,\n         (byte) 0xab, (byte) 0xce,\n         (byte) 0xab, (byte) 0xcf};\n\n     if ((Arrays.compare(bytes, HTTP1_1_BYTES) \u003d\u003d 0 )\n             || Arrays.compare(bytes, HUK_UN_I_BYTES) \u003d\u003d 0) {\n        ...\n     }\n\n     //\n     // Alternatively match using string.equals() if we know the ALPN value\n     // was encoded from a \u003ccode\u003eString\u003c/code\u003e using a certain character set,\n     // for example \u003ccode\u003eUTF-8\u003c/code\u003e.  The ALPN value must first be properly\n     // decoded to a Unicode \u003ccode\u003eString\u003c/code\u003e before use.\n     //\n     String unicodeString \u003d new String(bytes, StandardCharsets.UTF_8);\n     if (unicodeString.equals(HTTP1_1)\n             || unicodeString.equals(\"\\uabcd\\uabce\\uabcf\")) {\n         ...\n     }\n \u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/Socket.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eSocket\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLServerSocket.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLServerSocket\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocketFactory.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLSocketFactory\u003c/code\u003e\u003c/a\u003e"
    ],
    "apiNote": [
      "When the connection is no longer needed, the client and server applications should each close both sides of their respective connection. For \n\u003ccode\u003eSSLSocket\u003c/code\u003e objects, for example, an application can call \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/Socket.html#shutdownOutput()\"\u003e\u003ccode\u003eSocket.shutdownOutput()\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/OutputStream.html#close()\"\u003e\u003ccode\u003eOutputStream.close()\u003c/code\u003e\u003c/a\u003e for output stream close and call \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/Socket.html#shutdownInput()\"\u003e\u003ccode\u003eSocket.shutdownInput()\u003c/code\u003e\u003c/a\u003e or \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/InputStream.html#close()\"\u003e\u003ccode\u003eInputStream.close()\u003c/code\u003e\u003c/a\u003e for input stream close. Note that in some cases, closing the input stream may depend on the peer\u0027s output stream being closed first. If the connection is not closed in an orderly manner (for example \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/Socket.html#shutdownInput()\"\u003e\u003ccode\u003eSocket.shutdownInput()\u003c/code\u003e\u003c/a\u003e is called before the peer\u0027s write closure notification has been received), exceptions may be raised to indicate that an error has occurred. Once an \n\u003ccode\u003eSSLSocket\u003c/code\u003e is closed, it is not reusable: a new \n\u003ccode\u003eSSLSocket\u003c/code\u003e must be created."
    ],
    "since": [
      "1.4"
    ]
  }
}