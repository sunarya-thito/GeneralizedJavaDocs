{
  "packageName": "javax.net.ssl",
  "simpleName": "SSLEngine",
  "moduleName": "java.base",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPeerHost",
      "comment": "Returns the host name of the peer. Note that the value is not authenticated, and should not be relied upon.",
      "tagMap": {
        "return": [
          "the host name of the peer, or null if nothing is available."
        ]
      }
    },
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getPeerPort",
      "comment": "Returns the port number of the peer. Note that the value is not authenticated, and should not be relied upon.",
      "tagMap": {
        "return": [
          "the port number of the peer, or -1 if nothing is available."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLEngineResult",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "src"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "dst"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "wrap",
      "comment": "Attempts to encode a buffer of plaintext application data into SSL/TLS/DTLS network data. An invocation of this method behaves in exactly the same manner as the invocation:  engine.wrap(new ByteBuffer [] { src }, 0, 1, dst);",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer%5B%5D,int,int,java.nio.ByteBuffer)\"\u003e\u003ccode\u003ewrap(ByteBuffer [], int, int, ByteBuffer)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e containing outbound application data",
          "\u003ccode\u003edst\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e to hold outbound network data"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - A problem was encountered while processing the data that caused the \n\u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003edst\u003c/code\u003e buffer is read-only.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if either \n\u003ccode\u003esrc\u003c/code\u003e or \n\u003ccode\u003edst\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the client/server mode has not yet been set."
        ],
        "return": [
          "an \n\u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the result of this operation."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLEngineResult",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "srcs"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "dst"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "wrap",
      "comment": "Attempts to encode plaintext bytes from a sequence of data buffers into SSL/TLS/DTLS network data. An invocation of this method behaves in exactly the same manner as the invocation:  engine.wrap(srcs, 0, srcs.length, dst);",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer%5B%5D,int,int,java.nio.ByteBuffer)\"\u003e\u003ccode\u003ewrap(ByteBuffer [], int, int, ByteBuffer)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esrcs\u003c/code\u003e - an array of \n\u003ccode\u003eByteBuffers\u003c/code\u003e containing the outbound application data",
          "\u003ccode\u003edst\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e to hold outbound network data"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - A problem was encountered while processing the data that caused the \n\u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003edst\u003c/code\u003e buffer is read-only.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if either \n\u003ccode\u003esrcs\u003c/code\u003e or \n\u003ccode\u003edst\u003c/code\u003e is null, or if any element in \n\u003ccode\u003esrcs\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the client/server mode has not yet been set."
        ],
        "return": [
          "an \n\u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the result of this operation."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLEngineResult",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "srcs"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "length"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "dst"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "wrap",
      "comment": "Attempts to encode plaintext bytes from a subsequence of data buffers into SSL/TLS/DTLS network data. This \"gathering\" operation encodes, in a single invocation, a sequence of bytes from one or more of a given sequence of buffers. Gathering wraps are often useful when implementing network protocols or file formats that, for example, group data into segments consisting of one or more fixed-length headers followed by a variable-length body. See GatheringByteChannel for more information on gathering, and GatheringByteChannel.write(ByteBuffer[], int, int) for more information on the subsequence behavior. Depending on the state of the SSLEngine, this method may produce network data without consuming any application data (for example, it may generate handshake data.) The application is responsible for reliably transporting the network data to the peer, and for ensuring that data created by multiple calls to wrap() is transported in the same order in which it was generated. The application must properly synchronize multiple calls to this method. If this SSLEngine has not yet started its initial handshake, this method will automatically start the handshake. This method will attempt to produce SSL/TLS/DTLS records, and will consume as much source data as possible, but will never consume more than the sum of the bytes remaining in each buffer. Each ByteBuffer\u0027s position is updated to reflect the amount of data consumed or produced. The limits remain the same. The underlying memory used by the srcs and dst ByteBuffers must not be the same. See the class description for more information on engine closure.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/GatheringByteChannel.html\" title\u003d\"interface in java.nio.channels\"\u003e\u003ccode\u003eGatheringByteChannel\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer%5B%5D,int,int)\"\u003e\u003ccode\u003eGatheringByteChannel.write( ByteBuffer[], int, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esrcs\u003c/code\u003e - an array of \n\u003ccode\u003eByteBuffers\u003c/code\u003e containing the outbound application data",
          "\u003ccode\u003eoffset\u003c/code\u003e - The offset within the buffer array of the first buffer from which bytes are to be retrieved; it must be non-negative and no larger than \n\u003ccode\u003esrcs.length\u003c/code\u003e",
          "\u003ccode\u003elength\u003c/code\u003e - The maximum number of buffers to be accessed; it must be non-negative and no larger than \n\u003ccode\u003esrcs.length\u003c/code\u003e\u0026nbsp;-\u0026nbsp;\n\u003ccode\u003eoffset\u003c/code\u003e",
          "\u003ccode\u003edst\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e to hold outbound network data"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - A problem was encountered while processing the data that caused the \n\u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - if the preconditions on the \n\u003ccode\u003eoffset\u003c/code\u003e and \n\u003ccode\u003elength\u003c/code\u003e parameters do not hold.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003edst\u003c/code\u003e buffer is read-only.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if either \n\u003ccode\u003esrcs\u003c/code\u003e or \n\u003ccode\u003edst\u003c/code\u003e is null, or if any element in the \n\u003ccode\u003esrcs\u003c/code\u003e subsequence specified is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the client/server mode has not yet been set."
        ],
        "return": [
          "an \n\u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the result of this operation."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLEngineResult",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "src"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "dst"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unwrap",
      "comment": "Attempts to decode SSL/TLS/DTLS network data into a plaintext application data buffer. An invocation of this method behaves in exactly the same manner as the invocation:  engine.unwrap(src, new ByteBuffer [] { dst }, 0, 1);",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer%5B%5D,int,int)\"\u003e\u003ccode\u003eunwrap(ByteBuffer, ByteBuffer [], int, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e containing inbound network data.",
          "\u003ccode\u003edst\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e to hold inbound application data."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - A problem was encountered while processing the data that caused the \n\u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if the \n\u003ccode\u003edst\u003c/code\u003e buffer is read-only.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if either \n\u003ccode\u003esrc\u003c/code\u003e or \n\u003ccode\u003edst\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the client/server mode has not yet been set."
        ],
        "return": [
          "an \n\u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the result of this operation."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLEngineResult",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "src"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "dsts"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "unwrap",
      "comment": "Attempts to decode SSL/TLS/DTLS network data into a sequence of plaintext application data buffers. An invocation of this method behaves in exactly the same manner as the invocation:  engine.unwrap(src, dsts, 0, dsts.length);",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer%5B%5D,int,int)\"\u003e\u003ccode\u003eunwrap(ByteBuffer, ByteBuffer [], int, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e containing inbound network data.",
          "\u003ccode\u003edsts\u003c/code\u003e - an array of \n\u003ccode\u003eByteBuffer\u003c/code\u003es to hold inbound application data."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - A problem was encountered while processing the data that caused the \n\u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if any of the \n\u003ccode\u003edst\u003c/code\u003e buffers are read-only.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if either \n\u003ccode\u003esrc\u003c/code\u003e or \n\u003ccode\u003edsts\u003c/code\u003e is null, or if any element in \n\u003ccode\u003edsts\u003c/code\u003e is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the client/server mode has not yet been set."
        ],
        "return": [
          "an \n\u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the result of this operation."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLEngineResult",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class"
          },
          "field": {
            "name": "src"
          }
        },
        {
          "type": {
            "name": "java.nio.ByteBuffer",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "dsts"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "offset"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "length"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "unwrap",
      "comment": "Attempts to decode SSL/TLS/DTLS network data into a subsequence of plaintext application data buffers. This \"scattering\" operation decodes, in a single invocation, a sequence of bytes into one or more of a given sequence of buffers. Scattering unwraps are often useful when implementing network protocols or file formats that, for example, group data into segments consisting of one or more fixed-length headers followed by a variable-length body. See ScatteringByteChannel for more information on scattering, and ScatteringByteChannel.read(ByteBuffer[], int, int) for more information on the subsequence behavior. Depending on the state of the SSLEngine, this method may consume network data without producing any application data (for example, it may consume handshake data.) The application is responsible for reliably obtaining the network data from the peer, and for invoking unwrap() on the data in the order it was received. The application must properly synchronize multiple calls to this method. If this SSLEngine has not yet started its initial handshake, this method will automatically start the handshake. This method will attempt to consume one complete SSL/TLS/DTLS network packet, but will never consume more than the sum of the bytes remaining in the buffers. Each ByteBuffer\u0027s position is updated to reflect the amount of data consumed or produced. The limits remain the same. The underlying memory used by the src and dsts ByteBuffers must not be the same. The inbound network buffer may be modified as a result of this call: therefore if the network data packet is required for some secondary purpose, the data should be duplicated before calling this method. Note: the network data will not be useful to a second SSLEngine, as each SSLEngine contains unique random state which influences the SSL/TLS/DTLS messages. See the class description for more information on engine closure.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ScatteringByteChannel.html\" title\u003d\"interface in java.nio.channels\"\u003e\u003ccode\u003eScatteringByteChannel\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer%5B%5D,int,int)\"\u003e\u003ccode\u003eScatteringByteChannel.read( ByteBuffer[], int, int)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esrc\u003c/code\u003e - a \n\u003ccode\u003eByteBuffer\u003c/code\u003e containing inbound network data.",
          "\u003ccode\u003edsts\u003c/code\u003e - an array of \n\u003ccode\u003eByteBuffer\u003c/code\u003es to hold inbound application data.",
          "\u003ccode\u003eoffset\u003c/code\u003e - The offset within the buffer array of the first buffer from which bytes are to be transferred; it must be non-negative and no larger than \n\u003ccode\u003edsts.length\u003c/code\u003e.",
          "\u003ccode\u003elength\u003c/code\u003e - The maximum number of buffers to be accessed; it must be non-negative and no larger than \n\u003ccode\u003edsts.length\u003c/code\u003e\u0026nbsp;-\u0026nbsp;\n\u003ccode\u003eoffset\u003c/code\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - A problem was encountered while processing the data that caused the \n\u003ccode\u003eSSLEngine\u003c/code\u003e to abort. See the class description for more information on engine closure.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IndexOutOfBoundsException.html\" title\u003d\"class in java.lang\"\u003eIndexOutOfBoundsException\u003c/a\u003e\u003c/code\u003e - If the preconditions on the \n\u003ccode\u003eoffset\u003c/code\u003e and \n\u003ccode\u003elength\u003c/code\u003e parameters do not hold.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/ReadOnlyBufferException.html\" title\u003d\"class in java.nio\"\u003eReadOnlyBufferException\u003c/a\u003e\u003c/code\u003e - if any of the \n\u003ccode\u003edst\u003c/code\u003e buffers are read-only.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if either \n\u003ccode\u003esrc\u003c/code\u003e or \n\u003ccode\u003edsts\u003c/code\u003e is null, or if any element in the \n\u003ccode\u003edsts\u003c/code\u003e subsequence specified is null.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the client/server mode has not yet been set."
        ],
        "return": [
          "an \n\u003ccode\u003eSSLEngineResult\u003c/code\u003e describing the result of this operation."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Runnable",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getDelegatedTask",
      "comment": "Returns a delegated Runnable task for this SSLEngine. SSLEngine operations may require the results of operations that block, or may take an extended period of time to complete. This method is used to obtain an outstanding Runnable operation (task). Each task must be assigned a thread (possibly the current) to perform the run operation. Once the run method returns, the Runnable object is no longer needed and may be discarded. Delegated tasks run in the AccessControlContext in place when this object was created. A call to this method will return each outstanding task exactly once. Multiple delegated tasks can be run in parallel.",
      "tagMap": {
        "return": [
          "a delegated \n\u003ccode\u003eRunnable\u003c/code\u003e task, or null if none are available."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "closeInbound",
      "comment": "Signals that no more inbound network data will be sent to this SSLEngine. If the application initiated the closing process by calling closeOutbound(), under some circumstances it is not required that the initiator wait for the peer\u0027s corresponding close message. (See section 7.2.1 of the TLS specification (RFC 2246) for more information on waiting for closure alerts.) In such cases, this method need not be called. But if the application did not initiate the closure process, or if the circumstances above do not apply, this method should be called whenever the end of the SSL/TLS/DTLS data stream is reached. This ensures closure of the inbound side, and checks that the peer followed the SSL/TLS/DTLS close procedure properly, thus detecting possible truncation attacks. This method is idempotent: if the inbound side has already been closed, this method does not do anything. wrap() should be called to flush any remaining handshake data.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#isInboundDone()\"\u003e\u003ccode\u003eisInboundDone()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#isOutboundDone()\"\u003e\u003ccode\u003eisOutboundDone()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - if this engine has not received the proper SSL/TLS/DTLS close notification message from the peer."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "isInboundDone",
      "comment": "Returns whether unwrap(ByteBuffer, ByteBuffer) will accept any more inbound data messages.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#closeInbound()\"\u003e\u003ccode\u003ecloseInbound()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if the \n\u003ccode\u003eSSLEngine\u003c/code\u003e will not consume anymore network data (and by implication, will not produce any more application data.)"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "closeOutbound",
      "comment": "Signals that no more outbound application data will be sent on this SSLEngine. This method is idempotent: if the outbound side has already been closed, this method does not do anything. wrap(ByteBuffer, ByteBuffer) should be called to flush any remaining handshake data.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#isOutboundDone()\"\u003e\u003ccode\u003eisOutboundDone()\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "isOutboundDone",
      "comment": "Returns whether wrap(ByteBuffer, ByteBuffer) will produce any more outbound data messages. Note that during the closure phase, a SSLEngine may generate handshake closure data that must be sent to the peer. wrap() must be called to generate this data. When this method returns true, no more outbound data will be created.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#closeOutbound()\"\u003e\u003ccode\u003ecloseOutbound()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#closeInbound()\"\u003e\u003ccode\u003ecloseInbound()\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if the \n\u003ccode\u003eSSLEngine\u003c/code\u003e will not produce any more network data"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getSupportedCipherSuites",
      "comment": "Returns the names of the cipher suites which could be enabled for use on this engine. Normally, only a subset of these will actually be enabled by default, since this list may include cipher suites which do not meet quality of service requirements for those defaults. Such cipher suites might be useful in specialized applications. The returned array includes cipher suites from the list of standard cipher suite names in the JSSE Cipher Suite Names section of the Java Cryptography Architecture Standard Algorithm Name Documentation, and may also include other cipher suites that the provider supports.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()\"\u003e\u003ccode\u003egetEnabledCipherSuites()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetEnabledCipherSuites(String [])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an array of cipher suite names"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getEnabledCipherSuites",
      "comment": "Returns the names of the SSL cipher suites which are currently enabled for use on this engine. When an SSLEngine is first created, all enabled cipher suites support a minimum quality of service. Thus, in some environments this value might be empty. Note that even if a suite is enabled, it may never be used. This can occur if the peer does not support it, or its use is restricted, or the requisite certificates (and private keys) for the suite are not available, or an anonymous suite is enabled but authentication is required. The returned array includes cipher suites from the list of standard cipher suite names in the JSSE Cipher Suite Names section of the Java Cryptography Architecture Standard Algorithm Name Documentation, and may also include other cipher suites that the provider supports.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()\"\u003e\u003ccode\u003egetSupportedCipherSuites()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetEnabledCipherSuites(String [])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an array of cipher suite names"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "suites"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setEnabledCipherSuites",
      "comment": "Sets the cipher suites enabled for use on this engine. Each cipher suite in the suites parameter must have been listed by getSupportedCipherSuites(), or the method will fail. Following a successful call to this method, only suites listed in the suites parameter are enabled for use. Note that the standard list of cipher suite names may be found in the JSSE Cipher Suite Names section of the Java Cryptography Architecture Standard Algorithm Name Documentation. Providers may support cipher suite names not found in this list or might not use the recommended name for a certain cipher suite. See getEnabledCipherSuites() for more information on why a specific cipher suite may never be used on a engine.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()\"\u003e\u003ccode\u003egetSupportedCipherSuites()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()\"\u003e\u003ccode\u003egetEnabledCipherSuites()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003esuites\u003c/code\u003e - Names of all the cipher suites to enable"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - when one or more of the ciphers named by the parameter is not supported, or when the parameter is null."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getSupportedProtocols",
      "comment": "Returns the names of the protocols which could be enabled for use with this SSLEngine.",
      "tagMap": {
        "return": [
          "an array of protocols supported"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class",
        "arrayDimensions": [
          {}
        ]
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getEnabledProtocols",
      "comment": "Returns the names of the protocol versions which are currently enabled for use with this SSLEngine. Note that even if a protocol is enabled, it may never be used. This can occur if the peer does not support the protocol, or its use is restricted, or there are no enabled cipher suites supported by the protocol.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setEnabledProtocols(java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetEnabledProtocols(String [])\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "an array of protocols"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class",
            "arrayDimensions": [
              {}
            ]
          },
          "field": {
            "name": "protocols"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setEnabledProtocols",
      "comment": "Set the protocol versions enabled for use on this engine. The protocols must have been listed by getSupportedProtocols() as being supported. Following a successful call to this method, only protocols listed in the protocols parameter are enabled for use.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getEnabledProtocols()\"\u003e\u003ccode\u003egetEnabledProtocols()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eprotocols\u003c/code\u003e - Names of all the protocols to enable."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - when one or more of the protocols named by the parameter is not supported or when the protocols parameter is null."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLSession",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getSession",
      "comment": "Returns the SSLSession in use in this SSLEngine. These can be long lived, and frequently correspond to an entire login session for some user. The session specifies a particular cipher suite which is being actively used by all connections in that session, as well as the identities of the session\u0027s client and server. Unlike SSLSocket.getSession() this method does not block until handshaking is complete. Until the initial handshake has completed, this method returns a session object which reports an invalid cipher suite of \"SSL_NULL_WITH_NULL_NULL\".",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSession.html\" title\u003d\"interface in javax.net.ssl\"\u003e\u003ccode\u003eSSLSession\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "the \n\u003ccode\u003eSSLSession\u003c/code\u003e for this \n\u003ccode\u003eSSLEngine\u003c/code\u003e"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLSession",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getHandshakeSession",
      "comment": "Returns the SSLSession being constructed during a SSL/TLS/DTLS handshake. TLS/DTLS protocols may negotiate parameters that are needed when using an instance of this class, but before the SSLSession has been completely initialized and made available via getSession. For example, the list of valid signature algorithms may restrict the type of certificates that can be used during TrustManager decisions, or the maximum TLS/DTLS fragment packet sizes can be resized to better support the network environment. This method provides early access to the SSLSession being constructed. Depending on how far the handshake has progressed, some data may not yet be available for use. For example, if a remote server will be sending a Certificate chain, but that chain has yet not been processed, the getPeerCertificates method of SSLSession will throw a SSLPeerUnverifiedException. Once that chain has been processed, getPeerCertificates will return the proper value.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLSocket\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSession.html\" title\u003d\"interface in javax.net.ssl\"\u003e\u003ccode\u003eSSLSession\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eExtendedSSLSession\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/X509ExtendedKeyManager.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eX509ExtendedKeyManager\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/X509ExtendedTrustManager.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eX509ExtendedTrustManager\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "null if this instance is not currently handshaking, or if the current handshake has not progressed far enough to create a basic SSLSession. Otherwise, this method returns the \n\u003ccode\u003eSSLSession\u003c/code\u003e currently being negotiated."
        ],
        "since": [
          "1.7"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "javax.net.ssl.SSLException",
          "type": "Class"
        }
      ],
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "beginHandshake",
      "comment": "Initiates handshaking (initial or renegotiation) on this SSLEngine. This method is not needed for the initial handshake, as the wrap() and unwrap() methods will implicitly call this method if handshaking has not already begun. Note that the peer may also request a session renegotiation with this SSLEngine by sending the appropriate session renegotiate handshake message. Unlike the SSLSocket#startHandshake() method, this method does not block until handshaking is completed. To force a complete SSL/TLS/DTLS session renegotiation, the current session should be invalidated prior to calling this method. Some protocols may not support multiple handshakes on an existing engine and may throw an SSLException.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSession.html#invalidate()\"\u003e\u003ccode\u003eSSLSession.invalidate()\u003c/code\u003e\u003c/a\u003e"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLException.html\" title\u003d\"class in javax.net.ssl\"\u003eSSLException\u003c/a\u003e\u003c/code\u003e - if a problem was encountered while signaling the \n\u003ccode\u003eSSLEngine\u003c/code\u003e to begin a new handshake. See the class description for more information on engine closure.",
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalStateException.html\" title\u003d\"class in java.lang\"\u003eIllegalStateException\u003c/a\u003e\u003c/code\u003e - if the client/server mode has not yet been set."
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLEngineResult$HandshakeStatus",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getHandshakeStatus",
      "comment": "Returns the current handshake status for this SSLEngine.",
      "tagMap": {
        "return": [
          "the current \n\u003ccode\u003eSSLEngineResult.HandshakeStatus\u003c/code\u003e."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "mode"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setUseClientMode",
      "comment": "Configures the engine to use client (or server) mode when handshaking. This method must be called before any handshaking occurs. Once handshaking has begun, the mode can not be reset for the life of this engine. Servers normally authenticate themselves, and clients are not required to do so.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getUseClientMode()\"\u003e\u003ccode\u003egetUseClientMode()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003emode\u003c/code\u003e - true if the engine should start its handshaking in \"client\" mode"
        ],
        "implNote": [
          "The JDK SunJSSE provider implementation default for this mode is false."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if a mode change is attempted after the initial handshake has begun."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getUseClientMode",
      "comment": "Returns true if the engine is set to use client mode when handshaking.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "implNote": [
          "The JDK SunJSSE provider implementation returns false unless \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e is used to change the mode to true."
        ],
        "return": [
          "true if the engine should do handshaking in \"client\" mode"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "need"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setNeedClientAuth",
      "comment": "Configures the engine to require client authentication. This option is only useful for engines in the server mode. An engine\u0027s client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike setWantClientAuth(boolean), if this option is set and the client chooses not to provide authentication information about itself, the negotiations will stop and the engine will begin its closure procedure. Calling this method overrides any previous setting made by this method or setWantClientAuth(boolean).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getNeedClientAuth()\"\u003e\u003ccode\u003egetNeedClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)\"\u003e\u003ccode\u003esetWantClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getWantClientAuth()\"\u003e\u003ccode\u003egetWantClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eneed\u003c/code\u003e - set to true if client authentication is required, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getNeedClientAuth",
      "comment": "Returns true if the engine will require client authentication. This option is only useful to engines in the server mode.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)\"\u003e\u003ccode\u003esetNeedClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)\"\u003e\u003ccode\u003esetWantClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getWantClientAuth()\"\u003e\u003ccode\u003egetWantClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if client authentication is required, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "want"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setWantClientAuth",
      "comment": "Configures the engine to request client authentication. This option is only useful for engines in the server mode. An engine\u0027s client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike setNeedClientAuth(boolean), if this option is set and the client chooses not to provide authentication information about itself, the negotiations will continue. Calling this method overrides any previous setting made by this method or setNeedClientAuth(boolean).",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getWantClientAuth()\"\u003e\u003ccode\u003egetWantClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)\"\u003e\u003ccode\u003esetNeedClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getNeedClientAuth()\"\u003e\u003ccode\u003egetNeedClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003ewant\u003c/code\u003e - set to true if client authentication is requested, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getWantClientAuth",
      "comment": "Returns true if the engine will request client authentication. This option is only useful for engines in the server mode.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)\"\u003e\u003ccode\u003esetNeedClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getNeedClientAuth()\"\u003e\u003ccode\u003egetNeedClientAuth()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)\"\u003e\u003ccode\u003esetWantClientAuth(boolean)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true if client authentication is requested, or false if no client authentication is desired."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "flag"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "setEnableSessionCreation",
      "comment": "Controls whether new SSL sessions may be established by this engine. If session creations are not allowed, and there are no existing sessions to resume, there will be no successful handshaking.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#getEnableSessionCreation()\"\u003e\u003ccode\u003egetEnableSessionCreation()\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003eflag\u003c/code\u003e - true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1025,
      "name": "getEnableSessionCreation",
      "comment": "Returns true if new SSL sessions may be established by this engine.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLEngine.html#setEnableSessionCreation(boolean)\"\u003e\u003ccode\u003esetEnableSessionCreation(boolean)\u003c/code\u003e\u003c/a\u003e"
        ],
        "return": [
          "true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"
        ]
      }
    },
    {
      "returnType": {
        "name": "javax.net.ssl.SSLParameters",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getSSLParameters",
      "comment": "Returns the SSLParameters in effect for this SSLEngine. The ciphersuites and protocols of the returned SSLParameters are always non-null.",
      "tagMap": {
        "return": [
          "the SSLParameters in effect for this SSLEngine."
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "javax.net.ssl.SSLParameters",
            "type": "Class"
          },
          "field": {
            "name": "params"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setSSLParameters",
      "comment": "Applies SSLParameters to this engine. This means: If params.getCipherSuites() is non-null, setEnabledCipherSuites() is called with that value. If params.getProtocols() is non-null, setEnabledProtocols() is called with that value. If params.getNeedClientAuth() or params.getWantClientAuth() return true, setNeedClientAuth(true) and setWantClientAuth(true) are called, respectively; otherwise setWantClientAuth(false) is called. If params.getServerNames() is non-null, the engine will configure its server names with that value. If params.getSNIMatchers() is non-null, the engine will configure its SNI matchers with that value.",
      "tagMap": {
        "param": [
          "\u003ccode\u003eparams\u003c/code\u003e - the parameters"
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if the setEnabledCipherSuites() or the setEnabledProtocols() call fails"
        ],
        "since": [
          "1.6"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getApplicationProtocol",
      "comment": "Returns the most recent application protocol value negotiated for this connection. If supported by the underlying SSL/TLS/DTLS implementation, application name negotiation mechanisms such as RFC 7301 , the Application-Layer Protocol Negotiation (ALPN), can negotiate application-level values between peers.",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "null if it has not yet been determined if application protocols might be used for this connection, an empty \n\u003ccode\u003eString\u003c/code\u003e if application protocols values will not be used, or a non-empty application protocol \n\u003ccode\u003eString\u003c/code\u003e if a value was successfully negotiated."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.String",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getHandshakeApplicationProtocol",
      "comment": "Returns the application protocol value negotiated on a SSL/TLS handshake currently in progress. Like getHandshakeSession(), a connection may be in the middle of a handshake. The application protocol may or may not yet be available.",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "null if it has not yet been determined if application protocols might be used for this handshake, an empty \n\u003ccode\u003eString\u003c/code\u003e if application protocols values will not be used, or a non-empty application protocol \n\u003ccode\u003eString\u003c/code\u003e if a value was successfully negotiated."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "java.util.function.BiFunction",
            "parameters": [
              {
                "name": "javax.net.ssl.SSLEngine",
                "type": "Class"
              },
              {
                "name": "java.util.List",
                "parameters": [
                  {
                    "name": "java.lang.String",
                    "type": "Class"
                  }
                ],
                "type": "Class"
              },
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          "field": {
            "name": "selector"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "setHandshakeApplicationProtocolSelector",
      "comment": "Registers a callback function that selects an application protocol value for a SSL/TLS/DTLS handshake. The function overrides any values supplied using SSLParameters.setApplicationProtocols and it supports the following type parameters: SSLEngine The function\u0027s first argument allows the current SSLEngine to be inspected, including the handshake session and configuration settings. List\u003cString\u003e The function\u0027s second argument lists the application protocol names advertised by the TLS peer. String The function\u0027s result is an application protocol name, or null to indicate that none of the advertised names are acceptable. If the return value is an empty String then application protocol indications will not be used. If the return value is null (no value chosen) or is a value that was not advertised by the peer, the underlying protocol will determine what action to take. (For example, ALPN will send a \"no_application_protocol\" alert and terminate the connection.) For example, the following call registers a callback function that examines the TLS handshake parameters and selects an application protocol name: \n     serverEngine.setHandshakeApplicationProtocolSelector(\n         (serverEngine, clientProtocols) -\u003e {\n             SSLSession session \u003d serverEngine.getHandshakeSession();\n             return chooseApplicationProtocol(\n                 serverEngine,\n                 clientProtocols,\n                 session.getProtocol(),\n                 session.getCipherSuite());\n         });",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "apiNote": [
          "This method should be called by TLS server applications before the TLS handshake begins. Also, this \n\u003ccode\u003eSSLEngine\u003c/code\u003e should be configured with parameters that are compatible with the application protocol selected by the callback function. For example, enabling a poor choice of cipher suites could result in no suitable application protocol. See \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLParameters.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLParameters\u003c/code\u003e\u003c/a\u003e."
        ],
        "param": [
          "\u003ccode\u003eselector\u003c/code\u003e - the callback function, or null to disable the callback functionality."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "returnType": {
        "name": "java.util.function.BiFunction",
        "parameters": [
          {
            "name": "javax.net.ssl.SSLEngine",
            "type": "Class"
          },
          {
            "name": "java.util.List",
            "parameters": [
              {
                "name": "java.lang.String",
                "type": "Class"
              }
            ],
            "type": "Class"
          },
          {
            "name": "java.lang.String",
            "type": "Class"
          }
        ],
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getHandshakeApplicationProtocolSelector",
      "comment": "Retrieves the callback function that selects an application protocol value during a SSL/TLS/DTLS handshake. See setHandshakeApplicationProtocolSelector for the function\u0027s type parameters.",
      "tagMap": {
        "implSpec": [
          "The implementation in this class throws \n\u003ccode\u003eUnsupportedOperationException\u003c/code\u003e and performs no other action."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/UnsupportedOperationException.html\" title\u003d\"class in java.lang\"\u003eUnsupportedOperationException\u003c/a\u003e\u003c/code\u003e - if the underlying provider does not implement the operation."
        ],
        "return": [
          "the callback function, or null if none has been set."
        ],
        "since": [
          "9"
        ]
      }
    },
    {
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Constructor for an SSLEngine providing no hints for an internal session reuse strategy.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLContext.html#createSSLEngine()\"\u003e\u003ccode\u003eSSLContext.createSSLEngine()\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSessionContext.html\" title\u003d\"interface in javax.net.ssl\"\u003e\u003ccode\u003eSSLSessionContext\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    },
    {
      "parameters": [
        {
          "type": {
            "name": "java.lang.String",
            "type": "Class"
          },
          "field": {
            "name": "peerHost"
          }
        },
        {
          "type": {
            "name": "int",
            "type": "Class"
          },
          "field": {
            "name": "peerPort"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 4,
      "comment": "Constructor for an SSLEngine. SSLEngine implementations may use the peerHost and peerPort parameters as hints for their internal session reuse strategy. Some cipher suites (such as Kerberos) require remote hostname information. Implementations of this class should use this constructor to use Kerberos. The parameters are not authenticated by the SSLEngine.",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLContext.html#createSSLEngine(java.lang.String,int)\"\u003e\u003ccode\u003eSSLContext.createSSLEngine(String, int)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSessionContext.html\" title\u003d\"interface in javax.net.ssl\"\u003e\u003ccode\u003eSSLSessionContext\u003c/code\u003e\u003c/a\u003e"
        ],
        "param": [
          "\u003ccode\u003epeerHost\u003c/code\u003e - the name of the peer host",
          "\u003ccode\u003epeerPort\u003c/code\u003e - the port number of the peer"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1025,
  "name": "javax.net.ssl.SSLEngine",
  "comment": "A class which enables secure communications using protocols such as the Secure Sockets Layer (SSL) or \n\u003ca href\u003d\"http://www.ietf.org/rfc/rfc2246.txt\"\u003e IETF RFC 2246 \"Transport Layer Security\" (TLS) \u003c/a\u003e protocols, but is transport independent. \n\u003cp\u003e The secure communications modes include: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cem\u003eIntegrity Protection\u003c/em\u003e. SSL/TLS/DTLS protects against modification of messages by an active wiretapper. \u003c/li\u003e\n \u003cli\u003e \u003cem\u003eAuthentication\u003c/em\u003e. In most modes, SSL/TLS/DTLS provides peer authentication. Servers are usually authenticated, and clients may be authenticated as requested by servers. \u003c/li\u003e\n \u003cli\u003e \u003cem\u003eConfidentiality (Privacy Protection)\u003c/em\u003e. In most modes, SSL/TLS/DTLS encrypts data being sent between client and server. This protects the confidentiality of data, so that passive wiretappers won\u0027t see sensitive data such as financial information or personal information of many kinds. \u003c/li\u003e\n\u003c/ul\u003e These kinds of protection are specified by a \"cipher suite\", which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a cipher suite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The cipher suite used is established by a negotiation process called \"handshaking\". The goal of this process is to create or rejoin a \"session\", which may protect many connections over time. After handshaking has completed, you can access session attributes by using the \u003ca href\u003d\"#getSession()\"\u003e\u003ccode\u003egetSession()\u003c/code\u003e\u003c/a\u003e method. \u003c/p\u003e\n\u003cp\u003e The \u003ccode\u003eSSLSocket\u003c/code\u003e class provides much of the same security functionality, but all of the inbound and outbound data is automatically transported using the underlying \u003ca href\u003d\"../../../java/net/Socket.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eSocket\u003c/code\u003e\u003c/a\u003e, which by design uses a blocking model. While this is appropriate for many applications, this model does not provide the scalability required by large servers. \u003c/p\u003e\n\u003cp\u003e The primary distinction of an \u003ccode\u003eSSLEngine\u003c/code\u003e is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the \u003ccode\u003eSSLEngine\u003c/code\u003e user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS/DTLS abstraction from the I/O transport mechanism, the \u003ccode\u003eSSLEngine\u003c/code\u003e can be used for a wide variety of I/O types, such as \u003ca href\u003d\"../../../java/nio/channels/spi/AbstractSelectableChannel.html#configureBlocking(boolean)\"\u003e\u003ccode\u003enon-blocking I/O (polling)\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"../../../java/nio/channels/Selector.html\" title\u003d\"class in java.nio.channels\"\u003e\u003ccode\u003eselectable non-blocking I/O\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"../../../java/net/Socket.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eSocket\u003c/code\u003e\u003c/a\u003e and the traditional Input/OutputStreams, local \u003ca href\u003d\"../../../java/nio/ByteBuffer.html\" title\u003d\"class in java.nio\"\u003e\u003ccode\u003eByteBuffers\u003c/code\u003e\u003c/a\u003e or byte arrays, \u003ca href\u003d\"http://www.jcp.org/en/jsr/detail?id\u003d203\"\u003e future asynchronous I/O models \u003c/a\u003e, and so on. \u003c/p\u003e\n\u003cp\u003e At a high level, the \u003ccode\u003eSSLEngine\u003c/code\u003e appears thus: \u003c/p\u003e\n\u003cpre\u003e                   app data\n\n                |           ^\n                |     |     |\n                v     |     |\n           +----+-----|-----+----+\n           |          |          |\n           |       SSL|Engine    |\n   wrap()  |          |          |  unwrap()\n           | OUTBOUND | INBOUND  |\n           |          |          |\n           +----+-----|-----+----+\n                |     |     ^\n                |     |     |\n                v           |\n\n                   net data\n \u003c/pre\u003e Application data (also known as plaintext or cleartext) is data which is produced or consumed by an application. Its counterpart is network data, which consists of either handshaking and/or ciphertext (encrypted) data, and destined to be transported via an I/O mechanism. Inbound data is data which has been received from the peer, and outbound data is destined for the peer. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e (In the context of an \u003ccode\u003eSSLEngine\u003c/code\u003e, the term \"handshake data\" is taken to mean any data exchanged to establish and control a secure connection. Handshake data includes the SSL/TLS/DTLS messages \"alert\", \"change_cipher_spec,\" and \"handshake.\") \u003c/p\u003e\n\u003cp\u003e There are five distinct phases to an \u003ccode\u003eSSLEngine\u003c/code\u003e. \u003c/p\u003e\n\u003col\u003e \n \u003cli\u003e Creation - The \u003ccode\u003eSSLEngine\u003c/code\u003e has been created and initialized, but has not yet been used. During this phase, an application may set any \u003ccode\u003eSSLEngine\u003c/code\u003e-specific settings (enabled cipher suites, whether the \u003ccode\u003eSSLEngine\u003c/code\u003e should handshake in client or server mode, and so on). Once handshaking has begun, though, any new settings (except client/server mode, see below) will be used for the next handshake. \u003c/li\u003e\n \u003cli\u003e Initial Handshake - The initial handshake is a procedure by which the two peers exchange communication parameters until an SSLSession is established. Application data can not be sent during this phase. \u003c/li\u003e\n \u003cli\u003e Application Data - Once the communication parameters have been established and the handshake is complete, application data may flow through the \u003ccode\u003eSSLEngine\u003c/code\u003e. Outbound application messages are encrypted and integrity protected, and inbound messages reverse the process. \u003c/li\u003e\n \u003cli\u003e Rehandshaking - Either side may request a renegotiation of the session at any time during the Application Data phase. New handshaking data can be intermixed among the application data. Before starting the rehandshake phase, the application may reset the SSL/TLS/DTLS communication parameters such as the list of enabled ciphersuites and whether to use client authentication, but can not change between client/server modes. As before, once handshaking has begun, any new \u003ccode\u003eSSLEngine\u003c/code\u003e configuration settings will not be used until the next handshake. \u003c/li\u003e\n \u003cli\u003e Closure - When the connection is no longer needed, the client and the server applications should each close both sides of their respective connections. For \u003ccode\u003eSSLEngine\u003c/code\u003e objects, an application should call \u003ca href\u003d\"#closeOutbound()\"\u003e\u003ccode\u003ecloseOutbound()\u003c/code\u003e\u003c/a\u003e and send any remaining messages to the peer. Likewise, an application should receive any remaining messages from the peer before calling \u003ca href\u003d\"#closeInbound()\"\u003e\u003ccode\u003ecloseInbound()\u003c/code\u003e\u003c/a\u003e. The underlying transport mechanism can then be closed after both sides of the \u003ccode\u003eSSLEngine\u003c/code\u003e have been closed. If the connection is not closed in an orderly manner (for example \u003ca href\u003d\"#closeInbound()\"\u003e\u003ccode\u003ecloseInbound()\u003c/code\u003e\u003c/a\u003e is called before the peer\u0027s write closure notification has been received), exceptions will be raised to indicate that an error has occurred. Once an engine is closed, it is not reusable: a new \u003ccode\u003eSSLEngine\u003c/code\u003e must be created. \u003c/li\u003e\n\u003c/ol\u003e An \n\u003ccode\u003eSSLEngine\u003c/code\u003e is created by calling \n\u003ca href\u003d\"SSLContext.html#createSSLEngine()\"\u003e\u003ccode\u003eSSLContext.createSSLEngine()\u003c/code\u003e\u003c/a\u003e from an initialized \n\u003ccode\u003eSSLContext\u003c/code\u003e. Any configuration parameters should be set before making the first call to \n\u003ccode\u003ewrap()\u003c/code\u003e, \n\u003ccode\u003eunwrap()\u003c/code\u003e, or \n\u003ccode\u003ebeginHandshake()\u003c/code\u003e. These methods all trigger the initial handshake. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Data moves through the engine by calling \u003ca href\u003d\"#wrap(java.nio.ByteBuffer,java.nio.ByteBuffer)\"\u003e\u003ccode\u003ewrap()\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"#unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer)\"\u003e\u003ccode\u003eunwrap()\u003c/code\u003e\u003c/a\u003e on outbound or inbound data, respectively. Depending on the state of the \u003ccode\u003eSSLEngine\u003c/code\u003e, a \u003ccode\u003ewrap()\u003c/code\u003e call may consume application data from the source buffer and may produce network data in the destination buffer. The outbound data may contain application and/or handshake data. A call to \u003ccode\u003eunwrap()\u003c/code\u003e will examine the source buffer and may advance the handshake if the data is handshaking information, or may place application data in the destination buffer if the data is application. The state of the underlying SSL/TLS/DTLS algorithm will determine when data is consumed and produced. \u003c/p\u003e\n\u003cp\u003e Calls to \u003ccode\u003ewrap()\u003c/code\u003e and \u003ccode\u003eunwrap()\u003c/code\u003e return an \u003ccode\u003eSSLEngineResult\u003c/code\u003e which indicates the status of the operation, and (optionally) how to interact with the engine to make progress. \u003c/p\u003e\n\u003cp\u003e The \u003ccode\u003eSSLEngine\u003c/code\u003e produces/consumes complete SSL/TLS/DTLS packets only, and does not store application data internally between calls to \u003ccode\u003ewrap()/unwrap()\u003c/code\u003e. Thus input and output \u003ccode\u003eByteBuffer\u003c/code\u003es must be sized appropriately to hold the maximum record that can be produced. Calls to \u003ca href\u003d\"SSLSession.html#getPacketBufferSize()\"\u003e\u003ccode\u003eSSLSession.getPacketBufferSize()\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"SSLSession.html#getApplicationBufferSize()\"\u003e\u003ccode\u003eSSLSession.getApplicationBufferSize()\u003c/code\u003e\u003c/a\u003e should be used to determine the appropriate buffer sizes. The size of the outbound application data buffer generally does not matter. If buffer conditions do not allow for the proper consumption/production of data, the application must determine (via \u003ca href\u003d\"SSLEngineResult.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLEngineResult\u003c/code\u003e\u003c/a\u003e) and correct the problem, and then try the call again. \u003c/p\u003e\n\u003cp\u003e For example, \u003ccode\u003eunwrap()\u003c/code\u003e will return a \u003ca href\u003d\"SSLEngineResult.Status.html#BUFFER_OVERFLOW\"\u003e\u003ccode\u003eSSLEngineResult.Status.BUFFER_OVERFLOW\u003c/code\u003e\u003c/a\u003e result if the engine determines that there is not enough destination buffer space available. Applications should call \u003ca href\u003d\"SSLSession.html#getApplicationBufferSize()\"\u003e\u003ccode\u003eSSLSession.getApplicationBufferSize()\u003c/code\u003e\u003c/a\u003e and compare that value with the space available in the destination buffer, enlarging the buffer if necessary. Similarly, if \u003ccode\u003eunwrap()\u003c/code\u003e were to return a \u003ca href\u003d\"SSLEngineResult.Status.html#BUFFER_UNDERFLOW\"\u003e\u003ccode\u003eSSLEngineResult.Status.BUFFER_UNDERFLOW\u003c/code\u003e\u003c/a\u003e, the application should call \u003ca href\u003d\"SSLSession.html#getPacketBufferSize()\"\u003e\u003ccode\u003eSSLSession.getPacketBufferSize()\u003c/code\u003e\u003c/a\u003e to ensure that the source buffer has enough room to hold a record (enlarging if necessary), and then obtain more inbound data. \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n   SSLEngineResult r \u003d engine.unwrap(src, dst);\n   switch (r.getStatus()) {\n   BUFFER_OVERFLOW:\n       // Could attempt to drain the dst buffer of any already obtained\n       // data, but we\u0027ll just increase it to the size needed.\n       int appSize \u003d engine.getSession().getApplicationBufferSize();\n       ByteBuffer b \u003d ByteBuffer.allocate(appSize + dst.position());\n       dst.flip();\n       b.put(dst);\n       dst \u003d b;\n       // retry the operation.\n       break;\n   BUFFER_UNDERFLOW:\n       int netSize \u003d engine.getSession().getPacketBufferSize();\n       // Resize buffer if needed.\n       if (netSize \u0026gt; src.capacity()) {\n           ByteBuffer b \u003d ByteBuffer.allocate(netSize);\n           src.flip();\n           b.put(src);\n           src \u003d b;\n       }\n       // Obtain more inbound network data for src,\n       // then retry the operation.\n       break;\n   // other cases: CLOSED, OK.\n   }\n \u003c/code\u003e\u003c/pre\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Unlike \u003ccode\u003eSSLSocket\u003c/code\u003e, all methods of SSLEngine are non-blocking. \u003ccode\u003eSSLEngine\u003c/code\u003e implementations may require the results of tasks that may take an extended period of time to complete, or may even block. For example, a TrustManager may need to connect to a remote certificate validation service, or a KeyManager might need to prompt a user to determine which certificate to use as part of client authentication. Additionally, creating cryptographic signatures and verifying them can be slow, seemingly blocking. \u003c/p\u003e\n\u003cp\u003e For any operation which may potentially block, the \u003ccode\u003eSSLEngine\u003c/code\u003e will create a \u003ca href\u003d\"../../../java/lang/Runnable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eRunnable\u003c/code\u003e\u003c/a\u003e delegated task. When \u003ccode\u003eSSLEngineResult\u003c/code\u003e indicates that a delegated task result is needed, the application must call \u003ca href\u003d\"#getDelegatedTask()\"\u003e\u003ccode\u003egetDelegatedTask()\u003c/code\u003e\u003c/a\u003e to obtain an outstanding delegated task and call its \u003ca href\u003d\"../../../java/lang/Runnable.html#run()\"\u003e\u003ccode\u003erun()\u003c/code\u003e\u003c/a\u003e method (possibly using a different thread depending on the compute strategy). The application should continue obtaining delegated tasks until no more exist, and try the original operation again. \u003c/p\u003e\n\u003cp\u003e At the end of a communication session, applications should properly close the SSL/TLS/DTLS link. The SSL/TLS/DTLS protocols have closure handshake messages, and these messages should be communicated to the peer before releasing the \u003ccode\u003eSSLEngine\u003c/code\u003e and closing the underlying transport mechanism. A close can be initiated by one of: an SSLException, an inbound closure handshake message, or one of the close methods. In all cases, closure handshake messages are generated by the engine, and \u003ccode\u003ewrap()\u003c/code\u003e should be repeatedly called until the resulting \u003ccode\u003eSSLEngineResult\u003c/code\u003e\u0027s status returns \"CLOSED\", or \u003ca href\u003d\"#isOutboundDone()\"\u003e\u003ccode\u003eisOutboundDone()\u003c/code\u003e\u003c/a\u003e returns true. All data obtained from the \u003ccode\u003ewrap()\u003c/code\u003e method should be sent to the peer. \u003c/p\u003e\n\u003cp\u003e \u003ca href\u003d\"#closeOutbound()\"\u003e\u003ccode\u003ecloseOutbound()\u003c/code\u003e\u003c/a\u003e is used to signal the engine that the application will not be sending any more data. \u003c/p\u003e\n\u003cp\u003e A peer will signal its intent to close by sending its own closure handshake message. After this message has been received and processed by the local \u003ccode\u003eSSLEngine\u003c/code\u003e\u0027s \u003ccode\u003eunwrap()\u003c/code\u003e call, the application can detect the close by calling \u003ccode\u003eunwrap()\u003c/code\u003e and looking for a \u003ccode\u003eSSLEngineResult\u003c/code\u003e with status \"CLOSED\", or if \u003ca href\u003d\"#isInboundDone()\"\u003e\u003ccode\u003eisInboundDone()\u003c/code\u003e\u003c/a\u003e returns true. If for some reason the peer closes the communication link without sending the proper SSL/TLS/DTLS closure message, the application can detect the end-of-stream and can signal the engine via \u003ca href\u003d\"#closeInbound()\"\u003e\u003ccode\u003ecloseInbound()\u003c/code\u003e\u003c/a\u003e that there will no more inbound messages to process. Some applications might choose to require orderly shutdown messages from a peer, in which case they can check that the closure was generated by a handshake message and not by an end-of-stream condition. \u003c/p\u003e\n\u003cp\u003e There are two groups of cipher suites which you will need to know about when managing cipher suites: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e \u003cem\u003eSupported\u003c/em\u003e cipher suites: all the suites which are supported by the SSL implementation. This list is reported using \u003ca href\u003d\"#getSupportedCipherSuites()\"\u003e\u003ccode\u003egetSupportedCipherSuites()\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n \u003cli\u003e \u003cem\u003eEnabled\u003c/em\u003e cipher suites, which may be fewer than the full set of supported suites. This group is set using the \u003ca href\u003d\"#setEnabledCipherSuites(java.lang.String%5B%5D)\"\u003e\u003ccode\u003esetEnabledCipherSuites(String [])\u003c/code\u003e\u003c/a\u003e method, and queried using the \u003ca href\u003d\"#getEnabledCipherSuites()\"\u003e\u003ccode\u003egetEnabledCipherSuites()\u003c/code\u003e\u003c/a\u003e method. Initially, a default set of cipher suites will be enabled on a new engine that represents the minimum suggested configuration. \u003c/li\u003e\n\u003c/ul\u003e Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a cipher suite be selected. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Each SSL/TLS/DTLS connection must have one client and one server, thus each endpoint must decide which role to assume. This choice determines who begins the handshaking process as well as which type of messages should be sent by each party. The method \u003ca href\u003d\"#setUseClientMode(boolean)\"\u003e\u003ccode\u003esetUseClientMode(boolean)\u003c/code\u003e\u003c/a\u003e configures the mode. Note that the default mode for a new \u003ccode\u003eSSLEngine\u003c/code\u003e is provider-specific. Applications should set the mode explicitly before invoking other methods of the \u003ccode\u003eSSLEngine\u003c/code\u003e. Once the initial handshaking has started, an \u003ccode\u003eSSLEngine\u003c/code\u003e can not switch between client and server modes, even when performing renegotiations. \u003c/p\u003e\n\u003cp\u003e The ApplicationProtocol \u003ccode\u003eString\u003c/code\u003e values returned by the methods in this class are in the network byte representation sent by the peer. The bytes could be directly compared, or converted to its Unicode {code String} format for comparison. \u003c/p\u003e\n\u003cblockquote\u003e\n \u003cpre\u003e     String networkString \u003d sslEngine.getHandshakeApplicationProtocol();\n     byte[] bytes \u003d networkString.getBytes(StandardCharsets.ISO_8859_1);\n\n     //\n     // Match using bytes:\n     //\n     //   \"http/1.1\"                       (7-bit ASCII values same in UTF-8)\n     //   MEETEI MAYEK LETTERS \"HUK UN I\"  (Unicode 0xabcd-\u0026gt;0xabcf)\n     //\n     String HTTP1_1 \u003d \"http/1.1\";\n     byte[] HTTP1_1_BYTES \u003d HTTP1_1.getBytes(StandardCharsets.UTF_8);\n\n     byte[] HUK_UN_I_BYTES \u003d new byte[] {\n         (byte) 0xab, (byte) 0xcd,\n         (byte) 0xab, (byte) 0xce,\n         (byte) 0xab, (byte) 0xcf};\n\n     if ((Arrays.compare(bytes, HTTP1_1_BYTES) \u003d\u003d 0 )\n             || Arrays.compare(bytes, HUK_UN_I_BYTES) \u003d\u003d 0) {\n        ...\n     }\n\n     //\n     // Alternatively match using string.equals() if we know the ALPN value\n     // was encoded from a \u003ccode\u003eString\u003c/code\u003e using a certain character set,\n     // for example \u003ccode\u003eUTF-8\u003c/code\u003e.  The ALPN value must first be properly\n     // decoded to a Unicode \u003ccode\u003eString\u003c/code\u003e before use.\n     //\n     String unicodeString \u003d new String(bytes, StandardCharsets.UTF_8);\n     if (unicodeString.equals(HTTP1_1)\n             || unicodeString.equals(\"\\uabcd\\uabce\\uabcf\")) {\n         ...\n     }\n \u003c/pre\u003e\n\u003c/blockquote\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e Applications might choose to process delegated tasks in different threads. When an \u003ccode\u003eSSLEngine\u003c/code\u003e is created, the current \u003ca href\u003d\"../../../java/security/AccessControlContext.html\" title\u003d\"class in java.security\"\u003e\u003ccode\u003eAccessControlContext\u003c/code\u003e\u003c/a\u003e is saved. All future delegated tasks will be processed using this context: that is, all access control decisions will be made using the context captured at engine creation. \u003c/p\u003e\n\u003chr\u003e \n\u003cb\u003eConcurrency Notes\u003c/b\u003e: There are two concurrency issues to be aware of: \n\u003col\u003e \n \u003cli\u003eThe \u003ccode\u003ewrap()\u003c/code\u003e and \u003ccode\u003eunwrap()\u003c/code\u003e methods may execute concurrently of each other. \u003c/li\u003e\n \u003cli\u003e The SSL/TLS/DTLS protocols employ ordered packets. Applications must take care to ensure that generated packets are delivered in sequence. If packets arrive out-of-order, unexpected or fatal results may occur. \u003cp\u003e For example: \u003c/p\u003e\u003cpre\u003e              synchronized (outboundLock) {\n                  sslEngine.wrap(src, dst);\n                  outboundQueue.put(dst);\n              }\n      \u003c/pre\u003e As a corollary, two threads must not attempt to call the same method (either \u003ccode\u003ewrap()\u003c/code\u003e or \u003ccode\u003eunwrap()\u003c/code\u003e) concurrently, because there is no way to guarantee the eventual packet ordering. \u003cp\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLContext.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLContext\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSocket.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLSocket\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLServerSocket.html\" title\u003d\"class in javax.net.ssl\"\u003e\u003ccode\u003eSSLServerSocket\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLSession.html\" title\u003d\"interface in javax.net.ssl\"\u003e\u003ccode\u003eSSLSession\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/net/Socket.html\" title\u003d\"class in java.net\"\u003e\u003ccode\u003eSocket\u003c/code\u003e\u003c/a\u003e"
    ],
    "since": [
      "1.5"
    ]
  }
}