{
  "packageName": "java.lang.management",
  "simpleName": "MemoryMXBean",
  "moduleName": "java.management",
  "type": "INTERFACE",
  "superClass": {
    "name": "java.lang.management.PlatformManagedObject",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "int",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getObjectPendingFinalizationCount",
      "comment": "Returns the approximate number of objects for which finalization is pending.",
      "tagMap": {
        "return": [
          "the approximate number objects for which finalization is pending."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.management.MemoryUsage",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getHeapMemoryUsage",
      "comment": "Returns the current memory usage of the heap that is used for object allocation. The heap consists of one or more memory pools. The used and committed size of the returned memory usage is the sum of those values of all heap memory pools whereas the init and max size of the returned memory usage represents the setting of the heap memory which may not be the sum of those of all heap memory pools. The amount of used memory in the returned memory usage is the amount of memory occupied by both live objects and garbage objects that have not been collected, if any. MBeanServer access: The mapped type of MemoryUsage is CompositeData with attributes as specified in MemoryUsage.",
      "tagMap": {
        "return": [
          "a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.management/java/lang/management/MemoryUsage.html\" title\u003d\"class in java.lang.management\"\u003e\u003ccode\u003eMemoryUsage\u003c/code\u003e\u003c/a\u003e object representing the heap memory usage."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.management.MemoryUsage",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "getNonHeapMemoryUsage",
      "comment": "Returns the current memory usage of non-heap memory that is used by the Java virtual machine. The non-heap memory consists of one or more memory pools. The used and committed size of the returned memory usage is the sum of those values of all non-heap memory pools whereas the init and max size of the returned memory usage represents the setting of the non-heap memory which may not be the sum of those of all non-heap memory pools. MBeanServer access: The mapped type of MemoryUsage is CompositeData with attributes as specified in MemoryUsage.",
      "tagMap": {
        "return": [
          "a \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.management/java/lang/management/MemoryUsage.html\" title\u003d\"class in java.lang.management\"\u003e\u003ccode\u003eMemoryUsage\u003c/code\u003e\u003c/a\u003e object representing the non-heap memory usage."
        ]
      }
    },
    {
      "returnType": {
        "name": "boolean",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "isVerbose",
      "comment": "Tests if verbose output for the memory system is enabled.",
      "tagMap": {
        "return": [
          "\u003ccode\u003etrue\u003c/code\u003e if verbose output for the memory system is enabled; \n\u003ccode\u003efalse\u003c/code\u003e otherwise."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [
        {
          "type": {
            "name": "boolean",
            "type": "Class"
          },
          "field": {
            "name": "value"
          }
        }
      ],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "setVerbose",
      "comment": "Enables or disables verbose output for the memory system. The verbose output information and the output stream to which the verbose information is emitted are implementation dependent. Typically, a Java virtual machine implementation prints a message whenever it frees memory at garbage collection. Each invocation of this method enables or disables verbose output globally.",
      "tagMap": {
        "param": [
          "\u003ccode\u003evalue\u003c/code\u003e - \n\u003ccode\u003etrue\u003c/code\u003e to enable verbose output; \n\u003ccode\u003efalse\u003c/code\u003e to disable."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityException.html\" title\u003d\"class in java.lang\"\u003eSecurityException\u003c/a\u003e\u003c/code\u003e - if a security manager exists and the caller does not have ManagementPermission(\"control\")."
        ]
      }
    },
    {
      "returnType": {
        "name": "void",
        "type": "Class"
      },
      "parameters": [],
      "memberType": "JavaMethod",
      "modifiers": 0,
      "name": "gc",
      "comment": "Runs the garbage collector. The call gc() is effectively equivalent to the call:  System.gc()",
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#gc()\"\u003e\u003ccode\u003eSystem.gc()\u003c/code\u003e\u003c/a\u003e"
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 513,
  "name": "java.lang.management.MemoryMXBean",
  "comment": "The management interface for the memory system of the Java virtual machine. \n\u003cp\u003e A Java virtual machine has a single instance of the implementation class of this interface. This instance implementing this interface is an \u003ca href\u003d\"ManagementFactory.html#MXBean\"\u003eMXBean\u003c/a\u003e that can be obtained by calling the \u003ca href\u003d\"ManagementFactory.html#getMemoryMXBean()\"\u003e\u003ccode\u003eManagementFactory.getMemoryMXBean()\u003c/code\u003e\u003c/a\u003e method or from the \u003ca href\u003d\"ManagementFactory.html#getPlatformMBeanServer()\"\u003e\u003ccode\u003eplatform MBeanServer\u003c/code\u003e\u003c/a\u003e method. \u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eObjectName\u003c/code\u003e for uniquely identifying the MXBean for the memory system within an MBeanServer is: \u003c/p\u003e\n\u003cblockquote\u003e \n \u003ca href\u003d\"ManagementFactory.html#MEMORY_MXBEAN_NAME\"\u003e\u003ccode\u003ejava.lang:type\u003dMemory\u003c/code\u003e\u003c/a\u003e \n\u003c/blockquote\u003e It can be obtained by calling the \n\u003ca href\u003d\"PlatformManagedObject.html#getObjectName()\"\u003e\u003ccode\u003ePlatformManagedObject.getObjectName()\u003c/code\u003e\u003c/a\u003e method. \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e Memory \u003c/h2\u003e The memory system of the Java virtual machine manages the following kinds of memory: \n\u003ch3\u003e 1. Heap \u003c/h3\u003e The Java virtual machine has a \n\u003ci\u003eheap\u003c/i\u003e that is the runtime data area from which memory for all class instances and arrays are allocated. It is created at the Java virtual machine start-up. Heap memory for objects is reclaimed by an automatic memory management system which is known as a \n\u003ci\u003egarbage collector\u003c/i\u003e. \n\u003cp\u003eThe heap may be of a fixed size or may be expanded and shrunk. The memory for the heap does not need to be contiguous. \u003c/p\u003e\n\u003ch3\u003e 2. Non-Heap Memory\u003c/h3\u003e The Java virtual machine manages memory other than the heap (referred as \n\u003ci\u003enon-heap memory\u003c/i\u003e). \n\u003cp\u003e The Java virtual machine has a \u003ci\u003emethod area\u003c/i\u003e that is shared among all threads. The method area belongs to non-heap memory. It stores per-class structures such as a runtime constant pool, field and method data, and the code for methods and constructors. It is created at the Java virtual machine start-up. \u003c/p\u003e\n\u003cp\u003e The method area is logically part of the heap but a Java virtual machine implementation may choose not to either garbage collect or compact it. Similar to the heap, the method area may be of a fixed size or may be expanded and shrunk. The memory for the method area does not need to be contiguous. \u003c/p\u003e\n\u003cp\u003eIn addition to the method area, a Java virtual machine implementation may require memory for internal processing or optimization which also belongs to non-heap memory. For example, the JIT compiler requires memory for storing the native machine code translated from the Java virtual machine code for high performance. \u003c/p\u003e\n\u003ch2\u003eMemory Pools and Memory Managers\u003c/h2\u003e \n\u003ca href\u003d\"MemoryPoolMXBean.html\" title\u003d\"interface in java.lang.management\"\u003e\u003ccode\u003eMemory pools\u003c/code\u003e\u003c/a\u003e and \n\u003ca href\u003d\"MemoryManagerMXBean.html\" title\u003d\"interface in java.lang.management\"\u003e\u003ccode\u003ememory managers\u003c/code\u003e\u003c/a\u003e are the abstract entities that monitor and manage the memory system of the Java virtual machine. \n\u003cp\u003eA memory pool represents a memory area that the Java virtual machine manages. The Java virtual machine has at least one memory pool and it may create or remove memory pools during execution. A memory pool can belong to either the heap or the non-heap memory. \u003c/p\u003e\n\u003cp\u003eA memory manager is responsible for managing one or more memory pools. The garbage collector is one type of memory manager responsible for reclaiming memory occupied by unreachable objects. A Java virtual machine may have one or more memory managers. It may add or remove memory managers during execution. A memory pool can be managed by more than one memory manager. \u003c/p\u003e\n\u003ch2\u003eMemory Usage Monitoring\u003c/h2\u003e Memory usage is a very important monitoring attribute for the memory system. The memory usage, for example, could indicate: \n\u003cul\u003e \n \u003cli\u003ethe memory usage of an application,\u003c/li\u003e \n \u003cli\u003ethe workload being imposed on the automatic memory management system,\u003c/li\u003e \n \u003cli\u003epotential memory leakage.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e The memory usage can be monitored in three ways: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003ePolling\u003c/li\u003e \n \u003cli\u003eUsage Threshold Notification\u003c/li\u003e \n \u003cli\u003eCollection Usage Threshold Notification\u003c/li\u003e \n\u003c/ul\u003e Details are specified in the \n\u003ca href\u003d\"MemoryPoolMXBean.html\" title\u003d\"interface in java.lang.management\"\u003e\u003ccode\u003eMemoryPoolMXBean\u003c/code\u003e\u003c/a\u003e interface. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe memory usage monitoring mechanism is intended for load-balancing or workload distribution use. For example, an application would stop receiving any new workload when its memory usage exceeds a certain threshold. It is not intended for an application to detect and recover from a low memory condition. \u003c/p\u003e\n\u003ch2\u003eNotifications\u003c/h2\u003e \n\u003cp\u003eThis \u003ccode\u003eMemoryMXBean\u003c/code\u003e is a \u003ca href\u003d\"../../../javax/management/NotificationEmitter.html\" title\u003d\"interface in javax.management\"\u003e\u003ccode\u003eNotificationEmitter\u003c/code\u003e\u003c/a\u003e that emits two types of memory \u003ca href\u003d\"../../../javax/management/Notification.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003enotifications\u003c/code\u003e\u003c/a\u003e if any one of the memory pools supports a \u003ca href\u003d\"MemoryPoolMXBean.html#UsageThreshold\"\u003eusage threshold\u003c/a\u003e or a \u003ca href\u003d\"MemoryPoolMXBean.html#CollectionThreshold\"\u003ecollection usage threshold\u003c/a\u003e which can be determined by calling the \u003ca href\u003d\"MemoryPoolMXBean.html#isUsageThresholdSupported()\"\u003e\u003ccode\u003eMemoryPoolMXBean.isUsageThresholdSupported()\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"MemoryPoolMXBean.html#isCollectionUsageThresholdSupported()\"\u003e\u003ccode\u003eMemoryPoolMXBean.isCollectionUsageThresholdSupported()\u003c/code\u003e\u003c/a\u003e methods. \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003e\u003ca href\u003d\"MemoryNotificationInfo.html#MEMORY_THRESHOLD_EXCEEDED\"\u003e\u003ccode\u003eusage threshold exceeded notification\u003c/code\u003e\u003c/a\u003e - for notifying that the memory usage of a memory pool is increased and has reached or exceeded its \u003ca href\u003d\"MemoryPoolMXBean.html#UsageThreshold\"\u003e usage threshold\u003c/a\u003e value. \u003c/li\u003e \n \u003cli\u003e\u003ca href\u003d\"MemoryNotificationInfo.html#MEMORY_COLLECTION_THRESHOLD_EXCEEDED\"\u003e\u003ccode\u003ecollection usage threshold exceeded notification\u003c/code\u003e\u003c/a\u003e - for notifying that the memory usage of a memory pool is greater than or equal to its \u003ca href\u003d\"MemoryPoolMXBean.html#CollectionThreshold\"\u003e collection usage threshold\u003c/a\u003e after the Java virtual machine has expended effort in recycling unused objects in that memory pool.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e The notification emitted is a \u003ca href\u003d\"../../../javax/management/Notification.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eNotification\u003c/code\u003e\u003c/a\u003e instance whose \u003ca href\u003d\"../../../javax/management/Notification.html#setUserData(java.lang.Object)\"\u003e\u003ccode\u003euser data\u003c/code\u003e\u003c/a\u003e is set to a \u003ca href\u003d\"../../../javax/management/openmbean/CompositeData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeData\u003c/code\u003e\u003c/a\u003e that represents a \u003ca href\u003d\"MemoryNotificationInfo.html\" title\u003d\"class in java.lang.management\"\u003e\u003ccode\u003eMemoryNotificationInfo\u003c/code\u003e\u003c/a\u003e object containing information about the memory pool when the notification was constructed. The \u003ccode\u003eCompositeData\u003c/code\u003e contains the attributes as described in \u003ca href\u003d\"MemoryNotificationInfo.html#from(javax.management.openmbean.CompositeData)\"\u003e\u003ccode\u003eMemoryNotificationInfo\u003c/code\u003e\u003c/a\u003e. \u003c/p\u003e\n\u003chr\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eNotificationEmitter\u003c/h2\u003e The \n\u003ccode\u003eMemoryMXBean\u003c/code\u003e object returned by \n\u003ca href\u003d\"ManagementFactory.html#getMemoryMXBean()\"\u003e\u003ccode\u003eManagementFactory.getMemoryMXBean()\u003c/code\u003e\u003c/a\u003e implements the \n\u003ca href\u003d\"../../../javax/management/NotificationEmitter.html\" title\u003d\"interface in javax.management\"\u003e\u003ccode\u003eNotificationEmitter\u003c/code\u003e\u003c/a\u003e interface that allows a listener to be registered within the \n\u003ccode\u003eMemoryMXBean\u003c/code\u003e as a notification listener. Below is an example code that registers a \n\u003ccode\u003eMyListener\u003c/code\u003e to handle notification emitted by the \n\u003ccode\u003eMemoryMXBean\u003c/code\u003e. \n\u003cblockquote\u003e\n \u003cpre\u003e class MyListener implements javax.management.NotificationListener {\n     public void handleNotification(Notification notif, Object handback) {\n         // handle notification\n         ....\n     }\n }\n\n MemoryMXBean mbean \u003d ManagementFactory.getMemoryMXBean();\n NotificationEmitter emitter \u003d (NotificationEmitter) mbean;\n MyListener listener \u003d new MyListener();\n emitter.addNotificationListener(listener, null, null);\n \u003c/pre\u003e\n\u003c/blockquote\u003e",
  "tagMap": {
    "see": [
      "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.management/java/lang/management/ManagementFactory.html#getPlatformMXBeans(java.lang.Class)\"\u003e\u003ccode\u003eManagementFactory.getPlatformMXBeans(Class)\u003c/code\u003e\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.management/javax/management/package-summary.html\"\u003e JMX Specification.\u003c/a\u003e, \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.management/java/lang/management/package-summary.html#examples\"\u003e Ways to Access MXBeans\u003c/a\u003e"
    ],
    "since": [
      "1.5"
    ]
  }
}