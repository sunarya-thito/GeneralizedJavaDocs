{
  "packageName": "javax.management",
  "simpleName": "ConstructorParameters",
  "moduleName": "java.management",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.management.ConstructorParameters",
  "comment": "\u003cp\u003e An annotation on a constructor that shows how the parameters of that constructor correspond to the constructed object\u0027s getter methods. For example: \u003c/p\u003e \n\u003cblockquote\u003e \n \u003cpre\u003e         public class MemoryUsage {\n             // standard JavaBean conventions with getters\n             \u003cb\u003e@ConstructorParameters({\"init\", \"used\", \"committed\", \"max\"})\u003c/b\u003e\n             public MemoryUsage(long init, long used,\n                                long committed, long max) {...}\n             public long getInit() {...}\n             public long getUsed() {...}\n             public long getCommitted() {...}\n             public long getMax() {...}\n         }\n     \u003c/pre\u003e \n\u003c/blockquote\u003e \n\u003cp\u003e The annotation shows that the first parameter of the constructor can be retrieved with the \u003ccode\u003egetInit()\u003c/code\u003e method, the second one with the \u003ccode\u003egetUsed()\u003c/code\u003e method, and so on. Since parameter names are not in general available at runtime, without the annotation there would be no way of knowing which parameter corresponds to which property. \u003c/p\u003e \n\u003cp\u003e If a constructor is annotated by the both \u003ccode\u003e@java.beans.ConstructorProperties\u003c/code\u003e and \u003ccode\u003e@javax.management.ConstructorParameters\u003c/code\u003e annotations the JMX introspection will give an absolute precedence to the latter one. \u003c/p\u003e",
  "tagMap": {
    "since": [
      "9"
    ]
  }
}