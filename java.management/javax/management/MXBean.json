{
  "packageName": "javax.management",
  "simpleName": "MXBean",
  "moduleName": "java.management",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.management.MXBean",
  "comment": "\u003cp\u003eAnnotation to mark an interface explicitly as being an MXBean interface, or as not being an MXBean interface. By default, an interface is an MXBean interface if it is public and its name ends with \u003ccode\u003eMXBean\u003c/code\u003e, as in \u003ccode\u003eSomethingMXBean\u003c/code\u003e. The following interfaces are MXBean interfaces:\u003c/p\u003e \n\u003cpre\u003e    public interface WhatsitMXBean {}\n\n    @MXBean\n    public interface Whatsit1Interface {}\n\n    @MXBean(true)\n    public interface Whatsit2Interface {}\n    \u003c/pre\u003e \n\u003cp\u003eThe following interfaces are not MXBean interfaces:\u003c/p\u003e \n\u003cpre\u003e    interface NonPublicInterfaceNotMXBean{}\n\n    public interface Whatsit3Interface{}\n\n    @MXBean(false)\n    public interface MisleadingMXBean {}\n    \u003c/pre\u003e \n\u003ch2 id\u003d\"MXBean-spec\"\u003eMXBean specification\u003c/h2\u003e \n\u003cp\u003eThe MXBean concept provides a simple way to code an MBean that only references a predefined set of types, the ones defined by \u003ca href\u003d\"openmbean/package-summary.html\"\u003e\u003ccode\u003ejavax.management.openmbean\u003c/code\u003e\u003c/a\u003e. In this way, you can be sure that your MBean will be usable by any client, including remote clients, without any requirement that the client have access to \u003cem\u003emodel-specific classes\u003c/em\u003e representing the types of your MBeans.\u003c/p\u003e \n\u003cp\u003eThe concepts are easier to understand by comparison with the Standard MBean concept. Here is how a managed object might be represented as a Standard MBean, and as an MXBean:\u003c/p\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eStandard MBean\u003c/h3\u003e \n \u003cpre\u003epublic interface MemoryPool\u003cb\u003eMBean\u003c/b\u003e {\n    String getName();\n    MemoryUsage getUsage();\n    // ...\n}\n          \u003c/pre\u003e \n\u003c/div\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eMXBean\u003c/h3\u003e \n \u003cpre\u003epublic interface MemoryPool\u003cb\u003eMXBean\u003c/b\u003e {\n    String getName();\n    MemoryUsage getUsage();\n    // ...\n}\n          \u003c/pre\u003e \n\u003c/div\u003e \n\u003cp\u003eAs you can see, the definitions are very similar. The only difference is that the convention for naming the interface is to use \u003ccode\u003e\u003cem\u003eSomething\u003c/em\u003eMXBean\u003c/code\u003e for MXBeans, rather than \u003ccode\u003e\u003cem\u003eSomething\u003c/em\u003eMBean\u003c/code\u003e for Standard MBeans.\u003c/p\u003e \n\u003cp\u003eIn this managed object, there is an attribute called \u003ccode\u003eUsage\u003c/code\u003e of type \u003ca href\u003d\"../../java/lang/management/MemoryUsage.html\" title\u003d\"class in java.lang.management\"\u003e\u003ccode\u003eMemoryUsage\u003c/code\u003e\u003c/a\u003e. The point of an attribute like this is that it gives a coherent snapshot of a set of data items. For example, it might include the current amount of used memory in the memory pool, and the current maximum of the memory pool. If these were separate items, obtained with separate \u003ca href\u003d\"MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)\"\u003e\u003ccode\u003egetAttribute\u003c/code\u003e\u003c/a\u003e calls, then we could get values seen at different times that were not consistent. We might get a \u003ccode\u003eused\u003c/code\u003e value that was greater than the \u003ccode\u003emax\u003c/code\u003e value.\u003c/p\u003e \n\u003cp\u003eSo, we might define \u003ccode\u003eMemoryUsage\u003c/code\u003e like this:\u003c/p\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eStandard MBean\u003c/h3\u003e \n \u003cpre\u003epublic class MemoryUsage \u003cb\u003eimplements Serializable\u003c/b\u003e {\n    // standard JavaBean conventions with getters\n\n    public MemoryUsage(long init, long used,\n                       long committed, long max) {...}\n    long getInit() {...}\n    long getUsed() {...}\n    long getCommitted() {...}\n    long getMax() {...}\n}\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eMXBean\u003c/h3\u003e \n \u003cpre\u003epublic class MemoryUsage {\n    // standard JavaBean conventions with getters\n    \u003cb\u003e@ConstructorParameters({\"init\", \"used\", \"committed\", \"max\"})\u003c/b\u003e\n    public MemoryUsage(long init, long used,\n                       long committed, long max) {...}\n    long getInit() {...}\n    long getUsed() {...}\n    long getCommitted() {...}\n    long getMax() {...}\n}\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003cp\u003eThe definitions are the same in the two cases, except that with the MXBean, \u003ccode\u003eMemoryUsage\u003c/code\u003e no longer needs to be marked \u003ccode\u003eSerializable\u003c/code\u003e (though it can be). On the other hand, we have added a \u003ca href\u003d\"ConstructorParameters.html\" title\u003d\"annotation in javax.management\"\u003e\u003ccode\u003e@ConstructorParameters\u003c/code\u003e\u003c/a\u003e annotation to link the constructor parameters to the corresponding getters. We will see more about this below.\u003c/p\u003e \n\u003cp\u003e\u003ccode\u003eMemoryUsage\u003c/code\u003e is a \u003cem\u003emodel-specific class\u003c/em\u003e. With Standard MBeans, a client of the MBean Server cannot access the \u003ccode\u003eUsage\u003c/code\u003e attribute if it does not know the class \u003ccode\u003eMemoryUsage\u003c/code\u003e. Suppose the client is a generic console based on JMX technology. Then the console would have to be configured with the model-specific classes of every application it might connect to. The problem is even worse for clients that are not written in the Java language. Then there may not be any way to tell the client what a \u003ccode\u003eMemoryUsage\u003c/code\u003e looks like.\u003c/p\u003e \n\u003cp\u003eThis is where MXBeans differ from Standard MBeans. Although we define the management interface in almost exactly the same way, the MXBean framework \u003cem\u003econverts\u003c/em\u003e model-specific classes into standard classes from the Java platform. Using arrays and the \u003ca href\u003d\"openmbean/CompositeData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeData\u003c/code\u003e\u003c/a\u003e and \u003ca href\u003d\"openmbean/TabularData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eTabularData\u003c/code\u003e\u003c/a\u003e classes from the standard \u003ca href\u003d\"openmbean/package-summary.html\"\u003e\u003ccode\u003ejavax.management.openmbean\u003c/code\u003e\u003c/a\u003e package, it is possible to build data structures of arbitrary complexity using only standard classes.\u003c/p\u003e \n\u003cp\u003eThis becomes clearer if we compare what the clients of the two models might look like:\u003c/p\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eStandard MBean\u003c/h3\u003e \n \u003cpre\u003eString name \u003d (String)\n    mbeanServer.\u003ca href\u003d\"MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)\"\u003e\u003ccode\u003egetAttribute\u003c/code\u003e\u003c/a\u003e(objectName, \"Name\");\n\u003cb\u003eMemoryUsage\u003c/b\u003e usage \u003d (\u003cb\u003eMemoryUsage\u003c/b\u003e)\n    mbeanServer.getAttribute(objectName, \"Usage\");\n\u003cb\u003elong used \u003d usage.getUsed();\u003c/b\u003e\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eMXBean\u003c/h3\u003e \n \u003cpre\u003eString name \u003d (String)\n    mbeanServer.\u003ca href\u003d\"MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)\"\u003e\u003ccode\u003egetAttribute\u003c/code\u003e\u003c/a\u003e(objectName, \"Name\");\n\u003cb\u003e\u003ca href\u003d\"openmbean/CompositeData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeData\u003c/code\u003e\u003c/a\u003e\u003c/b\u003e usage \u003d (\u003cb\u003eCompositeData\u003c/b\u003e)\n    mbeanServer.getAttribute(objectName, \"Usage\");\n\u003cb\u003elong used \u003d (Long) usage.\u003ca href\u003d\"openmbean/CompositeData.html#get(java.lang.String)\"\u003e\u003ccode\u003eget\u003c/code\u003e\u003c/a\u003e(\"used\");\u003c/b\u003e\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003cp\u003eFor attributes with simple types like \u003ccode\u003eString\u003c/code\u003e, the code is the same. But for attributes with complex types, the Standard MBean code requires the client to know the model-specific class \u003ccode\u003eMemoryUsage\u003c/code\u003e, while the MXBean code requires no non-standard classes.\u003c/p\u003e \n\u003cp\u003eThe client code shown here is slightly more complicated for the MXBean client. But, if the client does in fact know the model, here the interface \u003ccode\u003eMemoryPoolMXBean\u003c/code\u003e and the class \u003ccode\u003eMemoryUsage\u003c/code\u003e, then it can construct a \u003cem\u003eproxy\u003c/em\u003e. This is the recommended way to interact with managed objects when you know the model beforehand, regardless of whether you are using Standard MBeans or MXBeans:\u003c/p\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eStandard MBean\u003c/h3\u003e \n \u003cpre\u003eMemoryPool\u003cb\u003eMBean\u003c/b\u003e proxy \u003d\n    JMX.\u003cb\u003e\u003ca href\u003d\"JMX.html#newMBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)\"\u003e\u003ccode\u003enewMBeanProxy\u003c/code\u003e\u003c/a\u003e\u003c/b\u003e(\n        mbeanServer,\n        objectName,\n        MemoryPool\u003cb\u003eMBean\u003c/b\u003e.class);\nString name \u003d proxy.getName();\nMemoryUsage usage \u003d proxy.getUsage();\nlong used \u003d usage.getUsed();\n          \u003c/pre\u003e \n\u003c/div\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eMXBean\u003c/h3\u003e \n \u003cpre\u003eMemoryPool\u003cb\u003eMXBean\u003c/b\u003e proxy \u003d\n    JMX.\u003cb\u003e\u003ca href\u003d\"JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)\"\u003e\u003ccode\u003enewMXBeanProxy\u003c/code\u003e\u003c/a\u003e\u003c/b\u003e(\n        mbeanServer,\n        objectName,\n        MemoryPool\u003cb\u003eMXBean\u003c/b\u003e.class);\nString name \u003d proxy.getName();\nMemoryUsage usage \u003d proxy.getUsage();\nlong used \u003d usage.getUsed();\n          \u003c/pre\u003e \n\u003c/div\u003e \n\u003cp\u003eImplementing the MemoryPool object works similarly for both Standard MBeans and MXBeans.\u003c/p\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eStandard MBean\u003c/h3\u003e \n \u003cpre\u003epublic class MemoryPool\n        implements MemoryPool\u003cb\u003eMBean\u003c/b\u003e {\n    public String getName() {...}\n    public MemoryUsage getUsage() {...}\n    // ...\n}\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eMXBean\u003c/h3\u003e \n \u003cpre\u003epublic class MemoryPool\n        implements MemoryPool\u003cb\u003eMXBean\u003c/b\u003e {\n    public String getName() {...}\n    public MemoryUsage getUsage() {...}\n    // ...\n}\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003cp\u003eRegistering the MBean in the MBean Server works in the same way in both cases:\u003c/p\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eStandard MBean\u003c/h3\u003e \n \u003cpre\u003e{\n    MemoryPool\u003cb\u003eMBean\u003c/b\u003e pool \u003d new MemoryPool();\n    mbeanServer.\u003ca href\u003d\"MBeanServer.html#registerMBean(java.lang.Object,javax.management.ObjectName)\"\u003e\u003ccode\u003eregisterMBean\u003c/code\u003e\u003c/a\u003e(pool, objectName);\n}\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003cdiv style\u003d\"display:inline-block; margin: 0 3em\"\u003e \n \u003ch3\u003eMXBean\u003c/h3\u003e \n \u003cpre\u003e{\n    MemoryPool\u003cb\u003eMXBean\u003c/b\u003e pool \u003d new MemoryPool();\n    mbeanServer.\u003ca href\u003d\"MBeanServer.html#registerMBean(java.lang.Object,javax.management.ObjectName)\"\u003e\u003ccode\u003eregisterMBean\u003c/code\u003e\u003c/a\u003e(pool, objectName);\n}\n        \u003c/pre\u003e \n\u003c/div\u003e \n\u003ch2 id\u003d\"mxbean-def\"\u003eDefinition of an MXBean\u003c/h2\u003e \n\u003cp\u003eAn MXBean is a kind of MBean. An MXBean object can be registered directly in the MBean Server, or it can be used as an argument to \u003ca href\u003d\"StandardMBean.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eStandardMBean\u003c/code\u003e\u003c/a\u003e and the resultant MBean registered in the MBean Server.\u003c/p\u003e \n\u003cp\u003eWhen an object is registered in the MBean Server using the \u003ccode\u003eregisterMBean\u003c/code\u003e or \u003ccode\u003ecreateMBean\u003c/code\u003e methods of the \u003ca href\u003d\"MBeanServer.html\" title\u003d\"interface in javax.management\"\u003e\u003ccode\u003eMBeanServer\u003c/code\u003e\u003c/a\u003e interface, the object\u0027s class is examined to determine what type of MBean it is:\u003c/p\u003e \n\u003cul\u003e \n \u003cli\u003eIf the class implements the interface \u003ca href\u003d\"DynamicMBean.html\" title\u003d\"interface in javax.management\"\u003e\u003ccode\u003eDynamicMBean\u003c/code\u003e\u003c/a\u003e then the MBean is a Dynamic MBean. Note that the class \u003ccode\u003eStandardMBean\u003c/code\u003e implements this interface, so this case applies to a Standard MBean or MXBean created using the class \u003ccode\u003eStandardMBean\u003c/code\u003e.\u003c/li\u003e \n \u003cli\u003eOtherwise, if the class matches the Standard MBean naming conventions, then the MBean is a Standard MBean.\u003c/li\u003e \n \u003cli\u003eOtherwise, it may be an MXBean. The set of interfaces implemented by the object is examined for interfaces that: \n  \u003cul\u003e \n   \u003cli\u003ehave a class name \u003ccode\u003e\u003cem\u003eS\u003c/em\u003eMXBean\u003c/code\u003e where \u003ccode\u003e\u003cem\u003eS\u003c/em\u003e\u003c/code\u003e is any non-empty string, and do not have an annotation \u003ccode\u003e@MXBean(false)\u003c/code\u003e; and/or\u003c/li\u003e \n   \u003cli\u003ehave an annotation \u003ccode\u003e@MXBean(true)\u003c/code\u003e or just \u003ccode\u003e@MXBean\u003c/code\u003e.\u003c/li\u003e \n  \u003c/ul\u003e If there is exactly one such interface, or if there is one such interface that is a subinterface of all the others, then the object is an MXBean. The interface in question is the \u003cem\u003eMXBean interface\u003c/em\u003e. In the example above, the MXBean interface is \u003ccode\u003eMemoryPoolMXBean\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eIf none of these conditions is met, the MBean is invalid and the attempt to register it will generate \u003ca href\u003d\"NotCompliantMBeanException.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eNotCompliantMBeanException\u003c/code\u003e\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003eEvery Java type that appears as the parameter or return type of a method in an MXBean interface must be \u003cem\u003econvertible\u003c/em\u003e using the rules below. Additionally, parameters must be \u003cem\u003ereconstructible\u003c/em\u003e as defined below.\u003c/p\u003e \n\u003cp\u003eAn attempt to construct an MXBean that does not conform to the above rules will produce an exception.\u003c/p\u003e \n\u003ch2 id\u003d\"naming-conv\"\u003eNaming conventions\u003c/h2\u003e \n\u003cp\u003eThe same naming conventions are applied to the methods in an MXBean as in a Standard MBean:\u003c/p\u003e \n\u003col\u003e \n \u003cli\u003eA method \u003ccode\u003e\u003cem\u003eT\u003c/em\u003e get\u003cem\u003eN\u003c/em\u003e()\u003c/code\u003e, where \u003ccode\u003e\u003cem\u003eT\u003c/em\u003e\u003c/code\u003e is a Java type (not \u003ccode\u003evoid\u003c/code\u003e) and \u003ccode\u003e\u003cem\u003eN\u003c/em\u003e\u003c/code\u003e is a non-empty string, specifies that there is a readable attribute called \u003ccode\u003e\u003cem\u003eN\u003c/em\u003e\u003c/code\u003e. The Java type and Open type of the attribute are determined by the mapping rules below. The method \u003ccode\u003efinal Class getClass()\u003c/code\u003e inherited from \u003ccode\u003e Object\u003c/code\u003e is ignored when looking for getters.\u003c/li\u003e \n \u003cli\u003eA method \u003ccode\u003eboolean is\u003cem\u003eN\u003c/em\u003e()\u003c/code\u003e specifies that there is a readable attribute called \u003ccode\u003e\u003cem\u003eN\u003c/em\u003e\u003c/code\u003e with Java type \u003ccode\u003eboolean\u003c/code\u003e and Open type \u003ccode\u003eSimpleType.Boolean\u003c/code\u003e.\u003c/li\u003e \n \u003cli\u003eA method \u003ccode\u003evoid set\u003cem\u003eN\u003c/em\u003e(\u003cem\u003eT\u003c/em\u003e x)\u003c/code\u003e specifies that there is a writeable attribute called \u003ccode\u003e\u003cem\u003eN\u003c/em\u003e\u003c/code\u003e. The Java type and Open type of the attribute are determined by the mapping rules below. (Of course, the name \u003ccode\u003ex\u003c/code\u003e of the parameter is irrelevant.)\u003c/li\u003e \n \u003cli\u003eEvery other method specifies that there is an operation with the same name as the method. The Java type and Open type of the return value and of each parameter are determined by the mapping rules below.\u003c/li\u003e \n\u003c/ol\u003e \n\u003cp\u003eThe rules for \u003ccode\u003eget\u003cem\u003eN\u003c/em\u003e\u003c/code\u003e and \u003ccode\u003eis\u003cem\u003eN\u003c/em\u003e\u003c/code\u003e collectively define the notion of a \u003cem\u003egetter\u003c/em\u003e. The rule for \u003ccode\u003eset\u003cem\u003eN\u003c/em\u003e\u003c/code\u003e defines the notion of a \u003cem\u003esetter\u003c/em\u003e.\u003c/p\u003e \n\u003cp\u003eIt is an error for there to be two getters with the same name, or two setters with the same name. If there is a getter and a setter for the same name, then the type \u003ccode\u003e\u003cem\u003eT\u003c/em\u003e\u003c/code\u003e in both must be the same. In this case the attribute is read/write. If there is only a getter or only a setter, the attribute is read-only or write-only respectively.\u003c/p\u003e \n\u003ch2 id\u003d\"mapping-rules\"\u003eType mapping rules\u003c/h2\u003e \n\u003cp\u003eAn MXBean is a kind of Open MBean, as defined by the \u003ca href\u003d\"openmbean/package-summary.html\"\u003e\u003ccode\u003ejavax.management.openmbean\u003c/code\u003e\u003c/a\u003e package. This means that the types of attributes, operation parameters, and operation return values must all be describable using \u003cem\u003eOpen Types\u003c/em\u003e, that is the four standard subclasses of \u003ca href\u003d\"openmbean/OpenType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eOpenType\u003c/code\u003e\u003c/a\u003e. MXBeans achieve this by mapping Java types into Open Types.\u003c/p\u003e \n\u003cp\u003eFor every Java type \u003cem\u003eJ\u003c/em\u003e, the MXBean mapping is described by the following information:\u003c/p\u003e \n\u003cul\u003e \n \u003cli\u003eThe corresponding Open Type, \u003cem\u003eopentype(J)\u003c/em\u003e. This is an instance of a subclass of \u003ca href\u003d\"openmbean/OpenType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eOpenType\u003c/code\u003e\u003c/a\u003e.\u003c/li\u003e \n \u003cli\u003eThe \u003cem\u003emapped\u003c/em\u003e Java type, \u003cem\u003eopendata(J)\u003c/em\u003e, which is always the same for any given \u003cem\u003eopentype(J)\u003c/em\u003e. This is a Java class.\u003c/li\u003e \n \u003cli\u003eHow a value is converted from type \u003cem\u003eJ\u003c/em\u003e to type \u003cem\u003eopendata(J)\u003c/em\u003e.\u003c/li\u003e \n \u003cli\u003eHow a value is converted from type \u003cem\u003eopendata(J)\u003c/em\u003e to type \u003cem\u003eJ\u003c/em\u003e, if it can be.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003eFor example, for the Java type \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e:\u003c/p\u003e \n\u003cul\u003e \n \u003cli\u003eThe Open Type, \u003cem\u003eopentype(\u003c/em\u003e\u003ccode\u003e List\u0026lt;String\u0026gt;\u003c/code\u003e\u003cem\u003e)\u003c/em\u003e, is \u003ca href\u003d\"openmbean/ArrayType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eArrayType\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e(1, \u003c/code\u003e\u003ca href\u003d\"openmbean/SimpleType.html#STRING\"\u003e\u003ccode\u003eSimpleType.STRING\u003c/code\u003e\u003c/a\u003e\u003ccode\u003e)\u003c/code\u003e, representing a 1-dimensional array of \u003ccode\u003eString\u003c/code\u003es.\u003c/li\u003e \n \u003cli\u003eThe mapped Java type, \u003cem\u003eopendata(\u003c/em\u003e\u003ccode\u003e List\u0026lt;String\u0026gt;\u003c/code\u003e\u003cem\u003e)\u003c/em\u003e, is \u003ccode\u003eString[]\u003c/code\u003e.\u003c/li\u003e \n \u003cli\u003eA \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e can be converted to a \u003ccode\u003eString[]\u003c/code\u003e using \u003ca href\u003d\"../../../java.base/java/util/List.html#toArray(T%5B%5D)\"\u003e\u003ccode\u003eList.toArray(new String[0])\u003c/code\u003e\u003c/a\u003e.\u003c/li\u003e \n \u003cli\u003eA \u003ccode\u003eString[]\u003c/code\u003e can be converted to a \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e using \u003ca href\u003d\"../../../java.base/java/util/Arrays.html#asList(T...)\"\u003e\u003ccode\u003eArrays.asList\u003c/code\u003e\u003c/a\u003e.\u003c/li\u003e \n\u003c/ul\u003e \n\u003cp\u003eIf no mapping rules exist to derive \u003cem\u003eopentype(J)\u003c/em\u003e from \u003cem\u003eJ\u003c/em\u003e, then \u003cem\u003eJ\u003c/em\u003e cannot be the type of a method parameter or return value in an MXBean interface.\u003c/p\u003e \n\u003cp id\u003d\"reconstructible-def\"\u003eIf there is a way to convert \u003cem\u003eopendata(J)\u003c/em\u003e back to \u003cem\u003eJ\u003c/em\u003e then we say that \u003cem\u003eJ\u003c/em\u003e is \u003cem\u003ereconstructible\u003c/em\u003e. All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from \u003cem\u003eopendata(J)\u003c/em\u003e to \u003cem\u003eJ\u003c/em\u003e. In a proxy generated by \u003ca href\u003d\"JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)\"\u003e\u003ccode\u003eJMX.newMXBeanProxy\u003c/code\u003e\u003c/a\u003e, it is the return values of the methods in the MXBean interface that must be reconstructible.\u003c/p\u003e \n\u003cp\u003eNull values are allowed for all Java types and Open Types, except primitive Java types where they are not possible. When converting from type \u003cem\u003eJ\u003c/em\u003e to type \u003cem\u003eopendata(J)\u003c/em\u003e or from type \u003cem\u003eopendata(J)\u003c/em\u003e to type \u003cem\u003eJ\u003c/em\u003e, a null value is mapped to a null value.\u003c/p\u003e \n\u003cp\u003eThe following table summarizes the type mapping rules.\u003c/p\u003e \n\u003ctable class\u003d\"striped\"\u003e \n \u003ccaption style\u003d\"display:none\"\u003e\n  Type Mapping Rules\n \u003c/caption\u003e \n \u003cthead\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"col\"\u003eJava type \u003cem\u003eJ\u003c/em\u003e\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003e\u003cem\u003eopentype(J)\u003c/em\u003e\u003c/th\u003e \n   \u003cth scope\u003d\"col\"\u003e\u003cem\u003eopendata(J)\u003c/em\u003e\u003c/th\u003e \n  \u003c/tr\u003e \n \u003c/thead\u003e \n \u003ctbody style\u003d\"text-align:left; vertical-align:top\"\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eboolean\u003c/code\u003e, etc\u003cbr\u003e (the 8 primitive Java types)\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eSimpleType.INTEGER\u003c/code\u003e,\u003cbr\u003e \u003ccode\u003eSimpleType.BOOLEAN\u003c/code\u003e, etc\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eInteger\u003c/code\u003e, \u003ccode\u003eBoolean\u003c/code\u003e, etc\u003cbr\u003e (the corresponding boxed types)\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003eInteger\u003c/code\u003e, \u003ccode\u003eObjectName\u003c/code\u003e, etc\u003cbr\u003e (the types covered by \u003ca href\u003d\"openmbean/SimpleType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eSimpleType\u003c/code\u003e\u003c/a\u003e)\u003c/th\u003e \n   \u003ctd\u003ethe corresponding \u003ccode\u003eSimpleType\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003cem\u003eJ\u003c/em\u003e, the same type\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003eint[]\u003c/code\u003e etc\u003cbr\u003e (a one-dimensional array with primitive element type)\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eArrayType.getPrimitiveArrayType(int[].class)\u003c/code\u003e etc\u003c/td\u003e \n   \u003ctd\u003e\u003cem\u003eJ\u003c/em\u003e, the same type\u003c/td\u003e \n  \u003c/tr\u003e\n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e[]\u003c/code\u003e\u003cbr\u003e (an array with non-primitive element type \u003cem\u003eE\u003c/em\u003e; this includes \u003ccode\u003eint[][]\u003c/code\u003e, where \u003cem\u003eE\u003c/em\u003e is \u003ccode\u003eint[]\u003c/code\u003e)\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eArrayType.getArrayType(\u003c/code\u003e\u003cem\u003eopentype(E)\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003cem\u003eopendata(E)\u003c/em\u003e\u003ccode\u003e[]\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003eList\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e\u003cbr\u003e \u003ccode\u003eSet\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e\u003cbr\u003e \u003ccode\u003eSortedSet\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e (see below)\u003c/th\u003e \n   \u003ctd\u003esame as for \u003cem\u003eE\u003c/em\u003e\u003ccode\u003e[]\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003esame as for \u003cem\u003eE\u003c/em\u003e\u003ccode\u003e[]\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eAn enumeration \u003cem\u003eE\u003c/em\u003e\u003cbr\u003e (declared in Java as \u003ccode\u003eenum \u003c/code\u003e\u003cem\u003eE\u003c/em\u003e \u003ccode\u003e{...}\u003c/code\u003e)\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eSimpleType.STRING\u003c/code\u003e\u003c/td\u003e \n   \u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003e\u003ccode\u003eMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e\u003cbr\u003e \u003ccode\u003eSortedMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e\u003c/th\u003e \n   \u003ctd\u003e\u003ca href\u003d\"openmbean/TabularType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eTabularType\u003c/code\u003e\u003c/a\u003e\u003cbr\u003e (see below)\u003c/td\u003e \n   \u003ctd\u003e\u003ca href\u003d\"openmbean/TabularData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eTabularData\u003c/code\u003e\u003c/a\u003e\u003cbr\u003e (see below)\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eAn MXBean interface\u003c/th\u003e \n   \u003ctd\u003e\u003ccode\u003eSimpleType.OBJECTNAME\u003c/code\u003e\u003cbr\u003e (see below)\u003c/td\u003e \n   \u003ctd\u003e\u003ca href\u003d\"ObjectName.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eObjectName\u003c/code\u003e\u003c/a\u003e\u003cbr\u003e (see below)\u003c/td\u003e \n  \u003c/tr\u003e \n  \u003ctr\u003e \n   \u003cth scope\u003d\"row\"\u003eAny other type\u003c/th\u003e \n   \u003ctd\u003e\u003ca href\u003d\"openmbean/CompositeType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeType\u003c/code\u003e\u003c/a\u003e, if possible\u003cbr\u003e (see below)\u003c/td\u003e \n   \u003ctd\u003e\u003ca href\u003d\"openmbean/CompositeData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeData\u003c/code\u003e\u003c/a\u003e\u003c/td\u003e \n  \u003c/tr\u003e\n \u003c/tbody\u003e \n\u003c/table\u003e \n\u003cp\u003eThe following sections give further details of these rules.\u003c/p\u003e \n\u003ch3\u003eMappings for primitive types\u003c/h3\u003e \n\u003cp\u003eThe 8 primitive Java types (\u003ccode\u003eboolean\u003c/code\u003e, \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003e long\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e, \u003ccode\u003echar\u003c/code\u003e) are mapped to the corresponding boxed types from \u003ccode\u003ejava.lang\u003c/code\u003e, namely \u003ccode\u003e Boolean\u003c/code\u003e, \u003ccode\u003eByte\u003c/code\u003e, etc. The Open Type is the corresponding \u003ccode\u003eSimpleType\u003c/code\u003e. Thus, \u003cem\u003eopentype(\u003c/em\u003e\u003ccode\u003e long\u003c/code\u003e\u003cem\u003e)\u003c/em\u003e is \u003ccode\u003eSimpleType.LONG\u003c/code\u003e, and \u003cem\u003eopendata(\u003c/em\u003e\u003ccode\u003elong\u003c/code\u003e\u003cem\u003e)\u003c/em\u003e is \u003ccode\u003e java.lang.Long\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eAn array of primitive type such as \u003ccode\u003elong[]\u003c/code\u003e can be represented directly as an Open Type. Thus, \u003cem\u003eopenType(\u003c/em\u003e\u003ccode\u003e long[]\u003c/code\u003e\u003cem\u003e)\u003c/em\u003e is \u003ccode\u003e ArrayType.getPrimitiveArrayType(long[].class)\u003c/code\u003e, and \u003cem\u003eopendata(\u003c/em\u003e\u003ccode\u003elong[]\u003c/code\u003e\u003cem\u003e)\u003c/em\u003e is \u003ccode\u003e long[]\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eIn practice, the difference between a plain \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003e Integer\u003c/code\u003e, etc, does not show up because operations in the JMX API are always on Java objects, not primitives. However, the difference \u003cem\u003edoes\u003c/em\u003e show up with arrays.\u003c/p\u003e \n\u003ch3\u003eMappings for collections (\u003ccode\u003eList\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e etc)\u003c/h3\u003e \n\u003cp\u003eA \u003ccode\u003eList\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e or \u003ccode\u003e Set\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e, such as \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e or \u003ccode\u003e Set\u0026lt;ObjectName\u0026gt;\u003c/code\u003e, is mapped in the same way as an array of the same element type, such as \u003ccode\u003eString[]\u003c/code\u003e or \u003ccode\u003e ObjectName[]\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eA \u003ccode\u003eSortedSet\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e is also mapped in the same way as an \u003cem\u003eE\u003c/em\u003e\u003ccode\u003e[]\u003c/code\u003e, but it is only convertible if \u003cem\u003eE\u003c/em\u003e is a class or interface that implements \u003ca href\u003d\"../../../java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eComparable\u003c/code\u003e\u003c/a\u003e. Thus, a \u003ccode\u003eSortedSet\u0026lt;String\u0026gt;\u003c/code\u003e or \u003ccode\u003eSortedSet\u0026lt;Integer\u0026gt;\u003c/code\u003e is convertible, but a \u003ccode\u003e SortedSet\u0026lt;int[]\u0026gt;\u003c/code\u003e or \u003ccode\u003eSortedSet\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;\u003c/code\u003e is not. The conversion of a \u003ccode\u003eSortedSet\u003c/code\u003e instance will fail with an \u003ccode\u003eIllegalArgumentException\u003c/code\u003e if it has a non-null \u003ca href\u003d\"../../../java.base/java/util/SortedSet.html#comparator()\"\u003e\u003ccode\u003ecomparator()\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e \n\u003cp\u003eA \u003ccode\u003eList\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e is reconstructed as a \u003ccode\u003ejava.util.ArrayList\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e; a \u003ccode\u003eSet\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e as a \u003ccode\u003ejava.util.HashSet\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e; a \u003ccode\u003eSortedSet\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e as a \u003ccode\u003ejava.util.TreeSet\u0026lt;\u003c/code\u003e\u003cem\u003eE\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e.\u003c/p\u003e \n\u003ch3\u003eMappings for maps (\u003ccode\u003eMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e etc)\u003c/h3\u003e \n\u003cp\u003eA \u003ccode\u003eMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e or \u003ccode\u003e SortedMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e, for example \u003ccode\u003e Map\u0026lt;String,ObjectName\u0026gt;\u003c/code\u003e, has Open Type \u003ca href\u003d\"openmbean/TabularType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eTabularType\u003c/code\u003e\u003c/a\u003e and is mapped to a \u003ca href\u003d\"openmbean/TabularData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eTabularData\u003c/code\u003e\u003c/a\u003e. The \u003ccode\u003eTabularType\u003c/code\u003e has two items called \u003ccode\u003ekey\u003c/code\u003e and \u003ccode\u003evalue\u003c/code\u003e. The Open Type of \u003ccode\u003ekey\u003c/code\u003e is \u003cem\u003eopentype(K)\u003c/em\u003e, and the Open Type of \u003ccode\u003evalue\u003c/code\u003e is \u003cem\u003eopentype(V)\u003c/em\u003e. The index of the \u003ccode\u003eTabularType\u003c/code\u003e is the single item \u003ccode\u003ekey\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eFor example, the \u003ccode\u003eTabularType\u003c/code\u003e for a \u003ccode\u003e Map\u0026lt;String,ObjectName\u0026gt;\u003c/code\u003e might be constructed with code like this:\u003c/p\u003e \n\u003cpre\u003eString typeName \u003d\n    \"java.util.Map\u0026lt;java.lang.String, javax.management.ObjectName\u0026gt;\";\nString[] keyValue \u003d\n    new String[] {\"key\", \"value\"};\nOpenType[] openTypes \u003d\n    new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};\nCompositeType rowType \u003d\n    new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);\nTabularType tabularType \u003d\n    new TabularType(typeName, typeName, rowType, new String[] {\"key\"});\n    \u003c/pre\u003e \n\u003cp\u003eThe \u003ccode\u003etypeName\u003c/code\u003e here is determined by the \u003ca href\u003d\"#type-names\"\u003e type name rules\u003c/a\u003e detailed below. \u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eSortedMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e is mapped in the same way, but it is only convertible if \u003cem\u003eK\u003c/em\u003e is a class or interface that implements \u003ca href\u003d\"../../../java.base/java/lang/Comparable.html\" title\u003d\"interface in java.lang\"\u003e\u003ccode\u003eComparable\u003c/code\u003e\u003c/a\u003e. Thus, a \u003ccode\u003eSortedMap\u0026lt;String,int[]\u0026gt;\u003c/code\u003e is convertible, but a \u003ccode\u003eSortedMap\u0026lt;int[],String\u0026gt;\u003c/code\u003e is not. The conversion of a \u003ccode\u003eSortedMap\u003c/code\u003e instance will fail with an \u003ccode\u003e IllegalArgumentException\u003c/code\u003e if it has a non-null \u003ca href\u003d\"../../../java.base/java/util/SortedMap.html#comparator()\"\u003e\u003ccode\u003ecomparator()\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e \n\u003cp\u003eA \u003ccode\u003eMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e is reconstructed as a \u003ccode\u003ejava.util.HashMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e; a \u003ccode\u003eSortedMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e as a \u003ccode\u003ejava.util.TreeMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003e\u003ccode\u003eTabularData\u003c/code\u003e is an interface. The concrete class that is used to represent a \u003ccode\u003eMap\u0026lt;\u003c/code\u003e\u003cem\u003eK\u003c/em\u003e,\u003cem\u003eV\u003c/em\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e as Open Data is \u003ca href\u003d\"openmbean/TabularDataSupport.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eTabularDataSupport\u003c/code\u003e\u003c/a\u003e, or another class implementing \u003ccode\u003e TabularData\u003c/code\u003e that serializes as \u003ccode\u003eTabularDataSupport\u003c/code\u003e.\u003c/p\u003e \n\u003ch3 id\u003d\"mxbean-map\"\u003eMappings for MXBean interfaces\u003c/h3\u003e \n\u003cp\u003eAn MXBean interface, or a type referenced within an MXBean interface, can reference another MXBean interface, \u003cem\u003eJ\u003c/em\u003e. Then \u003cem\u003eopentype(J)\u003c/em\u003e is \u003ccode\u003eSimpleType.OBJECTNAME\u003c/code\u003e and \u003cem\u003eopendata(J)\u003c/em\u003e is \u003ccode\u003eObjectName\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eFor example, suppose you have two MXBean interfaces like this:\u003c/p\u003e \n\u003cpre\u003epublic interface ProductMXBean {\n    public ModuleMXBean[] getModules();\n}\n\npublic interface ModuleMXBean {\n    public ProductMXBean getProduct();\n}\n    \u003c/pre\u003e \n\u003cp\u003eThe object implementing the \u003ccode\u003eModuleMXBean\u003c/code\u003e interface returns from its \u003ccode\u003egetProduct\u003c/code\u003e method an object implementing the \u003ccode\u003eProductMXBean\u003c/code\u003e interface. The \u003ccode\u003eModuleMXBean\u003c/code\u003e object and the returned \u003ccode\u003e ProductMXBean\u003c/code\u003e objects must both be registered as MXBeans in the same MBean Server.\u003c/p\u003e \n\u003cp\u003eThe method \u003ccode\u003eModuleMXBean.getProduct()\u003c/code\u003e defines an attribute called \u003ccode\u003eProduct\u003c/code\u003e. The Open Type for this attribute is \u003ccode\u003eSimpleType.OBJECTNAME\u003c/code\u003e, and the corresponding \u003ccode\u003eObjectName\u003c/code\u003e value will be the name under which the referenced \u003ccode\u003eProductMXBean\u003c/code\u003e is registered in the MBean Server.\u003c/p\u003e \n\u003cp\u003eIf you make an MXBean proxy for a \u003ccode\u003eModuleMXBean\u003c/code\u003e and call its \u003ccode\u003egetProduct()\u003c/code\u003e method, the proxy will map the \u003ccode\u003eObjectName\u003c/code\u003e back into a \u003ccode\u003eProductMXBean\u003c/code\u003e by making another MXBean proxy. More formally, when a proxy made with \u003ca href\u003d\"JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)\"\u003e\u003ccode\u003eJMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)\u003c/code\u003e\u003c/a\u003e needs to map \u003ccode\u003eobjectNameY\u003c/code\u003e back into \u003ccode\u003e interfaceY\u003c/code\u003e, another MXBean interface, it does so with \u003ccode\u003e JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)\u003c/code\u003e. The implementation may return a proxy that was previously created by a call to \u003ccode\u003eJMX.newMXBeanProxy\u003c/code\u003e with the same parameters, or it may create a new proxy.\u003c/p\u003e \n\u003cp\u003eThe reverse mapping is illustrated by the following change to the \u003ccode\u003eModuleMXBean\u003c/code\u003e interface:\u003c/p\u003e \n\u003cpre\u003epublic interface ModuleMXBean {\n    public ProductMXBean getProduct();\n    public void setProduct(ProductMXBean c);\n}\n    \u003c/pre\u003e \n\u003cp\u003eThe presence of the \u003ccode\u003esetProduct\u003c/code\u003e method now means that the \u003ccode\u003eProduct\u003c/code\u003e attribute is read/write. As before, the value of this attribute is an \u003ccode\u003eObjectName\u003c/code\u003e. When the attribute is set, the \u003ccode\u003eObjectName\u003c/code\u003e must be converted into the \u003ccode\u003eProductMXBean\u003c/code\u003e object that the \u003ccode\u003esetProduct\u003c/code\u003e method expects. This object will be an MXBean proxy for the given \u003ccode\u003eObjectName\u003c/code\u003e in the same MBean Server.\u003c/p\u003e \n\u003cp\u003eIf you make an MXBean proxy for a \u003ccode\u003eModuleMXBean\u003c/code\u003e and call its \u003ccode\u003esetProduct\u003c/code\u003e method, the proxy will map its \u003ccode\u003eProductMXBean\u003c/code\u003e argument back into an \u003ccode\u003eObjectName\u003c/code\u003e. This will only work if the argument is in fact another proxy, for a \u003ccode\u003eProductMXBean\u003c/code\u003e in the same \u003ccode\u003e MBeanServerConnection\u003c/code\u003e. The proxy can have been returned from another proxy (like \u003ccode\u003eModuleMXBean.getProduct()\u003c/code\u003e which returns a proxy for a \u003ccode\u003eProductMXBean\u003c/code\u003e); or it can have been created by \u003ca href\u003d\"JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)\"\u003e\u003ccode\u003eJMX.newMXBeanProxy\u003c/code\u003e\u003c/a\u003e; or it can have been created using \u003ca href\u003d\"../../../java.base/java/lang/reflect/Proxy.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eProxy\u003c/code\u003e\u003c/a\u003e with an invocation handler that is \u003ca href\u003d\"MBeanServerInvocationHandler.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eMBeanServerInvocationHandler\u003c/code\u003e\u003c/a\u003e or a subclass.\u003c/p\u003e \n\u003cp\u003eIf the same MXBean were registered under two different \u003ccode\u003eObjectName\u003c/code\u003es, a reference to that MXBean from another MXBean would be ambiguous. Therefore, if an MXBean object is already registered in an MBean Server and an attempt is made to register it in the same MBean Server under another name, the result is an \u003ca href\u003d\"InstanceAlreadyExistsException.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eInstanceAlreadyExistsException\u003c/code\u003e\u003c/a\u003e. Registering the same MBean object under more than one name is discouraged in general, notably because it does not work well for MBeans that are \u003ca href\u003d\"NotificationBroadcaster.html\" title\u003d\"interface in javax.management\"\u003e\u003ccode\u003eNotificationBroadcaster\u003c/code\u003e\u003c/a\u003es.\u003c/p\u003e \n\u003ch3 id\u003d\"composite-map\"\u003eMappings for other types\u003c/h3\u003e \n\u003cp\u003eGiven a Java class or interface \u003cem\u003eJ\u003c/em\u003e that does not match the other rules in the table above, the MXBean framework will attempt to map it to a \u003ca href\u003d\"openmbean/CompositeType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeType\u003c/code\u003e\u003c/a\u003e as follows. The type name of this \u003ccode\u003eCompositeType\u003c/code\u003e is determined by the \u003ca href\u003d\"#type-names\"\u003e type name rules\u003c/a\u003e below.\u003c/p\u003e \n\u003cp\u003eThe class is examined for getters using the conventions \u003ca href\u003d\"#naming-conv\"\u003eabove\u003c/a\u003e. (Getters must be public instance methods.) If there are no getters, or if any getter has a type that is not convertible, then \u003cem\u003eJ\u003c/em\u003e is not convertible.\u003c/p\u003e \n\u003cp\u003eIf there is at least one getter and every getter has a convertible type, then \u003cem\u003eopentype(J)\u003c/em\u003e is a \u003ccode\u003e CompositeType\u003c/code\u003e with one item for every getter. If the getter is \u003c/p\u003e\n\u003cblockquote\u003e \n \u003ccode\u003e\u003cem\u003eT\u003c/em\u003e get\u003cem\u003eName\u003c/em\u003e()\u003c/code\u003e \n\u003c/blockquote\u003e then the item in the \n\u003ccode\u003eCompositeType\u003c/code\u003e is called \n\u003ccode\u003ename\u003c/code\u003e and has type \n\u003cem\u003eopentype(T)\u003c/em\u003e. For example, if the item is \n\u003cblockquote\u003e \n \u003ccode\u003eString getOwner()\u003c/code\u003e \n\u003c/blockquote\u003e then the item is called \n\u003ccode\u003eowner\u003c/code\u003e and has Open Type \n\u003ccode\u003e SimpleType.STRING\u003c/code\u003e. If the getter is \n\u003cblockquote\u003e \n \u003ccode\u003eboolean is\u003cem\u003eName\u003c/em\u003e()\u003c/code\u003e \n\u003c/blockquote\u003e then the item in the \n\u003ccode\u003eCompositeType\u003c/code\u003e is called \n\u003ccode\u003ename\u003c/code\u003e and has type \n\u003ccode\u003eSimpleType.BOOLEAN\u003c/code\u003e. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eNotice that the first character (or code point) is converted to lower case. This follows the Java Beans convention, which for historical reasons is different from the Standard MBean convention. In a Standard MBean or MXBean interface, a method \u003ccode\u003egetOwner\u003c/code\u003e defines an attribute called \u003ccode\u003eOwner\u003c/code\u003e, while in a Java Bean or mapped \u003ccode\u003eCompositeType\u003c/code\u003e, a method \u003ccode\u003e getOwner\u003c/code\u003e defines a property or item called \u003ccode\u003eowner\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eIf two methods produce the same item name (for example, \u003ccode\u003e getOwner\u003c/code\u003e and \u003ccode\u003eisOwner\u003c/code\u003e, or \u003ccode\u003egetOwner\u003c/code\u003e and \u003ccode\u003e getowner\u003c/code\u003e) then the type is not convertible.\u003c/p\u003e \n\u003cp\u003eWhen the Open Type is \u003ccode\u003eCompositeType\u003c/code\u003e, the corresponding mapped Java type (\u003cem\u003eopendata(J)\u003c/em\u003e) is \u003ca href\u003d\"openmbean/CompositeData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeData\u003c/code\u003e\u003c/a\u003e. The mapping from an instance of \u003cem\u003eJ\u003c/em\u003e to a \u003ccode\u003eCompositeData\u003c/code\u003e corresponding to the \u003ccode\u003eCompositeType\u003c/code\u003e just described is done as follows. First, if \u003cem\u003eJ\u003c/em\u003e implements the interface \u003ca href\u003d\"openmbean/CompositeDataView.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeDataView\u003c/code\u003e\u003c/a\u003e, then that interface\u0027s \u003ca href\u003d\"openmbean/CompositeDataView.html#toCompositeData(javax.management.openmbean.CompositeType)\"\u003e\u003ccode\u003etoCompositeData\u003c/code\u003e\u003c/a\u003e method is called to do the conversion. Otherwise, the \u003ccode\u003eCompositeData\u003c/code\u003e is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as\u003c/p\u003e \n\u003cblockquote\u003e \n \u003ccode\u003eList\u0026lt;String\u0026gt; getNames()\u003c/code\u003e \n\u003c/blockquote\u003e \n\u003cp\u003ewill have been mapped to an item with name \"\u003ccode\u003enames\u003c/code\u003e\" and Open Type \u003ccode\u003eArrayType(1, SimpleType.STRING)\u003c/code\u003e. The conversion to \u003ccode\u003eCompositeData\u003c/code\u003e will call \u003ccode\u003egetNames()\u003c/code\u003e and convert the resultant \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e into a \u003ccode\u003eString[]\u003c/code\u003e for the item \"\u003ccode\u003enames\u003c/code\u003e\".\u003c/p\u003e \n\u003cp\u003e\u003ccode\u003eCompositeData\u003c/code\u003e is an interface. The concrete class that is used to represent a type as Open Data is \u003ca href\u003d\"openmbean/CompositeDataSupport.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeDataSupport\u003c/code\u003e\u003c/a\u003e, or another class implementing \u003ccode\u003e CompositeData\u003c/code\u003e that serializes as \u003ccode\u003e CompositeDataSupport\u003c/code\u003e.\u003c/p\u003e \n\u003ch4\u003eReconstructing an instance of Java type \u003cem\u003eJ\u003c/em\u003e from a \u003ccode\u003eCompositeData\u003c/code\u003e\u003c/h4\u003e \n\u003cp\u003eIf \u003cem\u003eopendata(J)\u003c/em\u003e is \u003ccode\u003eCompositeData\u003c/code\u003e for a Java type \u003cem\u003eJ\u003c/em\u003e, then either an instance of \u003cem\u003eJ\u003c/em\u003e can be reconstructed from a \u003ccode\u003eCompositeData\u003c/code\u003e, or \u003cem\u003eJ\u003c/em\u003e is not reconstructible. If any item in the \u003ccode\u003eCompositeData\u003c/code\u003e is not reconstructible, then \u003cem\u003eJ\u003c/em\u003e is not reconstructible either.\u003c/p\u003e \n\u003cp\u003eFor any given \u003cem\u003eJ\u003c/em\u003e, the following rules are consulted to determine how to reconstruct instances of \u003cem\u003eJ\u003c/em\u003e from \u003ccode\u003eCompositeData\u003c/code\u003e. The first applicable rule in the list is the one that will be used.\u003c/p\u003e \n\u003col\u003e \n \u003cli\u003e\u003cp\u003eIf \u003cem\u003eJ\u003c/em\u003e has a method\u003cbr\u003e \u003ccode\u003epublic static \u003c/code\u003e\u003cem\u003eJ \u003c/em\u003e\u003ccode\u003efrom(CompositeData cd)\u003c/code\u003e\u003cbr\u003e then that method is called to reconstruct an instance of \u003cem\u003eJ\u003c/em\u003e.\u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003eOtherwise, if \u003cem\u003eJ\u003c/em\u003e has at least one public constructor with either \u003ca href\u003d\"ConstructorParameters.html\" title\u003d\"annotation in javax.management\"\u003e\u003ccode\u003e@javax.management.ConstructorParameters\u003c/code\u003e\u003c/a\u003e or \u003ccode\u003e@java.beans.ConstructoProperties\u003c/code\u003e annotation, then one of those constructors (not necessarily always the same one) will be called to reconstruct an instance of \u003cem\u003eJ\u003c/em\u003e. If a constructor is annotated with both \u003ccode\u003e@javax.management.ConstructorParameters\u003c/code\u003e and \u003ccode\u003e@java.beans.ConstructorProperties\u003c/code\u003e, \u003ccode\u003e@javax.management.ConstructorParameters\u003c/code\u003e will be used and \u003ccode\u003e@java.beans.ConstructorProperties\u003c/code\u003e will be ignored. Every such annotation must list as many strings as the constructor has parameters; each string must name a property corresponding to a getter of \u003cem\u003eJ\u003c/em\u003e; and the type of this getter must be the same as the corresponding constructor parameter. It is not an error for there to be getters that are not mentioned in the \u003ccode\u003e@ConstructorParameters\u003c/code\u003e or \u003ccode\u003e@ConstructorProperties\u003c/code\u003e annotations (these may correspond to information that is not needed to reconstruct the object).\u003c/p\u003e \u003cp\u003eAn instance of \u003cem\u003eJ\u003c/em\u003e is reconstructed by calling a constructor with the appropriate reconstructed items from the \u003ccode\u003eCompositeData\u003c/code\u003e. The constructor to be called will be determined at runtime based on the items actually present in the \u003ccode\u003eCompositeData\u003c/code\u003e, given that this \u003ccode\u003e CompositeData\u003c/code\u003e might come from an earlier version of \u003cem\u003eJ\u003c/em\u003e where not all the items were present. A constructor is \u003cem\u003eapplicable\u003c/em\u003e if all the properties named in its \u003ccode\u003e@ConstructorParameters\u003c/code\u003e or \u003ccode\u003e@ConstructorProperties\u003c/code\u003e annotation are present as items in the \u003ccode\u003eCompositeData\u003c/code\u003e. If no constructor is applicable, then the attempt to reconstruct \u003cem\u003eJ\u003c/em\u003e fails.\u003c/p\u003e \u003cp\u003eFor any possible combination of properties, it must be the case that either (a) there are no applicable constructors, or (b) there is exactly one applicable constructor, or (c) one of the applicable constructors names a proper superset of the properties named by each other applicable constructor. (In other words, there should never be ambiguity over which constructor to choose.) If this condition is not true, then \u003cem\u003eJ\u003c/em\u003e is not reconstructible.\u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003eOtherwise, if \u003cem\u003eJ\u003c/em\u003e has a public no-arg constructor, and for every getter in \u003cem\u003eJ\u003c/em\u003e with type \u003cem\u003eT\u003c/em\u003e and name \u003cem\u003eN\u003c/em\u003e there is a corresponding setter with the same name and type, then an instance of \u003cem\u003eJ\u003c/em\u003e is constructed with the no-arg constructor and the setters are called with the reconstructed items from the \u003ccode\u003eCompositeData\u003c/code\u003e to restore the values. For example, if there is a method\u003cbr\u003e \u003ccode\u003epublic List\u0026lt;String\u0026gt; getNames()\u003c/code\u003e\u003cbr\u003e then there must also be a method\u003cbr\u003e \u003ccode\u003epublic void setNames(List\u0026lt;String\u0026gt; names)\u003c/code\u003e\u003cbr\u003e for this rule to apply.\u003c/p\u003e \u003cp\u003eIf the \u003ccode\u003eCompositeData\u003c/code\u003e came from an earlier version of \u003cem\u003eJ\u003c/em\u003e, some items might not be present. In this case, the corresponding setters will not be called.\u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003eOtherwise, if \u003cem\u003eJ\u003c/em\u003e is an interface that has no methods other than getters, an instance of \u003cem\u003eJ\u003c/em\u003e is constructed using a \u003ca href\u003d\"../../../java.base/java/lang/reflect/Proxy.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eProxy\u003c/code\u003e\u003c/a\u003e with a \u003ca href\u003d\"openmbean/CompositeDataInvocationHandler.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeDataInvocationHandler\u003c/code\u003e\u003c/a\u003e backed by the \u003ccode\u003e CompositeData\u003c/code\u003e being converted.\u003c/p\u003e\u003c/li\u003e \n \u003cli\u003e\u003cp\u003eOtherwise, \u003cem\u003eJ\u003c/em\u003e is not reconstructible.\u003c/p\u003e\u003c/li\u003e \n\u003c/ol\u003e \n\u003cp\u003eRule 2 is not applicable when \u003ccode\u003ejava.beans.ConstructorProperties\u003c/code\u003e is not visible (e.g. when the java.desktop module is not readable or when the runtime image does not contain the java.desktop module). When targeting a runtime that does not include the \u003ccode\u003ejava.beans\u003c/code\u003e package, and where there is a mismatch between the compile-time and runtime environment whereby \u003cem\u003eJ\u003c/em\u003e is compiled with a public constructor and the \u003ccode\u003eConstructorProperties\u003c/code\u003e annotation, then \u003cem\u003eJ\u003c/em\u003e is not reconstructible unless another rule applies.\u003c/p\u003e \n\u003cp\u003eHere are examples showing different ways to code a type \u003ccode\u003e NamedNumber\u003c/code\u003e that consists of an \u003ccode\u003eint\u003c/code\u003e and a \u003ccode\u003e String\u003c/code\u003e. In each case, the \u003ccode\u003eCompositeType\u003c/code\u003e looks like this:\u003c/p\u003e \n\u003cblockquote\u003e \n \u003cpre\u003e\u003ca href\u003d\"openmbean/CompositeType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeType\u003c/code\u003e\u003c/a\u003e(\n    \"NamedNumber\",                      // typeName\n    \"NamedNumber\",                      // description\n    new String[] {\"number\", \"name\"},    // itemNames\n    new String[] {\"number\", \"name\"},    // itemDescriptions\n    new OpenType[] {SimpleType.INTEGER,\n                    SimpleType.STRING}  // itemTypes\n);\n      \u003c/pre\u003e \n\u003c/blockquote\u003e \n\u003col\u003e \n \u003cli\u003eStatic \u003ccode\u003efrom\u003c/code\u003e method: \n  \u003cblockquote\u003e \n   \u003cpre\u003epublic class NamedNumber {\n    public int getNumber() {return number;}\n    public String getName() {return name;}\n    private NamedNumber(int number, String name) {\n        this.number \u003d number;\n        this.name \u003d name;\n    }\n    \u003cb\u003epublic static NamedNumber from(CompositeData cd)\u003c/b\u003e {\n        return new NamedNumber((Integer) cd.get(\"number\"),\n                               (String) cd.get(\"name\"));\n    }\n    private final int number;\n    private final String name;\n}\n          \u003c/pre\u003e \n  \u003c/blockquote\u003e \u003c/li\u003e \n \u003cli\u003ePublic constructor with \u003ccode\u003e@ConstructorParameters\u003c/code\u003e annotation: \n  \u003cblockquote\u003e \n   \u003cpre\u003epublic class NamedNumber {\n    public int getNumber() {return number;}\n    public String getName() {return name;}\n    \u003cb\u003e@ConstructorParameters({\"number\", \"name\"})\n    public NamedNumber(int number, String name)\u003c/b\u003e {\n        this.number \u003d number;\n        this.name \u003d name;\n    }\n    private final int number;\n    private final String name;\n}\n          \u003c/pre\u003e \n  \u003c/blockquote\u003e \u003c/li\u003e \n \u003cli\u003eSetter for every getter: \n  \u003cblockquote\u003e \n   \u003cpre\u003epublic class NamedNumber {\n    public int getNumber() {return number;}\n    public void \u003cb\u003esetNumber\u003c/b\u003e(int number) {this.number \u003d number;}\n    public String getName() {return name;}\n    public void \u003cb\u003esetName\u003c/b\u003e(String name) {this.name \u003d name;}\n    \u003cb\u003epublic NamedNumber()\u003c/b\u003e {}\n    private int number;\n    private String name;\n}\n          \u003c/pre\u003e \n  \u003c/blockquote\u003e \u003c/li\u003e \n \u003cli\u003eInterface with only getters: \n  \u003cblockquote\u003e \n   \u003cpre\u003epublic interface NamedNumber {\n    public int getNumber();\n    public String getName();\n}\n          \u003c/pre\u003e \n  \u003c/blockquote\u003e \u003c/li\u003e \n\u003c/ol\u003e \n\u003cp\u003eIt is usually better for classes that simply represent a collection of data to be \u003cem\u003eimmutable\u003c/em\u003e. An instance of an immutable class cannot be changed after it has been constructed. Notice that \u003ccode\u003eCompositeData\u003c/code\u003e itself is immutable. Immutability has many advantages, notably with regard to thread-safety and security. So the approach using setters should generally be avoided if possible.\u003c/p\u003e \n\u003ch3\u003eRecursive types\u003c/h3\u003e \n\u003cp\u003eRecursive (self-referential) types cannot be used in MXBean interfaces. This is a consequence of the immutability of \u003ca href\u003d\"openmbean/CompositeType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeType\u003c/code\u003e\u003c/a\u003e. For example, the following type could not be the type of an attribute, because it refers to itself:\u003c/p\u003e \n\u003cpre\u003epublic interface \u003cb\u003eNode\u003c/b\u003e {\n    public String getName();\n    public int getPriority();\n    public \u003cb\u003eNode\u003c/b\u003e getNext();\n}\n\u003c/pre\u003e \n\u003cp\u003eIt is always possible to rewrite recursive types like this so they are no longer recursive. Doing so may require introducing new types. For example:\u003c/p\u003e \n\u003cpre\u003epublic interface \u003cb\u003eNodeList\u003c/b\u003e {\n    public List\u0026lt;Node\u0026gt; getNodes();\n}\n\npublic interface Node {\n    public String getName();\n    public int getPriority();\n}\n\u003c/pre\u003e \n\u003ch3\u003eMBeanInfo contents for an MXBean\u003c/h3\u003e \n\u003cp\u003eAn MXBean is a type of Open MBean. However, for compatibility reasons, its \u003ca href\u003d\"MBeanInfo.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eMBeanInfo\u003c/code\u003e\u003c/a\u003e is not an \u003ca href\u003d\"openmbean/OpenMBeanInfo.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eOpenMBeanInfo\u003c/code\u003e\u003c/a\u003e. In particular, when the type of an attribute, parameter, or operation return value is a primitive type such as \u003ccode\u003eint\u003c/code\u003e, or is \u003ccode\u003evoid\u003c/code\u003e (for a return type), then the attribute, parameter, or operation will be represented respectively by an \u003ca href\u003d\"MBeanAttributeInfo.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eMBeanAttributeInfo\u003c/code\u003e\u003c/a\u003e, \u003ca href\u003d\"MBeanParameterInfo.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eMBeanParameterInfo\u003c/code\u003e\u003c/a\u003e, or \u003ca href\u003d\"MBeanOperationInfo.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eMBeanOperationInfo\u003c/code\u003e\u003c/a\u003e whose \u003ccode\u003egetType()\u003c/code\u003e or \u003ccode\u003e getReturnType()\u003c/code\u003e returns the primitive name (\"\u003ccode\u003eint\u003c/code\u003e\" etc). This is so even though the mapping rules above specify that the \u003cem\u003eopendata\u003c/em\u003e mapping is the wrapped type (\u003ccode\u003eInteger\u003c/code\u003e etc).\u003c/p\u003e \n\u003cp\u003eThe array of public constructors returned by \u003ca href\u003d\"MBeanInfo.html#getConstructors()\"\u003e\u003ccode\u003eMBeanInfo.getConstructors()\u003c/code\u003e\u003c/a\u003e for an MXBean that is directly registered in the MBean Server will contain all of the public constructors of that MXBean. If the class of the MXBean is not public then its constructors are not considered public either. The list returned for an MXBean that is constructed using the \u003ca href\u003d\"StandardMBean.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eStandardMBean\u003c/code\u003e\u003c/a\u003e class is derived in the same way as for Standard MBeans. Regardless of how the MXBean was constructed, its constructor parameters are not subject to MXBean mapping rules and do not have a corresponding \u003ccode\u003eOpenType\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eThe array of notification types returned by \u003ca href\u003d\"MBeanInfo.html#getNotifications()\"\u003e\u003ccode\u003eMBeanInfo.getNotifications()\u003c/code\u003e\u003c/a\u003e for an MXBean that is directly registered in the MBean Server will be empty if the MXBean does not implement the \u003ca href\u003d\"NotificationBroadcaster.html\" title\u003d\"interface in javax.management\"\u003e\u003ccode\u003eNotificationBroadcaster\u003c/code\u003e\u003c/a\u003e interface. Otherwise, it will be the result of calling \u003ca href\u003d\"NotificationBroadcaster.html#getNotificationInfo()\"\u003e\u003ccode\u003eNotificationBroadcaster.getNotificationInfo()\u003c/code\u003e\u003c/a\u003e at the time the MXBean was registered. Even if the result of this method changes subsequently, the result of \u003ccode\u003eMBeanInfo.getNotifications()\u003c/code\u003e will not. The list returned for an MXBean that is constructed using the \u003ca href\u003d\"StandardMBean.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eStandardMBean\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"StandardEmitterMBean.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eStandardEmitterMBean\u003c/code\u003e\u003c/a\u003e class is derived in the same way as for Standard MBeans.\u003c/p\u003e \n\u003cp\u003eThe \u003ca href\u003d\"Descriptor.html\" title\u003d\"interface in javax.management\"\u003e\u003ccode\u003eDescriptor\u003c/code\u003e\u003c/a\u003e for all of the \u003ccode\u003eMBeanAttributeInfo\u003c/code\u003e, \u003ccode\u003eMBeanParameterInfo\u003c/code\u003e, and \u003ccode\u003eMBeanOperationInfo\u003c/code\u003e objects contained in the \u003ccode\u003eMBeanInfo\u003c/code\u003e will have a field \u003ccode\u003eopenType\u003c/code\u003e whose value is the \u003ca href\u003d\"openmbean/OpenType.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eOpenType\u003c/code\u003e\u003c/a\u003e specified by the mapping rules above. So even when \u003ccode\u003egetType()\u003c/code\u003e is \"\u003ccode\u003eint\u003c/code\u003e\", \u003ccode\u003egetDescriptor().getField(\"openType\")\u003c/code\u003e will be \u003ca href\u003d\"openmbean/SimpleType.html#INTEGER\"\u003e\u003ccode\u003eSimpleType.INTEGER\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e \n\u003cp\u003eThe \u003ccode\u003eDescriptor\u003c/code\u003e for each of these objects will also have a field \u003ccode\u003eoriginalType\u003c/code\u003e that is a string representing the Java type that appeared in the MXBean interface. The format of this string is described in the section \u003ca href\u003d\"#type-names\"\u003eType Names\u003c/a\u003e below.\u003c/p\u003e \n\u003cp\u003eThe \u003ccode\u003eDescriptor\u003c/code\u003e for the \u003ccode\u003eMBeanInfo\u003c/code\u003e will have a field \u003ccode\u003emxbean\u003c/code\u003e whose value is the string \"\u003ccode\u003etrue\u003c/code\u003e\".\u003c/p\u003e \n\u003ch3 id\u003d\"type-names\"\u003eType Names\u003c/h3\u003e \n\u003cp\u003eSometimes the unmapped type \u003cem\u003eT\u003c/em\u003e of a method parameter or return value in an MXBean must be represented as a string. If \u003cem\u003eT\u003c/em\u003e is a non-generic type, this string is the value returned by \u003ca href\u003d\"../../../java.base/java/lang/Class.html#getName()\"\u003e\u003ccode\u003eClass.getName()\u003c/code\u003e\u003c/a\u003e. Otherwise it is the value of \u003cem\u003egenericstring(T)\u003c/em\u003e, defined as follows: \u003c/p\u003e\n\u003cul\u003e \n \u003cli\u003eIf \u003cem\u003eT\u003c/em\u003e is a non-generic non-array type, \u003cem\u003egenericstring(T)\u003c/em\u003e is the value returned by \u003ca href\u003d\"../../../java.base/java/lang/Class.html#getName()\"\u003e\u003ccode\u003eClass.getName()\u003c/code\u003e\u003c/a\u003e, for example \u003ccode\u003e\"int\"\u003c/code\u003e or \u003ccode\u003e \"java.lang.String\"\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eIf \u003cem\u003eT\u003c/em\u003e is an array \u003cem\u003eE[]\u003c/em\u003e, \u003cem\u003egenericstring(T)\u003c/em\u003e is \u003cem\u003egenericstring(E)\u003c/em\u003e followed by \u003ccode\u003e\"[]\"\u003c/code\u003e. For example, \u003cem\u003egenericstring(\u003ccode\u003eint[]\u003c/code\u003e)\u003c/em\u003e is \u003ccode\u003e\"int[]\"\u003c/code\u003e, and \u003cem\u003egenericstring(\u003ccode\u003e List\u0026lt;String\u0026gt;[][]\u003c/code\u003e)\u003c/em\u003e is \u003ccode\u003e \"java.util.List\u0026lt;java.lang.String\u0026gt;[][]\"\u003c/code\u003e. \u003c/li\u003e\n \u003cli\u003eOtherwise, \u003cem\u003eT\u003c/em\u003e is a parameterized type such as \u003ccode\u003e List\u0026lt;String\u0026gt;\u003c/code\u003e and \u003cem\u003egenericstring(T)\u003c/em\u003e consists of the following: the fully-qualified name of the parameterized type as returned by \u003ccode\u003eClass.getName()\u003c/code\u003e; a left angle bracket (\u003ccode\u003e \"\u0026lt;\"\u003c/code\u003e); \u003cem\u003egenericstring(A)\u003c/em\u003e where \u003cem\u003eA\u003c/em\u003e is the first type parameter; if there is a second type parameter \u003cem\u003eB\u003c/em\u003e then \u003ccode\u003e\", \"\u003c/code\u003e (a comma and a single space) followed by \u003cem\u003egenericstring(B)\u003c/em\u003e; a right angle bracket (\u003ccode\u003e\"\u0026gt;\"\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eNote that if a method returns \u003ccode\u003eint[]\u003c/code\u003e, this will be represented by the string \u003ccode\u003e\"[I\"\u003c/code\u003e returned by \u003ccode\u003e Class.getName()\u003c/code\u003e, but if a method returns \u003ccode\u003eList\u0026lt;int[]\u0026gt;\u003c/code\u003e, this will be represented by the string \u003ccode\u003e \"java.util.List\u0026lt;int[]\u0026gt;\"\u003c/code\u003e. \u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e \n\u003cp\u003eA problem with mapping \u003cem\u003efrom\u003c/em\u003e Java types \u003cem\u003eto\u003c/em\u003e Open types is signaled with an \u003ca href\u003d\"openmbean/OpenDataException.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eOpenDataException\u003c/code\u003e\u003c/a\u003e. This can happen when an MXBean interface is being analyzed, for example if it references a type like \u003ca href\u003d\"../../../java.base/java/util/Random.html\" title\u003d\"class in java.util\"\u003e\u003ccode\u003ejava.util.Random\u003c/code\u003e\u003c/a\u003e that has no getters. Or it can happen when an instance is being converted (a return value from a method in an MXBean or a parameter to a method in an MXBean proxy), for example when converting from \u003ccode\u003eSortedSet\u0026lt;String\u0026gt;\u003c/code\u003e to \u003ccode\u003e String[]\u003c/code\u003e if the \u003ccode\u003eSortedSet\u003c/code\u003e has a non-null \u003ccode\u003e Comparator\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eA problem with mapping \u003cem\u003eto\u003c/em\u003e Java types \u003cem\u003efrom\u003c/em\u003e Open types is signaled with an \u003ca href\u003d\"../../../java.base/java/io/InvalidObjectException.html\" title\u003d\"class in java.io\"\u003e\u003ccode\u003eInvalidObjectException\u003c/code\u003e\u003c/a\u003e. This can happen when an MXBean interface is being analyzed, for example if it references a type that is not \u003cem\u003ereconstructible\u003c/em\u003e according to the rules above, in a context where a reconstructible type is required. Or it can happen when an instance is being converted (a parameter to a method in an MXBean or a return value from a method in an MXBean proxy), for example from a String to an Enum if there is no Enum constant with that name.\u003c/p\u003e \n\u003cp\u003eDepending on the context, the \u003ccode\u003eOpenDataException\u003c/code\u003e or \u003ccode\u003eInvalidObjectException\u003c/code\u003e may be wrapped in another exception such as \u003ca href\u003d\"RuntimeMBeanException.html\" title\u003d\"class in javax.management\"\u003e\u003ccode\u003eRuntimeMBeanException\u003c/code\u003e\u003c/a\u003e or \u003ca href\u003d\"../../../java.base/java/lang/reflect/UndeclaredThrowableException.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eUndeclaredThrowableException\u003c/code\u003e\u003c/a\u003e. For every thrown exception, the condition \u003cem\u003eC\u003c/em\u003e will be true: \"\u003cem\u003ee\u003c/em\u003e is \u003ccode\u003e OpenDataException\u003c/code\u003e or \u003ccode\u003eInvalidObjectException\u003c/code\u003e (as appropriate), or \u003cem\u003eC\u003c/em\u003e is true of \u003cem\u003ee\u003c/em\u003e.\u003ca href\u003d\"../../../java.base/java/lang/Throwable.html#getCause()\"\u003e\u003ccode\u003egetCause()\u003c/code\u003e\u003c/a\u003e\".\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.6"
    ]
  }
}