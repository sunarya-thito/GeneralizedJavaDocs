{
  "packageName": "javax.management.openmbean",
  "simpleName": "CompositeDataInvocationHandler",
  "moduleName": "java.management",
  "type": "CLASS",
  "superClass": {
    "name": "java.lang.Object",
    "type": "Class"
  },
  "members": [
    {
      "returnType": {
        "name": "javax.management.openmbean.CompositeData",
        "type": "Class"
      },
      "parameters": [],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "getCompositeData",
      "comment": "Return the CompositeData that was supplied to the constructor.",
      "annotations": [],
      "tagMap": {
        "return": [
          "the \n\u003ccode\u003eCompositeData\u003c/code\u003e that this handler is backed by. This is never null."
        ]
      }
    },
    {
      "returnType": {
        "name": "java.lang.Object",
        "type": "Class"
      },
      "throwsClasses": [
        {
          "name": "java.lang.Throwable",
          "type": "Class"
        }
      ],
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class"
          },
          "name": "proxy",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.reflect.Method",
            "type": "Class"
          },
          "name": "method",
          "varargs": false
        },
        {
          "annotations": [],
          "type": {
            "name": "java.lang.Object",
            "type": "Class",
            "arrayDimensions": 1
          },
          "name": "args",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "name": "invoke",
      "comment": "Description copied from interface: InvocationHandler",
      "annotations": [],
      "tagMap": {
        "see": [
          "\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/UndeclaredThrowableException.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eUndeclaredThrowableException\u003c/code\u003e\u003c/a\u003e"
        ],
        "Specified by:": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/InvocationHandler.html#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)\"\u003einvoke\u003c/a\u003e\u003c/code\u003e\u0026nbsp;in interface\u0026nbsp;\n\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/InvocationHandler.html\" title\u003d\"interface in java.lang.reflect\"\u003eInvocationHandler\u003c/a\u003e\u003c/code\u003e"
        ],
        "param": [
          "\u003ccode\u003eproxy\u003c/code\u003e - the proxy instance that the method was invoked on",
          "\u003ccode\u003emethod\u003c/code\u003e - the \n\u003ccode\u003eMethod\u003c/code\u003e instance corresponding to the interface method invoked on the proxy instance. The declaring class of the \n\u003ccode\u003eMethod\u003c/code\u003e object will be the interface that the method was declared in, which may be a superinterface of the proxy interface that the proxy class inherits the method through.",
          "\u003ccode\u003eargs\u003c/code\u003e - an array of objects containing the values of the arguments passed in the method invocation on the proxy instance, or \n\u003ccode\u003enull\u003c/code\u003e if interface method takes no arguments. Arguments of primitive types are wrapped in instances of the appropriate primitive wrapper class, such as \n\u003ccode\u003ejava.lang.Integer\u003c/code\u003e or \n\u003ccode\u003ejava.lang.Boolean\u003c/code\u003e."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Throwable.html\" title\u003d\"class in java.lang\"\u003eThrowable\u003c/a\u003e\u003c/code\u003e - the exception to throw from the method invocation on the proxy instance. The exception\u0027s type must be assignable either to any of the exception types declared in the \n\u003ccode\u003ethrows\u003c/code\u003e clause of the interface method or to the unchecked exception types \n\u003ccode\u003ejava.lang.RuntimeException\u003c/code\u003e or \n\u003ccode\u003ejava.lang.Error\u003c/code\u003e. If a checked exception is thrown by this method that is not assignable to any of the exception types declared in the \n\u003ccode\u003ethrows\u003c/code\u003e clause of the interface method, then an \n\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/UndeclaredThrowableException.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eUndeclaredThrowableException\u003c/code\u003e\u003c/a\u003e containing the exception that was thrown by this method will be thrown by the method invocation on the proxy instance."
        ],
        "return": [
          "the value to return from the method invocation on the proxy instance. If the declared return type of the interface method is a primitive type, then the value returned by this method must be an instance of the corresponding primitive wrapper class; otherwise, it must be a type assignable to the declared return type. If the value returned by this method is \n\u003ccode\u003enull\u003c/code\u003e and the interface method\u0027s return type is primitive, then a \n\u003ccode\u003eNullPointerException\u003c/code\u003e will be thrown by the method invocation on the proxy instance. If the value returned by this method is otherwise not compatible with the interface method\u0027s declared return type as described above, a \n\u003ccode\u003eClassCastException\u003c/code\u003e will be thrown by the method invocation on the proxy instance."
        ]
      }
    },
    {
      "parameters": [
        {
          "annotations": [],
          "type": {
            "name": "javax.management.openmbean.CompositeData",
            "type": "Class"
          },
          "name": "compositeData",
          "varargs": false
        }
      ],
      "isDefaultMethod": false,
      "memberType": "JavaMethod",
      "modifiers": 1,
      "comment": "Construct a handler backed by the given CompositeData.",
      "annotations": [],
      "tagMap": {
        "param": [
          "\u003ccode\u003ecompositeData\u003c/code\u003e - the \n\u003ccode\u003eCompositeData\u003c/code\u003e that will supply information to getters."
        ],
        "throws": [
          "\u003ccode\u003e\u003ca href\u003d\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/IllegalArgumentException.html\" title\u003d\"class in java.lang\"\u003eIllegalArgumentException\u003c/a\u003e\u003c/code\u003e - if \n\u003ccode\u003ecompositeData\u003c/code\u003e is null."
        ]
      }
    }
  ],
  "memberType": "JavaClass",
  "modifiers": 1,
  "name": "javax.management.openmbean.CompositeDataInvocationHandler",
  "comment": "\u003cp\u003eAn \u003ca href\u003d\"../../../../java.base/java/lang/reflect/InvocationHandler.html\" title\u003d\"interface in java.lang.reflect\"\u003e\u003ccode\u003eInvocationHandler\u003c/code\u003e\u003c/a\u003e that forwards getter methods to a \u003ca href\u003d\"CompositeData.html\" title\u003d\"interface in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeData\u003c/code\u003e\u003c/a\u003e. If you have an interface that contains only getter methods (such as \u003ccode\u003eString getName()\u003c/code\u003e or \u003ccode\u003eboolean isActive()\u003c/code\u003e) then you can use this class in conjunction with the \u003ca href\u003d\"../../../../java.base/java/lang/reflect/Proxy.html\" title\u003d\"class in java.lang.reflect\"\u003e\u003ccode\u003eProxy\u003c/code\u003e\u003c/a\u003e class to produce an implementation of the interface where each getter returns the value of the corresponding item in a \u003ccode\u003eCompositeData\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eFor example, suppose you have an interface like this: \u003c/p\u003e\n\u003cblockquote\u003e \n \u003cpre\u003e   public interface NamedNumber {\n       public int getNumber();\n       public String getName();\n   }\n   \u003c/pre\u003e \n\u003c/blockquote\u003e and a \n\u003ccode\u003eCompositeData\u003c/code\u003e constructed like this: \n\u003cblockquote\u003e \n \u003cpre\u003e   CompositeData cd \u003d\n       new \u003ca href\u003d\"CompositeDataSupport.html\" title\u003d\"class in javax.management.openmbean\"\u003e\u003ccode\u003eCompositeDataSupport\u003c/code\u003e\u003c/a\u003e(\n           someCompositeType,\n           new String[] {\"number\", \"name\"},\n           new Object[] {\u003cb\u003e5\u003c/b\u003e, \"five\"}\n       );\n   \u003c/pre\u003e \n\u003c/blockquote\u003e then you can construct an object implementing \n\u003ccode\u003eNamedNumber\u003c/code\u003e and backed by the object \n\u003ccode\u003ecd\u003c/code\u003e like this: \n\u003cblockquote\u003e \n \u003cpre\u003e   InvocationHandler handler \u003d\n       new CompositeDataInvocationHandler(cd);\n   NamedNumber nn \u003d (NamedNumber)\n       Proxy.newProxyInstance(NamedNumber.class.getClassLoader(),\n                              new Class[] {NamedNumber.class},\n                              handler);\n   \u003c/pre\u003e \n\u003c/blockquote\u003e A call to \n\u003ccode\u003enn.getNumber()\u003c/code\u003e will then return \n\u003cb\u003e5\u003c/b\u003e. \n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eIf the first letter of the property defined by a getter is a capital, then this handler will look first for an item in the \u003ccode\u003eCompositeData\u003c/code\u003e beginning with a capital, then, if that is not found, for an item beginning with the corresponding lowercase letter or code point. For a getter called \u003ccode\u003egetNumber()\u003c/code\u003e, the handler will first look for an item called \u003ccode\u003eNumber\u003c/code\u003e, then for \u003ccode\u003enumber\u003c/code\u003e. If the getter is called \u003ccode\u003egetnumber()\u003c/code\u003e, then the item must be called \u003ccode\u003enumber\u003c/code\u003e.\u003c/p\u003e \n\u003cp\u003eIf the method given to \u003ca href\u003d\"#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)\"\u003e\u003ccode\u003einvoke\u003c/code\u003e\u003c/a\u003e is the method \u003ccode\u003eboolean equals(Object)\u003c/code\u003e inherited from \u003ccode\u003eObject\u003c/code\u003e, then it will return true if and only if the argument is a \u003ccode\u003eProxy\u003c/code\u003e whose \u003ccode\u003eInvocationHandler\u003c/code\u003e is also a \u003ccode\u003e CompositeDataInvocationHandler\u003c/code\u003e and whose backing \u003ccode\u003e CompositeData\u003c/code\u003e is equal (not necessarily identical) to this object\u0027s. If the method given to \u003ccode\u003einvoke\u003c/code\u003e is the method \u003ccode\u003eint hashCode()\u003c/code\u003e inherited from \u003ccode\u003eObject\u003c/code\u003e, then it will return a value that is consistent with this definition of \u003ccode\u003e equals\u003c/code\u003e: if two objects are equal according to \u003ccode\u003eequals\u003c/code\u003e, then they will have the same \u003ccode\u003ehashCode\u003c/code\u003e.\u003c/p\u003e",
  "tagMap": {
    "since": [
      "1.6"
    ]
  }
}